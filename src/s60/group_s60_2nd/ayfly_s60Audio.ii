# 1 "../../libayfly/s60/ayfly_s60Audio.cpp"
 



















 



# 1 "../../libayfly/ayfly.h" 1
 










































# 52 "../../libayfly/ayfly.h"


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 1
 




 




 


















 









extern "C" {


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/_ansi.h" 1
 




 




 







 











 










 




















# 43 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stddef.h" 1
 




 







 





typedef unsigned short int wchar_t;



typedef long		ptrdiff_t;
typedef unsigned int	size_t;

 





# 48 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdarg_e.h" 1
 




 




 










 


typedef char* __e32_va_list;






# 50 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/sys/stdio_t.h" 1
 







extern "C" {




 




struct __sbuf {
	unsigned char *	_base;
	int				_size;
};

 






typedef long _fpos_t;		 
							 

 

























struct __sFILE {
  unsigned char *_p;			 
  int			 _r;			 
  int			 _w;			 
  short			 _flags;		 
  short			 _file;			 
  struct __sbuf	 _bf;			 
  int			 _lbfsize;		 

   
  void *		 _cookie;		 

  int		(*_read) (void * _cookie, char *_buf, int _n);
  int		(*_write)(void * _cookie, const char *_buf, int _n);
  _fpos_t	(*_seek) (void * _cookie, _fpos_t _offset, int _whence);
  int		(*_close)(void * _cookie);

   
  struct __sbuf		_ub;		 
  unsigned char *	_up;		 
  int				_ur;		 

   
  unsigned char		_ubuf[3];	 
  unsigned char		_nbuf[1];	 

   
  struct __sbuf		_lb;		 

   
  int				_blksize;	 
  int				_offset;	 

  struct _reent *	_data;		 
};



}


# 52 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2


typedef _fpos_t fpos_t;
typedef struct __sFILE FILE;





	 











 





































 













  FILE *__stdin  (void);
  FILE *__stdout (void);
  FILE *__stderr (void);





 


  FILE *	tmpfile		(void);
  char *	tmpnam		(char *);
  wchar_t *	wtmpnam		(wchar_t *);
  int	fclose		(FILE *);
  int	fflush		(FILE *);
  FILE *	freopen		(const char *, const char *, FILE *);
  FILE *	wfreopen		(const wchar_t *, const wchar_t *, FILE *);
  void	setbuf		(FILE *, char *);
  int	setvbuf		(FILE *, char *, int, size_t);
  int	fprintf		(FILE *, const char *, ...);
  int	fscanf		(FILE *, const char *, ...);
  int	printf		(const char *, ...);
  int	scanf		(const char *, ...);
  int	sscanf		(const char *, const char *, ...);
  int	vfprintf	(FILE *, const char *, __e32_va_list);
  int	vprintf		(const char *, __e32_va_list);
  int	vsprintf	(char *, const char *, __e32_va_list);
  int	fgetc		(FILE *);
  char *  fgets		(char *, int, FILE *);
  int	fputc		(int, FILE *);
  int	fputs		(const char *, FILE *);
  int	getc		(FILE *);
  int	getchar		(void);
  char *  gets		(char *);
  int	putc		(int, FILE *);
  int	putchar		(int);
  int	puts		(const char *);
  int	ungetc		(int, FILE *);
  size_t	fread		(void*, size_t _size, size_t _n, FILE *);
  size_t	fwrite		(const void* , size_t _size, size_t _n, FILE *);
  int	fgetpos		(FILE *, fpos_t *);
  int	fseek		(FILE *, long, int);
  int	fsetpos		(FILE *, const fpos_t *);
  long	ftell		(FILE *);
  void	rewind		(FILE *);
  void	clearerr	(FILE *);
  int	feof		(FILE *);
  int	ferror		(FILE *);
  void    perror		(const char *);

  FILE *	fopen		(const char *_name, const char *_type);
  FILE *	wfopen		(const wchar_t *_name, const wchar_t *_type);
  int	sprintf		(char *, const char *, ...);


 


  int	fileno		(FILE *);


  FILE *	fdopen		(int, const char *);
  FILE *	wfdopen		(int, const wchar_t *);


 


  void	_cleanup	(void);

 


  int	popen3	(const char *cmd, const char *mode, char** envp, int fids[3]);
  int	wpopen3	(const wchar_t *cmd, const wchar_t *mode, wchar_t** envp, int fids[3]);

# 223 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h"



}


# 54 "../../libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdlib.h" 1
 




 




 






extern "C" {









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/sys/reent.h" 1
 




 




 






extern "C" {






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/time.h" 1
 




 




 







extern "C" {








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/machine/types.h" 1
 




 
















# 28 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/time.h" 2






typedef signed int  clock_t;




typedef signed int  time_t;



struct tm
{
  int	tm_sec;		 
  int	tm_min;		 
  int	tm_hour;	 
  int	tm_mday;	 
  int	tm_mon;		 
  int	tm_year;	 
  int	tm_wday;	 
  int	tm_yday;	 
  int	tm_isdst;	 
};

  clock_t	clock		(void);
  double		difftime	(time_t _time2, time_t _time1);
  time_t		mktime		(struct tm *_timeptr);
  time_t		time		(time_t *_timer);
  size_t		strftime	(char *_s, size_t _maxsize, const char *_fmt, const struct tm *_t);

  char*		asctime		(const struct tm *_tblock);
  char*		ctime		(const time_t *_time);
  struct tm*	gmtime		(const time_t *_timer);
  struct tm*	localtime	(const time_t *_timer);


 




  char*		asctime_r	(const struct tm *, char *);
  char*		ctime_r		(const time_t *, char *);
  struct tm*	gmtime_r	(const time_t *, struct tm *);
  struct tm*	localtime_r	(const time_t *, struct tm *);


}


# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/sys/reent.h" 2


struct _glue 
{
  struct _glue *_next;
  int _niobs;
  struct __sFILE *_iobs;
};

 




struct _atexit {
	struct	_atexit *_next;			 
	int	_ind;				 
	void	(*_fns[32 ])(void);	 
};


 










struct _reent
{
   
  int _errno;
  struct __sFILE _sf[3];		 

  char *_scanpoint;		 
  char _asctime[(26+8) ];	 
  struct tm _struct_tm;		 
  long _next[2];		 
  int  _inc;			 
  char _tmpnam[37];		 
  wchar_t _wtmpnam[37];		 
  void *_netdb;			 
 
  int _current_category;	 
  const char *_current_locale;

  int __sdidinit;		 

  void (*__cleanup)(struct _reent *);

   
  struct _atexit *_atexit;	 
  struct _atexit _atexit0;	 

   
  void (**(_sig_func))();

  struct _glue __sglue;		 

  char **environ;
  int environ_slots;

  char* _pNarrowEnvBuffer;
  int _NEBSize;

  void *_system;		 
};

 



  void		_reclaim_reent	(struct _reent*);
  void		_REENT_INIT	(struct _reent*);
  struct _reent*	ImpurePtr	(void);
  void		_init_reent	(struct _reent*,void*);

 


  void CloseSTDLIB();





}



# 28 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdlib.h" 2


typedef struct 
{
  int quot;  
  int rem;  
} div_t;














 



  int	_epoc32_atexit	(void (*_func)(void));




  void	abort	(void);


  int	abs		(int);
  double	atof	(const char *_nptr);
  int	atoi	(const char *_nptr);


  void*	bsearch	(const void * _key,
		       const void * _base,
		       size_t _nmemb,
		       size_t _size,
		       int (*_compar)(const void *, const void *));
  void*	calloc	(size_t _nmemb, size_t _size);
  div_t	div	(int _numer, int _denom);
  void	exit	(int _status)  ;
  void	free	(void *);
  char*  getenv	(const char *_string);
  wchar_t*  wgetenv	(const wchar_t *_string);
  void*	malloc	(size_t _size);

  int	mbtowc	 (wchar_t *pwc, const char *s, size_t n);
  int	wctomb	 (char *s, wchar_t wc);
  int	mbstowcs (wchar_t *pwc, const char *s, size_t n);
  int	wcstombs (char *s, const wchar_t *pwc, size_t n);
  int    mblen    (const char * string, size_t size);

  void	qsort	(void * _base, size_t _nmemb, size_t _size, int(*_compar)(const void *, const void *));
  int	rand	(void);
  void*	realloc	(void * _r, size_t _size);
  void	srand	(unsigned _seed);
  double	strtod	(const char *_n, char **_end_PTR);
  long	strtol	(const char *_n, char **_end_PTR, int _base);
  unsigned long strtoul		(const char *_n_PTR, char **_end_PTR, int _base);
  int	system	(const char *_string);
  int	wsystem	(const wchar_t *_string);

 


  int	setenv	(const char *_string, const char *_value, int _overwrite);
  void	unsetenv (const char *_name);
  int	wsetenv	(const wchar_t *_string, const wchar_t *_value, int _overwrite);
  void	wunsetenv (const wchar_t *_name);

# 119 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdlib.h"


 


}


# 55 "../../libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/string.h" 1
 




 




 







extern "C" {















  void*	memchr		(const void*, int, size_t);
  int 	memcmp		(const void*, const void*, size_t);
  void*	memcpy		(void* dst, const void* src, size_t);
  void*	memmove		(void*, const void*, size_t);
  void*	memset		(void*, int, size_t);
  char*	strcat		(char *, const char *);
  wchar_t* wcscat	(wchar_t *, const wchar_t *);
  char*	strchr		(const char *, int);
  int	strcmp		(const char *, const char *);
  int	wcscmp		(const wchar_t *, const wchar_t *);
  int	strcoll		(const char *, const char *);
  char*	strcpy		(char *, const char *);
  wchar_t* wcscpy	(wchar_t *, const wchar_t *);
  size_t	strcspn		(const char *, const char *);
  char*	strerror	(int);
  size_t	strlen		(const char *);
  size_t	wcslen		(const wchar_t *);
  char*	strncat		(char *, const char *, size_t);
  int	strncmp		(const char *, const char *, size_t);
  char*	strncpy		(char *, const char *, size_t);
  char*	strpbrk		(const char *, const char *);
  char*	strrchr		(const char *, int);
  size_t	strspn		(const char *, const char *);
  char*	strstr		(const char *, const char *);
  size_t	strxfrm		(char *, const char *, size_t);


  char*	strtok		(char *, const char *);


  char*	strtok_r	(char *, const char *, char **);

 


  int	strcasecmp	(const char *, const char *);
  char*	strdup		(const char *);
  wchar_t*	wcsdup		(const wchar_t *);
  int	strncasecmp	(const char *, const char *, size_t);
  char 	*rindex		(const char *, int);
  char 	*index		(const char *, int);

# 85 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/string.h"



}


# 56 "../../libayfly/ayfly.h" 2













# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.h" 1
 
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 1
 
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h" 1
 
 
 
 
 








# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"






 
# 47 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"


# 63 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"
























































typedef void TAny;
typedef signed char TInt8;
typedef unsigned char TUint8;
typedef short int TInt16;
typedef unsigned short int TUint16;
typedef long int TInt32;
typedef unsigned long int TUint32;
typedef signed int TInt;
typedef unsigned int TUint;
typedef float TReal32;
typedef double TReal64;
typedef double TReal;
typedef unsigned char TText8;
typedef unsigned short int TText16;
typedef int TBool;
















typedef TText16 TText;










typedef TInt8 *VA_LIST[1];
















# 224 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"

















 








 








 































 
















# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2




const TInt KDefaultJustifyWidth=(-1);
const TInt KMaxCheckedUid=3;
const TInt KMaxUidName=10;
const TInt KMaxName=0x80;
const TInt KMaxOsName=(KMaxName-KMaxUidName-2-4);
const TInt KMaxInfoName=0x10;
const TInt KMaxFullName=(KMaxName<<1);
const TInt KMaxPassword=0x10;
const TInt KMaxExitCategoryName=0x10;
const TInt KMaxDayName=0x20;
const TInt KMaxDayNameAbb=0x08;
const TInt KMaxDays=7;
const TInt KMaxMonthName=0x20;
const TInt KMaxMonthNameAbb=0x08;
const TInt KMaxMonths=12;
const TInt KMaxSuffix=0x04;
const TInt KMaxSuffixes=31;
const TInt KMaxAmPmName=0x04;
const TInt KMaxAmPms=2;
const TInt KMaxTranslateTable=0x100;
const TInt KMaxCurrencySymbol=0x08;
const TInt KMaxShortDateFormatSpec=40;
const TInt KMaxLongDateFormatSpec=80;
const TInt KMaxTimeFormatSpec=60;
const TInt KMaxFileName=0x100;
const TInt KMaxVersionName=0x10;
const TInt KMaxPath=0x100;
const TInt KMaxDeviceInfo=0x80;
const TInt KMinHeapSize=0x100;
const TInt KDstHome=0x01;
const TInt KDstEuropean=0x02;
const TInt KDstNorthern=0x04;
const TInt KDstSouthern=0x08;
const TInt KDefaultStackSize=0x2000;
const TUint KNoChar=0xffffffffu;
const TInt KIndexPtr=(-1);
const TInt KCurrentProcessHandle=0xffff0000;
const TInt KHandleNoClose=0x00008000;
const TInt KCurrentThreadHandle=0xffff0001|KHandleNoClose;
const TInt KNullHandle=0;
const TInt KDefaultUnit=0x00;
const TInt KNullUnit=0xffffffff;
const TInt KMaxUnits=0x20;
const TInt KMaxMessageArguments=0x04;
const TInt KDefaultRealWidth=20;
const TInt KMinHeapGrowBy=0x1000;
const TInt KMaxExponentConversion=99;
const TInt KNullUidValue=0;
const TInt KDeltaTimerDefaultGranularity=100000;
const TInt KMaxTInt8=0x7f;
const TInt KMinTInt8=(-128);
const TUint KMaxTUint8=0xffu;
const TInt KMaxTInt16=0x7fff;
const TInt KMinTInt16=(-32768);
const TUint KMaxTUint16=0xffffu;
const TInt KMaxTInt32=0x7fffffff;
const TInt KMinTInt32=(TInt)0x80000000;
const TUint KMaxTUint32=0xffffffffu;
const TInt KMaxTInt=0x7fffffff;
const TInt KMinTInt=(TInt)0x80000000;
const TUint KMaxTUint=0xffffffffu;
const TUint KMatchAny='*';
const TUint KMatchOne='?';
const TInt KMaxLocalDrives=9;
const TInt KMaxPBusSockets=4;

const TInt KErrNone=0;
const TInt KErrNotFound=(-1);  
const TInt KErrGeneral=(-2);
const TInt KErrCancel=(-3);
const TInt KErrNoMemory=(-4);
const TInt KErrNotSupported=(-5);
const TInt KErrArgument=(-6);
const TInt KErrTotalLossOfPrecision=(-7);
const TInt KErrBadHandle=(-8);
const TInt KErrOverflow=(-9);
const TInt KErrUnderflow=(-10);
const TInt KErrAlreadyExists=(-11);
const TInt KErrPathNotFound=(-12);
const TInt KErrDied=(-13);
const TInt KErrInUse=(-14);
const TInt KErrServerTerminated=(-15);
const TInt KErrServerBusy=(-16);
const TInt KErrCompletion=(-17);
const TInt KErrNotReady=(-18);
const TInt KErrUnknown=(-19);
const TInt KErrCorrupt=(-20);
const TInt KErrAccessDenied=(-21);
const TInt KErrLocked=(-22);
const TInt KErrWrite=(-23);
const TInt KErrDisMounted=(-24);
const TInt KErrEof=(-25);
const TInt KErrDiskFull=(-26);
const TInt KErrBadDriver=(-27);
const TInt KErrBadName=(-28);
const TInt KErrCommsLineFail=(-29);
const TInt KErrCommsFrame=(-30);
const TInt KErrCommsOverrun=(-31);
const TInt KErrCommsParity=(-32);
const TInt KErrTimedOut=(-33);
const TInt KErrCouldNotConnect=(-34);
const TInt KErrCouldNotDisconnect=(-35);
const TInt KErrDisconnected=(-36);
const TInt KErrBadLibraryEntryPoint=(-37);
const TInt KErrBadDescriptor=(-38);
const TInt KErrAbort=(-39);
const TInt KErrTooBig=(-40);
const TInt KErrDivideByZero=(-41);
const TInt KErrBadPower=(-42);
const TInt KErrDirFull=(-43);
const TInt KErrHardwareNotAvailable=(-44);
const TInt KErrSessionClosed=(-45);
const TInt KErrPermissionDenied=(-46);

 
 
 
 
 

const TInt KRequestPending=(-KMaxTInt);

enum TKernelPanic
	{
	EBadHandle=0,
	EAccessDenied=1,
	EBadName=2,
	ECausedException=3,
	ECompletion=4,
	ELeaveWithoutTrap=5,
	ESegmentReadOutOfRange=6,
	ESegmentWriteOutOfRange=7,
	EChunkSizeTooBig=8,
	ERequestAlreadyPending=9,
	ERequestNoInvalid=10,
	EBadUnitNumber=11,
	EEventAlreadyCaptured=12,
	EEventNotCaptured=13,
	EBadPriority=14,
	ETimerAlreadyPending=15,
	EAlreadyLoggedOn=16,
	EFailedKernelHeapCheck=17,
	ERequestFromWrongThread=18,
	EMesAlreadyPending=19,
	EEventRequestPending=20,
	EIllegalWsProcess=21,
	EHardwareNotAvailable=22,
	EUnsharableSession=23,
	EDesOverflow=24,
	ETransferBufferTooBigForWindow=25,
	ETransferBufferNotMappedIntoWindow=26,
	ETransferWindowAlreadyInUse=27,
	EMsgQueueRequestPending=28,
	EMsgQueueIllegalCancel=29,
	EMsgQueueInvalidSlots=30,
	EMsgQueueInvalidLength=31,
	};

 

enum TMediaType
	{
	EMediaNotPresent,
	EMediaUnknown,EMediaFloppy,EMediaHardDisk,EMediaCdRom,
	EMediaRam,EMediaFlash,EMediaRom,EMediaRemote
	};

 
const TUint KMediaSubTypeATACard=1;
const TUint KMediaSubTypeMMCCard=2;
const TUint KMediaSubTypeMMCCardSecure=3;
const TUint KMediaSubTypeSDCard=4;
const TUint KMediaSubTypeSDCardProtected=5;

enum TBatteryState {EBatNotSupported,EBatGood,EBatLow};

const TUint KDriveAttLocal=0x01;
const TUint KDriveAttRom=0x02;
const TUint KDriveAttRedirected=0x04;
const TUint KDriveAttSubsted=0x08;
const TUint KDriveAttInternal=0x10;
const TUint KDriveAttRemovable=0x20;
const TUint KDriveAttRemote=0x40;
const TUint KDriveAttTransaction=0x80;

const TUint KMediaAttVariableSize=0x01;
const TUint KMediaAttDualDensity=0x02;
const TUint KMediaAttFormattable=0x04;
const TUint KMediaAttWriteProtected=0x08;
const TUint KMediaAttLockable=0x10;
const TUint KMediaAttLocked=0x20;
const TUint KMediaAttHasPassword=0x40;

const TUint KMediaAttReadWhileWrite=0x80;


const TUint KDriveFileSysFAT=0x01;
const TUint KDriveFileSysROM=0x02;
const TUint KDriveFileSysLFFS=0x03;

enum TFalse {EFalse= 0 };
enum TTrue {ETrue= 1 };
enum TAllowDuplicates {ENoDuplicates,EAllowDuplicates};
enum TRadix {EBinary=2,EOctal=8,EDecimal=10,EHex=16};

 














 








enum TLanguage
	{
	 


	ELangTest = 0,
	 
	ELangEnglish = 1,
	 
	ELangFrench = 2,
	 
	ELangGerman = 3,
	 
	ELangSpanish = 4,
	 
	ELangItalian = 5,
	 
	ELangSwedish = 6,
	 
	ELangDanish = 7,
	 
	ELangNorwegian = 8,
	 
	ELangFinnish = 9,
	 
	ELangAmerican = 10,
	 
	ELangSwissFrench = 11,
	 
	ELangSwissGerman = 12,
	 
	ELangPortuguese = 13,
	 
	ELangTurkish = 14,
	 
	ELangIcelandic = 15,
	 
	ELangRussian = 16,
	 
	ELangHungarian = 17,
	 
	ELangDutch = 18,
	 
	ELangBelgianFlemish = 19,
	 
	ELangAustralian = 20,
	 
	ELangBelgianFrench = 21,
	 
	ELangAustrian = 22,
	 
	ELangNewZealand = 23,
	 
	ELangInternationalFrench = 24,
	 
	ELangCzech = 25,
	 
	ELangSlovak = 26,
	 
	ELangPolish = 27,
	 
	ELangSlovenian = 28,
	 
	ELangTaiwanChinese = 29,
	 
	ELangHongKongChinese = 30,
	 
	ELangPrcChinese = 31,
	 
	ELangJapanese = 32,
	 
	ELangThai = 33,
	 
	ELangAfrikaans = 34,
	 
	ELangAlbanian = 35,
	 
	ELangAmharic = 36,
	 
	ELangArabic = 37,
	 
	ELangArmenian = 38,
	 
	ELangTagalog = 39,
	 
	ELangBelarussian = 40,
	  
	ELangBengali = 41,
	 
	ELangBulgarian = 42,
	  
	ELangBurmese = 43,
	 
	ELangCatalan = 44,
	 
	ELangCroatian = 45,
	 
	ELangCanadianEnglish = 46,
	 
	ELangInternationalEnglish = 47,
	 
	ELangSouthAfricanEnglish = 48,
	 
	ELangEstonian = 49,
	 
	ELangFarsi = 50,
	 
	ELangCanadianFrench = 51,
	 
	ELangScotsGaelic = 52,
	 
	ELangGeorgian = 53,
	  
	ELangGreek = 54,
	 
	ELangCyprusGreek = 55,
	 
	ELangGujarati = 56,
	 
	ELangHebrew = 57,
	  
	ELangHindi = 58,
	 
	ELangIndonesian = 59,
	 
	ELangIrish = 60,
	 
	ELangSwissItalian = 61,
	 
	ELangKannada = 62,
	 
	ELangKazakh = 63,
	 
	ELangKhmer = 64,
	 
	ELangKorean = 65,
	 
	ELangLao = 66,
	 
	ELangLatvian = 67,
	 
	ELangLithuanian = 68,
	 
	ELangMacedonian = 69,
	 
	ELangMalay = 70,
	 
	ELangMalayalam = 71,
	  
	ELangMarathi = 72,
	 
	ELangMoldavian = 73,
	 
	ELangMongolian = 74,
	 
	ELangNorwegianNynorsk = 75,
	 
	ELangBrazilianPortuguese = 76,
	 
	ELangPunjabi = 77,
	 
	ELangRomanian = 78,
	 
	ELangSerbian = 79,
	 
	ELangSinhalese = 80,
	 
	ELangSomali = 81,
	 
	ELangInternationalSpanish = 82,
	 
	ELangLatinAmericanSpanish = 83,
	 
	ELangSwahili = 84,
	 
	ELangFinlandSwedish = 85,
	ELangReserved1 = 86,		 
	  
	ELangTamil = 87,
	 
	ELangTelugu = 88,
	 
	ELangTibetan = 89,
	 
	ELangTigrinya = 90,
	 
	ELangCyprusTurkish = 91,
	 
	ELangTurkmen = 92,
	 
	ELangUkrainian = 93,
	  
	ELangUrdu = 94,
	ELangReserved2 = 95,	 
	 
	ELangVietnamese = 96,
	 
	ELangWelsh = 97,
	 
	ELangZulu = 98,
	 
	ELangOther = 99,
	ELangNone = 0xFFFF,  
	ELangMaximum = ELangNone  
	};

 
const TUint KDialectMask=0x03FF;


 



enum TDateFormat 
	{
	 
	EDateAmerican,
	 
	EDateEuropean,
	 
	EDateJapanese
	};


 




enum TTimeFormat 
	{
	 
	ETime12,
	 
	ETime24
	};

 




enum TClockFormat 
	{
	 
	EClockAnalog,
	 
	EClockDigital
	};

 





enum TUnitsFormat 
	{
	 
	EUnitsImperial,
	 
	EUnitsMetric
	};

 




enum TAmPm 
	{
	 
	EAm,
	 
	EPm
	};

 



enum TDay
	{
	 
	EMonday,
	 
	ETuesday,
	 
	EWednesday,
	 
	EThursday,
	 
	EFriday,
	 
	ESaturday,
	 
	ESunday
	};

 











enum TMonth
	{
	 
	EJanuary,
	 
	EFebruary,
	 
	EMarch,
	 
	EApril,
	 
	EMay,
	  
	EJune,
	 
	EJuly,
	 
	EAugust,
	 
	ESeptember,
	 
	EOctober,
	 
	ENovember,
	 
	EDecember
	};

enum TOwnerType {EOwnerProcess,EOwnerThread};
enum TDllReason {EDllProcessAttach,EDllThreadAttach,EDllThreadDetach,EDllProcessDetach};

enum TProcessPriority
	{
	EPriorityLow=150,
	EPriorityBackground=250,
	EPriorityForeground=350,
	EPriorityHigh=450,
	EPriorityWindowServer=650,
	EPriorityFileServer=750,
	EPriorityRealTimeServer=850,
	EPrioritySupervisor=950
	};

enum TThreadPriority
	{
	EPriorityNull=(-30),
	EPriorityMuchLess=(-20),
	EPriorityLess=(-10),
	EPriorityNormal=0,
	EPriorityMore=10,
	EPriorityMuchMore=20,
	EPriorityRealTime=30,
	EPriorityAbsoluteVeryLow=100,
	EPriorityAbsoluteLow=200,
	EPriorityAbsoluteBackground=300,
	EPriorityAbsoluteForeground=400,
	EPriorityAbsoluteHigh=500
	};

enum TExcType
	{
	EExcGeneral=0,
	EExcIntegerDivideByZero=1,
	EExcSingleStep=2,
	EExcBreakPoint=3,
	EExcIntegerOverflow=4,
	EExcBoundsCheck=5,
	EExcInvalidOpCode=6,
	EExcDoubleFault=7,
	EExcStackFault=8,
	EExcAccessViolation=9,
	EExcPrivInstruction=10,
	EExcAlignment=11,
	EExcPageFault=12,
	EExcFloatDenormal=13,
	EExcFloatDivideByZero=14,
	EExcFloatInexactResult=15,
	EExcFloatInvalidOperation=16,
	EExcFloatOverflow=17,
	EExcFloatStackCheck=18,
	EExcFloatUnderflow=19,
	EExcAbort=20,
	EExcKill=21,
	EExcUserInterrupt=22,
	EExcDataAbort=23,
	EExcCodeAbort=24,
	EExcMaxNumber=25,
	EExcInvalidVector=26,
	};

enum TExitType {EExitKill,EExitTerminate,EExitPanic,EExitPending};
enum TAlign {ELeft,ECenter,ERight};

const TInt KRealFormatTypesMask=0x00000007;
const TInt KRealFormatFixed=1;
const TInt KRealFormatExponent=2;
const TInt KRealFormatGeneral=3;
const TInt KRealFormatNoExponent=4;
const TInt KRealFormatCalculator=5;

 

const TInt KRealFormatTypeFlagsMask=0x7C000000;
const TInt KExtraSpaceForSign=0x40000000;
const TInt KAllowThreeDigitExp=0x20000000;
const TInt KUseSigFigs=0x10000000;
const TInt KDoNotUseTriads=0x08000000;
const TInt KGeneralLimit=0x04000000;

enum TLeave {ELeave};

 





enum TFirstWeekRule 
	{
	 


	EFirstWeek,
	 




	EFirstFourDayWeek,
	 


	EFirstFullWeek
	};

enum TTimerLockSpec
	{
	EOneOClock,
	ETwoOClock,
	EThreeOClock,
	EFourOClock,
	EFiveOClock,
	ESixOClock,
	ESevenOClock,
	EEightOClock,
	ENineOClock,
	ETenOClock,
	EElevenOClock,
	ETwelveOClock
	};

typedef TInt (*TThreadFunction)(TAny *aPtr);
typedef TInt (*TLibraryFunction)();
typedef TInt (*TLibraryEntry)(TDllReason aReason);

inline TInt Lim(TInt aVal,TUint aLimit)
	{return(((TUint)aVal)<=aLimit);}

inline TInt LimX(TInt aVal,TUint aLimit)
	{return(((TUint)aVal)<aLimit);}

template <class T>
inline T Min(T aLeft,T aRight)
	{return(aLeft<aRight ? aLeft : aRight);}

template <class T>
inline T Min(T aLeft,TUint aRight)
	{return(aLeft<(TInt)aRight ? aLeft : (T)aRight);}

template <class T>
inline T Max(T aLeft,T aRight)
	{return(aLeft<aRight ? aRight : aLeft);}

template <class T>
inline T Max(T aLeft,TUint aRight)
	{return(aLeft<(TInt)aRight ? (TInt)aRight : aLeft);}

template <class T>
inline T Abs(T aVal)
	{return(aVal<0 ? -aVal : aVal);}

template <class T>
inline TBool Rng(T aMin,T aVal,T aMax)
	{return(aVal>=aMin && aVal<=aMax);}

template <class T,class S>
inline T* PtrAdd(T* aPtr,S aVal)
	{return((T*)(((TUint8*)aPtr)+aVal));}

template <class T,class S>
inline T* PtrSub(T* aPtr,S aVal)
	{return((T*)(((TUint8*)aPtr)-aVal));}

template <class T>
inline T Align2(T aValue)
	{return((T)((((TUint)aValue)+sizeof(TUint16)-1)&~(sizeof(TUint16)-1)));}

template <class T>
inline T Align4(T aValue)
	{return((T)((((TUint)aValue)+sizeof(TUint32)-1)&~(sizeof(TUint32)-1)));}

class TInt64
	{
public:
	inline TInt64();
	  TInt64(TInt aVal);
	inline TInt64(TUint aVal);
	inline TInt64(TUint aHigh,TUint aLow);
	  TInt64(TReal aVal);
	inline void Set(TUint aHigh,TUint aLow);
	inline TUint Low() const;
	inline TUint High() const;
	  TInt GetTInt() const;
	  TReal GetTReal() const;
	  TInt64 &operator=(TInt aVal);
	inline TInt64& operator=(TUint aVal);
	  TInt64& operator=(TReal aVal);
	  TInt64& operator+=(const TInt64 &aVal);
	  TInt64& operator-=(const TInt64 &aVal);
	  TInt64& operator*=(const TInt64 &aVal);
	  TInt64& operator/=(const TInt64 &aVal);
	  TInt64& operator%=(const TInt64 &aVal);
	  TInt64& operator>>=(TInt aShift);
	  TInt64& operator<<=(TInt aShift);
	  TInt64 operator+() const;
	  TInt64 operator-() const;
	  TInt64& operator++();
	  TInt64 operator++(TInt);
	  TInt64& operator--();
	  TInt64 operator--(TInt);
	  TInt64 operator+(const TInt64 &aVal) const;
	  TInt64 operator-(const TInt64 &aVal) const;
	  TInt64 operator*(const TInt64 &aVal) const;
	  TInt64 operator/(const TInt64 &aVal) const;
	  TInt64 operator%(const TInt64 &aVal) const;
	  TInt64 operator>>(TInt aShift) const;
	  TInt64 operator<<(TInt aShift) const;
	  void Lsr(TInt aShift);
	  void Mul10();
	  TInt MulTop(const TInt64 &aVal);
	  void DivMod(const TInt64 &aVal,TInt64 &aRemainder);
	  TInt operator==(const TInt64 &aVal) const;
	  TInt operator!=(const TInt64 &aVal) const;
	  TInt operator>=(const TInt64 &aVal) const;
	  TInt operator<=(const TInt64 &aVal) const;
	  TInt operator>(const TInt64 &aVal) const;
	  TInt operator<(const TInt64 &aVal) const;
protected:
	TUint iLow;
	TUint iHigh;
	};

typedef void TExceptionHandler(TExcType);

 

const TUint KExceptionAbort=0x01;
const TUint KExceptionKill=0x02;
const TUint KExceptionUserInterrupt=0x04;
const TUint KExceptionFpe=0x08;
const TUint KExceptionFault=0x10;
const TUint KExceptionInteger=0x20;
const TUint KExceptionDebug=0x40;

template <class T>
class TRefByValue
	{
public:
	inline TRefByValue(T& aRef);
	inline operator T&();
private:
	TRefByValue& operator=(TRefByValue aRef);
private:
	T &iRef;
	};

class TFunctor
	{
public:
	  virtual void operator()() =0;
	};

class TCallBack
	{
public:
	inline TCallBack();
	inline TCallBack(TInt (*aFunction)(TAny* aPtr));
	inline TCallBack(TInt (*aFunction)(TAny* aPtr),TAny* aPtr);
	inline TInt CallBack() const;
public:
	TInt (*iFunction)(TAny* aPtr);
	TAny* iPtr;
	};

class TSglQueLink
	{




private:
	  void Enque(TSglQueLink* aLink);
public:
	TSglQueLink* iNext;
	friend class TSglQueBase;
	};

class TDblQueLinkBase
	{
public:
	inline TDblQueLinkBase() : iNext(0L ) {}
	  void Enque(TDblQueLinkBase* aLink);
	  void AddBefore(TDblQueLinkBase* aLink);
public:
	TDblQueLinkBase* iNext;
	TDblQueLinkBase* iPrev;
	};

class TDblQueLink : public TDblQueLinkBase
	{
public:
	  void Deque();
	};

class TPriQueLink : public TDblQueLink
	{
public:
	TInt iPriority;
	};

class TDeltaQueLink : public TDblQueLinkBase
	{
public:
	TInt iDelta;
	};

class TSglQueBase
	{
public:
	  TBool IsEmpty() const;
	  void SetOffset(TInt anOffset);
	  void Reset();
protected:
	  TSglQueBase();
	  TSglQueBase(TInt anOffset);
	  void DoAddFirst(TAny* aPtr);
	  void DoAddLast(TAny* aPtr);
	  void DoRemove(TAny* aPtr);
protected:
	TSglQueLink* iHead;
	TSglQueLink* iLast;
	TInt iOffset;
private:
	TSglQueBase(const TSglQueBase& aQue);
	TSglQueBase &operator=(const TSglQueBase& aQue);
	friend class TSglQueIterBase;
	};

class TDblQueBase
	{
public:
	  TBool IsEmpty() const;
	  void SetOffset(TInt anOffset);
	  void Reset();
protected:
	  TDblQueBase();
	  TDblQueBase(TInt anOffset);
	  void DoAddFirst(TAny* aPtr);
	  void DoAddLast(TAny* aPtr);
	  void DoAddPriority(TAny* aPtr);
	  void __DbgTestEmpty() const;
protected:
	TDblQueLink iHead;
	TInt iOffset;
private:
	TDblQueBase(const TDblQueBase& aQue);
	TDblQueBase& operator=(const TDblQueBase& aQue);
	friend class TDblQueIterBase;
	};

class TDeltaQueBase : public TDblQueBase
	{
public:
	  TBool CountDown();
	  TBool CountDown(TInt aValue);
	  TBool FirstDelta(TInt& aValue);
	  void Reset();
protected:
	  TDeltaQueBase();
	  TDeltaQueBase(TInt anOffset);
	  void DoAddDelta(TAny* aPtr,TInt aDelta);
	  void DoRemove(TAny* aPtr);
	  TAny* DoRemoveFirst();
protected:
	TInt* iFirstDelta;
	};

template <class T>
class TSglQue : public TSglQueBase
	{
public:
	inline TSglQue();
	inline TSglQue(TInt anOffset);
	inline void AddFirst(T& aRef);
	inline void AddLast(T& aRef);
	inline TBool IsFirst(const T* aPtr) const;
	inline TBool IsLast(const T* aPtr) const;
	inline T* First() const;
	inline T* Last() const;
	inline void Remove(T& aRef);
	};

template <class T>
class TDblQue : public TDblQueBase
	{
public:
	inline TDblQue();
	inline TDblQue(TInt anOffset);
	inline void AddFirst(T& aRef);
	inline void AddLast(T& aRef);
	inline TBool IsHead(const T* aPtr) const;
	inline TBool IsFirst(const T* aPtr) const;
	inline TBool IsLast(const T* aPtr) const;
	inline T* First() const;
	inline T* Last() const;
	};

template <class T>
class TPriQue : public TDblQueBase
	{
public:
	inline TPriQue();
	inline TPriQue(TInt anOffset);
	inline void Add(T& aRef);
	inline TBool IsHead(const T* aPtr) const;
	inline TBool IsFirst(const T* aPtr) const;
	inline TBool IsLast(const T* aPtr) const;
	inline T* First() const;
	inline T* Last() const;
	};

template <class T>
class TDeltaQue : public TDeltaQueBase
	{
public:
	inline TDeltaQue();
	inline TDeltaQue(TInt anOffset);
	inline void Add(T& aRef,TInt aDelta);
	inline void Remove(T& aRef);
	inline T* RemoveFirst();
	};

class TSglQueIterBase
	{
public:
	  void SetToFirst();
protected:
	  TSglQueIterBase(TSglQueBase& aQue);
	  TAny* DoPostInc();
	  TAny* DoCurrent();
	  void DoSet(TAny* aLink);
protected:
	TInt iOffset;
	TSglQueLink* iHead;
	TSglQueLink* iNext;
	};

template <class T>
class TSglQueIter : public TSglQueIterBase
	{
public:
	inline TSglQueIter(TSglQueBase& aQue);
	inline void Set(T& aLink);
	inline operator T*();
	inline T* operator++(TInt);
	};

class TDblQueIterBase
	{
public:
	  void SetToFirst();
	  void SetToLast();
protected:
	  TDblQueIterBase(TDblQueBase& aQue);
	  TAny* DoPostInc();
	  TAny* DoPostDec();
	  TAny* DoCurrent();
	  void DoSet(TAny* aLink);
protected:
	TInt iOffset;
	TDblQueLinkBase* iHead;
	TDblQueLinkBase* iNext;
	};
 
template <class T>
class TDblQueIter : public TDblQueIterBase
	{
public:
	inline TDblQueIter(TDblQueBase& aQue);
	inline void Set(T& aLink);
	inline operator T*();
	inline T* operator++(TInt);
	inline T* operator--(TInt);
	};

enum TKeyCmpText
	{
	ECmpNormal,ECmpNormal8,ECmpNormal16,
	ECmpFolded,ECmpFolded8,ECmpFolded16,
	ECmpCollated,ECmpCollated8,ECmpCollated16
	};

enum TKeyCmpNumeric
	{
	ECmpTInt8=((ECmpCollated16+1)<<1),ECmpTInt16,ECmpTInt32,ECmpTInt,
	ECmpTUint8,ECmpTUint16,ECmpTUint32,ECmpTUint,
	ECmpTInt64
	};

class TKey
	{
public:
	inline void SetPtr(const TAny* aPtr);
	  virtual TInt Compare(TInt aLeft,TInt aRight) const;
	  virtual TAny* At(TInt anIndex) const;
protected:
	  TKey();
	  TKey(TInt anOffset,TKeyCmpText aType);
	  TKey(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKey(TInt anOffset,TKeyCmpNumeric aType);
protected:
	TInt iKeyOffset;
	TInt iKeyLength;
	TInt iCmpType;
	const TAny* iPtr;
	};

class TSwap
	{
public:
	  TSwap();
	  virtual void Swap(TInt aLeft,TInt aRight) const;
	};

class TDesC16;	 
class TPtrC16;	 

class TChar
	{
public:

	 



	enum TCategory
		{
		EAlphaGroup = 0x00,								 
		ELetterOtherGroup = 0x10,						 
		ELetterModifierGroup = 0x20,					 
		EMarkGroup = 0x30,
		ENumberGroup = 0x40,
		EPunctuationGroup = 0x50,
		ESymbolGroup = 0x60,
		ESeparatorGroup = 0x70,
		EControlGroup = 0x80,
		EMaxAssignedGroup = 0xE0,
		EUnassignedGroup = 0xF0,

		ELuCategory = EAlphaGroup | 0,					 
		ELlCategory = EAlphaGroup | 1,					 
		ELtCategory = EAlphaGroup | 2,					 
		ELoCategory = ELetterOtherGroup | 0,			 
		EMaxLetterCategory = ELetterOtherGroup | 0x0F,	 

		ELmCategory = ELetterModifierGroup | 0,			 
		EMaxLetterOrLetterModifierCategory = ELetterModifierGroup | 0x0F,  

		EMnCategory = EMarkGroup | 0,					 
		EMcCategory = EMarkGroup | 1,					 
		EMeCategory = EMarkGroup | 2,					 
		ENdCategory = ENumberGroup | 0,					 
		ENlCategory = ENumberGroup | 1,					 
		ENoCategory = ENumberGroup | 2,					 
		EPcCategory = EPunctuationGroup | 0,			 
		EPdCategory = EPunctuationGroup | 1,			 
		EPsCategory = EPunctuationGroup | 2,			 
		EPeCategory = EPunctuationGroup | 3,			 
		EPiCategory = EPunctuationGroup | 4,			 
		EPfCategory = EPunctuationGroup | 5,			 
		EPoCategory = EPunctuationGroup | 6,			 
		ESmCategory = ESymbolGroup | 0,					 
		EScCategory = ESymbolGroup | 1,					 
		ESkCategory = ESymbolGroup | 2,					 
		ESoCategory = ESymbolGroup | 3,					 
		EMaxGraphicCategory = ESymbolGroup | 0x0F,		 

		EZsCategory = ESeparatorGroup | 0,				 
		EMaxPrintableCategory = EZsCategory,			 

		EZlCategory = ESeparatorGroup | 1,				 
		EZpCategory = ESeparatorGroup | 2,				 
		ECcCategory = EControlGroup | 0,				 
		ECfCategory = EControlGroup | 1,				 
		EMaxAssignedCategory = EMaxAssignedGroup | 0x0F, 
														 
														 

		ECsCategory = EUnassignedGroup | 0,				 
		ECoCategory = EUnassignedGroup | 1,				 
		ECnCategory = EUnassignedGroup | 2				 
		};

	 
	enum TBdCategory
		{
		ELeftToRight,				 
		ELeftToRightEmbedding,		 
		ELeftToRightOverride,		 
		ERightToLeft,				 
		ERightToLeftArabic,			 
		ERightToLeftEmbedding,		 
		ERightToLeftOverride,		 
		EPopDirectionalFormat,		 
		EEuropeanNumber,			 
		EEuropeanNumberSeparator,	 
		EEuropeanNumberTerminator,	 
		EArabicNumber,				 
		ECommonNumberSeparator,		 
		ENonSpacingMark,			 
		EBoundaryNeutral,			 
		EParagraphSeparator,		 
		ESegmentSeparator,			 
		EWhitespace,				 
		EOtherNeutral				 
		};

	 
	enum TCjkWidth
		{
		ENeutralWidth,			 
		EHalfWidth,				 
		EFullWidth,
		ENarrow,
		EWide
		};

	 
  	enum TEncoding
  		{
  		EUnicode,				 
  		EShiftJIS				 
  		};
  
	 
	enum
		{

		EFoldCase = 1,			 
		EFoldAccents = 2,		 
		EFoldDigits = 4,		 
		EFoldSpaces = 8,		 
		EFoldKana = 16,			 
		EFoldWidth = 32,		 
		EFoldStandard = EFoldCase | EFoldAccents | EFoldDigits | EFoldSpaces,
								 

		EFoldAll = -1			 
		};

	 
	struct TCharInfo
		{
		TCategory iCategory;				 
		TBdCategory iBdCategory;			 
		TInt iCombiningClass;				 
		TUint iLowerCase;					 
		TUint iUpperCase;					 
		TUint iTitleCase;					 
		TBool iMirrored;					 
		TInt iNumericValue;					 
		};

	inline TChar();
	inline TChar(TUint aChar);
	inline TChar& operator-=(TUint aChar);
	inline TChar& operator+=(TUint aChar);
	inline TChar operator-(TUint aChar);
	inline TChar operator+(TUint aChar);
	inline operator TUint() const;
	inline void Fold();
	inline void LowerCase();
	inline void UpperCase();
	inline TBool Eos() const;
	  TUint GetUpperCase() const;
	  TUint GetLowerCase() const;
	  TBool IsLower() const;
	  TBool IsUpper() const;
	  TBool IsAlpha() const;
	  TBool IsDigit() const;
	  TBool IsAlphaDigit() const;
	  TBool IsHexDigit() const;
	  TBool IsSpace() const;
	  TBool IsPunctuation() const;
	  TBool IsGraph() const;
	  TBool IsPrint() const;
	  TBool IsControl() const;
	inline void Fold(TInt aFlags);
	inline void TitleCase();
	  TUint GetTitleCase() const;
	  TBool IsTitle() const;
	  TBool IsAssigned() const;
	  void GetInfo(TCharInfo& aInfo) const;
	  TCategory GetCategory() const;
	  TBdCategory GetBdCategory() const;
	  TInt GetCombiningClass() const;
	  TBool IsMirrored() const;
	  TInt GetNumericValue() const;
	  TCjkWidth GetCjkWidth() const;
	  static TBool Compose(TUint& aResult,const TDesC16& aSource);
	  TBool Decompose(TPtrC16& aResult) const;
	 
  	  TBool TranslateFromUnicode(TUint& aCode,TEncoding aEncoding) const;
	 
  	  static TBool TranslateToUnicode(TUint& aTo,TUint aFrom,TEncoding aEncoding);

protected:
	inline void SetChar(TUint aChar);
private:
	TUint iChar;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TCharF : public TChar
	{
public:
	inline TCharF(TUint aChar);
	inline TCharF(const TChar &aChar);
	inline TCharF& operator=(TUint aChar);
	inline TCharF& operator=(const TChar &aChar);
	};

class TCharLC : public TChar
	{
public:
	inline TCharLC(TUint aChar);
	inline TCharLC(const TChar& aChar);
	inline TCharLC& operator=(TUint aChar);
	inline TCharLC& operator=(const TChar& aChar);
	};

class TCharUC : public TChar
	{
public:
	inline TCharUC(TUint aChar);
	inline TCharUC(const TChar& aChar);
	inline TCharUC& operator=(TUint aChar);
	inline TCharUC& operator=(const TChar& aChar);
	};

class TRealFormat
	{
public:
	  TRealFormat();
	  TRealFormat(TInt aWidth);
	  TRealFormat(TInt aWidth,TInt aDecimalPlaces);
public:
	TInt iType;
	TInt iWidth;
	TInt iPlaces;
	TChar iPoint;
	TChar iTriad;
	TInt iTriLen;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32des8.h" 1
 
 
 
 
 








const TUint KMaskDesLength8=0xfffffff;
const TInt KShiftDesType8=28;

class TBufCBase8;
class HBufC8;
class TDes8;
class TPtrC8;
class TPtr8;
class TDesC8
    {
public:
	inline TInt operator<(const TDesC8 &aDes) const;
	inline TInt operator<=(const TDesC8 &aDes) const;
	inline TInt operator>(const TDesC8 &aDes) const;
	inline TInt operator>=(const TDesC8 &aDes) const;
	inline TInt operator==(const TDesC8 &aDes) const;
	inline TInt operator!=(const TDesC8 &aDes) const;
	inline const TUint8 &operator[](TInt anIndex) const;
	inline TInt Length() const;
	inline TInt Size() const;
	  const TUint8 *Ptr() const;
	  TInt Compare(const TDesC8 &aDes) const;
	  TInt CompareF(const TDesC8 &aDes) const;
	  TInt CompareC(const TDesC8 &aDes) const;
	  TInt Match(const TDesC8 &aDes) const;
	  TInt MatchF(const TDesC8 &aDes) const;
	  TInt MatchC(const TDesC8 &aDes) const;
	  TInt Locate(TChar aChar) const;
	  TInt LocateF(TChar aChar) const;
	  TInt LocateReverse(TChar aChar) const;
	  TInt LocateReverseF(TChar aChar) const;
	  TInt Find(const TDesC8 &aDes) const;
	  TInt Find(const TUint8 *pS,TInt aLenS) const;
	  TInt FindF(const TDesC8 &aDes) const;
	  TInt FindF(const TUint8 *pS,TInt aLenS) const;
	  TInt FindC(const TDesC8 &aDes) const;
	  TInt FindC(const TUint8 *pS,TInt aLenS) const;
	  TPtrC8 Left(TInt aLength) const;
	  TPtrC8 Right(TInt aLength) const;
	  TPtrC8 Mid(TInt aPos) const;
	  TPtrC8 Mid(TInt aPos,TInt aLength) const;
	  HBufC8 *Alloc() const;
	  HBufC8 *AllocL() const;
	  HBufC8 *AllocLC() const;
protected:
	inline TDesC8(TInt aType,TInt aLength);
	inline TDesC8() {}
 
	inline TInt Type() const;
	inline void DoSetLength(TInt aLength);
	  const TUint8 &AtC(TInt anIndex) const;
private:

	TUint iLength;




	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtrC8 : public TDesC8
	{
public:
	  TPtrC8();
	  TPtrC8(const TDesC8 &aDes);
	  TPtrC8(const TUint8 *aString);
	  TPtrC8(const TUint8 *aBuf,TInt aLength);
	inline void Set(const TUint8 *aBuf,TInt aLength);
	inline void Set(const TDesC8 &aDes);
	inline void Set(const TPtrC8& aPtr);
private:
	TPtrC8& operator=(const TPtrC8 &aDes);
protected:
	const TUint8 *iPtr;
private:
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TDes8Overflow
	{
public:
	virtual void Overflow(TDes8 &aDes)=0;
	};
 
class TDesC16;
class TDes8 : public TDesC8
	{
public:
	inline TDes8& operator=(const TUint8 *aString);
	inline TDes8& operator=(const TDesC8 &aDes);
	inline TDes8& operator=(const TDes8 &aDes);
	inline TInt MaxLength() const;
	inline TInt MaxSize() const;
	inline const TUint8 &operator[](TInt anIndex) const;
	inline TUint8 &operator[](TInt anIndex);
	inline TDes8 &operator+=(const TDesC8 &aDes);
	  void Zero();
	  const TUint8 *PtrZ();
 	  void SetLength(TInt aLength);
 	  void SetMax();
	  void Copy(const TDesC8 &aDes);
	  void Copy(const TUint8 *aBuf,TInt aLength);
	  void Copy(const TUint8 *aString);
	  void Copy(const TDesC16 &aDes);
	  void CopyF(const TDesC8 &aDes);
	  void CopyC(const TDesC8 &aDes);
	  void CopyLC(const TDesC8 &aDes);
	  void CopyUC(const TDesC8 &aDes);
	  void CopyCP(const TDesC8 &aDes);
	  void Append(TChar aChar);
	  void Append(const TDesC8 &aDes);
	  void Append(const TDesC16 &aDes);
	  void Append(const TUint8 *aBuf,TInt aLength);
	  void AppendFill(TChar aChar,TInt aLength);
	  void ZeroTerminate();
	  void Fill(TChar aChar);
	  void Fill(TChar aChar,TInt aLength);
	  void FillZ();
	  void FillZ(TInt aLength);
	  void Swap(TDes8 &aDes);
	  void Fold();
	  void Collate();
	  void LowerCase();
	  void UpperCase();
	  void Capitalize();
	  void Repeat(const TUint8 *aBuf,TInt aLength);
	  void Repeat(const TDesC8 &aDes);
	  void Trim();
	  void TrimAll();
	  void TrimLeft();
	  void TrimRight();
	  void Insert(TInt aPos,const TDesC8 &aDes);
	  void Delete(TInt aPos,TInt aLength);
	  void Replace(TInt aPos,TInt aLength,const TDesC8 &aDes);
	  void Justify(const TDesC8 &aDes,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void Num(TInt aVal);
	  void Num(TUint aVal,TRadix aRadix=EDecimal);
	  void NumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void NumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void NumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void Num(TInt64 aVal);
	  void Num(TInt64 aVal,TRadix aRadix);
	  void NumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt Num(TReal aVal,const TRealFormat &aFormat);
	  void Format(TRefByValue<const TDesC8> aFmt,...);
	  void FormatList(const TDesC8 &aFmt,VA_LIST aList);
	  void AppendJustify(const TDesC8 &Des,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TDesC8 &Des,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint8 *aString,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint8 *aString,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendNum(TInt aVal);
	  void AppendNum(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNum(TInt64 aVal);
	  void AppendNum(TInt64 aVal,TRadix aRadix);
	  void AppendNumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt AppendNum(TReal aVal,const TRealFormat &aFormat);
	  void AppendFormat(TRefByValue<const TDesC8> aFmt,TDes8Overflow *aOverflowHandler,...);
	  void AppendFormat(TRefByValue<const TDesC8> aFmt,...);
	  void AppendFormatList(const TDesC8 &aFmt,VA_LIST aList,TDes8Overflow *aOverflowHandler= 0L );
	  TPtr8 LeftTPtr(TInt aLength) const;
	  TPtr8 RightTPtr(TInt aLength) const;
	  TPtr8 MidTPtr(TInt aPos) const;
	  TPtr8 MidTPtr(TInt aPos,TInt aLength) const;
protected:
	inline TDes8(TInt aType,TInt aLength,TInt aMaxLength);
	inline TUint8 *WPtr() const;
	inline TDes8() {}
 
protected:
	TInt iMaxLength;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtr8 : public TDes8
	{
public:
	  TPtr8(TUint8 *aBuf,TInt aMaxLength);
	  TPtr8(TUint8 *aBuf,TInt aLength,TInt aMaxLength);
	inline TPtr8& operator=(const TUint8 *aString);
	inline TPtr8& operator=(const TDesC8& aDes);
	inline TPtr8& operator=(const TPtr8& aPtr);
	inline void Set(TUint8 *aBuf,TInt aLength,TInt aMaxLength);
	inline void Set(const TPtr8 &aPtr);
private:
	  TPtr8(TBufCBase8 &aLcb,TInt aMaxLength);
protected:
	TUint8 *iPtr;
private:
	friend class TBufCBase8;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TBufCBase8 : public TDesC8
	{
protected:
	  TBufCBase8();
	inline TBufCBase8(TInt aLength);
	  TBufCBase8(const TUint8 *aString,TInt aMaxLength);
	  TBufCBase8(const TDesC8 &aDes,TInt aMaxLength);
	  void Copy(const TUint8 *aString,TInt aMaxLength);
	  void Copy(const TDesC8 &aDes,TInt aMaxLength);
	inline TPtr8 DoDes(TInt aMaxLength);
	inline TUint8 *WPtr() const;
	};
 
class RReadStream;
class HBufC8 : public TBufCBase8
	{
public:
	  static HBufC8 *New(TInt aMaxLength);
	  static HBufC8 *NewL(TInt aMaxLength);
	  static HBufC8 *NewLC(TInt aMaxLength);
	  static HBufC8 *NewMax(TInt aMaxLength);
	  static HBufC8 *NewMaxL(TInt aMaxLength);
	  static HBufC8 *NewMaxLC(TInt aMaxLength);
	  static HBufC8 *NewL(RReadStream &aStream,TInt aMaxLength);
	  static HBufC8 *NewLC(RReadStream &aStream,TInt aMaxLength);
	  HBufC8& operator=(const TUint8 *aString);
	  HBufC8& operator=(const TDesC8 &aDes);
	inline HBufC8& operator=(const HBufC8 &aLcb);
	  HBufC8 *ReAlloc(TInt aMaxLength);
	  HBufC8 *ReAllocL(TInt aMaxLength);
	  TPtr8 Des();
private:
	inline HBufC8(TInt aLength);
private:
	TText8 iBuf[1];
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 


 
template <TInt S>
class TBufC8 : public TBufCBase8
	{
public:
	inline TBufC8();
    inline TBufC8(const TUint8 *aString);
	inline TBufC8(const TDesC8 &aDes);
	inline TBufC8<S> &operator=(const TUint8 *aString);
	inline TBufC8<S> &operator=(const TDesC8 &aDes);
	inline TPtr8 Des();
protected:
	TUint8 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt8)) -1)/ (sizeof(TInt)/sizeof(TInt8)) )* (sizeof(TInt)/sizeof(TInt8)) ) ];
	};
 
class TBufBase8 : public TDes8
	{
protected:
	  TBufBase8(TInt aMaxLength);
	  TBufBase8(TInt aLength,TInt aMaxLength);
	  TBufBase8(const TUint8* aString,TInt aMaxLength);
	  TBufBase8(const TDesC8& aDes,TInt aMaxLength);
	};
 
template <TInt S>
class TBuf8 : public TBufBase8
	{
public:
	inline TBuf8();
	inline TBuf8(TInt aLength);
    inline TBuf8(const TUint8* aString);
	inline TBuf8(const TDesC8& aDes);
	inline TBuf8<S>& operator=(const TUint8* aString);
	inline TBuf8<S>& operator=(const TDesC8& aDes);
	inline TBuf8<S>& operator=(const TBuf8<S>& aBuf);
protected:
	TUint8 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt8)) -1)/ (sizeof(TInt)/sizeof(TInt8)) )* (sizeof(TInt)/sizeof(TInt8)) ) ];
	};
 
typedef TRefByValue<const TDesC8> __TRefDesC8;
template <TInt S>
class TLitC8
	{
public:
	inline const TDesC8* operator&() const;
	inline operator const TDesC8&() const;
	inline const TDesC8& operator()() const;
	inline operator const __TRefDesC8() const;
public:
	TUint iTypeLength;
	TText8 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt8)) -1)/ (sizeof(TInt)/sizeof(TInt8)) )* (sizeof(TInt)/sizeof(TInt8)) ) ];
	};

class RBuf8 : public TDes8
 
















	{
public:
	  RBuf8();
	  explicit RBuf8(HBufC8* aHBuf);
	  void Assign(const RBuf8& aRBuf);
	  void Assign(TUint8 *aHeapCell,TInt aMaxLength);
	  void Assign(TUint8 *aHeapCell,TInt aLength,TInt aMaxLength);
	  void Assign(HBufC8* aHBuf);
	  void Swap(RBuf8& aRBuf);
	  TInt Create(TInt aMaxLength);
	  void CreateL(TInt aMaxLength);
	  TInt CreateMax(TInt aMaxLength);
	  void CreateMaxL(TInt aMaxLength);
	inline void CreateL(RReadStream &aStream,TInt aMaxLength);
	  TInt Create(const TDesC8& aDes);
	  void CreateL(const TDesC8& aDes);
	  TInt Create(const TDesC8& aDes,TInt aMaxLength);
	  void CreateL(const TDesC8& aDes,TInt aMaxLength);
	  TInt ReAlloc(TInt aMaxLength);
	  void ReAllocL(TInt aMaxLength);
	  void Close();
	  void CleanupClosePushL();

protected:
	  RBuf8(TInt aType,TInt aLength,TInt aMaxLength);
	RBuf8(const RBuf8&);  
	union
		{
		TUint8* iEPtrType;		 
		HBufC8* iEBufCPtrType;	 
		};
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


# 1334 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32des16.h" 1
 
 
 
 
 








const TUint KMaskDesLength16=0xfffffff;
const TInt KShiftDesType16=28;

class TBufCBase16;
class HBufC16;
class TDes16;
class TPtrC16;
class TPtr16;
struct TCollationMethod;

class TDesC16
    {
public:
	enum TPrefix { EIsPrefix = 0, EMightBePrefix = 1, EIsNotPrefix = 2 };

	inline TInt operator<(const TDesC16 &aDes) const;
	inline TInt operator<=(const TDesC16 &aDes) const;
	inline TInt operator>(const TDesC16 &aDes) const;
	inline TInt operator>=(const TDesC16 &aDes) const;
	inline TInt operator==(const TDesC16 &aDes) const;
	inline TInt operator!=(const TDesC16 &aDes) const;
	inline const TUint16 &operator[](TInt anIndex) const;
	inline TInt Length() const;
	inline TInt Size() const;
	  const TUint16 *Ptr() const;
	  TInt Compare(const TDesC16 &aDes) const;
	  TInt CompareF(const TDesC16 &aDes) const;
	  TInt CompareC(const TDesC16 &aDes) const;
	  TInt CompareC(const TDesC16& aDes,TInt aMaxLevel,const TCollationMethod* aCollationMethod) const;	
	  TInt Match(const TDesC16 &aDes) const;
	  TInt MatchF(const TDesC16 &aDes) const;
	  TInt MatchC(const TDesC16 &aDes) const;
	  TInt Locate(TChar aChar) const;
	  TInt LocateF(TChar aChar) const;
	  TInt LocateReverse(TChar aChar) const;
	  TInt LocateReverseF(TChar aChar) const;
	  TInt Find(const TDesC16 &aDes) const;
	  TInt Find(const TUint16 *aBuf,TInt aLen) const;
	  TInt FindF(const TDesC16 &aDes) const;
	  TInt FindF(const TUint16 *aBuf,TInt aLen) const;
	  TInt FindC(const TDesC16 &aDes) const;
	  TInt FindC(const TUint16 *aBuf,TInt aLen) const;
	  TInt FindC(const TUint16 *aBuf,TInt aLen, TInt aMaxLevel) const;
	  TPrefix HasPrefixC(const TDesC16& aPossiblePrefix,
		TInt aLevel, const TCollationMethod* aCollationMethod) const;
	  TPtrC16 Left(TInt aLength) const;
	  TPtrC16 Right(TInt aLength) const;
	  TPtrC16 Mid(TInt aPos) const;
	  TPtrC16 Mid(TInt aPos,TInt aLength) const;
	  HBufC16 *Alloc() const;
	  HBufC16 *AllocL() const;
	  HBufC16 *AllocLC() const;
protected:
	inline TDesC16() {}
	inline TDesC16(TInt aType,TInt aLength);
 
	inline TInt Type() const;
	inline void DoSetLength(TInt aLength);
	  const TUint16 &AtC(TInt anIndex) const;
private:

	TUint iLength;




	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtrC16 : public TDesC16
	{
public:
	  TPtrC16();
	  TPtrC16(const TDesC16 &aDes);
	  TPtrC16(const TUint16 *aString);
	  TPtrC16(const TUint16 *aBuf,TInt aLength);
	inline void Set(const TUint16 *aBuf,TInt aLength);
	inline void Set(const TDesC16 &aDes);
	inline void Set(const TPtrC16 &aPtr);
private:
	TPtrC16& operator=(const TPtrC16 &aDes);
protected:
	const TUint16 *iPtr;
private:
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TDes16Overflow
	{
public:
	virtual void Overflow(TDes16 &aDes)=0;
	};
 
class TDes16 : public TDesC16
	{
public:
	inline TDes16& operator=(const TUint16 *aString);
	inline TDes16& operator=(const TDesC16 &aDes);
	inline TDes16& operator=(const TDes16 &aDes);
	inline TInt MaxLength() const;
	inline TInt MaxSize() const;
	inline const TUint16 &operator[](TInt anIndex) const;
	inline TUint16 &operator[](TInt anIndex);
	inline TDes16 &operator+=(const TDesC16 &aDes);
	  void Zero();
	  const TUint16 *PtrZ();
 	  void SetLength(TInt aLength);
 	  void SetMax();
	  void Copy(const TDesC8 &aDes);
	  void Copy(const TDesC16 &aDes);
	  void Copy(const TUint16 *aBuf,TInt aLength);
	  void Copy(const TUint16 *aString);
	  void CopyF(const TDesC16 &aDes);
	  void CopyC(const TDesC16 &aDes);
	  void CopyLC(const TDesC16 &aDes);
	  void CopyUC(const TDesC16 &aDes);
	  void CopyCP(const TDesC16 &aDes);
	  void Append(TChar aChar);
	  void Append(const TDesC16 &aDes);
	  void Append(const TUint16 *aBuf,TInt aLength);
	  void AppendFill(TChar aChar,TInt aLength);
	  void ZeroTerminate();
	  void Fill(TChar aChar);
	  void Fill(TChar aChar,TInt aLength);
	  void FillZ();
	  void FillZ(TInt aLength);
	  void Swap(TDes16 &aDes);
	  void Fold();
	  void Collate();
	  void LowerCase();
	  void UpperCase();
	  void Capitalize();
	  void Repeat(const TDesC16 &aDes);
	  void Repeat(const TUint16 *aBuf,TInt aLength);
	  void Trim();
	  void TrimAll();
	  void TrimLeft();
	  void TrimRight();
	  void Insert(TInt aPos,const TDesC16 &aDes);
	  void Delete(TInt aPos,TInt aLength);
	  void Replace(TInt aPos,TInt aLength,const TDesC16 &aDes);
	  void Justify(const TDesC16 &aDes,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void Num(TInt aVal);
	  void Num(TUint aVal,TRadix aRadix=EDecimal);
	  void NumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void NumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void NumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void Num(TInt64 aVal);
	  void Num(TInt64 aVal,TRadix aRadix);
	  void NumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt Num(TReal aVal,const TRealFormat &aFormat);
	  void Format(TRefByValue<const TDesC16> aFmt,...);
	  void FormatList(const TDesC16 &aFmt,VA_LIST aList);
	  void AppendJustify(const TDesC16 &Des,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TDesC16 &Des,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint16 *aString,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint16 *aString,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendNum(TInt aVal);
	  void AppendNum(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNum(TInt64 aVal);
	  void AppendNum(TInt64 aVal,TRadix aRadix);
	  void AppendNumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt AppendNum(TReal aVal,const TRealFormat &aFormat);
	  void AppendFormat(TRefByValue<const TDesC16> aFmt,TDes16Overflow *aOverflowHandler,...);
	  void AppendFormat(TRefByValue<const TDesC16> aFmt,...);
	  void AppendFormatList(const TDesC16 &aFmt,VA_LIST aList,TDes16Overflow *aOverflowHandler= 0L );
	  TPtr16 LeftTPtr(TInt aLength) const;
	  TPtr16 RightTPtr(TInt aLength) const;
	  TPtr16 MidTPtr(TInt aPos) const;
	  TPtr16 MidTPtr(TInt aPos,TInt aLength) const;
protected:
	inline TDes16() {}
	inline TDes16(TInt aType,TInt aLength,TInt aMaxLength);
	inline TUint16 *WPtr() const;
 
protected:
	TInt iMaxLength;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtr16 : public TDes16
	{
public:
	  TPtr16(TUint16 *aBuf,TInt aMaxLength);
	  TPtr16(TUint16 *aBuf,TInt aLength,TInt aMaxLength);
	inline TPtr16& operator=(const TUint16 *aString);
	inline TPtr16& operator=(const TDesC16& aDes);
	inline TPtr16& operator=(const TPtr16& aDes);
	inline void Set(TUint16 *aBuf,TInt aLength,TInt aMaxLength);
	inline void Set(const TPtr16 &aPtr);
private:
	  TPtr16(TBufCBase16 &aLcb,TInt aMaxLength);
protected:
	TUint16 *iPtr;
private:
	friend class TBufCBase16;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TBufCBase16 : public TDesC16
	{
protected:
	  TBufCBase16();
	inline TBufCBase16(TInt aLength);
	  TBufCBase16(const TUint16 *aString,TInt aMaxLength);
	  TBufCBase16(const TDesC16 &aDes,TInt aMaxLength);
	  void Copy(const TUint16 *aString,TInt aMaxLength);
	  void Copy(const TDesC16 &aDes,TInt aMaxLength);
	inline TPtr16 DoDes(TInt aMaxLength);
	inline TUint16 *WPtr() const;
	};
 
class RReadStream;
class HBufC16 : public TBufCBase16
	{
public:
	  static HBufC16 *New(TInt aMaxLength);
	  static HBufC16 *NewL(TInt aMaxLength);
	  static HBufC16 *NewLC(TInt aMaxLength);
	  static HBufC16 *NewMax(TInt aMaxLength);
	  static HBufC16 *NewMaxL(TInt aMaxLength);
	  static HBufC16 *NewMaxLC(TInt aMaxLength);
	  static HBufC16 *NewL(RReadStream &aStream,TInt aMaxLength);
	  static HBufC16 *NewLC(RReadStream &aStream,TInt aMaxLength);
	  HBufC16& operator=(const TUint16 *aString);
	  HBufC16& operator=(const TDesC16 &aDes);
	inline HBufC16& operator=(const HBufC16 &aLcb);
	  HBufC16 *ReAlloc(TInt aMaxLength);
	  HBufC16 *ReAllocL(TInt aMaxLength);
	  TPtr16 Des();
private:
	inline HBufC16(TInt aLength);
private:
	TText16 iBuf[1];
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 


 
template <TInt S>
class TBufC16 : public TBufCBase16
	{
public:
	inline TBufC16();
    inline TBufC16(const TUint16 *aString);
	inline TBufC16(const TDesC16 &aDes);
	inline TBufC16<S> &operator=(const TUint16 *aString);
	inline TBufC16<S> &operator=(const TDesC16 &aDes);
	inline TPtr16 Des();
protected:
	TUint16 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt16)) -1)/ (sizeof(TInt)/sizeof(TInt16)) )* (sizeof(TInt)/sizeof(TInt16)) ) ];
	};
 
class TBufBase16 : public TDes16
	{
protected:
	  TBufBase16(TInt aMaxLength);
	  TBufBase16(TInt aLength,TInt aMaxLength);
	  TBufBase16(const TUint16* aString,TInt aMaxLength);
	  TBufBase16(const TDesC16& aDes,TInt aMaxLength);
	};
 
template <TInt S>
class TBuf16 : public TBufBase16
	{
public:
	inline TBuf16();
	inline TBuf16(TInt aLength);
    inline TBuf16(const TUint16* aString);
	inline TBuf16(const TDesC16& aDes);
	inline TBuf16<S>& operator=(const TUint16* aString);
	inline TBuf16<S>& operator=(const TDesC16& aDes);
	inline TBuf16<S>& operator=(const TBuf16<S>& aDes);
protected:
	TUint16 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt16)) -1)/ (sizeof(TInt)/sizeof(TInt16)) )* (sizeof(TInt)/sizeof(TInt16)) ) ];
	};
 
typedef TRefByValue<const TDesC16> __TRefDesC16;
template <TInt S>
class TLitC16
	{
public:
	inline const TDesC16* operator&() const;
	inline operator const TDesC16&() const;
	inline const TDesC16& operator()() const;
	inline operator const __TRefDesC16() const;
public:

	typedef __wchar_t __TText;







public:
	TUint iTypeLength;
	__TText iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt16)) -1)/ (sizeof(TInt)/sizeof(TInt16)) )* (sizeof(TInt)/sizeof(TInt16)) ) ];
	};

class RBuf16 : public TDes16
 
















	{
public:
	  RBuf16();
	  explicit RBuf16(HBufC16* aHBuf);
	  void Assign(const RBuf16& aRBuf);
	  void Assign(TUint16 *aHeapCell,TInt aMaxLength);
	  void Assign(TUint16 *aHeapCell,TInt aLength,TInt aMaxLength);
	  void Assign(HBufC16* aHBuf);
	  void Swap(RBuf16& aRBuf);
	  TInt Create(TInt aMaxLength);
	  void CreateL(TInt aMaxLength);
	  TInt CreateMax(TInt aMaxLength);
	  void CreateMaxL(TInt aMaxLength);
	inline void CreateL(RReadStream &aStream,TInt aMaxLength);
	  TInt Create(const TDesC16& aDes);
	  void CreateL(const TDesC16& aDes);
	  TInt Create(const TDesC16& aDes,TInt aMaxLength);
	  void CreateL(const TDesC16& aDes,TInt aMaxLength);
	  TInt ReAlloc(TInt aMaxLength);
	  void ReAllocL(TInt aMaxLength);
	  void Close();
	  void CleanupClosePushL();

protected:
	  RBuf16(TInt aType,TInt aLength,TInt aMaxLength);
	RBuf16(const RBuf16&);  
	union
		{
		TUint16* iEPtrType;		 
		HBufC16* iEBufCPtrType;	 
		};
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};




# 1335 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2






typedef TDesC16 TDesC;
typedef TPtrC16 TPtrC;
typedef TDes16 TDes;
typedef TPtr16 TPtr;
typedef HBufC16 HBufC;
 













typedef RBuf16 RBuf;
typedef TDes16Overflow TDesOverflow;
# 1385 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"


template <TInt S>

class TBufC : public TBufCBase16



	{
public:
	inline TBufC();
	inline TBufC(const TText* aString);
	inline TBufC(const TDesC& aDes);
	inline TBufC<S>& operator=(const TText* aString);
	inline TBufC<S>& operator=(const TDesC& aDes);
	inline TPtr Des();
private:
	TText iBuf[(((( S )+ (sizeof(TUint)/sizeof(TUint16)) -1)/ (sizeof(TUint)/sizeof(TUint16)) )* (sizeof(TUint)/sizeof(TUint16)) ) ];
	};

template <TInt S>

class TBuf : public TBufBase16



	{
public:
	inline TBuf();
	inline TBuf(TInt aLength);
	inline TBuf(const TText* aString);
	inline TBuf(const TDesC& aDes);
	inline TBuf<S>& operator=(const TText* aString);
	inline TBuf<S>& operator=(const TDesC& aDes);
	inline TBuf<S>& operator=(const TBuf<S>& aBuf);
private:
	TText iBuf[(((( S )+ (sizeof(TUint)/sizeof(TUint16)) -1)/ (sizeof(TUint)/sizeof(TUint16)) )* (sizeof(TUint)/sizeof(TUint16)) ) ];
	};

typedef TRefByValue<const TDesC> __TRefDesC;
template <TInt S>
class TLitC
	{
public:
	enum {BufferSize=S-1};
	inline const TDesC* operator&() const;
	inline operator const TDesC&() const;
	inline const TDesC& operator()() const;
	inline operator const __TRefDesC() const;
public:



	typedef __wchar_t __TText;







public:
	TUint iTypeLength;
	__TText iBuf[(((( S )+ (sizeof(TUint)/sizeof(TUint16)) -1)/ (sizeof(TUint)/sizeof(TUint16)) )* (sizeof(TUint)/sizeof(TUint16)) ) ];
	};

static const TLitC<sizeof(L"" )/2>  KNullDesC ={sizeof(L"" )/2-1,L"" } ;
static const TLitC8<sizeof( "" )>  KNullDesC8 ={sizeof( "" )-1, "" } ;
static const TLitC16<sizeof(L"" )/2>  KNullDesC16 ={sizeof(L"" )/2-1,L"" } ;

template <class T>
class TPckgC : public TPtrC8
	{
public:
	inline TPckgC(const T& aRef);
	inline const T& operator()() const;
private:
	TPckgC<T>& operator=(const TPckgC<T>& aRef);
	};

template <class T>
class TPckg : public TPtr8
	{
public:
	inline TPckg(const T& aRef);
	inline T& operator()();
private:
	TPckg<T>& operator=(const TPckg<T>& aRef);
	};

template <class T>
class TPckgBuf : public TBuf8<sizeof(T)>
	{
public:
	inline TPckgBuf();
	inline TPckgBuf(const T& aRef);
	inline TPckgBuf& operator=(const TPckgBuf<T>& aRef);
	inline T& operator=(const T& aRef);
	inline T& operator()();
	inline const T& operator()() const;
	};

typedef TBuf<KMaxName> TName;
typedef TBuf<KMaxInfoName> TInfoName;
typedef TBuf<KMaxFullName> TFullName;
typedef TBuf<KMaxExitCategoryName> TExitCategoryName;
typedef TBuf<KMaxFileName> TFileName;
typedef TBuf<KMaxPath> TPath;
typedef TBuf<KMaxDeviceInfo> TDeviceInfo;
typedef TBuf<KMaxVersionName> TVersionName;
typedef TBuf<KMaxPassword> TPassword;

class TLexMark8
	{
public:
	inline TLexMark8();
private:
	inline TLexMark8(const TUint8* aString);
	const TUint8* iPtr;
	friend class TLex8;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TRealX;
class TLex8
	{
public:
	  TLex8();
	inline TLex8(const TUint8* aString);
	inline TLex8(const TDesC8& aDes);
	inline TLex8& operator=(const TUint8* aString);
	inline TLex8& operator=(const TDesC8& aDes);
	inline TBool Eos() const;
	inline void Mark(TLexMark8& aMark) const;
	inline void Mark();
	  void Inc();
	  void Inc(TInt aNumber);
	  TChar Get();
	  TChar Peek() const;
	  void UnGet();
	inline void UnGetToMark();
	  void UnGetToMark(const TLexMark8 aMark);
	  void SkipSpace();
	inline void SkipAndMark(TInt aNumber);
	  void SkipAndMark(TInt aNumber, TLexMark8& aMark);
	inline void SkipSpaceAndMark();
	  void SkipSpaceAndMark(TLexMark8& aMark);
	  void SkipCharacters();
	inline TInt TokenLength() const;
	  TInt TokenLength(const TLexMark8 aMark) const;
	  TPtrC8 MarkedToken() const;
	  TPtrC8 MarkedToken(const TLexMark8 aMark) const;
	  TPtrC8 NextToken();
	  TPtrC8 Remainder() const;
	  TPtrC8 RemainderFromMark() const;
	  TPtrC8 RemainderFromMark(const TLexMark8 aMark) const;
	  TInt Offset() const;
	inline TInt MarkedOffset() const;
	  TInt MarkedOffset(const TLexMark8 aMark) const;
	  TInt Val(TInt8& aVal);
	  TInt Val(TInt16& aVal);
	  TInt Val(TInt32& aVal);
	  TInt Val(TInt64& aVal);
	inline TInt Val(TInt& aVal);
	  TInt Val(TUint8& aVal,TRadix aRadix);
	  TInt Val(TUint16& aVal,TRadix aRadix);
	  TInt Val(TUint32& aVal,TRadix aRadix);
	  TInt Val(TInt64& aVal,TRadix aRadix);
	inline TInt Val(TUint& aVal,TRadix aRadix=EDecimal);
	  TInt Val(TInt32& aVal,TInt aLimit);
	  TInt Val(TInt64& aVal,const TInt64& aLimit);
	  TInt Val(TUint32& aVal,TRadix aRadix,TUint aLimit);
	  TInt Val(TInt64& aVal,TRadix aRadix,const TInt64 &aLimit);
	  TInt Val(TReal32& aVal);
	  TInt Val(TReal32& aVal,TChar aPoint);
	  TInt Val(TReal64& aVal);
	  TInt Val(TReal64& aVal,TChar aPoint);
	inline void Assign(const TLex8& aLex);
	  void Assign(const TUint8* aString);
	  void Assign(const TDesC8& aDes);
	TInt Val(TRealX& aVal);
	TInt Val(TRealX& aVal, TChar aPoint);
private:
	void Scndig(TInt& aSig,TInt& aExp,TInt64& aDl);
	void ScndigAfterPoint(TInt& aSig,TInt64& aDl);
	void ValidateMark(const TLexMark8 aMark) const;
private:
	const TUint8* iNext;
	const TUint8* iBuf;
	const TUint8* iEnd;
	TLexMark8 iMark;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TLexMark16
	{
public:
	inline TLexMark16();
private:
	inline TLexMark16(const TUint16* aString);
	const TUint16* iPtr;
	friend class TLex16;	
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TLex16
	{
public:
	  TLex16();
	inline TLex16(const TUint16* aString);
	inline TLex16(const TDesC16& aDes);
	inline TLex16& operator=(const TUint16* aString);
	inline TLex16& operator=(const TDesC16& aDes);
	inline TBool Eos() const;
	inline void Mark();
	inline void Mark(TLexMark16& aMark) const;
	  void Inc();
	  void Inc(TInt aNumber);
	  TChar Get();
	  TChar Peek() const;
	  void UnGet();
	inline void UnGetToMark();
	  void UnGetToMark(const TLexMark16 aMark);
	  void SkipSpace();
	inline void SkipAndMark(TInt aNumber);
	  void SkipAndMark(TInt aNumber, TLexMark16& aMark);
	  void SkipSpaceAndMark(TLexMark16& aMark);
	inline void SkipSpaceAndMark();
	  void SkipCharacters();
	inline TInt TokenLength() const;
	  TInt TokenLength(const TLexMark16 aMark) const;
	  TPtrC16 MarkedToken() const;
	  TPtrC16 MarkedToken(const TLexMark16 aMark) const;
	  TPtrC16 NextToken();
	  TPtrC16 Remainder() const;
	  TPtrC16 RemainderFromMark() const;
	  TPtrC16 RemainderFromMark(const TLexMark16 aMark) const;
	  TInt Offset() const;
	inline TInt MarkedOffset() const;
	  TInt MarkedOffset(const TLexMark16 aMark) const;
	  TInt Val(TInt8& aVal);
	  TInt Val(TInt16& aVal);
	  TInt Val(TInt32& aVal);
	  TInt Val(TInt64& aVal);
	inline TInt Val(TInt& aVal);
	  TInt Val(TUint8& aVal,TRadix aRadix);
	  TInt Val(TUint16& aVal,TRadix aRadix);
	  TInt Val(TUint32& aVal,TRadix aRadix);
	  TInt Val(TInt64& aVal,TRadix aRadix);
	inline TInt Val(TUint& aVal,TRadix aRadix=EDecimal);
	  TInt Val(TInt32& aVal,TInt aLimit);
	  TInt Val(TInt64& aVal,const TInt64& aLimit);
	  TInt Val(TUint32& aVal,TRadix aRadix,TUint aLimit);
	  TInt Val(TInt64& aVal,TRadix aRadix,const TInt64& aLimit);
	  TInt Val(TReal32& aVal);
	  TInt Val(TReal32& aVal,TChar aPoint);
	  TInt Val(TReal64& aVal);
	  TInt Val(TReal64& aVal,TChar aPoint);
	inline void Assign(const TLex16& aLex);
	  void Assign(const TUint16* aString);
	  void Assign(const TDesC16& aDes);		
	TInt Val(TRealX& aVal);
	TInt Val(TRealX& aVal, TChar aPoint);
private:
	void Scndig(TInt& aSig,TInt& aExp,TInt64& aDl);
	void ValidateMark(const TLexMark16 aMark) const;
private:
	const TUint16* iNext;
	const TUint16* iBuf;
	const TUint16* iEnd;
	TLexMark16 iMark;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


typedef TLex16 TLex;
typedef TLexMark16 TLexMark;





typedef TBuf<KMaxUidName> TUidName;
class TUid
	{
public:
	  TInt operator==(const TUid& aUid) const;
	  TInt operator!=(const TUid& aUid) const;
	  TUidName Name() const;
	static inline TUid Uid(TInt aUid);
	static inline TUid Null();
public:
	TInt32 iUid;
	};

class TUidType
	{
public:
	  TUidType();
	  TUidType(TUid aUid1);
	  TUidType(TUid aUid1,TUid aUid2);
	  TUidType(TUid aUid1,TUid aUid2,TUid aUid3);
	  TInt operator==(const TUidType& aUidType) const;
	  TInt operator!=(const TUidType& aUidType) const;
	  const TUid& operator[](TInt anIndex) const;
	  TUid MostDerived() const;
	  TBool IsPresent(TUid aUid) const;
	  TBool IsValid() const;
private:
	TUid iUid[KMaxCheckedUid];
	};

 




class TSecureId
	{
public:
	inline TSecureId();
	inline TSecureId(TUint32 aId);
	inline operator TUint32() const;
	inline TSecureId(TUid aId);
	inline operator TUid() const;
public:
	TUint32 iId;
	};




 




class TVendorId
	{
public:
	inline TVendorId();
	inline TVendorId(TUint32 aId);
	inline operator TUint32() const;
	inline TVendorId(TUid aId);
	inline operator TUid() const;
public:
	TUint32 iId;
	};



 




class SSecureId
	{
public:
	inline const TSecureId* operator&() const;
	inline operator const TSecureId&() const;
	inline operator TUint32() const;
	inline operator TUid() const;
public:
	TUint32 iId;
	};


	
	
 




class SVendorId
	{
public:
	inline const TVendorId* operator&() const;
	inline operator const TVendorId&() const;
	inline operator TUint32() const;
	inline operator TUid() const;
public:
	TUint32 iId;
	};




 











 











 



enum TCapability
	{
	ECapabilityTCB				= 0,
	ECapabilityCommDD			= 1,
	ECapabilityPowerMgmt		= 2,
	ECapabilityMultimediaDD		= 3,
	ECapabilityReadDeviceData	= 4,
	ECapabilityWriteDeviceData	= 5,
	ECapabilityDRM				= 6,
	ECapabilityTrustedUI		= 7,
	ECapabilityProtServ			= 8,
	ECapabilityDiskAdmin		= 9,
	ECapabilityNetworkControl	= 10,
	ECapabilityAllFiles			= 11,
	ECapabilitySwEvent			= 12,
	ECapabilityNetworkServices	= 13,
	ECapabilityLocalServices	= 14,
	ECapabilityReadUserData		= 15,
	ECapabilityWriteUserData	= 16,
	ECapabilityLocation			= 17,

	ECapability_Limit,					 

	ECapability_HardLimit		= 255,	 

	ECapability_None			= -1	
	};


class TCheckedUid
	{
public:
	  TCheckedUid();
	  TCheckedUid(const TUidType& aUidType);
	  TCheckedUid(const TDesC8& aPtr);
	  void Set(const TUidType& aUidType);
	  void Set(const TDesC8& aPtr);
	  TPtrC8 Des() const;
	inline const TUidType& UidType() const;
protected:
	  TUint Check() const;
private:
	TUidType iType;
	TUint iCheck;
	};

class TVersion
	{
public:
	  TVersion();
	  TVersion(TInt aMajor,TInt aMinor,TInt aBuild);
	  TVersionName Name() const;
public:
	TInt8 iMajor;
	TInt8 iMinor;
	TInt16 iBuild;
	};

 
















class TDateTime
	{
public:
	inline TDateTime();
	  TDateTime(TInt aYear,TMonth aMonth,TInt aDay,TInt aHour,TInt aMinute, TInt aSecond,TInt aMicroSecond);
	  TInt Set(TInt aYear,TMonth aMonth,TInt aDay,TInt aHour,TInt aMinute, TInt aSecond,TInt aMicroSecond);
	  TInt SetYear(TInt aYear);
	  TInt SetYearLeapCheck(TInt aYear);
	  TInt SetMonth(TMonth aMonth);
	  TInt SetDay(TInt aDay);
	  TInt SetHour(TInt aHour);
	  TInt SetMinute(TInt aMinute);
	  TInt SetSecond(TInt aSecond);
	  TInt SetMicroSecond(TInt aMicroSecond);
	inline TInt Year() const;
	inline TMonth Month() const;
	inline TInt Day() const;
	inline TInt Hour() const;
	inline TInt Minute() const;
	inline TInt Second() const;
	inline TInt MicroSecond() const;
private:
	TInt iYear;
	TMonth iMonth;
	TInt iDay;
	TInt iHour;
	TInt iMinute;
	TInt iSecond;
	TInt iMicroSecond;
	};

 












class TTimeIntervalMicroSeconds
	{
public:
	inline TTimeIntervalMicroSeconds();
	inline TTimeIntervalMicroSeconds(const TInt64& aInterval);
	inline TTimeIntervalMicroSeconds& operator=(const TInt64& aInterval);
	inline TBool operator==(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator!=(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator>=(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator<=(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator>(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator<(const TTimeIntervalMicroSeconds& aInterval) const;
	inline const TInt64& Int64() const;
private:
	TInt64 iInterval;
	};

 
















class TTimeIntervalBase
	{
public:
	inline TBool operator==(TTimeIntervalBase aInterval) const;
	inline TBool operator!=(TTimeIntervalBase aInterval) const;
	inline TBool operator>=(TTimeIntervalBase aInterval) const;
	inline TBool operator<=(TTimeIntervalBase aInterval) const;
	inline TBool operator>(TTimeIntervalBase aInterval) const;
	inline TBool operator<(TTimeIntervalBase aInterval) const;
	inline TInt Int() const;
protected:
	inline TTimeIntervalBase();
	inline TTimeIntervalBase(TInt aInterval);
protected:
	TInt iInterval;
	};

 












class TTimeIntervalMicroSeconds32 : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalMicroSeconds32();
	inline TTimeIntervalMicroSeconds32(TInt aInterval);
	inline TTimeIntervalMicroSeconds32& operator=(TInt aInterval);
	};

 












class TTimeIntervalSeconds : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalSeconds();
	inline TTimeIntervalSeconds(TInt aInterval);
	inline TTimeIntervalSeconds& operator=(TInt aInterval);
	};

 










class TTimeIntervalMinutes : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalMinutes();
	inline TTimeIntervalMinutes(TInt aInterval);
	inline TTimeIntervalMinutes& operator=(TInt aInterval);
	};

 










class TTimeIntervalHours : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalHours();
	inline TTimeIntervalHours(TInt aInterval);
	inline TTimeIntervalHours& operator=(TInt aInterval);
	};

 










class TTimeIntervalDays : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalDays();
	inline TTimeIntervalDays(TInt aInterval);
	inline TTimeIntervalDays& operator=(TInt aInterval);
	};

 










class TTimeIntervalMonths : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalMonths();
	inline TTimeIntervalMonths(TInt aInterval);
	inline TTimeIntervalMonths& operator=(TInt aInterval);
	};

 












class TTimeIntervalYears : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalYears();
	inline TTimeIntervalYears(TInt aInterval);
	inline TTimeIntervalYears& operator=(TInt aInterval);
	};

 





enum 
	{
	 
	EParseTimePresent=0x1,
	 
	EParseDatePresent=0x2
	};


 




























class TTime
	{
public:
	inline TTime();
	inline TTime(const TInt64& aTime);
	  TTime(const TDesC& aString);
	  TTime(const TDateTime& aDateTime);
	inline TTime& operator=(const TInt64& aTime);
	  TTime& operator=(const TDateTime& aDateTime);
	  void HomeTime();
	  void UniversalTime();
	  TInt Set(const TDesC& aString);

	  TDateTime DateTime() const;
	  TTimeIntervalMicroSeconds MicroSecondsFrom(TTime aTime) const;
	  TInt SecondsFrom(TTime aTime,TTimeIntervalSeconds& aInterval) const;
	  TInt MinutesFrom(TTime aTime,TTimeIntervalMinutes& aInterval) const;
	  TInt HoursFrom(TTime aTime,TTimeIntervalHours& aInterval) const;
	  TTimeIntervalDays DaysFrom(TTime aTime) const;
	  TTimeIntervalMonths MonthsFrom(TTime aTime) const;
	  TTimeIntervalYears YearsFrom(TTime aTime) const;

	  TInt DaysInMonth() const;
	  TDay DayNoInWeek() const;
	  TInt DayNoInMonth() const;
	  TInt DayNoInYear() const;
	  TInt DayNoInYear(TTime aStartDate) const;
	  TInt WeekNoInYear() const;
	  TInt WeekNoInYear(TTime aStartDate) const;
	  TInt WeekNoInYear(TFirstWeekRule aRule) const;
	  TInt WeekNoInYear(TTime aStartDate,TFirstWeekRule aRule) const;
	  void FormatL(TDes& aDes,const TDesC& aFormat) const;
	  void RoundUpToNextMinute();
	  TInt Parse(const TDesC& aDes,TInt aCenturyOffset=0);

	  TTime operator+(TTimeIntervalYears aYear) const;
	  TTime operator+(TTimeIntervalMonths aMonth) const;
	  TTime operator+(TTimeIntervalDays aDay) const;
	  TTime operator+(TTimeIntervalHours aHour) const;
	  TTime operator+(TTimeIntervalMinutes aMinute) const;
	  TTime operator+(TTimeIntervalSeconds aSecond) const;  	
	  TTime operator+(TTimeIntervalMicroSeconds aMicroSecond) const;
	  TTime operator+(TTimeIntervalMicroSeconds32 aMicroSecond) const;
	  TTime operator-(TTimeIntervalYears aYear) const;
	  TTime operator-(TTimeIntervalMonths aMonth) const;
	  TTime operator-(TTimeIntervalDays aDay) const;
	  TTime operator-(TTimeIntervalHours aHour) const;
	  TTime operator-(TTimeIntervalMinutes aMinute) const;
	  TTime operator-(TTimeIntervalSeconds aSecond) const;  	
	  TTime operator-(TTimeIntervalMicroSeconds aMicroSecond) const;
	  TTime operator-(TTimeIntervalMicroSeconds32 aMicroSecond) const;
	  TTime& operator+=(TTimeIntervalYears aYear);
	  TTime& operator+=(TTimeIntervalMonths aMonth);
	  TTime& operator+=(TTimeIntervalDays aDay);
	  TTime& operator+=(TTimeIntervalHours aHour);
	  TTime& operator+=(TTimeIntervalMinutes aMinute);
	  TTime& operator+=(TTimeIntervalSeconds aSecond);	
	  TTime& operator+=(TTimeIntervalMicroSeconds aMicroSecond);
	  TTime& operator+=(TTimeIntervalMicroSeconds32 aMicroSecond);
	  TTime& operator-=(TTimeIntervalYears aYear);
	  TTime& operator-=(TTimeIntervalMonths aMonth);
	  TTime& operator-=(TTimeIntervalDays aDay);
	  TTime& operator-=(TTimeIntervalHours aHour);
	  TTime& operator-=(TTimeIntervalMinutes aMinute);
	  TTime& operator-=(TTimeIntervalSeconds aSecond);	
	  TTime& operator-=(TTimeIntervalMicroSeconds aMicroSecond);
	  TTime& operator-=(TTimeIntervalMicroSeconds32 aMicroSecond);
	inline TBool operator==(TTime aTime) const;
	inline TBool operator!=(TTime aTime) const;
	inline TBool operator>=(TTime aTime) const;
	inline TBool operator<=(TTime aTime) const;
	inline TBool operator>(TTime aTime) const;
	inline TBool operator<(TTime aTime) const;
	inline const TInt64& Int64() const;
private:
	static TTime Convert(const TDateTime& aDateTime);
private:
	TInt64 iTime;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


 







class Time
	{
public:
	  static TTime NullTTime();
	  static TTime MaxTTime();
	  static TTime MinTTime();
	  static TInt DaysInMonth(TInt aYear, TMonth aMonth);
	  static TBool IsLeapYear(TInt aYear);
	  static TInt LeapYearsUpTo(TInt aYear);
	};

 








class TDayName : public TBuf<KMaxDayName>
	{
public:
	  TDayName();
	  TDayName(TDay aDay);
	  void Set(TDay aDay);
	};

 












class TDayNameAbb : public TBuf<KMaxDayNameAbb>
	{
public:
	  TDayNameAbb();
	  TDayNameAbb(TDay aDay);
	  void Set(TDay aDay);
	};

 









class TMonthName : public TBuf<KMaxMonthName>
	{
public:
	  TMonthName();
	  TMonthName(TMonth aMonth);
	  void Set(TMonth aMonth);
	};

 












class TMonthNameAbb : public TBuf<KMaxMonthNameAbb>
	{
public:
	  TMonthNameAbb();
	  TMonthNameAbb(TMonth aMonth);
	  void Set(TMonth aMonth);
	};

 














class TDateSuffix : public TBuf<KMaxSuffix>
	{
public:
	  TDateSuffix();
	  TDateSuffix(TInt aDateSuffix);
	  void Set(TInt aDateSuffix);
	};

 













class TAmPmName : public TBuf<KMaxAmPmName>
	{
public:
	  TAmPmName();
	  TAmPmName(TAmPm aSelector);
	  void Set(TAmPm aSelector);
	};


 












class TCurrencySymbol : public TBuf<KMaxCurrencySymbol>
	{
public:
	  TCurrencySymbol();
	  void Set();
	};

 















class TShortDateFormatSpec : public TBuf<KMaxShortDateFormatSpec>  
	{
public:
	  TShortDateFormatSpec();
	  void Set();
	};

 















class TLongDateFormatSpec : public TBuf<KMaxLongDateFormatSpec>  
	{
public:
	  TLongDateFormatSpec();
	  void Set();
	};

 














class TTimeFormatSpec : public TBuf<KMaxTimeFormatSpec>  
	{
public:
	  TTimeFormatSpec();
	  void Set();
	};

 



enum TDaylightSavingZone
	{
	 




	EDstHome=0x40000000,

	 
	EDstNone=0,

	 
	EDstEuropean=1,
	
	 
	EDstNorthern=2,

	 
	EDstSouthern=4
	};

const TInt KMaxDateSeparators=4;
const TInt KMaxTimeSeparators=4;

 






enum TLocalePos 
	{
	 


	ELocaleBefore,
	
	 


	ELocaleAfter
	};

 


enum TDigitType
	{
	EDigitTypeUnknown = 0x0000,
	EDigitTypeWestern = 0x0030,
	EDigitTypeArabicIndic = 0x0660,
	EDigitTypeEasternArabicIndic = 0x6F0,
	EDigitTypeDevanagari = 0x0966,
	EDigitTypeThai = 0x0E50,
	EDigitTypeAllTypes = 0xFFFF
	};


 











class TLocale
	{
public:
	
	 




	enum TNegativeCurrencyFormat
		{
		 
		ELeadingMinusSign,
		 


		EInBrackets,  
		 
		ETrailingMinusSign,
		 
		EInterveningMinusSign
		};
	 


	enum 
		{
		 




		EFlagNegativeLoseSpace = 0x00000001,
		
		 




		EFlagNegativeCurrencySymbolOpposite=0x00000002
		};

	 
	enum TDeviceTimeState
		{
		 

		EDeviceUserTime,

		 

		ENITZNetworkTimeSync
		};
public:
	  TLocale();
	  void Refresh();
	  void Set() const;
	  void FormatCurrency(TDes& aText, TInt aAmount);
	  void FormatCurrency(TDes& aText, TInt64 aAmount);
	  void FormatCurrency(TDes& aText, TDesOverflow& aOverflowHandler, TInt aAmount); 
	  void FormatCurrency(TDes& aText, TDesOverflow& aOverflowHandler, TInt64 aAmount); 
	
	inline TInt CountryCode() const;
	inline void SetCountryCode(TInt aCode);
	inline TTimeIntervalSeconds UniversalTimeOffset() const;
	inline void SetUniversalTimeOffset(const TTimeIntervalSeconds& anOffset);
	inline TDateFormat DateFormat() const;
	inline void SetDateFormat(TDateFormat aFormat);
	inline TTimeFormat TimeFormat() const;
	inline void SetTimeFormat(TTimeFormat aFormat);
	inline TLocalePos CurrencySymbolPosition() const;
	inline void SetCurrencySymbolPosition(TLocalePos aPos);
	inline TBool CurrencySpaceBetween() const;
	inline void SetCurrencySpaceBetween(TBool aSpace);
	inline TInt CurrencyDecimalPlaces() const;
	inline void SetCurrencyDecimalPlaces(TInt aPlaces);
	inline TBool CurrencyNegativeInBrackets() const;         
	inline void SetCurrencyNegativeInBrackets(TBool aBool);  
 	inline TBool CurrencyTriadsAllowed() const;  
	inline void SetCurrencyTriadsAllowed(TBool aBool);
	inline TChar ThousandsSeparator() const;
	inline void SetThousandsSeparator(const TChar& aChar);
	inline TChar DecimalSeparator() const;
	inline void SetDecimalSeparator(const TChar& aChar);
	inline TChar DateSeparator(TInt aIndex) const;
	inline void SetDateSeparator(const TChar& aChar,TInt aIndex);
	inline TChar TimeSeparator(TInt aIndex) const;
	inline void SetTimeSeparator(const TChar& aChar,TInt aIndex);
	inline TBool AmPmSpaceBetween() const;
	inline void SetAmPmSpaceBetween(TBool aSpace);
	inline TLocalePos AmPmSymbolPosition() const;
	inline void SetAmPmSymbolPosition(TLocalePos aPos);
	inline TUint DaylightSaving() const;
	inline void SetDaylightSaving(TUint aDaylightSaving);
	inline TBool QueryHomeHasDaylightSavingOn() const;
	inline TDaylightSavingZone HomeDaylightSavingZone() const;
	inline void SetHomeDaylightSavingZone(TDaylightSavingZone aZone);
	inline TUint WorkDays() const;
	inline void SetWorkDays(TUint aMask);
	inline TDay StartOfWeek() const;
	inline void SetStartOfWeek(TDay aDay);
	inline TClockFormat ClockFormat() const;
	inline void SetClockFormat(TClockFormat aFormat);
	inline TUnitsFormat UnitsGeneral() const;
	inline void SetUnitsGeneral(TUnitsFormat aFormat);
	inline TUnitsFormat UnitsDistanceShort() const;
	inline void SetUnitsDistanceShort(TUnitsFormat aFormat);
	inline TUnitsFormat UnitsDistanceLong() const;
	inline void SetUnitsDistanceLong(TUnitsFormat aFormat);
	inline TNegativeCurrencyFormat NegativeCurrencyFormat() const;
	inline void SetNegativeCurrencyFormat(TNegativeCurrencyFormat aNegativeCurrencyFormat);
	inline TBool NegativeLoseSpace() const;
	inline void SetNegativeLoseSpace(TBool aBool);
	inline TBool NegativeCurrencySymbolOpposite() const;
	inline void SetNegativeCurrencySymbolOpposite(TBool aBool);
	inline TLanguage LanguageDowngrade(TInt aIndex) const;	  
	inline void SetLanguageDowngrade(TInt aIndex, TLanguage aLanguage);
	inline TDigitType DigitType() const;
	inline void SetDigitType(TDigitType aDigitType);
	inline void SetDeviceTime(TDeviceTimeState aState);
	inline TDeviceTimeState DeviceTime() const;
private:
	TInt iCountryCode;
	TTimeIntervalSeconds iUniversalTimeOffset;
	TDateFormat iDateFormat;
	TTimeFormat iTimeFormat;
	TLocalePos iCurrencySymbolPosition;
	TBool iCurrencySpaceBetween;
	TInt iCurrencyDecimalPlaces;
	TNegativeCurrencyFormat iNegativeCurrencyFormat;  
	TBool iCurrencyTriadsAllowed;
	TChar iThousandsSeparator;
	TChar iDecimalSeparator;
	TChar iDateSeparator[KMaxDateSeparators];
	TChar iTimeSeparator[KMaxTimeSeparators];
	TLocalePos iAmPmSymbolPosition;
	TBool iAmPmSpaceBetween;
	TUint iDaylightSaving;
	TDaylightSavingZone iHomeDaylightSavingZone;
	TUint iWorkDays;
	TDay iStartOfWeek;
	TClockFormat iClockFormat;
	TUnitsFormat iUnitsGeneral;
	TUnitsFormat iUnitsDistanceShort;
	TUnitsFormat iUnitsDistanceLong;
	TUint iExtraNegativeCurrencyFormatFlags;
	TUint16 iLanguageDowngrade[3];
	TUint16 iSpare16;
	TDigitType iDigitType;
	TDeviceTimeState iDeviceTimeState;
	TInt iSpare[0x1E];
	};

class TSize;
class TPoint
	{
public:
	enum TUninitialized { EUninitialized };
	TPoint(TUninitialized) {}
	inline TPoint();
	inline TPoint(TInt aX,TInt aY);
	  TInt operator==(const TPoint& aPoint) const;
	  TInt operator!=(const TPoint& aPoint) const;
	  TPoint& operator-=(const TPoint& aPoint);
	  TPoint& operator+=(const TPoint& aPoint);
	  TPoint& operator-=(const TSize& aSize);
	  TPoint& operator+=(const TSize& aSize);
	  TPoint operator-(const TPoint& aPoint) const;
	  TPoint operator+(const TPoint& aPoint) const;
	  TPoint operator-(const TSize& aSize) const;
	  TPoint operator+(const TSize& aSize) const;
	  TPoint operator-() const;
	  void SetXY(TInt aX,TInt aY);
	  TSize AsSize() const;
public:
	TInt iX;
	TInt iY;
	};

class TSize
	{
public:
	enum TUninitialized { EUninitialized };
	TSize(TUninitialized) {}
	inline TSize();
	inline TSize(TInt aWidth,TInt aHeight);
	  TInt operator==(const TSize& aSize) const;
	  TInt operator!=(const TSize& aSize) const;
	  TSize& operator-=(const TSize& aSize);
	  TSize& operator-=(const TPoint& aPoint);
	  TSize& operator+=(const TSize& aSize);
	  TSize& operator+=(const TPoint& aPoint);
	  TSize operator-(const TSize& aSize) const;
	  TSize operator-(const TPoint& aPoint) const;
	  TSize operator+(const TSize& aSize) const;
	  TSize operator+(const TPoint& aPoint) const;
	  TSize operator-() const;
	  void SetSize(TInt aWidth,TInt aHeight);
	  TPoint AsPoint() const;
public:
	TInt iWidth;
	TInt iHeight;
	};

class TRect
	{
public:
	enum TUninitialized { EUninitialized };
	TRect(TUninitialized) {}
	  TRect();
	  TRect(TInt aAx,TInt aAy,TInt aBx,TInt aBy);
	  TRect(const TPoint& aPointA,const TPoint& aPointB);
	  TRect(const TPoint& aPoint,const TSize& aSize);
	  TRect(const TSize& aSize);
	  TInt operator==(const TRect& aRect) const;
	  TInt operator!=(const TRect& aRect) const;
	  void SetRect(TInt aAx,TInt aAy,TInt aBx,TInt aBy);
	  void SetRect(const TPoint& aPointTL,const TPoint& aPointBR);
	  void SetRect(const TPoint& aPoint,const TSize& aSize);
	  void Move(TInt aDx,TInt aDy);
	  void Move(const TPoint& aOffset);
	  void Resize(TInt aDx,TInt aDy);
	  void Resize(const TSize& aSize);
	  void Shrink(TInt aDx,TInt aDy);
	  void Shrink(const TSize& aSize);
	  void Grow(TInt aDx,TInt aDy);
	  void Grow(const TSize& aSize);
	  void BoundingRect(const TRect& aRect);
	  TBool IsEmpty() const;
	  TBool Intersects(const TRect& aRect) const;
	  void Intersection(const TRect& aRect);
	  void Normalize();
	  TBool Contains(const TPoint& aPoint) const;
	  TSize Size() const;
	  TInt Width() const;
	  TInt Height() const;
	  TBool IsNormalized() const;
	  TPoint Center() const;
	  void SetSize(const TSize& aSize);
	  void SetWidth(TInt aWidth);
	  void SetHeight(TInt aHeight);
private:
	void Adjust(TInt aDx,TInt aDy);
public:
	TPoint iTl;
	TPoint iBr;
	};

class TRegion
	{
public:
	inline TInt Count() const;
	inline const TRect* RectangleList() const;
	inline TBool CheckError() const;
	  TBool IsEmpty() const;
	  TRect BoundingRect() const;
	  const TRect& operator[](TInt aIndex) const;
	  void Copy(const TRegion& aRegion);
	  void AddRect(const TRect& aRect);
	  void SubRect(const TRect& aRect,TRegion* aSubtractedRegion= 0L );
	  void Offset(TInt aXoffset,TInt aYoffset);
	  void Offset(const TPoint& aOffset);
	  void Union(const TRegion& aRegion);
	  void Intersection(const TRegion& aRegion,const TRegion& aRegion2);
	  void Intersect(const TRegion& aRegion);
	  void SubRegion(const TRegion& aRegion,TRegion* aSubtractedRegion= 0L );
	  void ClipRect(const TRect& aRect);
	  void Clear();
	  void Tidy();
	  TInt Sort();
	  TInt Sort(const TPoint& aOffset);
	  void ForceError();
	  TBool IsContainedBy(const TRect& aRect) const;
	  TBool Contains(const TPoint& aPoint) const;
protected:
	  TRect* RectangleListW();
	  TRegion(TInt aAllocedRects);
	inline TRegion();
	TBool SetListSize(TInt aCount);
	void AppendRect(const TRect& aRect);
	void DeleteRect(TRect* aRect);
	void AppendRegion(TRegion& aRegion);
protected:
	TInt iCount;
	TBool iError;
	TInt iAllocedRects;
protected:
	enum {ERRegionBuf=0x40000000};
	};

class RRegion : public TRegion
	{
private:
	enum {EDefaultGranularity=5};
protected:
	  RRegion(TInt aBuf,TInt aGran);
public:
	  RRegion();
	  RRegion(TInt aGran);
	  RRegion(const RRegion& aRegion);
	  RRegion(const TRect& aRect,TInt aGran=EDefaultGranularity);
	  RRegion(TInt aCount,TRect* aRectangleList,TInt aGran=EDefaultGranularity);
	  void Close();
	  void Destroy();
	inline TInt CheckSpare() const;
private:
	TInt iGranularity;
	TRect* iRectangleList;
	friend class TRegion;
	};

template <TInt S>
class RRegionBuf : public RRegion
	{
public:
	inline RRegionBuf();
	inline RRegionBuf(const RRegion& aRegion);
	inline RRegionBuf(const RRegionBuf<S>& aRegion);
	inline RRegionBuf(const TRect& aRect);
private:
	TInt8 iRectangleBuf[S*sizeof(TRect)];
	};

template <TInt S>
class TRegionFix : public TRegion
	{
public:
	inline TRegionFix();
	inline TRegionFix(const TRect& aRect);
	inline TRegionFix(const TRegionFix<S>& aRegion);
private:
	TInt8 iRectangleBuf[S*sizeof(TRect)];
	};

class TRequestStatus
	{
public:
	inline TRequestStatus();
	inline TRequestStatus(TInt aVal);
	inline TInt operator=(TInt aVal);
	inline TInt operator==(TInt aVal) const;
	inline TInt operator!=(TInt aVal) const;
	inline TInt operator>=(TInt aVal) const;
	inline TInt operator<=(TInt aVal) const;
	inline TInt operator>(TInt aVal) const;
	inline TInt operator<(TInt aVal) const;
	inline TInt Int() const;
private:
	TInt iStatus;
	};

class TFindHandleBase
	{
public:
	  TFindHandleBase();
	  TFindHandleBase(const TDesC& aMatch);
	  void Find(const TDesC& aMatch);
	inline TInt Handle() const;
protected:
	TInt iFindHandle;
	TFullName iMatch;
	};

class TFindSemaphore : public TFindHandleBase
	{
public:
	inline TFindSemaphore();
	inline TFindSemaphore(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindMutex : public TFindHandleBase
	{
public:
	inline TFindMutex();
	inline TFindMutex(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindChunk : public TFindHandleBase
	{
public:
	inline TFindChunk();
	inline TFindChunk(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindThread : public TFindHandleBase
	{
public:
	inline TFindThread();
	inline TFindThread(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindProcess : public TFindHandleBase
	{
public:
	inline TFindProcess();
	inline TFindProcess(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindLogicalDevice : public TFindHandleBase
	{
public:
	inline TFindLogicalDevice();
	inline TFindLogicalDevice(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindPhysicalDevice : public TFindHandleBase
	{
public:
	inline TFindPhysicalDevice();
	inline TFindPhysicalDevice(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindLogicalChannel : public TFindHandleBase
	{
public:
	inline TFindLogicalChannel();
	inline TFindLogicalChannel(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindServer : public TFindHandleBase
	{
public:
	inline TFindServer();
	inline TFindServer(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindLibrary : public TFindHandleBase
	{
public:
	inline TFindLibrary();
	inline TFindLibrary(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class THandleInfo
	{
public:
	TInt iNumOpenInProcess;
	TInt iNumOpenInThread;
	TInt iNumProcesses;
	TInt iNumThreads;
	};

class RThread;
class RHandleBase
	{
public:
	enum
		{
		EReadAccess=0x1,
		EWriteAccess=0x2,
		EDirectReadAccess=0x4,
		EDirectWriteAccess=0x8,
		};
public:
	inline RHandleBase();
	  void Close();
	  TName Name() const;
	  TFullName FullName() const;
	inline void SetHandle(TInt aHandle);
	  void SetHandleNC(TInt aHandle);
	  TInt Duplicate(const RThread& aSrc,TOwnerType aType=EOwnerProcess);
	  void HandleInfo(THandleInfo* anInfo);
	  TUint Attributes() const;
	inline TInt Handle() const;
protected:
	inline RHandleBase(TInt aHandle);
	  TInt Open(const TFindHandleBase& aHandle,TOwnerType aType);
protected:
	TInt iHandle;
	};

class RDevice : public RHandleBase
	{
public:
	inline TInt Open(const TFindLogicalDevice& aFind,TOwnerType aType=EOwnerProcess);
	  TInt Open(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  void GetCaps(TDes8& aDes) const;
	  TBool QueryVersionSupported(const TVersion& aVer) const;
	  TBool IsAvailable(TInt aUnit,const TDesC* aPhysicalDevice,const TDesC* anInfo) const;
	};

const TUint	KBusDevModeInvalid=0xFFFFFFFF;
const TUint	KBusDevSocketInfoMask=0x0000FFFF;
const TUint KBusDevPhase1Start=0x00010000;
const TUint KBusDevPhase2Start=0x00020000;

class MBusDev
	{
public:
      MBusDev();
    TInt CheckOpenMode(const TDesC& aDeviceName,TInt aUnit);
	TInt DoAsyncStart();
	TInt DoAsyncLateOpen(TInt aHandle,TInt anOpenInfo);
	inline TBool MayRequireRestart() {return(iStartInfo);}
	inline TInt DevSocketNumber() {return(iStartInfo&KBusDevSocketInfoMask);}
	inline TInt& Status() {return(iStatus);}
	inline void SetStatus(TInt aVal) {iStatus=aVal;}
private:
    TUint iStartInfo;
	TInt iStatus;
	};

class RBusLogicalChannel : public RHandleBase, public MBusDev
	{
protected:
	  TInt DoCreate(const TDesC& aDevice,const TVersion& aVer,const TDesC* aChan,TInt aUnit,const TDesC* aDriver,const TDesC8* anInfo,TOwnerType aType=EOwnerProcess);
	  void DoCancel(TUint aReqMask);
	  void DoRequest(TInt aReqNo,TRequestStatus& aStatus);
	  void DoRequest(TInt aReqNo,TRequestStatus& aStatus,TAny* a1);
	  void DoRequest(TInt aReqNo,TRequestStatus& aStatus,TAny* a1,TAny* a2);
	  TInt DoControl(TInt aFunction);
	  TInt DoControl(TInt aFunction,TAny* a1);
	  TInt DoControl(TInt aFunction,TAny* a1,TAny* a2);
	  TInt DoSvControl(TInt aFunction);
	  TInt DoSvControl(TInt aFunction,TAny* a1);
	  TInt DoSvControl(TInt aFunction,TAny* a1,TAny* a2);
private:
	TInt CheckBusStatus();
	TInt DoCheckBusStatus(TInt aSocket);
	};

class RTimer : public RHandleBase
	{
public:
	  TInt CreateLocal();
	  void Cancel();
	  void After(TRequestStatus& aStatus,TTimeIntervalMicroSeconds32 anInterval);
	  void At(TRequestStatus& aStatus,const TTime& aTime);
	  void Lock(TRequestStatus& aStatus,TTimerLockSpec aLock);
	  void Inactivity(TRequestStatus& aStatus, TTimeIntervalSeconds aSeconds);
	};

class RLibrary : public RHandleBase
	{
public:
	  void Close();
	  TInt Load(const TDesC& aFileName,const TUidType &aType);
	  TInt Load(const TDesC& aFileName,const TDesC& aPath=KNullDesC);
	  TInt Load(const TDesC& aFileName,const TDesC& aPath,const TUidType &aType);
	  TInt LoadRomLibrary(const TDesC& aFileName,const TDesC& aPath);
	  TLibraryFunction Lookup(TInt anOrdinal) const;
	  TUidType Type() const;
	  TLibraryEntry EntryPoint() const;
	  TUint* DllRefTable() const;
	TInt LibraryCallList(TInt& aNumEps, TUint*& aCallList);
	  TFileName FileName() const;
	  TInt GetRamSizes(TInt& aCodeSize, TInt& aConstDataSize);
	};

class RSemaphore : public RHandleBase
	{
public:
	inline TInt Open(const TFindSemaphore& aFind,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocal(TInt aCount,TOwnerType aType=EOwnerProcess);
	  TInt CreateGlobal(const TDesC& aName,TInt aCount,TOwnerType aType=EOwnerProcess);
	  TInt OpenGlobal(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt Count();
	  void Wait();
	  void Signal();
	  void Signal(TInt aCount);
	};

class RCriticalSection : private RSemaphore
	{
public:
	  RCriticalSection();
	  TInt CreateLocal(TOwnerType aType=EOwnerProcess);
	  void Close();
	  void Wait();
	  void Signal();
	inline TBool IsBlocked() const;
private:
	TInt iBlocked;
	};

class RMutex : public RHandleBase
	{
public:
	inline TInt Open(const TFindMutex& aFind,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocal(TOwnerType aType=EOwnerProcess);
	  TInt CreateGlobal(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt OpenGlobal(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt Count();
	  void Wait();
	  void Signal();
	};

class RChunk : public RHandleBase
	{
public:
	inline TInt Open(const TFindChunk& aFind,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocal(TInt aSize,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocalCode(TInt aSize,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateGlobal(const TDesC& aName,TInt aSize,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateDoubleEndedLocal(TInt aInitialBottom, TInt aInitialTop,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateDoubleEndedGlobal(const TDesC& aName,TInt aInitialBottom,TInt aInitialTop,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt OpenGlobal(const TDesC& aName,TBool isReadOnly,TOwnerType aType=EOwnerProcess);
	  TInt Adjust(TInt aNewSize) const;
	  TInt AdjustDoubleEnded(TInt aBottom, TInt aTop) const;
	  TUint8* Base() const;
	  TInt Size() const;
	  TInt Bottom() const;
	  TInt Top() const;
	  TInt MaxSize() const;
	inline TBool IsReadable() const;
	inline TBool IsWritable() const;
private:
	friend class UserHeap;
	};

class RHeap;
class THeapWalk
	{
protected:
	enum TCellType
		{
		EGoodAllocatedCell,EGoodFreeCell,
		EBadAllocatedCellSize,EBadAllocatedCellAddress,
		EBadFreeCellAddress
		};
public:
	  THeapWalk(const RHeap &aHeap);
	  TInt Walk();
	virtual void Info(TCellType aType,TAny* aBase,TInt aLength)=0;
protected:
	inline TInt Value() const;
	inline void SetValue(TInt aValue);
private:
	RHeap* iHeap;
	TInt iValue;
	};

class UserHeap
	{
public:
	  static RHeap* FixedHeap(TAny* aBase, TInt aMaxLength);
	  static RHeap* ChunkHeap(const TDesC* aName, TInt aMinLength, TInt aMaxLength, TInt aGrowBy=KMinHeapGrowBy);
	  static RHeap* ChunkHeap(RChunk& aChunk, TInt aMinLength, TInt aGrowBy=KMinHeapGrowBy);
	};

  TInt CalcChunkHeapCompression(RHeap* aHeap,TInt aBaseOffset);

 
 
class RHeapBase
	{
public:
	enum THeapType {EFixedAddress,EChunkSupervisor,EChunkStack,EChunkNormal};
	struct SCell {TInt len;SCell* next;};
protected:
	TInt iMinLength;
	TInt iMaxLength;
	TInt iOffset;
	TInt iGrowBy;
	TInt iAccessCount;
	THeapType iType;
	RChunk iChunk;
	RCriticalSection iLock;
	TUint8* iBase;
	TUint8* iTop;
	SCell iFree;
	friend class THeapWalk;
	friend class S;
	friend TInt CalcChunkHeapCompression(RHeap* aHeap,TInt aBaseOffset);
	friend class UserHeap;
protected:
	RHeapBase(TInt aMaxLength);
	RHeapBase(const RChunk& aChunk,TInt anOffset,TInt aMinLength,TInt aMaxLength,TInt aGrowBy);
	virtual TInt ChunkAdjust(TInt aSize)=0;
	virtual TInt CompressAll()=0;
	};

class RHeap : public RHeapBase
	{
public:
	typedef TUint32 TAllocSize;
	enum TAllocFail {ERandom,ETrueRandom,EDeterministic,ENone,EFailNext};
	enum TDbgHeapType {EUser,EKernel};
public:
	  TInt Open();
	  void Close();
	  TInt AllocLen(const TAny* aCell) const;
	  TInt AllocSize(TInt& aTotalAllocSize) const;
	  TAny* Alloc(TInt aSize);
	  TAny* AllocL(TInt aSize);
	  TAny* AllocLC(TInt aSize);
	  TAny* Adjust(TAny* aCell,TInt anOffset,TInt aDelta);
	  TAny* AdjustL(TAny* aCell,TInt anOffset,TInt aDelta);
	  TInt Compress();
	  void Free(TAny* aCell);
	  void FreeZ(TAny* &aCell);
	  void FreeAll();
	  TAny* ReAlloc(TAny* aCell,TInt aSize);
	  TAny* ReAllocL(TAny* aCell,TInt aSize);
	  THeapType Type() const;
	  TUint8* Base() const;
	  TInt Size() const;
	  TInt Available(TInt& aBiggestBlock) const;
	  void Check() const;
	  TInt Count() const;
	  TInt Count(TInt& aFreeCount) const;
	  void __DbgMarkStart();
	  TUint32 __DbgMarkEnd(TInt aCount);
	  void __DbgMarkCheck(TBool aCountAll,TInt aCount,const TDesC8& aFileName,TInt aLineNum);
	  void __DbgSetAllocFail(TAllocFail aType,TInt aValue);
protected:
	  RHeap(TInt aMaxLength);
	  RHeap(const RChunk& aChunk,TInt anOffset,TInt aMinLength,TInt aMaxLength,TInt aGrowBy);
	  TAny* operator new(TUint aSize,TAny* aBase);
	  void Initialise();
	  SCell* GetAddress(TAny* aCell);
	  virtual TInt ChunkAdjust(TInt aSize);
	  virtual TInt CompressAll();
protected:
	friend class THeapWalk;
	friend class S;
	friend TInt CalcChunkHeapCompression(RHeap* aHeap,TInt aBaseOffset);
	friend class UserHeap;
private:
	void ChunkHeapCreated() const;	 
	TInt TryToGrowHeap(TInt aSize, SCell* pC, SCell* pP);
public:
	struct SDebugCell {TInt len;TInt nestingLevel;TInt allocCount;};
# 3285 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

public:
	TBool iTestCodeRunning;	
	TInt iTestNestingLevel;
	TInt iTestNumAllocCells;
	TUint iTestAddress;
	TInt iTestSize;
	TInt iTestAllocCount;
private:
	TInt iNestingLevel;
	TInt iAllocCount;
	TInt iLevelNumAllocCells;
	SDebugCell* iPtrDebugCell;
	TAllocFail iFailType;
	TInt iFailRate;
	TBool iFailed;
	TInt iFailAllocCount;
	TInt iRand;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TThreadId
	{
public:
	inline TThreadId();
	inline TThreadId(TUint anId);
	inline operator TUint() const;
	inline TInt operator==(TThreadId aId) const;
	inline TInt operator!=(TThreadId aId) const;
private:
	TUint iId;
	};

class RProcess;
class RThread : public RHandleBase
 



	{
public:
	inline RThread();
	  TInt Create(const TDesC& aName,TThreadFunction aFunction,TInt aStackSize,TAny* aPtr,RLibrary* aLibrary,RHeap* aHeap, TInt aHeapMinSize,TInt aHeapMaxSize,TOwnerType aType);
	  TInt Create(const TDesC& aName,TThreadFunction aFunction,TInt aStackSize,TInt aHeapMinSize,TInt aHeapMaxSize,TAny *aPtr,TOwnerType aType=EOwnerProcess);
	  TInt Create(const TDesC& aName,TThreadFunction aFunction,TInt aStackSize,RHeap* aHeap,TAny* aPtr,TOwnerType aType=EOwnerProcess);
	  TInt SetInitialParameter(TAny* aPtr);
	  TInt Open(const TDesC& aFullName,TOwnerType aType=EOwnerProcess);
	  TInt Open(TThreadId aID,TOwnerType aType=EOwnerProcess);
	  TThreadId Id() const;
	  void Resume() const;
	  void Suspend() const;
	  TInt Rename(const TDesC& aName) const;
	  void Kill(TInt aReason);
	  void Terminate(TInt aReason);
	  void Panic(const TDesC& aCategory,TInt aReason);
	  TInt Process(RProcess& aProcess) const;
	  TThreadPriority Priority() const;
	  void SetPriority(TThreadPriority aPriority) const;
	  TProcessPriority ProcessPriority() const;
	  void SetProcessPriority(TProcessPriority aPriority) const;
	  TBool System() const;
	  void SetSystem(TBool aState) const;
	  TBool Protected() const;
	  void SetProtected(TBool aState) const;
	  TInt RequestCount() const;
	  TExitType ExitType() const;
	  TInt ExitReason() const;
	  TExitCategoryName ExitCategory() const;
	  void RequestComplete(TRequestStatus*& aStatus,TInt aReason) const;

	  TInt GetDesLength(const TAny* aPtr) const;
	  TInt GetDesMaxLength(const TAny* aPtr) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes,TInt anOffset) const;
	  void ReadL(const TAny* aPtr,TDes16 &aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes,TInt anOffset) const;

	  void Logon(TRequestStatus& aStatus) const;
	  TInt LogonCancel(TRequestStatus& aStatus) const;
	  RHeap* Heap();	
	  void HandleCount(TInt& aProcessHandleCount, TInt& aThreadHandleCount) const;
	  TExceptionHandler* ExceptionHandler() const;
	  TInt SetExceptionHandler(TExceptionHandler* aHandler,TUint32 aMask);
	  void ModifyExceptionMask(TUint32 aClearMask, TUint32 aSetMask);
	  TInt RaiseException(TExcType aType);
	  TBool IsExceptionHandled(TExcType aType);
	  void Context(TDes8& aDes) const;
	  TInt GetRamSizes(TInt& aHeapSize,TInt& aStackSize);
	  TInt GetCpuTime(TTimeIntervalMicroSeconds& aCpuTime) const;
	inline TInt Open(const TFindThread& aFind,TOwnerType aType=EOwnerProcess);
	  void Rendezvous(TRequestStatus& aStatus) const;
	  TInt RendezvousCancel(TRequestStatus& aStatus) const;
	  static void Rendezvous(TInt aReason);

	 





	  TSecureId SecureId() const;

	 






	inline TVendorId VendorId() const
		{ return 0; }

	 








	inline TBool HasCapability(TCapability  ,const char*  =0) const
		{ return ETrue; }

	 









	inline TBool HasCapability(TCapability  ,TCapability  ,const char*  =0) const
		{ return ETrue; }

# 3432 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

	};

class TProcessId
	{
public:
	inline TProcessId();
	inline TProcessId(TUint anId);
	inline operator TUint() const;
	inline TInt operator==(TProcessId aId) const;
	inline TInt operator!=(TProcessId aId) const;
private:
	TUint iId;
	};


 



class TProcessMemoryInfo
	{
public:
	TUint32 iCodeBase;
	TUint32 iCodeSize;
	TUint32 iConstDataBase;
	TUint32 iConstDataSize;
	TUint32 iInitialisedDataBase;
	TUint32 iInitialisedDataSize;
	TUint32 iUninitialisedDataBase;
	TUint32 iUninitialisedDataSize;
	};

class RProcess : public RHandleBase
 



	{
public:
	inline RProcess();
	  TInt Create(const TDesC& aFileName,const TDesC& aCommand,TOwnerType aType=EOwnerProcess);
	  TInt Create(const TDesC& aFileName,const TDesC& aCommand,const TUidType &aUidType, TOwnerType aType=EOwnerProcess);
	  TInt Open(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt Open(TProcessId aId,TOwnerType aType=EOwnerProcess);
	  TUidType Type() const;
	  void SetType(const TUidType& aType);
	  TProcessId Id() const;
	  TInt Rename(const TDesC& aName);
	  void Kill(TInt aReason);
	  void Terminate(TInt aReason);
	  void Panic(const TDesC& aCategory,TInt aReason);
	  void Resume();
	  TFileName FileName() const;
	  TInt CommandLineLength() const;
	  void CommandLine(TDes &aCommand) const;
	  TExitType ExitType() const;
	  TInt ExitReason() const;
	  TExitCategoryName ExitCategory() const;
	  TProcessPriority Priority() const;
	  void SetPriority(TProcessPriority aPriority) const;
	  TBool System() const;
	  void SetSystem(TBool aState) const;
	  TBool Protected() const;
	  void SetProtected(TBool aState) const;
	  TBool LoadedFromRam() const;
	  TInt Owner(RProcess &anOwner) const;
	  void SetOwner(const RProcess& aProcess) const;
	  void Logon(TRequestStatus& aStatus) const;
	  TInt LogonCancel(TRequestStatus& aStatus) const;
	  TInt GetRamSizes(TInt& aCodeSize, TInt& aConstDataSize, TInt& anInitialisedDataSize, TInt& anUninitialisedDataSize);
	  TInt GetMemoryInfo(TProcessMemoryInfo& aInfo) const;
	inline TInt Open(const TFindProcess& aFind,TOwnerType aType=EOwnerProcess);
	  void Rendezvous(TRequestStatus& aStatus) const;
	  TInt RendezvousCancel(TRequestStatus& aStatus) const;
	  static void Rendezvous(TInt aReason);

	 





	  TSecureId SecureId() const;

	 






	inline TVendorId VendorId() const
		{ return 0; }

	 








	inline TBool HasCapability(TCapability  ,const char*  =0) const
		{ return ETrue; }

	 









	inline TBool HasCapability(TCapability  ,TCapability  ,const char*  =0) const
		{ return ETrue; }
protected:
	inline RProcess(TInt aHandle);
	};



class RMessage;
class RMessagePtr
 



	{
	friend TBool operator==(RMessagePtr aLeft,RMessagePtr aRight);
public:
	inline RMessagePtr();
	inline RMessagePtr(const RMessage& aMessage);
	inline TBool IsNull() const;
	  void Complete(TInt aReason) const;
private:
	TInt iHandle;
	};
inline TBool operator==(RMessagePtr aLeft,RMessagePtr aRight);
inline TBool operator!=(RMessagePtr aLeft,RMessagePtr aRight);



class RMessagePtr2;

class RMessage
 



	{

	friend class CServer;
	friend class RMessagePtr;
public:
	enum TSessionMessages {EConnect=-1,EDisConnect=-2};
public:
	  RMessage();
	  void Complete(TInt aReason) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes,TInt anOffset) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes,TInt anOffset) const;
	  void Panic(const TDesC& aCategory,TInt aReason) const;
	  void Kill(TInt aReason) const;
	  void Terminate(TInt aReason) const;
	inline TInt Function() const;
	inline const RThread& Client() const;
	inline TInt Int0() const;
	inline TInt Int1() const;
	inline TInt Int2() const;
	inline TInt Int3() const;
	inline const TAny* Ptr0() const;
	inline const TAny* Ptr1() const;
	inline const TAny* Ptr2() const;
	inline const TAny* Ptr3() const;
	inline const RMessagePtr MessagePtr() const;




public:
	  explicit RMessage(const RMessagePtr2& aPtr);
protected:
	TInt iFunction;
	TInt iArgs[KMaxMessageArguments];
	RThread iClient;
	const TAny* iSessionPtr;
	TInt iHandle;
	};



class RServer : public RHandleBase
 



	{
public:
	  TInt CreateGlobal(const TDesC& aName);
	  void Receive(TRequestStatus& aStatus);
	  void Receive();
	  void Cancel();
	inline const RMessage& Message() const;
private:
	RMessage iMessage;
	};



class TIpcArgs
 



	{
public:
	 




	enum TArgType
		{
		 

		EUnspecified = 0,
		 

		EFlagDes = 4,
		 

		EFlagConst = 2,
		 

		EFlag16Bit = 1,
		 

		EDes8 = EFlagDes,
		 

		EDes16 = EFlagDes|EFlag16Bit,
		 

		EDesC8 = EFlagDes|EFlagConst,
		 

		EDesC16 = EFlagDes|EFlagConst|EFlag16Bit,
		};
	 



	enum
		{
		 

		KBitsPerType=3
		};
	 


	enum TNothing
		{
		 

		ENothing
		};
public:
	inline TIpcArgs()
		:iFlags(0)
	 




		{}
	template <class T0>
	inline explicit TIpcArgs(T0 a0)
	 


		{
		Assign(iArgs[0],a0);
		iFlags=(Type(a0)<<(0*KBitsPerType));
		}
	template <class T0,class T1>
	inline TIpcArgs(T0 a0,T1 a1)
	 


		{
		Assign(iArgs[0],a0);
		Assign(iArgs[1],a1);
		iFlags=(Type(a0)<<(0*KBitsPerType))|(Type(a1)<<(1*KBitsPerType));
		}
	template <class T0,class T1,class T2>
	inline TIpcArgs(T0 a0,T1 a1,T2 a2)
	 


		{
		Assign(iArgs[0],a0);
		Assign(iArgs[1],a1);
		Assign(iArgs[2],a2);
		iFlags=(Type(a0)<<(0*KBitsPerType))|(Type(a1)<<(1*KBitsPerType))|(Type(a2)<<(2*KBitsPerType));
		}
	template <class T0,class T1,class T2,class T3>
	inline TIpcArgs(T0 a0,T1 a1,T2 a2,T3 a3)
	 


		{
		Assign(iArgs[0],a0);
		Assign(iArgs[1],a1);
		Assign(iArgs[2],a2);
		Assign(iArgs[3],a3);
		iFlags=(Type(a0)<<(0*KBitsPerType))|(Type(a1)<<(1*KBitsPerType))|(Type(a2)<<(2*KBitsPerType))|(Type(a3)<<(3*KBitsPerType));
		}
	 
	inline void Set(TInt aIndex,TNothing);
	inline void Set(TInt aIndex,TInt aValue);
	inline void Set(TInt aIndex,const TAny* aValue);
	inline void Set(TInt aIndex,const TDesC8* aValue);
	inline void Set(TInt aIndex,const TDesC16* aValue);
	inline void Set(TInt aIndex,TDes8* aValue);
	inline void Set(TInt aIndex,TDes16* aValue);
private:
	inline static TArgType Type(TNothing);
	inline static TArgType Type(TInt);
	inline static TArgType Type(const TAny*);
	inline static TArgType Type(const TDesC8*);
	inline static TArgType Type(const TDesC16*);
	inline static TArgType Type(TDes8*);
	inline static TArgType Type(TDes16*);
	 
	inline static void Assign(TInt&,TNothing);
	inline static void Assign(TInt& aArg,TInt aValue);
	inline static void Assign(TInt& aArg,const TAny* aValue);
	inline static void Assign(TInt& aArg,const TDesC8* aValue);
	inline static void Assign(TInt& aArg,const TDesC16* aValue);
	inline static void Assign(TInt& aArg,TDes8* aValue);
	inline static void Assign(TInt& aArg,TDes16* aValue);
public:
	 



	TInt iArgs[KMaxMessageArguments];
	 



	TInt iFlags;
	};

class RMessagePtr2
 



	{
public:
	inline RMessagePtr2();
	inline TBool IsNull() const;
	inline TInt Handle() const;
	inline TBool ClientDataCaging() const;
	  void Complete(TInt aReason) const;
	  TInt GetDesLength(TInt aParam) const;
	  TInt GetDesLengthL(TInt aParam) const;
	  TInt GetDesMaxLength(TInt aParam) const;
	  TInt GetDesMaxLengthL(TInt aParam) const;
	  void ReadL(TInt aParam,TDes8& aDes,TInt aOffset=0) const;
	  void ReadL(TInt aParam,TDes16 &aDes,TInt aOffset=0) const;
	  void WriteL(TInt aParam,const TDesC8& aDes,TInt aOffset=0) const;
	  void WriteL(TInt aParam,const TDesC16& aDes,TInt aOffset=0) const;
	  TInt Read(TInt aParam,TDes8& aDes,TInt aOffset=0) const;
	  TInt Read(TInt aParam,TDes16 &aDes,TInt aOffset=0) const;
	  TInt Write(TInt aParam,const TDesC8& aDes,TInt aOffset=0) const;
	  TInt Write(TInt aParam,const TDesC16& aDes,TInt aOffset=0) const;
	  void Panic(const TDesC& aCategory,TInt aReason) const;
	  void Kill(TInt aReason) const;
	  void Terminate(TInt aReason) const;
	  TInt SetProcessPriority(TProcessPriority aPriority) const;
	inline   void SetProcessPriorityL(TProcessPriority aPriority) const;
	  TInt Client(RThread& aClient, TOwnerType aOwnerType=EOwnerProcess) const;
	inline   void ClientL(RThread& aClient, TOwnerType aOwnerType=EOwnerProcess) const;
	  TUint ClientProcessFlags() const;

	 





	  TSecureId SecureId() const;

	 






	inline TVendorId VendorId() const
		{ return 0; }

	 








	inline TBool HasCapability(TCapability  ,const char*  =0) const
		{ return ETrue; }

 	 







 	inline void HasCapabilityL(TCapability aCapability,const char* aDiagnosticMessage=0) const;

	 









	inline TBool HasCapability(TCapability  ,TCapability  ,const char*  =0) const
		{ return ETrue; }

	 








	inline void HasCapabilityL(TCapability aCapability1,TCapability aCapability2,const char* aDiagnosticMessage=0) const;

protected:
	TInt iHandle;
	};
inline TBool operator==(RMessagePtr2 aLeft,RMessagePtr2 aRight);
inline TBool operator!=(RMessagePtr2 aLeft,RMessagePtr2 aRight);

class CSession2;



class RMessage2 : public RMessagePtr2
 



	{
	friend class CServer2;
public:
	 

	enum TSessionMessages
		{
		 

		EConnect=-1,
		 

		EDisConnect=-2
		};
public:
	inline RMessage2();
	  explicit RMessage2(const RMessagePtr2& aPtr);
	inline TInt Function() const;
	inline TInt Int0() const;
	inline TInt Int1() const;
	inline TInt Int2() const;
	inline TInt Int3() const;
	inline const TAny* Ptr0() const;
	inline const TAny* Ptr1() const;
	inline const TAny* Ptr2() const;
	inline const TAny* Ptr3() const;
	inline CSession2* Session() const;
protected:
	TInt iFunction;
	TInt iArgs[KMaxMessageArguments];
private:
	TInt iSpare1;		 
protected:
	const TAny* iSessionPtr;
private:
	TInt iSpare2;		 
	TInt iSpare3;		 
	friend class RMessage;
	};

class RServer2 : public RHandleBase
 



	{
public:
	  TInt CreateGlobal(const TDesC& aName);
	  void Receive(RMessage2& aMessage,TRequestStatus& aStatus);
	  void Receive(RMessage2& aMessage);
	  void Cancel();
	};

class RSessionBase : public RHandleBase
 



	{
	friend class RSubSessionBase;
public:
	 

	enum TAttachMode
		{
		 

		EExplicitAttach,
		 

		EAutoAttach
		};
public:

	inline TInt Share(TAttachMode aAttachMode=EExplicitAttach);
	  TInt Attach() const;

	inline TInt ShareAuto();
protected:
	inline TInt CreateSession(const TDesC& aServer,const TVersion& aVersion);
	  TInt CreateSession(const TDesC& aServer,const TVersion& aVersion,TInt aAsyncMessageSlots);

	inline TInt Send(TInt aFunction,TAny* aPtr) const;
	inline void SendReceive(TInt aFunction,TAny* aPtr,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,TAny* aPtr) const;

	inline TInt Send(TInt aFunction,const TIpcArgs& aArgs) const;
	inline void SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,const TIpcArgs& aArgs) const;
	inline TInt Send(TInt aFunction) const;
	inline void SendReceive(TInt aFunction,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction) const;
private:
	  TInt DoShare(TInt aAttachMode);
	  TInt DoSend(TInt aFunction,TAny* aPtr) const;
	  void DoSendReceive(TInt aFunction,TAny* aPtr,TRequestStatus& aStatus) const;
	  TInt DoSendReceive(TInt aFunction,TAny* aPtr) const;
	TInt SendAsync(TInt aFunction,TAny* aPtr,TRequestStatus* aStatus) const;
	TInt SendSync(TInt aFunction,TAny *aPtr) const;
	};

class RSubSessionBase
 



	{
public:
	inline TInt SubSessionHandle() const;
protected:
	inline RSubSessionBase();
	inline RSessionBase& Session();

	inline TInt CreateSubSession(RSessionBase& aSession,TInt aFunction,const TAny* aPtr);

	inline TInt CreateSubSession(RSessionBase& aSession,TInt aFunction,const TIpcArgs& aArgs);
	inline TInt CreateSubSession(RSessionBase& aSession,TInt aFunction);
	  void CloseSubSession(TInt aFunction);

	inline TInt Send(TInt aFunction,const TAny* aPtr) const;
	inline void SendReceive(TInt aFunction,const TAny* aPtr,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,const TAny* aPtr) const;

	inline TInt Send(TInt aFunction,const TIpcArgs& aArgs) const;
	inline void SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,const TIpcArgs& aArgs) const;
	inline TInt Send(TInt aFunction) const;
	inline void SendReceive(TInt aFunction,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction) const;
private:
	  TInt DoCreateSubSession(RSessionBase& aSession,TInt aFunction,const TAny* aPtr);
	  TInt DoSend(TInt aFunction,const TAny* aPtr) const;
	  void DoSendReceive(TInt aFunction,const TAny* aPtr,TRequestStatus& aStatus) const;
	  TInt DoSendReceive(TInt aFunction,const TAny* aPtr) const;
private:
	RSessionBase iSession;
	TInt iSubSessionHandle;
	};

class RRefBase
	{
public:
	  void Free();
protected:
	inline RRefBase();
	inline RRefBase(const RRefBase& aRef);
	  void DoAlloc(const TAny* aPtr,TInt aSize);
	  void DoAllocL(const TAny* aPtr,TInt aSize);
	  void Copy(const RRefBase& aRef);
private:
	  void operator=(const RRefBase& aRef);
protected:
	TInt* iPtr;
	};

template <class T>
class RRef : public RRefBase
	{
public:
	inline RRef();
	inline RRef(const RRef<T>& anObject);
	inline void operator=(const RRef<T>& anObject);
	inline T* operator->();
	inline operator T*();
	inline void Alloc(const T& anObject);
	inline void Alloc(const T& anObject,TInt aSize);
	inline void AllocL(const T& anObject);
	inline void AllocL(const T& anObject,TInt aSize);
	};

class RChangeNotifier : public RHandleBase
	{
public:
	  TInt Create();
	  TInt Logon(TRequestStatus& aStatus) const;
	  TInt LogonCancel() const;
	};

enum TChanges
	{
	EChangesLocale=0x01,
	EChangesMidnightCrossover=0x02,
	EChangesThreadDeath=0x04,
	EChangesPowerStatus=0x08,
	EChangesSystemTime=0x10,
	EChangesFreeMemory=0x20,
	EChangesOutOfMemory=0x40,
	};

class RUndertaker : public RHandleBase
	{
public:
	  TInt Create();
	  TInt Logon(TRequestStatus& aStatus,TInt& aThreadHandle) const;
	  TInt LogonCancel() const;
	};

class TNotifyInfo
	{
public:
	const TDesC* iLine1;
	const TDesC* iLine2;
	const TDesC* iButton1;
	const TDesC* iButton2;
	TPtr* iButtonVal;
	};

 


class RNotifier : public RSessionBase
	{
public :
	  RNotifier();
	  TInt Connect();
	  TInt StartNotifier(TUid aNotifierUid,const TDesC8& aBuffer);
	  TInt StartNotifier(TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  TInt StartNotifier(TUid aNotifierDllUid,TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  TInt CancelNotifier(TUid aNotifierUid);
	  TInt UpdateNotifier(TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  void StartNotifierAndGetResponse(TRequestStatus& aRs,TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  void StartNotifierAndGetResponse(TRequestStatus& aRs,TUid aNotifierDllUid,TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  TInt UnloadNotifiers(TUid aNotifierUid);
	  TInt LoadNotifiers(TUid aNotifierUid);
	  void Notify(const TDesC& aLine1,const TDesC& aLine2,const TDesC& aBut1,const TDesC& aBut2,TInt& aButtonVal,TRequestStatus& aStatus);
	  TInt InfoPrint(const TDesC& aDes);
private:
	TPtr8 iButtonVal;
	TInt iSpare[7];  
	};

const TInt KMediaPasswordNotifyUid(0x10004c00);
const TInt KMaxMediaPassword(16);
typedef TBuf8<KMaxMediaPassword> TMediaPassword;	 

enum TMediaPswdNotifyExitMode {EMPEMUnlock, EMPEMCancel, EMPEMUnlockAndStore};

struct TMediaPswdNotifyBase
	{
	enum TCardType {ECTMmcPassword} iCT;
	TVersion iVersion;
	};

struct TMediaPswdSendNotifyInfoV1 : public TMediaPswdNotifyBase
	{
	 
	};

struct TMediaPswdSendNotifyInfoV1Debug : public TMediaPswdSendNotifyInfoV1
	{
	TInt iSleepPeriod;							 
	TMediaPswdNotifyExitMode iEM;
	TText8 iPW[KMaxMediaPassword];
	};

struct TMediaPswdReplyNotifyInfoV1 : public TMediaPswdNotifyBase
	{
	TText8 iPW[KMaxMediaPassword];
	TMediaPswdNotifyExitMode iEM;
	};

class TTrapHandler
	{
public:
	  TTrapHandler();
	  virtual void Trap()=0;
	  virtual void UnTrap()=0;
	  virtual void Leave(TInt aValue)=0;
	};

const TInt KNoCallEntryPoint = 0x01;

class TDllRefTable
	{
public:
	TUint16 iFlags;
	TUint16 iNumberOfEntries;
	};

class TDllRefTableEntry
	{
public:
	TUint iEntryPoint;
	TDllRefTable* iDllRefTable;
	};

struct TCollationMethod;  

class Mem
	{
public:
	  static TUint8* Copy(TAny* aTrg,const TAny* aSrc,TInt aLength);
	  static TUint8* Move(TAny* aTrg,const TAny* aSrc,TInt aLength);
	  static TInt Compare(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);
	  static TInt Compare(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);
	  static TInt CompareF(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);
	  static TInt CompareF(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);
	  static TInt CompareC(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);
	  static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);
	  static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL,
								  TInt aMaxLevel,const TCollationMethod* aCollationMethod);
	  static TInt CollationMethods();
	  static TUint CollationMethodId(TInt aIndex);
	  static const TCollationMethod* CollationMethodByIndex(TInt aIndex);
	  static const TCollationMethod* CollationMethodById(TUint aId);
	  static void Fill(TAny* aTrg,TInt aLength,TChar aChar);
	  static void FillZ(TAny* aTrg,TInt aLength);
	  static void Swap(TAny* aPtr1,TAny* aPtr2,TInt aLength);
	  static void Crc(TUint16& aCrc,const TAny* aPtr,TInt aLength);
	};

class Password
	{
public:
	  static TBool IsEnabled();
	  static TInt SetEnabled(const TPassword& aPassword,TBool aIsEnabled);
	  static TBool IsValid(const TPassword& aPassword);
	  static TInt Set(const TPassword& anOldPassword,const TPassword& aNewPassword);
	};

class User : public UserHeap
	{
public:
	 
	  static void Exit(TInt aReason);
	  static void Panic(const TDesC& aCategory,TInt aReason);
	  static TInt StartThread(TThreadFunction anEntryPt,TAny* aPtr);
	  static void HandleException(TExceptionHandler* aHandler, TExcType anException);
	 
	  static void Leave(TInt aReason);
	  static void LeaveNoMemory();
	  static TInt LeaveIfError(TInt aReason);
	  static TAny* LeaveIfNull(TAny* aPtr);
	  static TTrapHandler* SetTrapHandler(TTrapHandler* aHandler);
	  static TTrapHandler* TrapHandler();
	 
	  static TInt InfoPrint(const TDesC& aDes);
	 
	  static void RequestComplete(TRequestStatus*& aStatus,TInt aReason);
	  static void WaitForAnyRequest();
	  static void WaitForRequest(TRequestStatus& aStatus);
	  static void WaitForRequest(TRequestStatus& aStatus1,TRequestStatus& aStatus2);
	 
	  static TAny* Adjust(TAny* aCell,TInt anOffset,TInt aDelta);
	  static TAny* AdjustL(TAny* aCell,TInt anOffset,TInt aDelta);
	  static TInt AllocLen(const TAny* aCell);
	  static TAny* Alloc(TInt aSize);
	  static TAny* AllocL(TInt aSize);
	  static TAny* AllocLC(TInt aSize);
	  static TInt AllocSize(TInt& aTotalAllocSize);
	  static TInt Available(TInt& aBiggestBlock);
	  static TInt CountAllocCells();
	  static TInt CountAllocCells(TInt& aFreeCount);
	  static void Free(TAny* aCell);
	  static void FreeZ(TAny*& aCell);
	  static RHeap& Heap();
	  static TAny* ReAlloc(TAny* aCell,TInt aSize);
	  static TAny* ReAllocL(TAny* aCell,TInt aSize);
	  static RHeap* SwitchHeap(RHeap* aHeap);
	  static TInt CompressAllHeaps();
	 
	  static void After(TTimeIntervalMicroSeconds32 anInterval);
	  static TInt At(const TTime& aTime);
	 
	  static TInt SetHomeTime(const TTime& aTime);
	 
	  static void SetCurrencySymbol(const TDesC& aSymbol);
	 
	  static TUint TickCount();
	  static TTimerLockSpec LockPeriod();
	  static TInt LockedInc(TInt& aValue);
	  static TInt LockedDec(TInt& aValue);
	  static TTimeIntervalSeconds InactivityTime();
	  static void ResetInactivityTime();
	  static TUint32 FastCounter();
	 
	  static TInt Beep(TInt aFrequency,TTimeIntervalMicroSeconds32 aDuration);
	 
	  static TInt IsRomAddress(TBool& aBool,TAny* aPtr);
	 
	  static TInt BinarySearch(TInt aCount,const TKey& aKey,TInt& aPos);
	  static TInt QuickSort(TInt aCount,const TKey& aKey,const TSwap& aSwap);
	 
	  static TLanguage Language();
	 
	  static TUint Collate(TUint aChar);
	  static TUint Fold(TUint aChar);
	  static TUint LowerCase(TUint aChar);
	  static TUint UpperCase(TUint aChar);
	  static TUint Fold(TUint aChar,TInt aFlags);
	  static TUint TitleCase(TUint aChar);
	 
	  static TInt StringLength(const TUint8* aString);
	  static TInt StringLength(const TUint16* aString);
	 
	  static TInt FreeLogicalDevice(const TDesC& aDeviceName);
	  static TInt FreePhysicalDevice(const TDesC& aDriverName);
	  static TInt LoadLogicalDevice(const TDesC& aFileName);
	  static TInt LoadPhysicalDevice(const TDesC& aFileName);
	 
	  static TBool QueryVersionSupported(const TVersion& aCurrent,const TVersion& aRequested);
	  static TVersion Version();
	 
	  static TInt SetMachineConfiguration(const TDesC8& aConfig);
	  static TInt MachineConfiguration(TDes8& aConfig,TInt& aSize);
	 
	  static void SetDebugMask(TUint32 aVal);
	  static void SetJustInTime(const TBool aBoolean);
	  static void Check();
	  static void Invariant();
	  static TBool JustInTime();
	  static void __DbgMarkStart(RHeap::TDbgHeapType aHeapType);
	  static void __DbgMarkCheck(RHeap::TDbgHeapType aHeapType,TBool aCountAll,TInt aCount,const TDesC8& aFileName,TInt aLineNum);
	  static TUint32 __DbgMarkEnd(RHeap::TDbgHeapType aHeapType,TInt aCount);
	  static void __DbgSetAllocFail(RHeap::TDbgHeapType aHeapType,RHeap::TAllocFail aType,TInt aRate);
	 
	  static TInt ValidateName(const TDesC& aName);
	 
	  static void IMB_Range(TAny* aStart, TAny* aEnd);

	 





	  static TSecureId CreatorSecureId();

	 






	inline static TVendorId CreatorVendorId()
		{ return 0; }

	 








	inline static TBool CreatorHasCapability(TCapability  ,const char*  =0)
		{ return ETrue; }

	 









	inline static TBool CreatorHasCapability(TCapability  ,TCapability  ,const char*  =0)
		{ return ETrue; }
	};

class ExecHandler;
class TTrap
	{
public:
	inline TTrap();
	  TInt Trap(TInt& aResult);
	  static void UnTrap();
protected:
	enum {EMaxState=0x10};
protected:
	TInt iState[EMaxState];
	TTrap* iNext;
	TInt* iResult;
	TTrapHandler* iHandler;
	friend void User::Leave(TInt aNumber);
	friend class ExecHandler;
	};




class Dll
	{
public:
	static TInt GlobalAlloc(TInt aSize);
	static TBool GlobalAllocated();
	static TInt GlobalRead(TInt aPos, TInt aLength, TDes8& aDes);
	static TInt GlobalWrite(TInt aPos,const TDesC8& aDes);
	static TInt SetTls(TAny* aPtr);
	static TAny* Tls();
	static void FreeTls();
	static TInt InitialiseData();
	static void FreeData();
	static void FileName(TFileName &aFileName);
	};

class CBase;

template <class T>
class TArray
	{
public:
	inline TArray(TInt (*aCount)(const CBase* aPtr),const TAny*(*anAt)(const CBase* aPtr,TInt anIndex),const CBase* aPtr);
	inline TInt Count() const;
	inline const T& operator[](TInt anIndex) const;
private:
	const CBase* iPtr;
	TInt (*iCount)(const CBase* aPtr);
	const TAny*(*iAt)(const CBase* aPtr,TInt anIndex);
	};


template <class T,TInt S> 
class TFixedArray
 
 
	{
	typedef TFixedArray<T,S> ThisClass;
public:
	inline TFixedArray();
	inline TFixedArray(const T* aList, TInt aLength);
	 
	inline void Copy(const T* aList, TInt aLength);
	inline void Reset();		 
	inline void DeleteAll();
	 
	inline TInt Count() const;
	inline TInt Length() const;
	 
	inline T& operator[](TInt aIndex);
	inline const T& operator[] (TInt aIndex) const;
	 
	inline T& At(TInt aIndex);
	inline const T& At(TInt aIndex) const;
	 
	inline T* Begin();
	inline T* End();
	inline const T* Begin() const;
	inline const T* End() const;
	 
	inline TArray<T> Array() const;
protected:
	inline static TBool InRange(TInt aIndex);
	inline static TInt CountFunctionR(const CBase* aThis);
	inline static const TAny* AtFunctionR(const CBase* aThis,TInt aIndex);
protected:
	T iRep[S];
	};







typedef TBool (*TGeneralIdentityRelation)(const TAny*, const TAny*);
typedef TInt (*TGeneralLinearOrder)(const TAny*, const TAny*);

template <class T>
class TIdentityRelation
	{
public:
	inline TIdentityRelation( TBool(*anIdentity)(const T&, const T&) );
	inline operator TGeneralIdentityRelation() const;
private:
	TGeneralIdentityRelation iIdentity;
	};

template <class T>
class TLinearOrder
	{
public:
	inline TLinearOrder( TInt(*anOrder)(const T&, const T&) );
	inline operator TGeneralLinearOrder() const;
private:
	TGeneralLinearOrder iOrder;
	};

enum TArrayFindMode
 	{
 	EArrayFindMode_Any = 0,
 	EArrayFindMode_First = 1,
 	EArrayFindMode_Last = 2,
  
 	EArrayFindMode_Limit = 3
 	};

class RPointerArrayBase
	{
protected:
	  RPointerArrayBase();
	  RPointerArrayBase(TInt aGranularity);
	  RPointerArrayBase(TAny** aEntries, TInt aCount);
	  void Close();
	  TInt Count() const;
	inline void ZeroCount() {iCount=0;}
	inline TAny** Entries() {return iEntries;}
	  TAny*& At(TInt anIndex) const;
	  TInt Append(const TAny* anEntry);
	  TInt Insert(const TAny* anEntry, TInt aPos);
	  void Remove(TInt anIndex);
	  void Compress();
	  void GranularCompress();
	  void Reset();
	  TInt Find(const TAny* anEntry) const;
	  TInt Find(const TAny* anEntry, TGeneralIdentityRelation anIdentity) const;
	  TInt FindIsqSigned(TInt anEntry) const;
	  TInt FindIsqUnsigned(TUint anEntry) const;
	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder) const;
 	  TInt FindIsqSigned(TInt anEntry, TInt aMode) const;
 	  TInt FindIsqUnsigned(TUint anEntry, TInt aMode) const;
 	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TInt aMode) const;
	  TInt InsertIsqSigned(TInt anEntry, TBool aAllowRepeats);
	  TInt InsertIsqUnsigned(TUint anEntry, TBool aAllowRepeats);
	  TInt InsertIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TBool aAllowRepeats);
	  void HeapSortSigned();
	  void HeapSortUnsigned();
	  void HeapSort(TGeneralLinearOrder anOrder);
	  TInt BinarySearchSigned(TInt anEntry, TInt& anIndex) const;
	  TInt BinarySearchUnsigned(TUint anEntry, TInt& anIndex) const;
	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder) const;
 	  TInt BinarySearchSigned(TInt anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearchUnsigned(TUint anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder, TInt aMode) const;
	  static TInt GetCount(const CBase* aPtr);
	  static const TAny* GetElementPtr(const CBase* aPtr, TInt aIndex);
private:
	TInt Grow();
private:
	TInt iCount;
	TAny** iEntries;
	TInt iAllocated;
	TInt iGranularity;
	};

template <class T>
class RPointerArray : private RPointerArrayBase
	{
public:
	inline RPointerArray();
	inline RPointerArray(TInt aGranularity);
	inline RPointerArray(T** aEntries, TInt aCount);
	inline void Close();
	inline TInt Count() const;
	inline T* const& operator[](TInt anIndex) const;
	inline T*& operator[](TInt anIndex);
	inline TInt Append(const T* anEntry);
	inline TInt Insert(const T* anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void GranularCompress();
	inline void Reset();
	void ResetAndDestroy();
	inline TInt Find(const T* anEntry) const;
	inline TInt Find(const T* anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInAddressOrder(const T* anEntry) const;
	inline TInt FindInOrder(const T* anEntry, TLinearOrder<T> anOrder) const;
	inline TInt FindInAddressOrder(const T* anEntry, TInt& anIndex) const;
	inline TInt FindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
 	inline TInt SpecificFindInAddressOrder(const T* anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
 	inline TInt SpecificFindInAddressOrder(const T* anEntry, TInt& anIndex, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline TInt InsertInAddressOrder(const T* anEntry);
	inline TInt InsertInOrder(const T* anEntry, TLinearOrder<T> anOrder);
	inline TInt InsertInAddressOrderAllowRepeats(const T* anEntry);
	inline TInt InsertInOrderAllowRepeats(const T* anEntry, TLinearOrder<T> anOrder);

	 
	inline void AppendL(const T* anEntry);
	inline void InsertL(const T* anEntry, TInt aPos);
	inline TInt FindL(const T* anEntry) const;
	inline TInt FindL(const T* anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInAddressOrderL(const T* anEntry) const;
	inline TInt FindInOrderL(const T* anEntry, TLinearOrder<T> anOrder) const;
	inline void FindInAddressOrderL(const T* anEntry, TInt& anIndex) const;
	inline void FindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
	inline TInt SpecificFindInAddressOrderL(const T* anEntry, TInt aMode) const;
	inline TInt SpecificFindInOrderL(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void SpecificFindInAddressOrderL(const T* anEntry, TInt& anIndex, TInt aMode) const;
	inline void SpecificFindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void InsertInAddressOrderL(const T* anEntry);
	inline void InsertInOrderL(const T* anEntry, TLinearOrder<T> anOrder);
	inline void InsertInAddressOrderAllowRepeatsL(const T* anEntry);
	inline void InsertInOrderAllowRepeatsL(const T* anEntry, TLinearOrder<T> anOrder);

	inline void SortIntoAddressOrder();
	inline void Sort(TLinearOrder<T> anOrder);
	inline TArray<T*> Array() const;
	};

class RArrayBase
	{
protected:
	  RArrayBase(TInt anEntrySize);
	  RArrayBase(TInt aEntrySize,TAny* aEntries, TInt aCount);
	  RArrayBase(TInt anEntrySize, TInt aGranularity);
	  RArrayBase(TInt anEntrySize, TInt aGranularity, TInt aKeyOffset);
	  void Close();
	  TInt Count() const;
	  TAny* At(TInt anIndex) const;
	  TInt Append(const TAny* anEntry);
	  TInt Insert(const TAny* anEntry, TInt aPos);
	  void Remove(TInt anIndex);
	  void Compress();
	  void GranularCompress();
	  void Reset();
	  TInt Find(const TAny* anEntry) const;
	  TInt Find(const TAny* anEntry, TGeneralIdentityRelation anIdentity) const;
	  TInt FindIsqSigned(const TAny* anEntry) const;
	  TInt FindIsqUnsigned(const TAny* anEntry) const;
	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder) const;
 	  TInt FindIsqSigned(const TAny* anEntry, TInt aMode) const;
 	  TInt FindIsqUnsigned(const TAny* anEntry, TInt aMode) const;
 	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TInt aMode) const;
	  TInt InsertIsqSigned(const TAny* anEntry, TBool aAllowRepeats);
	  TInt InsertIsqUnsigned(const TAny* anEntry, TBool aAllowRepeats);
	  TInt InsertIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TBool aAllowRepeats);
	  void HeapSortSigned();
	  void HeapSortUnsigned();
	  void HeapSort(TGeneralLinearOrder anOrder);
	  TInt BinarySearchSigned(const TAny* anEntry, TInt& anIndex) const;
	  TInt BinarySearchUnsigned(const TAny* anEntry, TInt& anIndex) const;
	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder) const;
 	  TInt BinarySearchSigned(const TAny* anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearchUnsigned(const TAny* anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder, TInt aMode) const;
	  static TInt GetCount(const CBase* aPtr);
	  static const TAny* GetElementPtr(const CBase* aPtr, TInt aIndex);
private:
	TInt Grow();
private:
	TInt iCount;
	TAny* iEntries;
	TInt iEntrySize;
	TInt iKeyOffset;
	TInt iAllocated;
	TInt iGranularity;
	};

template <class T>
class RArray : private RArrayBase
	{
public:
	inline RArray();
	inline RArray(TInt aGranularity);
	inline RArray(TInt aGranularity, TInt aKeyOffset);
	inline RArray(TInt aEntrySize,T* aEntries, TInt aCount);
	inline void Close();
	inline TInt Count() const;
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline TInt Append(const T& anEntry);
	inline TInt Insert(const T& anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void GranularCompress();
	inline void Reset();
	inline TInt Find(const T& anEntry) const;
	inline TInt Find(const T& anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInSignedKeyOrder(const T& anEntry) const;
	inline TInt FindInUnsignedKeyOrder(const T& anEntry) const;
	inline TInt FindInOrder(const T& anEntry, TLinearOrder<T> anOrder) const;
	inline TInt FindInSignedKeyOrder(const T& anEntry, TInt& anIndex) const;
	inline TInt FindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex) const;
	inline TInt FindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
 	inline TInt SpecificFindInSignedKeyOrder(const T& anEntry, TInt aMode) const;
 	inline TInt SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
 	inline TInt SpecificFindInSignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const;
 	inline TInt SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline TInt InsertInSignedKeyOrder(const T& anEntry);
	inline TInt InsertInUnsignedKeyOrder(const T& anEntry);
	inline TInt InsertInOrder(const T& anEntry, TLinearOrder<T> anOrder);
	inline TInt InsertInSignedKeyOrderAllowRepeats(const T& anEntry);
	inline TInt InsertInUnsignedKeyOrderAllowRepeats(const T& anEntry);
	inline TInt InsertInOrderAllowRepeats(const T& anEntry, TLinearOrder<T> anOrder);

	 
	inline void AppendL(const T& anEntry);
	inline void InsertL(const T& anEntry, TInt aPos);
	inline TInt FindL(const T& anEntry) const;
	inline TInt FindL(const T& anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInSignedKeyOrderL(const T& anEntry) const;
	inline TInt FindInUnsignedKeyOrderL(const T& anEntry) const;
	inline TInt FindInOrderL(const T& anEntry, TLinearOrder<T> anOrder) const;
	inline void FindInSignedKeyOrderL(const T& anEntry, TInt& anIndex) const;
	inline void FindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex) const;
	inline void FindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
	inline TInt SpecificFindInSignedKeyOrderL(const T& anEntry, TInt aMode) const;
	inline TInt SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt aMode) const;
	inline TInt SpecificFindInOrderL(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void SpecificFindInSignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const;
	inline void SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const;
	inline void SpecificFindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void InsertInSignedKeyOrderL(const T& anEntry);
	inline void InsertInUnsignedKeyOrderL(const T& anEntry);
	inline void InsertInOrderL(const T& anEntry, TLinearOrder<T> anOrder);
	inline void InsertInSignedKeyOrderAllowRepeatsL(const T& anEntry);
	inline void InsertInUnsignedKeyOrderAllowRepeatsL(const T& anEntry);
	inline void InsertInOrderAllowRepeatsL(const T& anEntry, TLinearOrder<T> anOrder);
	
	inline void SortSigned();
	inline void SortUnsigned();
	inline void Sort(TLinearOrder<T> anOrder);
	inline TArray<T> Array() const;
	};

  class RArray<TInt> : private RPointerArrayBase
	{
public:
	inline RArray();
	inline RArray(TInt aGranularity);
	inline void Close();
	inline TInt Count() const;
	inline const TInt& operator[](TInt anIndex) const;
	inline TInt& operator[](TInt anIndex);
	inline TInt Append(TInt anEntry);
	inline TInt Insert(TInt anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void GranularCompress();
	inline void Reset();
	inline TInt Find(TInt anEntry) const;
	inline TInt FindInOrder(TInt anEntry) const;
	inline TInt FindInOrder(TInt anEntry, TInt& anIndex) const;
 	inline TInt SpecificFindInOrder(TInt anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(TInt anEntry, TInt& anIndex, TInt aMode) const;
	inline TInt InsertInOrder(TInt anEntry);
	inline TInt InsertInOrderAllowRepeats(TInt anEntry);

	 
	inline void AppendL(TInt anEntry);
	inline void InsertL(TInt anEntry, TInt aPos);
	inline TInt FindL(TInt anEntry) const;
	inline TInt FindInOrderL(TInt anEntry) const;
	inline void FindInOrderL(TInt anEntry, TInt& anIndex) const;
	inline TInt SpecificFindInOrderL(TInt anEntry, TInt aMode) const;
	inline void SpecificFindInOrderL(TInt anEntry, TInt& anIndex, TInt aMode) const;
	inline void InsertInOrderL(TInt anEntry);
	inline void InsertInOrderAllowRepeatsL(TInt anEntry);

	inline void Sort();
	inline TArray<TInt> Array() const;
	};

  class RArray<TUint> : private RPointerArrayBase
	{
public:
	inline RArray();
	inline RArray(TInt aGranularity);
	inline void Close();
	inline TInt Count() const;
	inline const TUint& operator[](TInt anIndex) const;
	inline TUint& operator[](TInt anIndex);
	inline TInt Append(TUint anEntry);
	inline TInt Insert(TUint anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void Reset();
	inline TInt Find(TUint anEntry) const;
	inline TInt FindInOrder(TUint anEntry) const;
	inline TInt FindInOrder(TUint anEntry, TInt& anIndex) const;
 	inline TInt SpecificFindInOrder(TUint anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(TUint anEntry, TInt& anIndex, TInt aMode) const;
	inline TInt InsertInOrder(TUint anEntry);
	inline TInt InsertInOrderAllowRepeats(TUint anEntry);

	 
	inline void AppendL(TUint anEntry);
	inline void InsertL(TUint anEntry, TInt aPos);
	inline TInt FindL(TUint anEntry) const;
	inline TInt FindInOrderL(TUint anEntry) const;
	inline void FindInOrderL(TUint anEntry, TInt& anIndex) const;
	inline TInt SpecificFindInOrderL(TUint anEntry, TInt aMode) const;
	inline void SpecificFindInOrderL(TUint anEntry, TInt& anIndex, TInt aMode) const;
	inline void InsertInOrderL(TUint anEntry);
	inline void InsertInOrderAllowRepeatsL(TUint anEntry);

	inline void Sort();
	inline TArray<TUint> Array() const;
	};

inline TAny* operator new(TUint aSize, TAny* aBase);
inline TAny* operator new(TUint aSize, TLeave);

extern  TAny* operator new(TUint aSize);
extern  TAny* operator new(TUint aSize,TUint anExtraSize);
extern  void operator delete(TAny* aPtr);


inline TAny* operator new[](TUint aSize, TLeave);



TBool operator==(TTrue,volatile const TBool);
TBool operator==(volatile const TBool,TTrue);
TBool operator!=(TTrue,volatile const TBool);
TBool operator!=(volatile const TBool,TTrue);


 




const TInt KCapabilitySetMaxSize = (((TInt)ECapability_HardLimit + 7)>>3);

 




const TInt KMaxSecurityPolicySize = KCapabilitySetMaxSize + 3*sizeof(TUint32);


 
























































class TSecurityPolicy
	{
public:
	enum TSecPolicyType 
		{
		EAlwaysFail=0,
		EAlwaysPass=1,
		};
		
public:
	inline TSecurityPolicy();
	  TSecurityPolicy(TSecPolicyType aType);
	  TSecurityPolicy(TCapability aCap1, TCapability aCap2 = ECapability_None, TCapability aCap3 = ECapability_None);
	  TSecurityPolicy(TCapability aCap1, TCapability aCap2, TCapability aCap3, TCapability aCap4, TCapability aCap5 = ECapability_None, TCapability aCap6 = ECapability_None, TCapability aCap7 = ECapability_None);
	  TSecurityPolicy(TSecureId aSecureId, TCapability aCap1 = ECapability_None, TCapability aCap2 = ECapability_None, TCapability aCap3 = ECapability_None);
	  TSecurityPolicy(TVendorId aVendorId, TCapability aCap1 = ECapability_None, TCapability aCap2 = ECapability_None, TCapability aCap3 = ECapability_None);
	  TInt Set(const TDesC8& aDes);
	  TPtrC8 Package() const;
	inline TBool CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RThread aThread, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage=0) const;
	TBool Validate() const;
public:
	 



	enum TType
		{
		ETypeFail=0,	 
		ETypePass=1,	 
		ETypeC3=2,		 
		ETypeC7=3,		 
		ETypeS3=4,		 
		ETypeV3=5,		 

		ETypeLimit

		 
		};
private:
	void ConstructAndCheck3(TCapability aCap1, TCapability aCap2, TCapability aCap3);
private:
	TUint8 iType;
	TUint8 iCaps[3];				 
	union
		{
		TUint32 iSecureId;
		TUint32 iVendorId;
		TUint8 iExtraCaps[4];		 
		};
	friend class TCompiledSecurityPolicy;
	};

 




typedef TPckgBuf<TSecurityPolicy> TSecurityPolicyBuf;


 


struct SSecurityPolicyV1C7
	{
	inline const TSecurityPolicy* operator&() const;
	inline operator const TSecurityPolicy&() const;
	inline const TSecurityPolicy& operator()() const;
	inline TBool CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RThread aThread, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage=0) const;
	TUint8	iType;
	TUint8	iCaps[7];				 
	};



 


struct SSecurityPolicyV1SVC3
	{
	inline const TSecurityPolicy* operator&() const;
	inline operator const TSecurityPolicy&() const;
	inline const TSecurityPolicy& operator()() const;
	inline TBool CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RThread aThread, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage=0) const;
	TUint8	iType;
	TUint8	iCaps[3];				 
	TUint32	iId;
	};


	
 



enum __invalid_capability_value {};

 
















 









# 5028 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

 









# 5051 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

 
























# 5089 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 



























 


























 

























 




















# 5206 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 























 





















 





















# 5286 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 
























 























 

















 





















# 5387 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 
























 























 


















 



class PlatSec
	{
public:
	 









	inline static TBool IsCapabilityEnforced(TCapability aCapability);

	 





	enum TConfigSetting
		{
		EPlatSecEnforcement,  
		EPlatSecDiagnotics,   
		};

	 









	inline static TInt ConfigSetting(TConfigSetting aSetting);
	};

 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.inl" 1
 
 
 
 
 





 
inline TAny* operator new(TUint  , TAny* aBase)
	{return(aBase);}
inline TAny* operator new(TUint aSize, TLeave)
	{return User::AllocL(aSize);}


inline TAny* operator new[](TUint aSize, TLeave)
	{return User::AllocL(aSize);}


 
inline TInt64::TInt64()
	{}
inline TInt64::TInt64(TUint aVal)
	: iLow(aVal),iHigh(0)
	{}
inline TInt64::TInt64(TUint aHigh,TUint aLow)
	: iLow(aLow),iHigh(aHigh)
	{}
inline void TInt64::Set(TUint aHigh,TUint aLow)
	{iLow=aLow;iHigh=aHigh;}
inline TUint TInt64::Low() const
	{return(iLow);}
inline TUint TInt64::High() const
	{return(iHigh);}
inline TInt64 &TInt64::operator=(TUint aVal)
	{iLow=aVal;iHigh=0;return(*this);}

 
template <class T>
inline TRefByValue<T>::TRefByValue(T &aRef)
	: iRef(aRef)
	{}
template <class T>
inline TRefByValue<T>::operator T &()
	{return(iRef);}

 
inline TCallBack::TCallBack()
	{iFunction= 0L ;}
inline TCallBack::TCallBack(TInt (*aFunction)(TAny *aPtr))
	: iFunction(aFunction),iPtr(0L )
	{}
inline TCallBack::TCallBack(TInt (*aFunction)(TAny *aPtr),TAny *aPtr)
	: iFunction(aFunction),iPtr(aPtr)
	{}
inline TInt TCallBack::CallBack() const
	{ return (iFunction ? (*iFunction)(iPtr) : 0); }

 
template <class T>
inline TSglQue<T>::TSglQue()
	{}
template <class T>
inline TSglQue<T>::TSglQue(TInt anOffset)
	: TSglQueBase(anOffset)
	{}
template <class T>
inline void TSglQue<T>::AddFirst(T &aRef)
	{DoAddFirst(&aRef);}
template <class T>
inline void TSglQue<T>::AddLast(T &aRef)
	{DoAddLast(&aRef);}
template <class T>
inline TBool TSglQue<T>::IsFirst(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead);}
template <class T>
inline TBool TSglQue<T>::IsLast(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iLast);}
template <class T>
inline T *TSglQue<T>::First() const
	{return(PtrSub((T *)iHead,iOffset));}
template <class T>
inline T *TSglQue<T>::Last() const
	{return(PtrSub((T *)iLast,iOffset));}
template <class T>
inline void TSglQue<T>::Remove(T &aRef)
	{DoRemove(&aRef);}

 
template <class T>
inline TDblQue<T>::TDblQue()
	{}
template <class T>
inline TDblQue<T>::TDblQue(TInt anOffset)
	: TDblQueBase(anOffset)
	{}
template <class T>
inline void TDblQue<T>::AddFirst(T &aRef)
	{DoAddFirst(&aRef);}
template <class T>
inline void TDblQue<T>::AddLast(T &aRef)
	{DoAddLast(&aRef);}
template <class T>
inline TBool TDblQue<T>::IsHead(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)&iHead);}
template <class T>
inline TBool TDblQue<T>::IsFirst(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iNext);}
template <class T>
inline TBool TDblQue<T>::IsLast(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iPrev);}
template <class T>
inline T *TDblQue<T>::First() const
	{



    return(PtrSub((T *)iHead.iNext,iOffset));
    }
template <class T>
inline T *TDblQue<T>::Last() const
	{



	return(PtrSub((T *)iHead.iPrev,iOffset));
	}

 
template <class T>
inline TPriQue<T>::TPriQue()
	{}
template <class T>
inline TPriQue<T>::TPriQue(TInt anOffset)
	: TDblQueBase(anOffset)
	{}
template <class T>
inline void TPriQue<T>::Add(T &aRef)
	{DoAddPriority(&aRef);}
template <class T>
inline TBool TPriQue<T>::IsHead(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)&iHead);}
template <class T>
inline TBool TPriQue<T>::IsFirst(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iNext);}
template <class T>
inline TBool TPriQue<T>::IsLast(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iPrev);}
template <class T>
inline T *TPriQue<T>::First() const
	{return(PtrSub((T *)iHead.iNext,iOffset));}
template <class T>
inline T *TPriQue<T>::Last() const
	{return(PtrSub((T *)iHead.iPrev,iOffset));}

 
template <class T>
inline TDeltaQue<T>::TDeltaQue()
	{}
template <class T>
inline TDeltaQue<T>::TDeltaQue(TInt anOffset)
	: TDeltaQueBase(anOffset)
	{}
template <class T>
inline void TDeltaQue<T>::Add(T &aRef,TInt aDelta)
	{DoAddDelta(&aRef,aDelta);}
template <class T>
inline void TDeltaQue<T>::Remove(T &aRef)
	{DoRemove(&aRef);}
template <class T>
inline T *TDeltaQue<T>::RemoveFirst()
	{return((T *) DoRemoveFirst());}

 
template <class T>
inline TSglQueIter<T>::TSglQueIter(TSglQueBase &aQue)
	: TSglQueIterBase(aQue)
	{}
template <class T>
inline void TSglQueIter<T>::Set(T &aLink)
	{DoSet(&aLink);}
template <class T>
inline TSglQueIter<T>::operator T *()
	{return((T *)DoCurrent());}
template <class T>
inline T *TSglQueIter<T>::operator++(TInt)
	{return((T *)DoPostInc());}

 
template <class T>
inline TDblQueIter<T>::TDblQueIter(TDblQueBase &aQue)
	: TDblQueIterBase(aQue)
	{}
template <class T>
inline void TDblQueIter<T>::Set(T &aLink)
	{DoSet(&aLink);}
template <class T>
inline TDblQueIter<T>::operator T *()
	{return((T *) DoCurrent());}
template <class T>
inline T *TDblQueIter<T>::operator++(TInt)
	{return((T *) DoPostInc());}
template <class T>
inline T *TDblQueIter<T>::operator--(TInt)
	{return((T *) DoPostDec());}

 
inline void TKey::SetPtr(const TAny *aPtr)
	{iPtr=aPtr;}

 
inline TInt THeapWalk::Value() const
	{return(iValue);}
inline void THeapWalk::SetValue(TInt aValue)
	{iValue=aValue;}

 
inline TChar::TChar()
	{}
inline TChar::TChar(TUint aChar)
	: iChar(aChar)
	{}
inline void TChar::SetChar(TUint aChar)
	{iChar=aChar;}
inline TChar& TChar::operator-=(TUint aChar)
	{iChar-=aChar;return(*this);}
inline TChar& TChar::operator+=(TUint aChar)
	{iChar+=aChar;return(*this);}
inline TChar TChar::operator-(TUint aChar)
	{return(iChar-aChar);}
inline TChar TChar::operator+(TUint aChar)
	{return(iChar+aChar);}
inline TChar::operator TUint() const
	{return(iChar);}
inline void TChar::Fold()
	{iChar=User::Fold(iChar);}
inline void TChar::LowerCase()
	{iChar=User::LowerCase(iChar);}
inline void TChar::UpperCase()
	{iChar=User::UpperCase(iChar);}

inline void TChar::Fold(TInt aFlags)
	{iChar=User::Fold(iChar,aFlags);}
inline void TChar::TitleCase()
	{iChar=User::TitleCase(iChar);}

inline TBool TChar::Eos() const
	{return(iChar==0);}

 
inline TCharF::TCharF(TUint aChar)
	: TChar(User::Fold(aChar))
	{}
inline TCharF::TCharF(const TChar& aChar)
	: TChar(User::Fold(aChar))
	{}
inline TCharF& TCharF::operator=(TUint aChar)
	{SetChar(User::Fold(aChar));return(*this);}
inline TCharF& TCharF::operator=(const TChar& aChar)
	{SetChar(User::Fold(aChar));return(*this);}

 
inline TCharLC::TCharLC(TUint aChar)
	: TChar(User::LowerCase(aChar))
	{}
inline TCharLC::TCharLC(const TChar& aChar)
	: TChar(User::LowerCase(aChar))
	{}
inline TCharLC& TCharLC::operator=(TUint aChar)
	{SetChar(User::LowerCase(aChar));return(*this);}
inline TCharLC& TCharLC::operator=(const TChar& aChar)
	{SetChar(User::LowerCase(aChar));return(*this);}

 
inline TCharUC::TCharUC(TUint aChar)
	: TChar(User::UpperCase(aChar))
	{}
inline TCharUC::TCharUC(const TChar& aChar)
	: TChar(User::UpperCase(aChar))
	{}
inline TCharUC& TCharUC::operator=(TUint aChar)
	{SetChar(User::UpperCase(aChar));return(*this);}
inline TCharUC& TCharUC::operator=(const TChar& aChar)
	{SetChar(User::UpperCase(aChar));return(*this);}

 
inline TInt TDesC8::operator<(const TDesC8 &aDes) const
	{return(Compare(aDes)<0);}
inline TInt TDesC8::operator<=(const TDesC8 &aDes) const
	{return(Compare(aDes)<=0);}
inline TInt TDesC8::operator>(const TDesC8 &aDes) const
	{return(Compare(aDes)>0);}
inline TInt TDesC8::operator>=(const TDesC8 &aDes) const
	{return(Compare(aDes)>=0);}
inline TInt TDesC8::operator==(const TDesC8 &aDes) const
	{return(Compare(aDes)==0);}
inline TInt TDesC8::operator!=(const TDesC8 &aDes) const
	{return(Compare(aDes)!=0);}
inline const TUint8 &TDesC8::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TInt TDesC8::Length() const
	{

	return(iLength&KMaskDesLength8);



	}
inline TInt TDesC8::Size() const
	{return(Length());}
inline void TDesC8::DoSetLength(TInt aLength)
	{

	iLength=(iLength&(~KMaskDesLength8))|aLength;



	}

 
inline void TPtrC8::Set(const TUint8 *aBuf,TInt aLength)
	{new(this) TPtrC8(aBuf,aLength);}
inline void TPtrC8::Set(const TDesC8 &aDes)
	{new(this) TPtrC8(aDes);}
inline void TPtrC8::Set(const TPtrC8& aPtr)
	{new(this) TPtrC8(aPtr);}

 
inline TPtr8 TBufCBase8::DoDes(TInt aMaxLength)
	{return TPtr8(*this,aMaxLength);}

 
template <TInt S>
inline TBufC8<S>::TBufC8()
	: TBufCBase8()
	{}
template <TInt S>
inline TBufC8<S>::TBufC8(const TUint8 *aString)
	: TBufCBase8(aString,S)
	{}
template <TInt S>
inline TBufC8<S>::TBufC8(const TDesC8 &aDes)
	: TBufCBase8(aDes,S)
	{}
template <TInt S>
inline TBufC8<S> &TBufC8<S>::operator=(const TUint8 *aString)
	{Copy(aString,S);return(*this);}
template <TInt S>
inline TBufC8<S> &TBufC8<S>::operator=(const TDesC8 &aDes)
	{Copy(aDes,S);return(*this);}
template <TInt S>
inline TPtr8 TBufC8<S>::Des()
	{return DoDes(S);}

 
inline HBufC8 &HBufC8::operator=(const HBufC8 &aLcb)
	{return *this=static_cast<const TDesC8&>(aLcb);}

 
inline TDes8 &TDes8::operator=(const TUint8 *aString)
    {Copy(aString);return(*this);}
inline TDes8 &TDes8::operator=(const TDesC8 &aDes)
    {Copy(aDes);return(*this);}
inline TDes8 &TDes8::operator=(const TDes8 &aDes)
    {Copy(aDes);return(*this);}
inline TDes8 &TDes8::operator+=(const TDesC8 &aDes)
	{Append(aDes);return(*this);}
inline const TUint8 &TDes8::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TUint8 &TDes8::operator[](TInt anIndex)
	{return((TUint8 &)AtC(anIndex));}
inline TInt TDes8::MaxLength() const
	{return(iMaxLength);}
inline TInt TDes8::MaxSize() const
	{return(iMaxLength);}
inline TUint8 * TDes8::WPtr() const
	{return((TUint8 *)Ptr());}

 
inline TPtr8 &TPtr8::operator=(const TUint8 *aString)
	{Copy(aString);return(*this);}
inline TPtr8 &TPtr8::operator=(const TDesC8 &aDes)
	{Copy(aDes);return(*this);}
inline TPtr8 &TPtr8::operator=(const TPtr8 &aDes)
	{Copy(aDes);return(*this);}
inline void TPtr8::Set(TUint8 *aBuf,TInt aLength,TInt aMaxLength)
	{new(this) TPtr8(aBuf,aLength,aMaxLength);}
inline void TPtr8::Set(const TPtr8 &aPtr)
	{new(this) TPtr8(aPtr);}

 
template <TInt S>
inline TBuf8<S>::TBuf8()
	: TBufBase8(S)
	{}
template <TInt S>
inline TBuf8<S>::TBuf8(TInt aLength)
	: TBufBase8(aLength,S)
	{}
template <TInt S>
inline TBuf8<S>::TBuf8(const TUint8 *aString)
	: TBufBase8(aString,S)
	{}
template <TInt S>
inline TBuf8<S>::TBuf8(const TDesC8 &aDes)
	: TBufBase8(aDes,S)
	{}
template <TInt S>
inline TBuf8<S> &TBuf8<S>::operator=(const TUint8 *aString)
	{Copy(aString);return(*this);}
template <TInt S>
inline TBuf8<S> &TBuf8<S>::operator=(const TDesC8 &aDes)
	{Copy(aDes);return(*this);}
template <TInt S>
inline TBuf8<S>& TBuf8<S>::operator=(const TBuf8<S>& aBuf)
	{Copy(aBuf);return *this;}

 
template <TInt S>
inline const TDesC8* TLitC8<S>::operator&() const
	{return (reinterpret_cast< const TDesC8* >( this )) ;}
template <TInt S>
inline const TDesC8& TLitC8<S>::operator()() const
	{return *operator&();}
template <TInt S>
inline TLitC8<S>::operator const TDesC8&() const
	{return *operator&();}
template <TInt S>
inline TLitC8<S>::operator const __TRefDesC8() const
	{return *operator&();}

 
inline TInt TDesC16::operator<(const TDesC16 &aDes) const
	{return(Compare(aDes)<0);}
inline TInt TDesC16::operator<=(const TDesC16 &aDes) const
	{return(Compare(aDes)<=0);}
inline TInt TDesC16::operator>(const TDesC16 &aDes) const
	{return(Compare(aDes)>0);}
inline TInt TDesC16::operator>=(const TDesC16 &aDes) const
	{return(Compare(aDes)>=0);}
inline TInt TDesC16::operator==(const TDesC16 &aDes) const
	{return(Compare(aDes)==0);}
inline TInt TDesC16::operator!=(const TDesC16 &aDes) const
	{return(Compare(aDes)!=0);}
inline const TUint16 &TDesC16::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TInt TDesC16::Length() const
	{

	return(iLength&KMaskDesLength16);



	}
inline TInt TDesC16::Size() const
	{return(Length()<<1);}
inline void TDesC16::DoSetLength(TInt aLength)
	{

	iLength=(iLength&(~KMaskDesLength16))|aLength;



	}

 
inline void TPtrC16::Set(const TUint16 *aBuf,TInt aLength)
	{new(this) TPtrC16(aBuf,aLength);}
inline void TPtrC16::Set(const TDesC16 &aDes)
	{new(this) TPtrC16(aDes);}
inline void TPtrC16::Set(const TPtrC16& aPtr)
	{new(this) TPtrC16(aPtr);}

 
inline TPtr16 TBufCBase16::DoDes(TInt aMaxLength)
	{return TPtr16(*this,aMaxLength);}

 
template <TInt S>
inline TBufC16<S>::TBufC16()
	: TBufCBase16()
	{}
template <TInt S>
inline TBufC16<S>::TBufC16(const TUint16 *aString)
	: TBufCBase16(aString,S)
	{}
template <TInt S>
inline TBufC16<S>::TBufC16(const TDesC16 &aDes)
	: TBufCBase16(aDes,S)
	{}
template <TInt S>
inline TBufC16<S> &TBufC16<S>::operator=(const TUint16 *aString)
	{Copy(aString,S);return(*this);}
template <TInt S>
inline TBufC16<S> &TBufC16<S>::operator=(const TDesC16 &aDes)
	{Copy(aDes,S);return(*this);}
template <TInt S>
inline TPtr16 TBufC16<S>::Des()
	{return(DoDes(S));}

 
inline HBufC16 &HBufC16::operator=(const HBufC16 &aLcb)
	{return *this=static_cast<const TDesC16&>(aLcb);}

 
inline TDes16 &TDes16::operator=(const TUint16 *aString)
    {Copy(aString);return(*this);}
inline TDes16 &TDes16::operator=(const TDesC16 &aDes)
    {Copy(aDes);return(*this);}
inline TDes16 &TDes16::operator=(const TDes16 &aDes)
    {Copy(aDes);return(*this);}
inline TDes16 &TDes16::operator+=(const TDesC16 &aDes)
	{Append(aDes);return(*this);}
inline const TUint16 &TDes16::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TUint16 &TDes16::operator[](TInt anIndex)
	{return((TUint16 &)AtC(anIndex));}
inline TInt TDes16::MaxLength() const
	{return(iMaxLength);}
inline TInt TDes16::MaxSize() const
	{return(iMaxLength<<1);}
inline TUint16 * TDes16::WPtr() const
	{return((TUint16 *)Ptr());}

 
inline TPtr16 &TPtr16::operator=(const TUint16 *aString)
	{Copy(aString);return(*this);}
inline TPtr16 &TPtr16::operator=(const TDesC16 &aDes)
	{Copy(aDes);return(*this);}
inline TPtr16 &TPtr16::operator=(const TPtr16 &aDes)
	{Copy(aDes);return(*this);}
inline void TPtr16::Set(TUint16 *aBuf,TInt aLength,TInt aMaxLength)
	{new(this) TPtr16(aBuf,aLength,aMaxLength);}
inline void TPtr16::Set(const TPtr16 &aPtr)
	{new(this) TPtr16(aPtr);}

 
template <TInt S>
inline TBuf16<S>::TBuf16()
	: TBufBase16(S)
	{}
template <TInt S>
inline TBuf16<S>::TBuf16(TInt aLength)
	: TBufBase16(aLength,S)
	{}
template <TInt S>
inline TBuf16<S>::TBuf16(const TUint16 *aString)
	: TBufBase16(aString,S)
	{}
template <TInt S>
inline TBuf16<S>::TBuf16(const TDesC16 &aDes)
	: TBufBase16(aDes,S)
	{}
template <TInt S>
inline TBuf16<S> &TBuf16<S>::operator=(const TUint16 *aString)
	{Copy(aString);return(*this);}
template <TInt S>
inline TBuf16<S> &TBuf16<S>::operator=(const TDesC16 &aDes)
	{Copy(aDes);return(*this);}
template <TInt S>
inline TBuf16<S>& TBuf16<S>::operator=(const TBuf16<S>& aBuf)
	{Copy(aBuf);return *this;}


 
 






inline void RBuf8::CreateL(RReadStream &aStream,TInt aMaxLength)
	{
	Assign(HBufC8::NewL(aStream,aMaxLength));
	}

 
 






inline void RBuf16::CreateL(RReadStream &aStream,TInt aMaxLength)
	{
	Assign(HBufC16::NewL(aStream,aMaxLength));
	}


 
template <TInt S>
inline const TDesC16* TLitC16<S>::operator&() const
	{return (reinterpret_cast< const TDesC16* >( this )) ;}
template <TInt S>
inline const TDesC16& TLitC16<S>::operator()() const
	{return *operator&();}
template <TInt S>
inline TLitC16<S>::operator const TDesC16&() const
	{return *operator&();}
template <TInt S>
inline TLitC16<S>::operator const __TRefDesC16() const
	{return *operator&();}

 

template <TInt S>
inline TBufC<S>::TBufC()
	: TBufCBase16()
	{}
template <TInt S>
inline TBufC<S>::TBufC(const TText *aString)
	: TBufCBase16(aString,S)
	{}
template <TInt S>
inline TBufC<S>::TBufC(const TDesC &aDes)
	: TBufCBase16(aDes,S)
	{}

template <TInt S>
inline TBufC<S> &TBufC<S>::operator=(const TText *aString)
	{Copy(aString,S);return(*this);}
template <TInt S>
inline TBufC<S> &TBufC<S>::operator=(const TDesC &aDes)
	{Copy(aDes,S);return(*this);}
template <TInt S>
inline TPtr TBufC<S>::Des()
	{return(DoDes(S));}

 

template <TInt S>
inline TBuf<S>::TBuf()
	: TBufBase16(S)
	{}
template <TInt S>
inline TBuf<S>::TBuf(TInt aLength)
	: TBufBase16(aLength,S)
	{}
template <TInt S>
inline TBuf<S>::TBuf(const TText *aString)
	: TBufBase16(aString,S)
	{}
template <TInt S>
inline TBuf<S>::TBuf(const TDesC &aDes)
	: TBufBase16(aDes,S)
	{}

template <TInt S>
inline TBuf<S> &TBuf<S>::operator=(const TText *aString)
	{Copy(aString);return(*this);}
template <TInt S>
inline TBuf<S> &TBuf<S>::operator=(const TDesC &aDes)
	{Copy(aDes);return(*this);}
template <TInt S>
inline TBuf<S> &TBuf<S>::operator=(const TBuf<S> &aBuf)
	{Copy(aBuf);return(*this);}

 
template <TInt S>
inline const TDesC* TLitC<S>::operator&() const
	{return (reinterpret_cast< const TDesC* >( this )) ;}
template <TInt S>
inline const TDesC& TLitC<S>::operator()() const
	{return *operator&();}
template <TInt S>
inline TLitC<S>::operator const TDesC&() const
	{return *operator&();}
template <TInt S>
inline TLitC<S>::operator const __TRefDesC() const
	{return *operator&();}

 
template <class T>
inline TPckgC<T>::TPckgC(const T &aRef)
	: TPtrC8((const TUint8 *)&aRef,sizeof(T))
	{}
template <class T>
inline const T &TPckgC<T>::operator()() const
	{return(*((const T *)iPtr));}

 
template <class T>
inline TPckg<T>::TPckg(const T &aRef)
	: TPtr8((TUint8 *)&aRef,sizeof(T),sizeof(T))
	{}
template <class T>
inline T &TPckg<T>::operator()()
	{return(*((T *)iPtr));}

 
template <class T>
inline TPckgBuf<T>::TPckgBuf()
	: TBuf8<sizeof(T)>(sizeof(T))
	{new(&iBuf[0]) T;}
template <class T>
inline TPckgBuf<T>::TPckgBuf(const T &aRef)
	: TBuf8<sizeof(T)>(sizeof(T))
	{new(&iBuf[0]) T(aRef);}
template <class T>
inline TPckgBuf<T> &TPckgBuf<T>::operator=(const TPckgBuf<T> &aRef)
	{Copy(aRef);return(*this);}
template <class T>
inline T &TPckgBuf<T>::operator=(const T &aRef)
	{Copy((TUint8 *)&aRef,sizeof(T));return(*((T *)&iBuf[0]));}
template <class T>
inline T &TPckgBuf<T>::operator()()
	{return(*((T *)&iBuf[0]));}
template <class T>
inline const T &TPckgBuf<T>::operator()() const
	{return(*((T *)&iBuf[0]));}

 
inline TDateTime::TDateTime()
	: iYear(1980),
	  iMonth(EJanuary), 
	  iDay(1),
	  iHour(0),
	  iMinute(0),
	  iSecond(0),
	  iMicroSecond(0)
	{}    

 








       
inline TInt TDateTime::Year() const
	{return(iYear);}

 









inline TMonth TDateTime::Month() const
	{return(iMonth);}

 








inline TInt TDateTime::Day() const
	{return(iDay);}

 







inline TInt TDateTime::Hour() const
	{return(iHour);}

 







inline TInt TDateTime::Minute() const
	{return(iMinute);}

 







inline TInt TDateTime::Second() const
	{return(iSecond);}

 







inline TInt TDateTime::MicroSecond() const
	{return(iMicroSecond);}

 

 









inline TTimeIntervalMicroSeconds::TTimeIntervalMicroSeconds()
	{}
inline TTimeIntervalMicroSeconds::TTimeIntervalMicroSeconds(const TInt64& aInterval)
	: iInterval(aInterval)
	{}

 











inline TTimeIntervalMicroSeconds& TTimeIntervalMicroSeconds::operator=(const TInt64& aInterval)
	{iInterval=aInterval;return(*this);}

 











inline TBool TTimeIntervalMicroSeconds::operator==(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval==aInterval.iInterval);}

 










inline TBool TTimeIntervalMicroSeconds::operator!=(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval!=aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator>=(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval>=aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator<=(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval<=aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator>(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval>aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator<(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval<aInterval.iInterval);}

 







inline const TInt64& TTimeIntervalMicroSeconds::Int64() const
	{return(iInterval);}

 
inline TTimeIntervalBase::TTimeIntervalBase()
	{}
inline TTimeIntervalBase::TTimeIntervalBase(TInt aInterval)
	: iInterval(aInterval)
	{}

 










inline TInt TTimeIntervalBase::operator==(TTimeIntervalBase aInterval) const
	{return(iInterval==aInterval.iInterval);}

 









inline TInt TTimeIntervalBase::operator!=(TTimeIntervalBase aInterval) const
	{return(iInterval!=aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator>=(TTimeIntervalBase aInterval) const
	{return(iInterval>=aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator<=(TTimeIntervalBase aInterval) const
	{return(iInterval<=aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator>(TTimeIntervalBase aInterval) const
	{return(iInterval>aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator<(TTimeIntervalBase aInterval) const
	{return(iInterval<aInterval.iInterval);}

 







inline TInt TTimeIntervalBase::Int() const
	{return(iInterval);}

 

inline TTimeIntervalMicroSeconds32::TTimeIntervalMicroSeconds32()
	{}

 









inline TTimeIntervalMicroSeconds32::TTimeIntervalMicroSeconds32(TInt aInterval)
    : TTimeIntervalBase(aInterval)
	{}

 











inline TTimeIntervalMicroSeconds32& TTimeIntervalMicroSeconds32::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

 








inline TTimeIntervalSeconds::TTimeIntervalSeconds()
	{}
inline TTimeIntervalSeconds::TTimeIntervalSeconds(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalSeconds& TTimeIntervalSeconds::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

inline TTimeIntervalMinutes::TTimeIntervalMinutes()
	{}

 








inline TTimeIntervalMinutes::TTimeIntervalMinutes(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalMinutes& TTimeIntervalMinutes::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

 








inline TTimeIntervalHours::TTimeIntervalHours()
	{}
inline TTimeIntervalHours::TTimeIntervalHours(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalHours& TTimeIntervalHours::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

inline TTimeIntervalDays::TTimeIntervalDays()
	{}

 








inline TTimeIntervalDays::TTimeIntervalDays(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalDays& TTimeIntervalDays::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 
inline TTimeIntervalMonths::TTimeIntervalMonths()
	{}

 








inline TTimeIntervalMonths::TTimeIntervalMonths(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalMonths& TTimeIntervalMonths::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 
inline TTimeIntervalYears::TTimeIntervalYears()
	{}

 









inline TTimeIntervalYears::TTimeIntervalYears(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalYears& TTimeIntervalYears::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 
inline TTime::TTime()
	{}
inline TTime::TTime(const TInt64& aTime)
	: iTime(aTime)
	{}
inline TTime &TTime::operator=(const TInt64& aTime)
	{iTime=aTime;return(*this);}

 










inline TBool TTime::operator==(TTime aTime) const
	{return(iTime==aTime.iTime);}

 










inline TBool TTime::operator!=(TTime aTime) const
	{return(iTime!=aTime.iTime);}

 










inline TBool TTime::operator>=(TTime aTime) const
	{return(iTime>=aTime.iTime);}

 










inline TBool TTime::operator<=(TTime aTime) const
	{return(iTime<=aTime.iTime);}

 










inline TBool TTime::operator>(TTime aTime) const
	{return(iTime>aTime.iTime);}

 










inline TBool TTime::operator<(TTime aTime) const
	{return(iTime<aTime.iTime);}

 







inline const TInt64& TTime::Int64() const
	{return(iTime);}

 
inline TLexMark8::TLexMark8()
	: iPtr(0L )
	{}
inline TLexMark8::TLexMark8(const TUint8 *aString) 
	: iPtr(aString)
	{}

 
inline TLex8::TLex8(const TUint8 *aString)
	{Assign(TPtrC8(aString));}
inline TLex8::TLex8(const TDesC8 &aDes)
	{Assign(aDes);}
inline TLex8& TLex8::operator=(const TUint8* aString)
	{Assign(TPtrC8(aString));return(*this);}
inline TLex8& TLex8::operator=(const TDesC8& aBuf)
	{Assign(aBuf);return(*this);}
inline TBool TLex8::Eos() const
	{return(iNext==iEnd);}
inline void TLex8::Mark()
	{Mark(iMark);}
inline void TLex8::Mark(TLexMark8& aMark) const
	{aMark.iPtr=iNext;}
inline void TLex8::UnGetToMark()
    {UnGetToMark(iMark);}
inline void TLex8::SkipAndMark(TInt aNumber)
    {SkipAndMark(aNumber,iMark);}
inline void TLex8::SkipSpaceAndMark()
    {SkipSpaceAndMark(iMark);}
inline TInt TLex8::TokenLength() const
	{return(iNext-iMark.iPtr);}
inline TInt TLex8::MarkedOffset() const
    {return(iMark.iPtr-iBuf);}
inline TInt TLex8::Val(TInt &aVal)
	{return(Val((TInt32&)aVal));}
inline TInt TLex8::Val(TUint &aVal,TRadix aRadix)
	{return(Val((TUint32&)aVal,aRadix));}
inline void TLex8::Assign(const TLex8& aLex)
	{new(this) TLex8(aLex);}

 
inline TLexMark16::TLexMark16()
	: iPtr(0L )
	{}
inline TLexMark16::TLexMark16(const TUint16 *aString) 
	: iPtr(aString)
	{}

 
inline TLex16::TLex16(const TUint16 *aString)
	{Assign(TPtrC16(aString));}
inline TLex16::TLex16(const TDesC16 &aDes)
	{Assign(aDes);}
inline TLex16& TLex16::operator=(const TUint16* aString)
	{Assign(TPtrC16(aString));return(*this);}
inline TLex16& TLex16::operator=(const TDesC16& aBuf)
	{Assign(aBuf);return(*this);}
inline TBool TLex16::Eos() const
	{return(iNext==iEnd);}
inline void TLex16::Mark(TLexMark16& aMark) const
	{aMark.iPtr=iNext;}
inline void TLex16::Mark()
	{iMark.iPtr=iNext;}
inline void TLex16::UnGetToMark()
    {UnGetToMark(iMark);}
inline void TLex16::SkipAndMark(TInt aNumber)
    {SkipAndMark(aNumber,iMark);}
inline void TLex16::SkipSpaceAndMark()
    {SkipSpaceAndMark(iMark);}
inline TInt TLex16::TokenLength() const
	{return(iNext-iMark.iPtr);}
inline TInt TLex16::MarkedOffset() const
    {return(iMark.iPtr-iBuf);}
inline TInt TLex16::Val(TInt &aVal)
	{return(Val((TInt32&)aVal));}
inline TInt TLex16::Val(TUint &aVal,TRadix aRadix)
	{return(Val((TUint32&)aVal,aRadix));}
inline void TLex16::Assign(const TLex16& aLex)
	{new(this) TLex16(aLex);}

 

 











inline TInt TLocale::CountryCode() const
	{return(iCountryCode);}

 












inline void TLocale::SetCountryCode(TInt aCode)
	{iCountryCode=aCode;}

 









inline TTimeIntervalSeconds TLocale::UniversalTimeOffset() const
	{return(iUniversalTimeOffset);}

 









inline void TLocale::SetUniversalTimeOffset(const TTimeIntervalSeconds& anOffset)
	{iUniversalTimeOffset=anOffset;}

 







inline TDateFormat TLocale::DateFormat() const
	{return(iDateFormat);}

 







inline void TLocale::SetDateFormat(TDateFormat aFormat)
	{iDateFormat=aFormat;}

 









inline TTimeFormat TLocale::TimeFormat() const
	{return(iTimeFormat);}

 









inline void TLocale::SetTimeFormat(TTimeFormat aFormat)
	{iTimeFormat=aFormat;}

 











inline TLocalePos TLocale::CurrencySymbolPosition() const
	{return(iCurrencySymbolPosition);}

 










inline void TLocale::SetCurrencySymbolPosition(TLocalePos aPos)
	{iCurrencySymbolPosition=aPos;}

 











inline TBool TLocale::CurrencySpaceBetween() const
	{return(iCurrencySpaceBetween);}

 









inline void TLocale::SetCurrencySpaceBetween(TBool aSpace)
	{iCurrencySpaceBetween=aSpace;}

 







inline TInt TLocale::CurrencyDecimalPlaces() const
	{return(iCurrencyDecimalPlaces);}

 








inline void TLocale::SetCurrencyDecimalPlaces(TInt aPlaces)
	{iCurrencyDecimalPlaces=aPlaces;}

 















inline TBool TLocale::CurrencyNegativeInBrackets() const				             
	{return((TBool)iNegativeCurrencyFormat);}							

 

















inline void TLocale::SetCurrencyNegativeInBrackets(TBool aBool)			
	{iNegativeCurrencyFormat=(aBool)?EInBrackets:ELeadingMinusSign;}	

 










inline TBool TLocale::CurrencyTriadsAllowed() const
	{return(iCurrencyTriadsAllowed);}

 








inline void TLocale::SetCurrencyTriadsAllowed(TBool aBool)
	{iCurrencyTriadsAllowed=aBool;}

 











inline TChar TLocale::ThousandsSeparator() const
	{return(iThousandsSeparator);}

 











inline void TLocale::SetThousandsSeparator(const TChar& aChar)
	{iThousandsSeparator=aChar;}

 








inline TChar TLocale::DecimalSeparator() const
	{return(iDecimalSeparator);}

 








inline void TLocale::SetDecimalSeparator(const TChar& aChar)
	{iDecimalSeparator=aChar;}

 

















inline TChar TLocale::DateSeparator(TInt aIndex) const
	{return(iDateSeparator[aIndex]);}

 
















inline void TLocale::SetDateSeparator(const TChar& aChar,TInt aIndex)
	{ ;
	iDateSeparator[aIndex]=aChar;}

 

















inline TChar TLocale::TimeSeparator(TInt aIndex) const
	{return(iTimeSeparator[aIndex]);}

 
















inline void TLocale::SetTimeSeparator(const TChar& aChar,TInt aIndex)
	{ ;
	iTimeSeparator[aIndex]=aChar;}

 









inline TLocalePos TLocale::AmPmSymbolPosition() const
	{return(iAmPmSymbolPosition);}

 









inline void TLocale::SetAmPmSymbolPosition(TLocalePos aPos)
	{iAmPmSymbolPosition=aPos;}

 









inline TBool TLocale::AmPmSpaceBetween() const
	{return(iAmPmSpaceBetween);}

 









inline void TLocale::SetAmPmSpaceBetween(TBool aSpace)
	{iAmPmSpaceBetween=aSpace;}

 




















inline TUint TLocale::DaylightSaving() const
	{return(iDaylightSaving);} 

 



























inline void TLocale::SetDaylightSaving(TUint aDaylightSaving)
	{iDaylightSaving=aDaylightSaving;} 

 








inline TBool TLocale::QueryHomeHasDaylightSavingOn() const
	{return((iHomeDaylightSavingZone|EDstHome) & iDaylightSaving);}

 








inline TDaylightSavingZone TLocale::HomeDaylightSavingZone() const
	{return(iHomeDaylightSavingZone);}

 








inline void TLocale::SetHomeDaylightSavingZone(TDaylightSavingZone aZone)
	{iHomeDaylightSavingZone=aZone;}

 











inline TUint TLocale::WorkDays() const
	{return(iWorkDays);}

 










inline void TLocale::SetWorkDays(TUint aMask)
	{iWorkDays=aMask;}

 







inline TDay TLocale::StartOfWeek() const
	{return(iStartOfWeek);}

 







inline void TLocale::SetStartOfWeek(TDay aDay)
	{iStartOfWeek=aDay;}

 







inline TClockFormat TLocale::ClockFormat() const
	{return(iClockFormat);}

 







inline void TLocale::SetClockFormat(TClockFormat aFormat)
	{iClockFormat=aFormat;}

 










inline TUnitsFormat TLocale::UnitsGeneral() const
	{return(iUnitsGeneral);}

 










inline void TLocale::SetUnitsGeneral(TUnitsFormat aFormat)
	{iUnitsGeneral=aFormat;}

 










inline TUnitsFormat TLocale::UnitsDistanceShort() const
	{return(iUnitsDistanceShort);}

 










inline void TLocale::SetUnitsDistanceShort(TUnitsFormat aFormat)
	{iUnitsDistanceShort=aFormat;}

 










inline TUnitsFormat TLocale::UnitsDistanceLong() const
	{return(iUnitsDistanceLong);}

 










inline void TLocale::SetUnitsDistanceLong(TUnitsFormat aFormat)
	{iUnitsDistanceLong=aFormat;}

 








inline TLocale::TNegativeCurrencyFormat TLocale::NegativeCurrencyFormat() const
	{return(iNegativeCurrencyFormat);}

 








inline void TLocale::SetNegativeCurrencyFormat(TLocale::TNegativeCurrencyFormat aNegativeCurrencyFormat)
	{iNegativeCurrencyFormat = aNegativeCurrencyFormat;}

 











inline TBool TLocale::NegativeLoseSpace() const
	{ 
	if((iExtraNegativeCurrencyFormatFlags|EFlagNegativeLoseSpace)==iExtraNegativeCurrencyFormatFlags)
		return ETrue;
	else
		return EFalse;
	}

 












inline void TLocale::SetNegativeLoseSpace(TBool aBool)
	{
	if(aBool)
		iExtraNegativeCurrencyFormatFlags |= EFlagNegativeLoseSpace;
	else
		iExtraNegativeCurrencyFormatFlags &= ~EFlagNegativeLoseSpace;
	}

 















inline TBool TLocale::NegativeCurrencySymbolOpposite() const
	{
	if((iExtraNegativeCurrencyFormatFlags|EFlagNegativeCurrencySymbolOpposite)==iExtraNegativeCurrencyFormatFlags)
		return ETrue;
	else
		return EFalse;
	}

 















inline void TLocale::SetNegativeCurrencySymbolOpposite(TBool aBool)
	{
	if (aBool)
		iExtraNegativeCurrencyFormatFlags |= EFlagNegativeCurrencySymbolOpposite;
	else
		iExtraNegativeCurrencyFormatFlags &= ~EFlagNegativeCurrencySymbolOpposite;
	}

inline TLanguage TLocale::LanguageDowngrade(TInt aIndex) const
	{
	 ;
	return static_cast<TLanguage>(iLanguageDowngrade[aIndex]);
	}

inline void TLocale::SetLanguageDowngrade(TInt aIndex, TLanguage aLanguage)
	{
	 ;
	iLanguageDowngrade[aIndex] = static_cast<TUint16>(aLanguage);
	}
 







inline TDigitType TLocale::DigitType() const
	{ return iDigitType; }
 







inline void TLocale::SetDigitType(TDigitType aDigitType)
	{ iDigitType=aDigitType; }

 





inline void TLocale::SetDeviceTime(TDeviceTimeState aState)
	{
	iDeviceTimeState=aState;
	}

 





inline TLocale::TDeviceTimeState TLocale::DeviceTime() const
	{
	return iDeviceTimeState;
	}

 
inline TPoint::TPoint()
	: iX(0),iY(0)
	{}
inline TPoint::TPoint(TInt aX,TInt aY)
	: iX(aX),iY(aY)
	{}

 
inline TSize::TSize()
	: iWidth(0),iHeight(0)
	{}
inline TSize::TSize(TInt aWidth,TInt aHeight)
	: iWidth(aWidth),iHeight(aHeight)
	{}

 
inline TRequestStatus::TRequestStatus()
	{}
inline TRequestStatus::TRequestStatus(TInt aVal)
	: iStatus(aVal)
	{}
inline TInt TRequestStatus::operator=(TInt aVal)
	{return(iStatus=aVal);}
inline TInt TRequestStatus::operator==(TInt aVal) const
	{return(iStatus==aVal);}
inline TInt TRequestStatus::operator!=(TInt aVal) const
	{return(iStatus!=aVal);}
inline TInt TRequestStatus::operator>=(TInt aVal) const
	{return(iStatus>=aVal);}
inline TInt TRequestStatus::operator<=(TInt aVal) const
	{return(iStatus<=aVal);}
inline TInt TRequestStatus::operator>(TInt aVal) const
	{return(iStatus>aVal);}
inline TInt TRequestStatus::operator<(TInt aVal) const
	{return(iStatus<aVal);}
inline TInt TRequestStatus::Int() const
	{return(iStatus);}

 
inline TInt TFindHandleBase::Handle() const
	{return(iFindHandle);}

 
inline RHandleBase::RHandleBase()
	: iHandle(0)
	{}
inline RHandleBase::RHandleBase(TInt aHandle)
	: iHandle(aHandle)
	{}
inline void RHandleBase::SetHandle(TInt aHandle)
	{iHandle=aHandle;}
inline TInt RHandleBase::Handle() const
	{return(iHandle);}

 
inline TFindSemaphore::TFindSemaphore()
    : TFindHandleBase()
    {}
inline TFindSemaphore::TFindSemaphore(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindMutex::TFindMutex()
    : TFindHandleBase()
    {}
inline TFindMutex::TFindMutex(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindChunk::TFindChunk()
    : TFindHandleBase()
    {}
inline TFindChunk::TFindChunk(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindThread::TFindThread()
    : TFindHandleBase()
    {}
inline TFindThread::TFindThread(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindProcess::TFindProcess()
    : TFindHandleBase()
    {}
inline TFindProcess::TFindProcess(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindLogicalDevice::TFindLogicalDevice()
    : TFindHandleBase()
    {}
inline TFindLogicalDevice::TFindLogicalDevice(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindPhysicalDevice::TFindPhysicalDevice()
    : TFindHandleBase()
    {}
inline TFindPhysicalDevice::TFindPhysicalDevice(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindLogicalChannel::TFindLogicalChannel()
    : TFindHandleBase()
    {}
inline TFindLogicalChannel::TFindLogicalChannel(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindServer::TFindServer()
    : TFindHandleBase()
    {}
inline TFindServer::TFindServer(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindLibrary::TFindLibrary()
    : TFindHandleBase()
    {}
inline TFindLibrary::TFindLibrary(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TInt RDevice::Open(const TFindLogicalDevice& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TInt RSemaphore::Open(const TFindSemaphore& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TBool RCriticalSection::IsBlocked() const
	{return(iBlocked!=1);}

 
inline TInt RMutex::Open(const TFindMutex& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TInt RChunk::Open(const TFindChunk& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}
inline TBool RChunk::IsReadable() const
	{return (Attributes()&RHandleBase::EDirectReadAccess); }
inline TBool RChunk::IsWritable() const
	{return (Attributes()&RHandleBase::EDirectWriteAccess); }

 
inline TThreadId::TThreadId()
	{}
inline TThreadId::TThreadId(TUint aId)
	: iId(aId)
	{}
inline TThreadId::operator TUint() const
	{ return iId; }
inline TInt TThreadId::operator==(TThreadId aId) const
	{return iId==aId.iId;}
inline TInt TThreadId::operator!=(TThreadId aId) const
	{return iId!=aId.iId;}

 
inline RThread::RThread()
	: RHandleBase(KCurrentThreadHandle)
	{}
inline TInt RThread::Open(const TFindThread& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TProcessId::TProcessId()
	{}
inline TProcessId::TProcessId(TUint aId)
	: iId(aId)
	{}
inline TProcessId::operator TUint() const
	{ return iId; }
inline TInt TProcessId::operator==(TProcessId aId) const
	{return iId==aId.iId;}
inline TInt TProcessId::operator!=(TProcessId aId) const
	{return iId!=aId.iId;}

 
inline RProcess::RProcess()
	: RHandleBase(KCurrentProcessHandle)
	{}
inline RProcess::RProcess(TInt aHandle)
	: RHandleBase(aHandle)
	{}
inline TInt RProcess::Open(const TFindProcess& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}



 
inline RMessagePtr::RMessagePtr()
	: iHandle(0)
	{}
inline RMessagePtr::RMessagePtr(const RMessage& aMessage)
	: iHandle(aMessage.iHandle)
	{}
inline TBool RMessagePtr::IsNull() const
	{return iHandle==0;}
inline TBool operator==(RMessagePtr aLeft,RMessagePtr aRight)
	{return aLeft.iHandle==aRight.iHandle;}
inline TBool operator!=(RMessagePtr aLeft,RMessagePtr aRight)
	{return !(aLeft==aRight);}

 
inline TInt RMessage::Function() const
	{return(iFunction);}
inline const RThread &RMessage::Client() const
	{return(iClient);}
inline TInt RMessage::Int0() const
	{return(iArgs[0]);}
inline TInt RMessage::Int1() const
	{return(iArgs[1]);}
inline TInt RMessage::Int2() const
	{return(iArgs[2]);}
inline TInt RMessage::Int3() const
	{return(iArgs[3]);}
inline const TAny *RMessage::Ptr0() const
	{return((const TAny *)iArgs[0]);}
inline const TAny *RMessage::Ptr1() const
	{return((const TAny *)iArgs[1]);}
inline const TAny *RMessage::Ptr2() const
	{return((const TAny *)iArgs[2]);}
inline const TAny *RMessage::Ptr3() const
	{return((const TAny *)iArgs[3]);}
inline const RMessagePtr RMessage::MessagePtr() const
	{return(RMessagePtr(*this));}

 
inline const RMessage &RServer::Message() const
	{return iMessage;}



 

inline TInt RSessionBase::Share(TAttachMode aAttachMode)
 


	{return DoShare(aAttachMode);}
inline TInt RSessionBase::Send(TInt aFunction,TAny* aPtr) const
 


	{return DoSend(aFunction,aPtr);}
inline void RSessionBase::SendReceive(TInt aFunction,TAny* aPtr,TRequestStatus& aStatus) const
 


	{DoSendReceive(aFunction,aPtr,aStatus);}
inline TInt RSessionBase::SendReceive(TInt aFunction,TAny* aPtr) const
 


	{return DoSendReceive(aFunction,aPtr);}

inline TInt RSessionBase::ShareAuto()
 








	{return DoShare(EAutoAttach);}
inline TInt RSessionBase::CreateSession(const TDesC& aServer,const TVersion& aVersion)
 








	{return CreateSession(aServer,aVersion,-1);}
inline TInt RSessionBase::Send(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSend(aFunction,(TAny*)&aArgs);}
inline void RSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const
 










	{DoSendReceive(aFunction,(TAny*)&aArgs,aStatus);}
inline TInt RSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSendReceive(aFunction,(TAny*)&aArgs);}
inline TInt RSessionBase::Send(TInt aFunction) const
 













	{return DoSend(aFunction,0L );}
inline void RSessionBase::SendReceive(TInt aFunction,TRequestStatus& aStatus) const
 










	{DoSendReceive(aFunction,0L ,aStatus);}
inline TInt RSessionBase::SendReceive(TInt aFunction) const
 








	{return DoSendReceive(aFunction,0L );}

 
inline RSubSessionBase::RSubSessionBase()
	: iSubSessionHandle(0)
 


	{}
inline TInt RSubSessionBase::SubSessionHandle() const
 




	{return iSubSessionHandle;}
inline RSessionBase& RSubSessionBase::Session()
 




	{return iSession;}

inline TInt RSubSessionBase::CreateSubSession(RSessionBase& aSession,TInt aFunction,const TAny* aPtr)
 


	{ return DoCreateSubSession(aSession,aFunction,aPtr); }

inline TInt RSubSessionBase::CreateSubSession(RSessionBase& aSession,TInt aFunction,const TIpcArgs& aArgs)
 












	{ return DoCreateSubSession(aSession,aFunction,(TAny*)&aArgs); }
inline TInt RSubSessionBase::CreateSubSession(RSessionBase& aSession,TInt aFunction)
 











	{ return DoCreateSubSession(aSession,aFunction,0L ); }

inline TInt RSubSessionBase::Send(TInt aFunction,const TAny* aPtr) const
 


	{return DoSend(aFunction,aPtr);}
inline void RSubSessionBase::SendReceive(TInt aFunction,const TAny* aPtr,TRequestStatus& aStatus) const
 


	{DoSendReceive(aFunction,aPtr,aStatus);}
inline TInt RSubSessionBase::SendReceive(TInt aFunction,const TAny* aPtr) const
 


	{return DoSendReceive(aFunction,aPtr);}

inline TInt RSubSessionBase::Send(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSend(aFunction,(TAny*)&aArgs);}
inline void RSubSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const
 











	{DoSendReceive(aFunction,(TAny*)&aArgs,aStatus);}
inline TInt RSubSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSendReceive(aFunction,(TAny*)&aArgs);}
inline TInt RSubSessionBase::Send(TInt aFunction) const
 














	{return DoSend(aFunction,0L );}
inline void RSubSessionBase::SendReceive(TInt aFunction,TRequestStatus& aStatus) const
 











	{ DoSendReceive(aFunction,0L ,aStatus);}
inline TInt RSubSessionBase::SendReceive(TInt aFunction) const
 








	{return DoSendReceive(aFunction,0L );}

 
inline RMessagePtr2::RMessagePtr2()
	: iHandle(0)
 


	{}
inline TBool RMessagePtr2::IsNull() const
 





	{return iHandle==0;}
inline TInt RMessagePtr2::Handle() const
 




	{return iHandle;}
inline TBool RMessagePtr2::ClientDataCaging() const
 





 
	{return ClientProcessFlags();}
inline TBool operator==(RMessagePtr2 aLeft,RMessagePtr2 aRight)
 





	{return aLeft.Handle()==aRight.Handle();}
inline TBool operator!=(RMessagePtr2 aLeft,RMessagePtr2 aRight)
 





	{return aLeft.Handle()!=aRight.Handle();}

 
inline RMessage2::RMessage2()
 


	{}
inline TInt RMessage2::Function() const
 




	{return(iFunction);}
inline TInt RMessage2::Int0() const
 




	{return(iArgs[0]);}
inline TInt RMessage2::Int1() const
 




	{return(iArgs[1]);}
inline TInt RMessage2::Int2() const
 




	{return(iArgs[2]);}
inline TInt RMessage2::Int3() const
 




	{return(iArgs[3]);}
inline const TAny *RMessage2::Ptr0() const
 




	{return((const TAny *)iArgs[0]);}
inline const TAny *RMessage2::Ptr1() const
 




	{return((const TAny *)iArgs[1]);}
inline const TAny *RMessage2::Ptr2() const
 




	{return((const TAny *)iArgs[2]);}
inline const TAny *RMessage2::Ptr3() const
 




	{return((const TAny *)iArgs[3]);}
inline CSession2* RMessage2::Session() const
 




	{return (CSession2*)iSessionPtr; }

 
inline RRefBase::RRefBase()
	: iPtr(0L )
	{}
inline RRefBase::RRefBase(const RRefBase &aRef)
	{Copy(aRef);}

 
template <class T>
inline RRef<T>::RRef()
	{}
template <class T>
inline RRef<T>::RRef(const RRef<T> &anObject)
	{Copy(anObject);}
template <class T>
inline void RRef<T>::operator=(const RRef<T> &anObject)
	{Copy(anObject);}
template <class T>
inline T *RRef<T>::operator->()
	{return((T *)iPtr);}
template <class T>
inline RRef<T>::operator T*()
	{return((T *)iPtr);}
template <class T>
void RRef<T>::Alloc(const T &anObject)
	{DoAlloc(&anObject,sizeof(T));}
template <class T>
void RRef<T>::Alloc(const T &anObject,TInt aSize)
	{DoAlloc(&anObject,aSize);}
template <class T>
void RRef<T>::AllocL(const T &anObject)
	{DoAllocL(&anObject,sizeof(T));}
template <class T>
void RRef<T>::AllocL(const T &anObject,TInt aSize)
	{DoAllocL(&anObject,aSize);}

 
inline TBool TRegion::CheckError() const
	{return(iError);}
inline TInt TRegion::Count() const
	{return(iCount);}
inline const TRect *TRegion::RectangleList() const
	{return(((TRegion *)this)->RectangleListW());}
inline TRegion::TRegion()
	{}

 
inline TInt RRegion::CheckSpare() const
	{return(iAllocedRects-iCount);}

 
template <TInt S>
inline TRegionFix<S>::TRegionFix() : TRegion(-S)
	{}
template <TInt S>
inline TRegionFix<S>::TRegionFix(const TRect &aRect) : TRegion(-S)
	{AddRect(aRect);}
template <TInt S>
inline TRegionFix<S>::TRegionFix(const TRegionFix<S> &aRegion)
	{*this=aRegion;}

template <TInt S>
inline RRegionBuf<S>::RRegionBuf() : RRegion(-S&(~ERRegionBuf),S)
	{}
template <TInt S>
inline RRegionBuf<S>::RRegionBuf(const RRegion &aRegion) 
	{*this=aRegion;}
template <TInt S>
inline RRegionBuf<S>::RRegionBuf(const TRect &aRect) : RRegion(-S&(~ERRegionBuf),S)
	{AddRect(aRect);}
template <TInt S>
inline RRegionBuf<S>::RRegionBuf(const RRegionBuf<S> &aRegion)
    {*this=aRegion;}

 
inline TTrap::TTrap()
	{}

 
inline TTimerLockSpec &operator++(TTimerLockSpec &aLock)
	{
	return aLock=((aLock==ETwelveOClock) ? EOneOClock : (TTimerLockSpec)((TInt)aLock+1));
	}
inline TTimerLockSpec operator++(TTimerLockSpec &aLock, TInt)
	{
	TTimerLockSpec l=aLock;
	aLock=((aLock==ETwelveOClock) ? EOneOClock : (TTimerLockSpec)((TInt)aLock+1));
	return l;
	}

 
inline TUid TUid::Uid(TInt aUid)
	{TUid uid={aUid};return uid;}
inline TUid TUid::Null()
	{TUid uid={KNullUidValue};return uid;}

 
inline const TUidType& TCheckedUid::UidType() const
    {return(iType);}

 
template <class T>
inline TArray<T>::TArray(TInt (*aCount)(const CBase *aPtr),const TAny *(*anAt)(const CBase *aPtr,TInt anIndex),const CBase *aPtr)
	: iPtr(aPtr),iCount(aCount),iAt(anAt)
	{}
template <class T>
inline TInt TArray<T>::Count() const
	{return((*iCount)(iPtr));}
template <class T>
inline const T &TArray<T>::operator[](TInt anIndex) const
	{return(*((const T *)(*iAt)(iPtr,anIndex)));}

 
template <class T>
void _DeleteArray(T** aBegin,T** aEnd)
	{for (;;) if (aBegin<aEnd) delete *aBegin++; else return;}
template <class T>
struct _ArrayUtil
	{
	static inline void Delete(T* aBegin,T* aEnd,CBase*)
		{::_DeleteArray((CBase**)aBegin,(CBase**)aEnd);}
	static inline void Delete(T* aBegin,T* aEnd,TAny*)
		{::_DeleteArray(aBegin,aEnd);}
	static inline void Delete(T* aArray,TInt aCount)
		{Delete(aArray,aArray+aCount,*aArray);}
	};


 
  void PanicTFixedArray();

template <class T,TInt S>
inline TFixedArray<T,S>::TFixedArray()
	{}
template <class T,TInt S>
inline void TFixedArray<T,S>::Copy(const T* aList,TInt aLength)
	{ ;Mem::Copy(iRep,aList,aLength*sizeof(T));}
template <class T,TInt S>
inline TFixedArray<T,S>::TFixedArray(const T* aList,TInt aLength)
	{Copy(aList,aLength);}
template <class T,TInt S>
inline void TFixedArray<T,S>::Reset()
	{Mem::FillZ(iRep,sizeof(iRep));}
template <class T,TInt S>
inline TInt TFixedArray<T,S>::Count() const
	{return S;}
template <class T,TInt S>
inline TInt TFixedArray<T,S>::Length() const
	{return sizeof(T);}
template <class T,TInt S>
inline TBool TFixedArray<T,S>::InRange(TInt aIndex)
	{return TUint(aIndex)<S;}
template <class T,TInt S>
inline T& TFixedArray<T,S>::operator[](TInt aIndex)
	{ ;return iRep[aIndex];}
template <class T,TInt S>
inline const T& TFixedArray<T,S>::operator[](TInt aIndex) const
	{return (const_cast< ThisClass& >( *this )) [aIndex];}
template <class T,TInt S>
inline T& TFixedArray<T,S>::At(TInt aIndex)
	{(void)(( InRange(aIndex) )||( PanicTFixedArray() ,0)) ;return iRep[aIndex];}
template <class T,TInt S>
inline const T& TFixedArray<T,S>::At(TInt aIndex) const
	{return (const_cast< ThisClass& >( *this )) .At(aIndex);}
template <class T,TInt S>
inline T* TFixedArray<T,S>::Begin()
	{return &iRep[0];}
template <class T,TInt S>
inline T* TFixedArray<T,S>::End()
	{return &iRep[S];}
template <class T,TInt S>
inline const T* TFixedArray<T,S>::Begin() const
	{return &iRep[0];}
template <class T,TInt S>
inline const T* TFixedArray<T,S>::End() const
	{return &iRep[S];}
template <class T,TInt S>
inline TInt TFixedArray<T,S>::CountFunctionR(const CBase*)
	{return S;}
template <class T,TInt S>
inline const TAny* TFixedArray<T,S>::AtFunctionR(const CBase* aThis,TInt aIndex)
	{return & (reinterpret_cast< const ThisClass& >( *aThis )) [aIndex];}
template <class T,TInt S>
inline TArray<T> TFixedArray<T,S>::Array() const
	{return TArray<T>(CountFunctionR,AtFunctionR,(reinterpret_cast< const CBase* >( this )) );}
template <class T,TInt S>
inline void TFixedArray<T,S>::DeleteAll()
	{_ArrayUtil<T>::Delete(iRep,S);}

 
template <class T>
inline TIdentityRelation<T>::TIdentityRelation( TBool(*anIdentity)(const T&, const T&) )
	{ iIdentity=(TGeneralIdentityRelation)anIdentity; }
template <class T>
inline TIdentityRelation<T>::operator TGeneralIdentityRelation() const
	{ return iIdentity; }

 
template <class T>
inline TLinearOrder<T>::TLinearOrder( TInt(*anOrder)(const T&, const T&) )
	{ iOrder=(TGeneralLinearOrder)anOrder; }
template <class T>
inline TLinearOrder<T>::operator TGeneralLinearOrder() const
	{ return iOrder; }

 
template <class T>
inline RPointerArray<T>::RPointerArray()
	: RPointerArrayBase()
	{}
template <class T>
inline RPointerArray<T>::RPointerArray(TInt aGranularity)
	: RPointerArrayBase(aGranularity)
	{}
template <class T>
inline RPointerArray<T>::RPointerArray(T** aEntries, TInt aCount)
	: RPointerArrayBase((TAny **)aEntries, aCount)
	{}
template <class T>
inline void RPointerArray<T>::Close()
	{RPointerArrayBase::Close();}
template <class T>
inline TInt RPointerArray<T>::Count() const
	{ return RPointerArrayBase::Count(); }
template <class T>
inline T* const& RPointerArray<T>::operator[](TInt anIndex) const
	{return (T* const&)At(anIndex);}
template <class T>
inline T*& RPointerArray<T>::operator[](TInt anIndex)
	{return (T*&)At(anIndex);}
template <class T>
inline TInt RPointerArray<T>::Append(const T* anEntry)
	{ return RPointerArrayBase::Append(anEntry); }
template <class T>
inline TInt RPointerArray<T>::Insert(const T* anEntry, TInt aPos)
	{ return RPointerArrayBase::Insert(anEntry,aPos); }
template <class T>
inline void RPointerArray<T>::Remove(TInt anIndex)
	{RPointerArrayBase::Remove(anIndex);}
template <class T>
inline void RPointerArray<T>::Compress()
	{RPointerArrayBase::Compress();}
template <class T>
inline void RPointerArray<T>::GranularCompress()
	{RPointerArrayBase::GranularCompress();}
template <class T>
inline void RPointerArray<T>::Reset()
	{RPointerArrayBase::Reset();}
template <class T>
inline TInt RPointerArray<T>::Find(const T* anEntry) const
	{ return RPointerArrayBase::Find(anEntry); }
template <class T>
inline TInt RPointerArray<T>::Find(const T* anEntry, TIdentityRelation<T> anIdentity) const
	{ return RPointerArrayBase::Find(anEntry,anIdentity); }
template <class T>
inline TInt RPointerArray<T>::FindInAddressOrder(const T* anEntry) const
	{ return RPointerArrayBase::FindIsqUnsigned((TUint)anEntry); }
template <class T>
inline TInt RPointerArray<T>::FindInOrder(const T* anEntry, TLinearOrder<T> anOrder) const
	{ return RPointerArrayBase::FindIsq(anEntry,anOrder); }
template <class T>
inline TInt RPointerArray<T>::FindInAddressOrder(const T* anEntry, TInt& anIndex) const
	{ return RPointerArrayBase::BinarySearchUnsigned((TUint)anEntry,anIndex); }
template <class T>
inline TInt RPointerArray<T>::FindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{ return RPointerArrayBase::BinarySearch(anEntry,anIndex,anOrder); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInAddressOrder(const T* anEntry, TInt aMode) const
	{ return RPointerArrayBase::FindIsqUnsigned((TUint)anEntry, aMode); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInOrder(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const
	{ return RPointerArrayBase::FindIsq(anEntry,anOrder,aMode); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInAddressOrder(const T* anEntry, TInt& anIndex, TInt aMode) const
	{ return RPointerArrayBase::BinarySearchUnsigned((TUint)anEntry,anIndex,aMode); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
	{ return RPointerArrayBase::BinarySearch(anEntry,anIndex,anOrder,aMode); }
template <class T>
inline TInt RPointerArray<T>::InsertInAddressOrder(const T* anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned((TUint)anEntry,EFalse); }
template <class T>
inline TInt RPointerArray<T>::InsertInOrder(const T* anEntry, TLinearOrder<T> anOrder)
	{ return RPointerArrayBase::InsertIsq(anEntry,anOrder,EFalse); }
template <class T>
inline TInt RPointerArray<T>::InsertInAddressOrderAllowRepeats(const T* anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned((TUint)anEntry,ETrue); }
template <class T>
inline TInt RPointerArray<T>::InsertInOrderAllowRepeats(const T* anEntry, TLinearOrder<T> anOrder)
	{ return RPointerArrayBase::InsertIsq(anEntry,anOrder,ETrue); }
template <class T>
inline void RPointerArray<T>::SortIntoAddressOrder()
	{ HeapSortUnsigned(); }
template <class T>
inline void RPointerArray<T>::Sort(TLinearOrder<T> anOrder)
	{ HeapSort(anOrder); }
template <class T>
inline TArray<T*> RPointerArray<T>::Array() const
	{ return TArray<T*>(GetCount,GetElementPtr,(const CBase*)this); }

template <class T>
void RPointerArray<T>::ResetAndDestroy()
	{
	TInt c=Count();
	T** pE=(T**)Entries();
	ZeroCount();
	TInt i;
	for (i=0; i<c; i++)
		{
		delete *pE;
		pE++;
		}
	Reset();
	}

template <class T>
inline RArray<T>::RArray()
	: RArrayBase(sizeof(T))
	{}
template <class T>
inline RArray<T>::RArray(TInt aGranularity)
	: RArrayBase(sizeof(T),aGranularity)
	{}
template <class T>
inline RArray<T>::RArray(TInt aGranularity, TInt aKeyOffset)
	: RArrayBase(sizeof(T),aGranularity,aKeyOffset)
	{}
template <class T>
inline RArray<T>::RArray(TInt aEntrySize,T* aEntries, TInt aCount)
	: RArrayBase(aEntrySize,aEntries,aCount)
	{}
template <class T>
inline void RArray<T>::Close()
	{RArrayBase::Close();}
template <class T>
inline TInt RArray<T>::Count() const
	{return RArrayBase::Count();}
template <class T>
inline const T& RArray<T>::operator[](TInt anIndex) const
	{return *(const T*)At(anIndex); }
template <class T>
inline T& RArray<T>::operator[](TInt anIndex)
	{return *(T*)At(anIndex); }
template <class T>
inline TInt RArray<T>::Append(const T& anEntry)
	{return RArrayBase::Append(&anEntry);}
template <class T>
inline TInt RArray<T>::Insert(const T& anEntry, TInt aPos)
	{return RArrayBase::Insert(&anEntry,aPos);}
template <class T>
inline void RArray<T>::Remove(TInt anIndex)
	{RArrayBase::Remove(anIndex);}
template <class T>
inline void RArray<T>::Compress()
	{RArrayBase::Compress();}
template <class T>
inline void RArray<T>::GranularCompress()
	{RArrayBase::GranularCompress();}
template <class T>
inline void RArray<T>::Reset()
	{RArrayBase::Reset();}
template <class T>
inline TInt RArray<T>::Find(const T& anEntry) const
	{return RArrayBase::Find(&anEntry);}
template <class T>
inline TInt RArray<T>::Find(const T& anEntry, TIdentityRelation<T> anIdentity) const
	{return RArrayBase::Find(&anEntry,anIdentity);}
template <class T>
inline TInt RArray<T>::FindInSignedKeyOrder(const T& anEntry) const
	{return RArrayBase::FindIsqSigned(&anEntry);}
template <class T>
inline TInt RArray<T>::FindInUnsignedKeyOrder(const T& anEntry) const
	{return RArrayBase::FindIsqUnsigned(&anEntry);}
template <class T>
inline TInt RArray<T>::FindInOrder(const T& anEntry, TLinearOrder<T> anOrder) const
	{return RArrayBase::FindIsq(&anEntry,anOrder);}
template <class T>
inline TInt RArray<T>::FindInSignedKeyOrder(const T& anEntry, TInt& anIndex) const
	{return RArrayBase::BinarySearchSigned(&anEntry,anIndex);}
template <class T>
inline TInt RArray<T>::FindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex) const
	{return RArrayBase::BinarySearchUnsigned(&anEntry,anIndex);}
template <class T>
inline TInt RArray<T>::FindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{return RArrayBase::BinarySearch(&anEntry,anIndex,anOrder);}
template <class T>
inline TInt RArray<T>::SpecificFindInSignedKeyOrder(const T& anEntry, TInt aMode) const
 	{return RArrayBase::FindIsqSigned(&anEntry,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt aMode) const
 	{return RArrayBase::FindIsqUnsigned(&anEntry,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInOrder(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const
 	{return RArrayBase::FindIsq(&anEntry,anOrder,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInSignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const
 	{return RArrayBase::BinarySearchSigned(&anEntry,anIndex,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const
 	{return RArrayBase::BinarySearchUnsigned(&anEntry,anIndex,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
 	{return RArrayBase::BinarySearch(&anEntry,anIndex,anOrder,aMode);}
template <class T>
inline TInt RArray<T>::InsertInSignedKeyOrder(const T& anEntry)
	{return RArrayBase::InsertIsqSigned(&anEntry,EFalse);}
template <class T>
inline TInt RArray<T>::InsertInUnsignedKeyOrder(const T& anEntry)
	{return RArrayBase::InsertIsqUnsigned(&anEntry,EFalse);}
template <class T>
inline TInt RArray<T>::InsertInOrder(const T& anEntry, TLinearOrder<T> anOrder)
	{return RArrayBase::InsertIsq(&anEntry,anOrder,EFalse);}
template <class T>
inline TInt RArray<T>::InsertInSignedKeyOrderAllowRepeats(const T& anEntry)
	{return RArrayBase::InsertIsqSigned(&anEntry,ETrue);}
template <class T>
inline TInt RArray<T>::InsertInUnsignedKeyOrderAllowRepeats(const T& anEntry)
	{return RArrayBase::InsertIsqUnsigned(&anEntry,ETrue);}
template <class T>
inline TInt RArray<T>::InsertInOrderAllowRepeats(const T& anEntry, TLinearOrder<T> anOrder)
	{return RArrayBase::InsertIsq(&anEntry,anOrder,ETrue);}
template <class T>
inline void RArray<T>::SortSigned()
	{HeapSortSigned();}
template <class T>
inline void RArray<T>::SortUnsigned()
	{HeapSortUnsigned();}
template <class T>
inline void RArray<T>::Sort(TLinearOrder<T> anOrder)
	{HeapSort(anOrder);}
template <class T>
inline TArray<T> RArray<T>::Array() const
	{ return TArray<T>(GetCount,GetElementPtr,(const CBase*)this); }

inline RArray<TInt>::RArray()
	: RPointerArrayBase()
	{}
inline RArray<TInt>::RArray(TInt aGranularity)
	: RPointerArrayBase(aGranularity)
	{}
inline void RArray<TInt>::Close()
	{RPointerArrayBase::Close();}
inline TInt RArray<TInt>::Count() const
	{ return RPointerArrayBase::Count(); }
inline const TInt& RArray<TInt>::operator[](TInt anIndex) const
	{return (const TInt&)At(anIndex);}
inline TInt& RArray<TInt>::operator[](TInt anIndex)
	{return (TInt&)At(anIndex);}
inline TInt RArray<TInt>::Append(TInt anEntry)
	{ return RPointerArrayBase::Append((const TAny*)anEntry); }
inline TInt RArray<TInt>::Insert(TInt anEntry, TInt aPos)
	{ return RPointerArrayBase::Insert((const TAny*)anEntry,aPos); }
inline void RArray<TInt>::Remove(TInt anIndex)
	{RPointerArrayBase::Remove(anIndex);}
inline void RArray<TInt>::Compress()
	{RPointerArrayBase::Compress();}
inline void RArray<TInt>::GranularCompress()
	{RPointerArrayBase::GranularCompress();}
inline void RArray<TInt>::Reset()
	{RPointerArrayBase::Reset();}
inline TInt RArray<TInt>::Find(TInt anEntry) const
	{ return RPointerArrayBase::Find((const TAny*)anEntry); }
inline TInt RArray<TInt>::FindInOrder(TInt anEntry) const
	{ return RPointerArrayBase::FindIsqSigned(anEntry); }
inline TInt RArray<TInt>::FindInOrder(TInt anEntry, TInt& anIndex) const
	{ return RPointerArrayBase::BinarySearchSigned(anEntry,anIndex); }
inline TInt RArray<TInt>::SpecificFindInOrder(TInt anEntry, TInt aMode) const
 	{ return RPointerArrayBase::FindIsqSigned(anEntry,aMode); }
inline TInt RArray<TInt>::SpecificFindInOrder(TInt anEntry, TInt& anIndex, TInt aMode) const
 	{ return RPointerArrayBase::BinarySearchSigned(anEntry,anIndex,aMode); }
inline TInt RArray<TInt>::InsertInOrder(TInt anEntry)
	{ return RPointerArrayBase::InsertIsqSigned(anEntry,EFalse); }
inline TInt RArray<TInt>::InsertInOrderAllowRepeats(TInt anEntry)
	{ return RPointerArrayBase::InsertIsqSigned(anEntry,ETrue); }
inline void RArray<TInt>::Sort()
	{ HeapSortSigned(); }
inline TArray<TInt> RArray<TInt>::Array() const
	{ return TArray<TInt>(GetCount,GetElementPtr,(const CBase*)this); }

inline RArray<TUint>::RArray()
	: RPointerArrayBase()
	{}
inline RArray<TUint>::RArray(TInt aGranularity)
	: RPointerArrayBase(aGranularity)
	{}
inline void RArray<TUint>::Close()
	{RPointerArrayBase::Close();}
inline TInt RArray<TUint>::Count() const
	{return RPointerArrayBase::Count(); }
inline const TUint& RArray<TUint>::operator[](TInt anIndex) const
	{return (const TUint&)At(anIndex);}
inline TUint& RArray<TUint>::operator[](TInt anIndex)
	{return (TUint&)At(anIndex);}
inline TInt RArray<TUint>::Append(TUint anEntry)
	{ return RPointerArrayBase::Append((const TAny*)anEntry); }
inline TInt RArray<TUint>::Insert(TUint anEntry, TInt aPos)
	{ return RPointerArrayBase::Insert((const TAny*)anEntry,aPos); }
inline void RArray<TUint>::Remove(TInt anIndex)
	{RPointerArrayBase::Remove(anIndex);}
inline void RArray<TUint>::Compress()
	{RPointerArrayBase::Compress();}
inline void RArray<TUint>::Reset()
	{RPointerArrayBase::Reset();}
inline TInt RArray<TUint>::Find(TUint anEntry) const
	{ return RPointerArrayBase::Find((const TAny*)anEntry); }
inline TInt RArray<TUint>::FindInOrder(TUint anEntry) const
	{ return RPointerArrayBase::FindIsqUnsigned(anEntry); }
inline TInt RArray<TUint>::FindInOrder(TUint anEntry, TInt& anIndex) const
	{ return RPointerArrayBase::BinarySearchUnsigned(anEntry,anIndex); }
inline TInt RArray<TUint>::SpecificFindInOrder(TUint anEntry, TInt aMode) const
 	{ return RPointerArrayBase::FindIsqUnsigned(anEntry,aMode); }
inline TInt RArray<TUint>::SpecificFindInOrder(TUint anEntry, TInt& anIndex, TInt aMode) const
 	{ return RPointerArrayBase::BinarySearchUnsigned(anEntry,anIndex,aMode); }
inline TInt RArray<TUint>::InsertInOrder(TUint anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned(anEntry,EFalse); }
inline TInt RArray<TUint>::InsertInOrderAllowRepeats(TUint anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned(anEntry,ETrue); }
inline void RArray<TUint>::Sort()
	{ HeapSortUnsigned(); }
inline TArray<TUint> RArray<TUint>::Array() const
	{ return TArray<TUint>(GetCount,GetElementPtr,(const CBase*)this); }



inline void TIpcArgs::Set(TInt,TNothing)
 








	{}
inline void TIpcArgs::Set(TInt aIndex,TInt aValue)
 








	{
	iArgs[aIndex] = aValue;
	iFlags |= EUnspecified<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,const TAny* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EUnspecified<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,const TDesC8* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDesC8<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,const TDesC16* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDesC16<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,TDes8* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDes8<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,TDes16* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDes16<<(aIndex*KBitsPerType);
	}
inline TIpcArgs::TArgType TIpcArgs::Type(TNothing)
	{ return EUnspecified; }
inline TIpcArgs::TArgType TIpcArgs::Type(TInt)
	{ return EUnspecified; }
inline TIpcArgs::TArgType TIpcArgs::Type(const TAny*)
	{ return EUnspecified; }
inline TIpcArgs::TArgType TIpcArgs::Type(const TDesC8*)
	{ return EDesC8; }
inline TIpcArgs::TArgType TIpcArgs::Type(const TDesC16*)
	{ return EDesC16; }
inline TIpcArgs::TArgType TIpcArgs::Type(TDes8*)
	{ return EDes8; }
inline TIpcArgs::TArgType TIpcArgs::Type(TDes16*)
	{ return EDes16; }
inline void TIpcArgs::Assign(TInt&,TIpcArgs::TNothing)
	{}
inline void TIpcArgs::Assign(TInt& aArg,TInt aValue)
	{ aArg = aValue; }
inline void TIpcArgs::Assign(TInt& aArg,const TAny* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,const TDesC8* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,const TDesC16* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,TDes8* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,TDes16* aValue)
	{ aArg = (TInt)aValue; }

 
 
 
inline TSecureId::TSecureId()
	{}
inline TSecureId::TSecureId(TUint32 aId)
	: iId(aId) {}
inline TSecureId::operator TUint32() const
	{ return iId; }
inline TSecureId::TSecureId(TUid aId)
	: iId(aId.iUid) {}
inline TSecureId::operator TUid() const
	{ return (TUid&)iId; }

 
 
 
inline const TSecureId* SSecureId::operator&() const
	{ return (const TSecureId*)this; }
inline SSecureId::operator const TSecureId&() const
	{ return (const TSecureId&)iId; }
inline SSecureId::operator TUint32() const
	{ return iId; }
inline SSecureId::operator TUid() const
	{ return (TUid&)iId; }

 
 
 
inline TVendorId::TVendorId()
	{}
inline TVendorId::TVendorId(TUint32 aId)
	: iId(aId) {}
inline TVendorId::operator TUint32() const
	{ return iId; }
inline TVendorId::TVendorId(TUid aId)
	: iId(aId.iUid) {}
inline TVendorId::operator TUid() const
	{ return (TUid&)iId; }

 
 
 
inline const TVendorId* SVendorId::operator&() const
	{ return (const TVendorId*)this; }
inline SVendorId::operator const TVendorId&() const
	{ return (const TVendorId&)iId; }
inline SVendorId::operator TUint32() const
	{ return iId; }
inline SVendorId::operator TUid() const
	{ return (TUid&)iId; }

 


inline TSecurityPolicy::TSecurityPolicy()
	{ new (this) TSecurityPolicy(EAlwaysFail); }

 
 
 
inline const TSecurityPolicy* SSecurityPolicyV1C7::operator&() const
	{ return (const TSecurityPolicy*)this; }
inline SSecurityPolicyV1C7::operator const TSecurityPolicy&() const
	{ return *(const TSecurityPolicy*)this; }
inline const TSecurityPolicy& SSecurityPolicyV1C7::operator()() const
	{ return *(const TSecurityPolicy*)this; }
inline const TSecurityPolicy* SSecurityPolicyV1SVC3::operator&() const
	{ return (const TSecurityPolicy*)this; }
inline SSecurityPolicyV1SVC3::operator const TSecurityPolicy&() const
	{ return *(const TSecurityPolicy*)this; }
inline const TSecurityPolicy& SSecurityPolicyV1SVC3::operator()() const
	{ return *(const TSecurityPolicy*)this; }


inline TBool SSecurityPolicyV1C7::CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aProcess, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1C7::CheckPolicy(RThread aThread, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aThread, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1C7::CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aMsgPtr, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1SVC3::CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aProcess, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1SVC3::CheckPolicy(RThread aThread, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aThread, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1SVC3::CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aMsgPtr, aDiagnosticMessage); }

 







inline TBool TSecurityPolicy::CheckPolicy(RProcess  , const char*  ) const
	{ return ETrue; }

 









inline TBool TSecurityPolicy::CheckPolicy(RThread  , const char*  ) const
	{ return ETrue; }

 








inline TBool TSecurityPolicy::CheckPolicy(RMessagePtr2  , const char*  ) const
	{ return ETrue; }

 
 
 

inline TBool PlatSec::IsCapabilityEnforced(TCapability  )
	{ return 0; }
inline TInt PlatSec::ConfigSetting(TConfigSetting  )
	{ return 0; }



 





template <class T>
inline void RPointerArray<T>::AppendL(const T* anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 











template <class T>
inline void RPointerArray<T>::InsertL(const T* anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry,aPos)); }


 












template <class T>
inline TInt RPointerArray<T>::FindL(const T* anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 
















template <class T>
inline TInt RPointerArray<T>::FindL(const T* anEntry, TIdentityRelation<T> anIdentity) const
	{ return User::LeaveIfError(Find(anEntry, anIdentity));}


 










template <class T>
inline TInt RPointerArray<T>::FindInAddressOrderL(const T* anEntry) const
	{ return User::LeaveIfError(FindInAddressOrder(anEntry));}


 














template <class T>
inline TInt RPointerArray<T>::FindInOrderL(const T* anEntry, TLinearOrder<T> anOrder) const
	{ return User::LeaveIfError(FindInOrder(anEntry, anOrder));}


 
















template <class T>
inline void RPointerArray<T>::FindInAddressOrderL(const T* anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInAddressOrder(anEntry, anIndex)); }


 




















template <class T>
inline void RPointerArray<T>::FindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex, anOrder)); }


 
















template <class T>
inline TInt RPointerArray<T>::SpecificFindInAddressOrderL(const T* anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInAddressOrder(anEntry, aMode));}


 





















template <class T>
inline TInt RPointerArray<T>::SpecificFindInOrderL(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInOrder(anEntry, anOrder, aMode));}


 



















template <class T>
inline void RPointerArray<T>::SpecificFindInAddressOrderL(const T* anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInAddressOrder(anEntry, anIndex, aMode)); }


 
























template <class T>
inline void RPointerArray<T>::SpecificFindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, anOrder, aMode)); }


 








template <class T>
inline void RPointerArray<T>::InsertInAddressOrderL(const T* anEntry)
	{ User::LeaveIfError(InsertInAddressOrder(anEntry)); }


 
















template <class T>
inline void RPointerArray<T>::InsertInOrderL(const T* anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrder(anEntry, anOrder)); }


 













template <class T>
inline void RPointerArray<T>::InsertInAddressOrderAllowRepeatsL(const T* anEntry)
	{ User::LeaveIfError(InsertInAddressOrderAllowRepeats(anEntry)); }


 
















template <class T>
inline void RPointerArray<T>::InsertInOrderAllowRepeatsL(const T* anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry, anOrder)); }


 





template <class T>
inline void RArray<T>::AppendL(const T& anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 












template <class T>
inline void RArray<T>::InsertL(const T& anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry, aPos));}


 














template <class T>
inline TInt RArray<T>::FindL(const T& anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 

















template <class T>
inline TInt RArray<T>::FindL(const T& anEntry, TIdentityRelation<T> anIdentity) const
	{ return User::LeaveIfError(Find(anEntry, anIdentity));}


 











template <class T>
inline TInt RArray<T>::FindInSignedKeyOrderL(const T& anEntry) const
	{ return User::LeaveIfError(FindInSignedKeyOrder(anEntry));}


 











template <class T>
inline TInt RArray<T>::FindInUnsignedKeyOrderL(const T& anEntry) const
	{ return User::LeaveIfError(FindInUnsignedKeyOrder(anEntry));}


 














template <class T>
inline TInt RArray<T>::FindInOrderL(const T& anEntry, TLinearOrder<T> anOrder) const
{ return User::LeaveIfError(FindInOrder(anEntry, anOrder));}


 













template <class T>
inline void RArray<T>::FindInSignedKeyOrderL(const T& anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInSignedKeyOrder(anEntry, anIndex));}


 













template <class T>
inline void RArray<T>::FindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInUnsignedKeyOrder(anEntry, anIndex));}


 
















template <class T>
inline void RArray<T>::FindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex, anOrder));}


 


















template <class T>
inline TInt RArray<T>::SpecificFindInSignedKeyOrderL(const T& anEntry, TInt aMode) const
{ return User::LeaveIfError(SpecificFindInSignedKeyOrder(anEntry, aMode));}


 


















template <class T>
inline TInt RArray<T>::SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInUnsignedKeyOrder(anEntry, aMode));}


 



















template <class T>
inline TInt RArray<T>::SpecificFindInOrderL(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const
{ return User::LeaveIfError(SpecificFindInOrder(anEntry, anOrder, aMode));}


 




















template <class T>
inline void RArray<T>::SpecificFindInSignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInSignedKeyOrder(anEntry, anIndex, aMode));}


 




















template <class T>
inline void RArray<T>::SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInUnsignedKeyOrder(anEntry, anIndex, aMode));}


 






















template <class T>
inline void RArray<T>::SpecificFindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, anOrder, aMode));}


 










template <class T>
inline void RArray<T>::InsertInSignedKeyOrderL(const T& anEntry)
	{ User::LeaveIfError(InsertInSignedKeyOrder(anEntry));}


 









template <class T>
inline void RArray<T>::InsertInUnsignedKeyOrderL(const T& anEntry)
	{ User::LeaveIfError(InsertInUnsignedKeyOrder(anEntry));}


 















template <class T>
inline void RArray<T>::InsertInOrderL(const T& anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrder(anEntry, anOrder));}


 














template <class T>
inline void RArray<T>::InsertInSignedKeyOrderAllowRepeatsL(const T& anEntry)
	{ User::LeaveIfError(InsertInSignedKeyOrderAllowRepeats(anEntry));}


 














template <class T>
inline void RArray<T>::InsertInUnsignedKeyOrderAllowRepeatsL(const T& anEntry)
	{ User::LeaveIfError(InsertInUnsignedKeyOrderAllowRepeats(anEntry));}


 

















template <class T>
inline void RArray<T>::InsertInOrderAllowRepeatsL(const T& anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry, anOrder));}


 





inline void RArray<TInt>::AppendL(TInt anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 











inline void RArray<TInt>::InsertL(TInt anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry, aPos));}


 










inline TInt RArray<TInt>::FindL(TInt anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 









inline TInt RArray<TInt>::FindInOrderL(TInt anEntry) const
	{ return User::LeaveIfError(FindInOrder(anEntry));}


 













inline void RArray<TInt>::FindInOrderL(TInt anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex));}


 
















inline TInt RArray<TInt>::SpecificFindInOrderL(TInt anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInOrder(anEntry, aMode));}


 


















inline void RArray<TInt>::SpecificFindInOrderL(TInt anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, aMode));}


 








inline void RArray<TInt>::InsertInOrderL(TInt anEntry)
	{ User::LeaveIfError(InsertInOrder(anEntry));}


 












inline void RArray<TInt>::InsertInOrderAllowRepeatsL(TInt anEntry)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry));}


 





inline void RArray<TUint>::AppendL(TUint anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 












inline void RArray<TUint>::InsertL(TUint anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry, aPos));}


 









inline TInt RArray<TUint>::FindL(TUint anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 











inline TInt RArray<TUint>::FindInOrderL(TUint anEntry) const
	{ return User::LeaveIfError(FindInOrder(anEntry));}


 
















inline void RArray<TUint>::FindInOrderL(TUint anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex));}


 
















inline TInt RArray<TUint>::SpecificFindInOrderL(TUint anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInOrder(anEntry, aMode));}


 


















inline void RArray<TUint>::SpecificFindInOrderL(TUint anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, aMode));}


 








inline void RArray<TUint>::InsertInOrderL(TUint anEntry)
	{ User::LeaveIfError(InsertInOrder(anEntry));}


 













inline void RArray<TUint>::InsertInOrderAllowRepeatsL(TUint anEntry)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry));}


 




inline void RMessagePtr2::SetProcessPriorityL(TProcessPriority aPriority) const
	{ User::LeaveIfError(SetProcessPriority(aPriority));}


 







inline void RMessagePtr2::ClientL(RThread& aClient, TOwnerType aOwnerType) const
	{ User::LeaveIfError(Client(aClient, aOwnerType));}


inline void RMessagePtr2::HasCapabilityL(TCapability  ,const char*  ) const
	{}

inline void RMessagePtr2::HasCapabilityL(TCapability  ,TCapability  ,const char*  ) const
	{}
# 5503 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.h" 2


 


class CBase
	{
public:
	  virtual ~CBase();
	inline TAny* operator new(TUint aSize,TAny *aBase);
	  TAny* operator new(TUint aSize);
	inline TAny* operator new(TUint aSize, TLeave);
	  TAny* operator new(TUint aSize,TUint anExtraSize);
	inline TAny* operator new(TUint aSize, TLeave, TUint aExtraSize);
protected:
	  CBase();
private:
	CBase(const CBase&);
	CBase& operator=(const CBase&);
	  static TAny* newL(TUint aSize);
	};
 
class CBufBase : public CBase
	{
public:
	  ~CBufBase();
	inline TInt Size() const;
	  void Reset();
	  void Read(TInt aPos,TDes8& aDes) const;
	  void Read(TInt aPos,TDes8& aDes,TInt aLength) const;
	  void Read(TInt aPos,TAny* aPtr,TInt aLength) const;
	  void Write(TInt aPos,const TDesC8& aDes);
	  void Write(TInt aPos,const TDesC8& aDes,TInt aLength);
	  void Write(TInt aPos,const TAny* aPtr,TInt aLength);
	  void InsertL(TInt aPos,const TDesC8& aDes);
	  void InsertL(TInt aPos,const TDesC8& aDes,TInt aLength);
	  void InsertL(TInt aPos,const TAny* aPtr,TInt aLength);
	  void ExpandL(TInt aPos,TInt aLength);
	  void ResizeL(TInt aSize);
 
    virtual void Compress()=0;
	virtual void Delete(TInt aPos,TInt aLength)=0;
	virtual TPtr8 Ptr(TInt aPos)=0;
	virtual TPtr8 BackPtr(TInt aPos)=0;
private:
	virtual void DoInsertL(TInt aPos,const TAny* aPtr,TInt aLength)=0;
protected:
	  CBufBase(TInt anExpandSize);
protected:
	TInt iSize;
	TInt iExpandSize;
	};
 
class CBufFlat : public CBufBase
	{
public:
	  ~CBufFlat();
	  static CBufFlat* NewL(TInt anExpandSize);
	inline TInt Capacity() const;
	  void SetReserveL(TInt aSize);
	  void Compress();
	  void Delete(TInt aPos,TInt aLength);
	  TPtr8 Ptr(TInt aPos);
	  TPtr8 BackPtr(TInt aPos);
protected:
	  CBufFlat(TInt anExpandSize);
private:
	  void DoInsertL(TInt aPos,const TAny* aPtr,TInt aLength);
private:
	TInt iMaxSize;
	TUint8* iPtr;
	};
 
class TBufSegLink;
class CBufSeg : public CBufBase
	{
public:
	  ~CBufSeg();
	  static CBufSeg* NewL(TInt anExpandSize);
      void Compress();
	  void Delete(TInt aPos,TInt aLength);
	  TPtr8 Ptr(TInt aPos);
	  TPtr8 BackPtr(TInt aPos);
protected:
	  CBufSeg(TInt anExpandSize);
	void InsertIntoSegment(TBufSegLink* aSeg,TInt anOffset,const TAny* aPtr,TInt aLength);
	void DeleteFromSegment(TBufSegLink* aSeg,TInt anOffset,TInt aLength);
	void FreeSegment(TBufSegLink* aSeg);
    void SetSBO(TInt aPos);
	void AllocSegL(TBufSegLink* aSeg,TInt aNumber);
private:
	  void DoInsertL(TInt aPos,const TAny* aPtr,TInt aLength);
private:
    TDblQue<TBufSegLink> iQue;
	TBufSegLink* iSeg;
	TInt iBase;
	TInt iOffset;
	};
 
class TKeyArrayFix : public TKey
	{
public:
	  TKeyArrayFix(TInt anOffset,TKeyCmpText aType);
	  TKeyArrayFix(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKeyArrayFix(TInt anOffset,TKeyCmpNumeric aType);
protected:
	  virtual void Set(CBufBase* aBase,TInt aRecordLength);
	  TAny* At(TInt anIndex) const;
protected:
	TInt iRecordLength;
	CBufBase* iBase;
	friend class CArrayFixBase;
	};
 
typedef CBufBase*(*TBufRep)(TInt anExpandSize);
class CArrayFixBase : public CBase
	{
public:
	  ~CArrayFixBase();
	inline TInt Count() const;
	inline TInt Length() const;
	  void Compress();
	  void Reset();
	  TInt Sort(TKeyArrayFix& aKey);
	  TAny* At(TInt anIndex) const;
	  TAny* End(TInt anIndex) const;
	  TAny* Back(TInt anIndex) const;
	  void Delete(TInt anIndex);
	  void Delete(TInt anIndex,TInt aCount);
	  TAny* ExpandL(TInt anIndex);
	  TInt Find(const TAny* aPtr,TKeyArrayFix& aKey,TInt& anIndex) const;
	  TInt FindIsq(const TAny* aPtr,TKeyArrayFix& aKey,TInt& anIndex) const;
	  void InsertL(TInt anIndex,const TAny* aPtr);
	  void InsertL(TInt anIndex,const TAny* aPtr,TInt aCount);
	  TInt InsertIsqL(const TAny* aPtr,TKeyArrayFix& aKey);
	  TInt InsertIsqAllowDuplicatesL(const TAny* aPtr,TKeyArrayFix& aKey);
	  void ResizeL(TInt aCount,const TAny* aPtr);
protected:
	  CArrayFixBase(TBufRep aRep,TInt aRecordLength,TInt aGranularity);
	  void InsertRepL(TInt anIndex,const TAny* aPtr,TInt aReplicas);
	  void SetKey(TKeyArrayFix& aKey) const;
	  void SetReserveFlatL(TInt aCount);
	  static TInt CountR(const CBase* aPtr);
	  static const TAny* AtR(const CBase* aPtr,TInt anIndex);
private:
	TInt iCount;
	TInt iGranularity;
	TInt iLength;
	TBufRep iCreateRep;
	CBufBase* iBase;
	};
 
template <class T>
class CArrayFix : public CArrayFixBase
	{
public:
	inline CArrayFix(TBufRep aRep,TInt aGranularity);
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline const T& At(TInt anIndex) const;
	inline const T* End(TInt anIndex) const;
	inline const T* Back(TInt anIndex) const;
	inline T& At(TInt anIndex);
	inline T* End(TInt anIndex);
	inline T* Back(TInt anIndex);
	inline void AppendL(const T& aRef);
	inline void AppendL(const T* aPtr,TInt aCount);
	inline void AppendL(const T& aRef,TInt aReplicas);
	inline T& ExpandL(TInt anIndex);
	inline T& ExtendL();
	inline TInt Find(const T& aRef,TKeyArrayFix& aKey,TInt& anIndex) const;
	inline TInt FindIsq(const T& aRef,TKeyArrayFix& aKey,TInt& anIndex) const;
	inline void InsertL(TInt anIndex,const T& aRef);
	inline void InsertL(TInt anIndex,const T* aPtr,TInt aCount);
	inline void InsertL(TInt anIndex,const T& aRef,TInt aReplicas);
	inline TInt InsertIsqL(const T& aRef,TKeyArrayFix& aKey);
	inline TInt InsertIsqAllowDuplicatesL(const T& aRef,TKeyArrayFix& aKey);
	inline void ResizeL(TInt aCount);
	inline void ResizeL(TInt aCount,const T& aRef);
	inline const TArray<T> Array() const;
	};
  class CArrayFix<TAny> : public CArrayFixBase
	{
public:
	inline CArrayFix(TBufRep aRep,TInt aRecordLength,TInt aGranularity);
	inline const TAny* At(TInt anIndex) const;
	inline const TAny* End(TInt anIndex) const;
	inline const TAny* Back(TInt anIndex) const;
	inline TAny* At(TInt anIndex);
	inline TAny* End(TInt anIndex);
	inline TAny* Back(TInt anIndex);
	inline void AppendL(const TAny* aPtr);
	inline void AppendL(const TAny* aPtr,TInt aCount);
	inline TAny* ExtendL();
	};
 
template <class T>
class CArrayFixFlat : public CArrayFix<T>
	{
public:
	inline CArrayFixFlat(TInt aGranularity);
	inline void SetReserveL(TInt aCount);
	};
  class CArrayFixFlat<TAny> : public CArrayFix<TAny>
	{
public:
	inline CArrayFixFlat(TInt aRecordLength,TInt aGranularity);
	inline void SetReserveL(TInt aCount);
	};
  class CArrayFixFlat<TInt> : public CArrayFix<TInt>
	{
public:
	  CArrayFixFlat(TInt aGranularity);
	  ~CArrayFixFlat();
	inline void SetReserveL(TInt aCount);
	};
  class CArrayFixFlat<TUid> : public CArrayFix<TUid>
	{
public:
	  CArrayFixFlat(TInt aGranularity);
	  ~CArrayFixFlat();
	inline void SetReserveL(TInt aCount);
	};
 
template <class T>
class CArrayFixSeg : public CArrayFix<T>
	{
public:
	inline CArrayFixSeg(TInt aGranularity);
	};
  class CArrayFixSeg<TAny> : public CArrayFix<TAny>
	{
public:
	inline CArrayFixSeg(TInt aRecordLength,TInt aGranularity);
	};
 
template <class T>
class CArrayPtr : public CArrayFix<T*>
	{
public:
	inline CArrayPtr(TBufRep aRep,TInt aGranularity);
    void ResetAndDestroy();
	};
 
template <class T>
class CArrayPtrFlat : public CArrayPtr<T>
	{
public:
	inline CArrayPtrFlat(TInt aGranularity);
	inline void SetReserveL(TInt aCount);
	};
 
template <class T>
class CArrayPtrSeg : public CArrayPtr<T>
	{
public:
	inline CArrayPtrSeg(TInt aGranularity);
	};
 
class TKeyArrayVar : public TKey
	{
public:
	  TKeyArrayVar(TInt anOffset,TKeyCmpText aType);
	  TKeyArrayVar(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKeyArrayVar(TInt anOffset,TKeyCmpNumeric aType);
protected:
	  virtual void Set(CBufBase* aBase);
	  TAny* At(TInt anIndex) const;
protected:
	CBufBase* iBase;
	friend class CArrayVarBase;
	};
 
class CArrayVarBase : public CBase
	{
public:
	  ~CArrayVarBase();
	inline TInt Count() const;
	  TInt Length(TInt anIndex) const;
	  void Compress();
	  void Reset();
	  TInt Sort(TKeyArrayVar& aKey);
	  TAny* At(TInt anIndex) const;
	  void Delete(TInt anIndex);
	  void Delete(TInt anIndex,TInt aCount);
	  TAny* ExpandL(TInt anIndex,TInt aLength);
	  TInt Find(const TAny* aPtr,TKeyArrayVar& aKey,TInt& anIndex) const;
	  TInt FindIsq(const TAny* aPtr,TKeyArrayVar& aKey,TInt& anIndex) const;
	  void InsertL(TInt anIndex,const TAny* aPtr,TInt aLength);
	  TInt InsertIsqL(const TAny* aPtr,TInt aLength,TKeyArrayVar& aKey);
	  TInt InsertIsqAllowDuplicatesL(const TAny* aPtr,TInt aLength,TKeyArrayVar& aKey);
protected:
	  CArrayVarBase(TBufRep aRep,TInt aGranularity);
	  void SetKey(TKeyArrayVar& aKey) const;
	  static TInt CountR(const CBase* aPtr);
	  static const TAny* AtR(const CBase* aPtr,TInt anIndex);
private:
	TInt iCount;
	TInt iGranularity;
	TBufRep iCreateRep;
	CBufBase* iBase;
	};
 
template <class T>
class CArrayVar : public CArrayVarBase
	{
public:
	inline CArrayVar(TBufRep aRep,TInt aGranularity);
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline const T& At(TInt anIndex) const;
	inline T& At(TInt anIndex);
	inline void AppendL(const T& aRef,TInt aLength);
	inline T& ExpandL(TInt anIndex,TInt aLength);
	inline T& ExtendL(TInt aLength);
	inline TInt Find(const T& aRef,TKeyArrayVar& aKey,TInt& anIndex) const;
	inline TInt FindIsq(const T& aRef,TKeyArrayVar& aKey,TInt& anIndex) const;
	inline void InsertL(TInt anIndex,const T& aRef,TInt aLength);
	inline TInt InsertIsqL(const T& aRef,TInt aLength,TKeyArrayVar& aKey);
 	inline TInt InsertIsqAllowDuplicatesL(const T& aRef,TInt aLength,TKeyArrayVar& aKey);
	inline const TArray<T> Array() const;
	};
  class CArrayVar<TAny> : public CArrayVarBase
	{
public:
	inline CArrayVar(TBufRep aRep,TInt aGranularity);
	inline const TAny* At(TInt anIndex) const;
	inline TAny* At(TInt anIndex);
	inline void AppendL(const TAny* aPtr,TInt aLength);
	inline TAny* ExtendL(TInt aLength);
	};
 
template <class T>
class CArrayVarFlat : public CArrayVar<T>
	{
public:
	inline CArrayVarFlat(TInt aGranularity);
	};
 
template <class T>
class CArrayVarSeg : public CArrayVar<T>
	{
public:
	inline CArrayVarSeg(TInt aGranularity);
	};
 
class TKeyArrayPak : public TKeyArrayVar
	{
public:
	  TKeyArrayPak(TInt anOffset,TKeyCmpText aType);
	  TKeyArrayPak(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKeyArrayPak(TInt anOffset,TKeyCmpNumeric aType);
protected:
	  virtual void Set(CBufBase* aBase);
	  TAny* At(TInt anIndex) const;
private:
	TInt iCacheIndex;
	TInt iCacheOffset;
	friend class CArrayPakBase;
	};
 
class CArrayPakBase : public CBase
	{
public:
	  ~CArrayPakBase();
	inline TInt Count() const;
	  TInt Length(TInt anIndex) const;
	  void Compress();
	  void Reset();
	  void SortL(TKeyArrayVar& aKey);
	  TAny* At(TInt anIndex) const;
	  void Delete(TInt anIndex);
	  void Delete(TInt anIndex,TInt aCount);
	  TAny* ExpandL(TInt anIndex,TInt aLength);
	  TInt Find(const TAny* aPtr,TKeyArrayPak& aKey,TInt& anIndex) const;
	  TInt FindIsq(const TAny* aPtr,TKeyArrayPak& aKey,TInt& anIndex) const;
	  void InsertL(TInt anIndex,const TAny* aPtr,TInt aLength);
	  TInt InsertIsqL(const TAny* aPtr,TInt aLength,TKeyArrayPak& aKey);
	  TInt InsertIsqAllowDuplicatesL(const TAny* aPtr,TInt aLength,TKeyArrayPak& aKey);
protected:
	  CArrayPakBase(TBufRep aRep,TInt aGranularity);
	  void SetKey(TKeyArrayPak& aKey) const;
	  TInt GetOffset(TInt anIndex) const;
	  void BuildVarArrayL(CArrayVarFlat<TAny>*& aVarFlat);
	  static TInt CountR(const CBase* aPtr);
	  static const TAny* AtR(const CBase* aPtr,TInt anIndex);
private:
	TInt iCount;
	TInt iGranularity;
	TBufRep iCreateRep;
	CBufBase* iBase;
	TInt iCacheIndex;
	TInt iCacheOffset;
	};
 
template <class T>
class CArrayPak : public CArrayPakBase
	{
public:
	inline CArrayPak(TBufRep aRep,TInt aGranularity);
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline const T& At(TInt anIndex) const;
	inline T& At(TInt anIndex);
	inline void AppendL(const T& aRef,TInt aLength);
	inline T& ExpandL(TInt anIndex,TInt aLength);
	inline T& ExtendL(TInt aLength);
	inline TInt Find(const T& aRef,TKeyArrayPak& aKey,TInt& anIndex) const;
	inline TInt FindIsq(const T& aRef,TKeyArrayPak& aKey,TInt& anIndex) const;
	inline void InsertL(TInt anIndex,const T& aRef,TInt aLength);
	inline TInt InsertIsqL(const T& aRef,TInt aLength,TKeyArrayPak& aKey);
	inline TInt InsertIsqAllowDuplicatesL(const T& aRef,TInt aLength,TKeyArrayPak& aKey);
	inline const TArray<T> Array() const;
	};
  class CArrayPak<TAny> : public CArrayPakBase
	{
public:
	inline CArrayPak(TBufRep aRep,TInt aGranularity);
	inline const TAny* At(TInt anIndex) const;
	inline TAny* At(TInt anIndex);
	inline void AppendL(const TAny* aPtr,TInt aLength);
	inline TAny* ExtendL(TInt aLength);
	};
 
template <class T>
class CArrayPakFlat : public CArrayPak<T>
	{
public:
	inline CArrayPakFlat(TInt aGranularity);
	};
 
class CObjectCon;
class CObject : public CBase
	{
public:
	  CObject();
	  ~CObject();
	  virtual TInt Open();
	  virtual void Close();
	  virtual TName Name() const;
	  virtual TFullName FullName() const;
	  TInt SetName(const TDesC* aName);
	  void SetNameL(const TDesC* aName);
	inline CObject* Owner() const;
	inline void SetOwner(CObject* anOwner);
	inline TInt AccessCount() const;
protected:
	inline TInt UniqueID() const;
	inline void Inc();
	inline void Dec();
private:
	TInt iAccessCount;
	CObject* iOwner;
	CObjectCon* iContainer;
	HBufC* iName;
	friend class CObjectCon;
	friend class CObjectIx;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
struct SObjectIxRec
	{
	TInt16 instance;
	TInt16 uniqueID;
	CObject* obj;
	};
 
class CObjectIx : public CBase
	{
public:
	enum {ENoClose=KHandleNoClose,ELocalHandle=0x40000000};
public:
	  static CObjectIx* NewL();
	  ~CObjectIx();
	  TInt AddL(CObject* anObj);
	  void Remove(TInt aHandle);
	  CObject* At(TInt aHandle,TInt aUniqueID);
	  CObject* At(TInt aHandle);
	  CObject* AtL(TInt aHandle,TInt aUniqueID);
	  CObject* AtL(TInt aHandle);
	  TInt At(const CObject* anObject) const;
	  TInt Count(CObject* anObject) const;
	  CObject* operator[](TInt anIndex);
	inline TInt Count() const;
	inline TInt ActiveCount() const;
protected:
	  CObjectIx();
private:
	TInt iNumEntries;		 
	TInt iHighWaterMark;	 
	TInt iAllocated;		 
	TInt iNextInstance;
	SObjectIxRec *iObjects;
	TInt iFree;				 
	};
 
inline TBool IsLocalHandle(TInt aHandle)
	{return(aHandle&CObjectIx::ELocalHandle);}
inline void SetLocalHandle(TInt &aHandle)
	{aHandle|=CObjectIx::ELocalHandle;}
inline void UnSetLocalHandle(TInt &aHandle)
	{aHandle&=(~CObjectIx::ELocalHandle);}
 
 
class CObjectCon : public CBase
	{
protected:
	enum {ENotOwnerID};
public:
	  static CObjectCon* NewL();
	  ~CObjectCon();
	  void Remove(CObject* anObj);
	  void AddL(CObject* anObj);
	  CObject* operator[](TInt anIndex);
	  CObject* At(TInt aFindHandle) const;
	  CObject* AtL(TInt aFindHandle) const;
	  TInt CheckUniqueFullName(const CObject* anOwner,const TDesC& aName) const;
	  TInt CheckUniqueFullName(const CObject* anObject) const;
	  TInt FindByName(TInt& aFindHandle,const TDesC& aMatch,TName& aName) const;
	  TInt FindByFullName(TInt& aFindHandle,const TDesC& aMatch,TFullName& aFullName) const;
	inline TInt UniqueID() const;
	inline TInt Count() const;
protected:
	  CObjectCon(TInt aUniqueID);
	TBool NamesMatch(const CObject* anObject, const CObject* aCurrentObject) const;
	TBool NamesMatch(const CObject* anObject, const TName& anObjectName, const CObject* aCurrentObject) const;
public:
	TInt iUniqueID;
private:
	TInt iCount;
	TInt iAllocated;
	CObject** iObjects;
	friend class CObjectConIx;
	};
 
class CObjectConIx : public CBase
	{
public:
	  static CObjectConIx* NewL();
	  ~CObjectConIx();
	  CObjectCon* Lookup(TInt aUniqueID) const;
	  CObjectCon* CreateL();
	  void Remove(CObjectCon* aCon);
protected:
	  CObjectConIx();
	  void CreateContainerL(CObjectCon*& anObject);
private:
	TInt iCount;
	TInt iAllocated;
	TInt iNextUniqueID;
	CObjectCon** iContainers;
	};
 
class CBitMapAllocator : public CBase
	{
public:
	  static CBitMapAllocator* New(TInt aSize);
	  static CBitMapAllocator* NewL(TInt aSize);
	  ~CBitMapAllocator();
	  TInt Alloc();
	  TInt AllocFrom(TInt aPos);
	  TInt Alloc(TInt aCount, TInt& aConsecutive);
	  TInt AllocAligned(TInt anAlignment);
	  TInt AllocAlignedBlock(TInt anAlignment);
	  TInt AllocFromTop();
	  TInt AllocFromTopFrom(TInt aPos);
	  void AllocAt(TInt aPos);
	  void AllocAt(TInt aPos, TInt aCount);
	  TBool IsFree(TInt aPos);
	  TBool IsFree(TInt aPos, TInt aCount);
	  void Free(TInt aPos);
	  void Free(TInt aPos, TInt aCount);
	  TInt Avail();
	  TInt Size();
	  TInt ExtractRamPages(TInt aConsecutive,TInt& aPageNo);
protected:
	  CBitMapAllocator(TInt aSize,TInt aLength);
protected:
	TInt iAvail;
	TInt iSize;
	TInt iLength;
	TUint iMap[1];
	};
 
typedef void (*TCleanupOperation)(TAny*);
 
class TCleanupItem
	{
public:
	inline TCleanupItem(TCleanupOperation anOperation);
	inline TCleanupItem(TCleanupOperation anOperation,TAny* aPtr);
private:
	TCleanupOperation iOperation;
	TAny* iPtr;
	friend class TCleanupStackItem;
	};
 
class CCleanup : public CBase
	{
public:
	  static CCleanup* New();
	  static CCleanup* NewL();
	  ~CCleanup();
	  void NextLevel();
	  void PreviousLevel();
	  void PushL(TAny* aPtr);
	  void PushL(CBase* anObject);
	  void PushL(TCleanupItem anItem);
	  void Pop();
	  void Pop(TInt aCount);
	  void PopAll();
	  void PopAndDestroy();
	  void PopAndDestroy(TInt aCount);
	  void PopAndDestroyAll();
	  void Check(TAny* aExpectedItem);
protected:
	  void DoPop(TInt aCount,TBool aDestroy);
	  void DoPopAll(TBool aDestroy);
protected:
	  CCleanup();
protected:
	TCleanupStackItem* iBase;
	TCleanupStackItem* iTop;
	TCleanupStackItem* iNext;
	};
 
class TCleanupTrapHandler : public TTrapHandler
	{
public:
	TCleanupTrapHandler();
	virtual void Trap();
	virtual void UnTrap();
	virtual void Leave(TInt aValue);
	inline CCleanup& Cleanup();
private:
	CCleanup* iCleanup;
	friend class CTrapCleanup;
	};
 
template <class T>
class TAutoClose
	{
public:
	inline ~TAutoClose();
	inline void PushL();
	inline void Pop();
private:
	static void Close(TAny *aObj);
public:
	T iObj;
	};
 
class CTrapCleanup : public CBase
	{
public:
	  static CTrapCleanup* New();
	  ~CTrapCleanup();
protected:
	  CTrapCleanup();
private:
	TCleanupTrapHandler iHandler;
	TTrapHandler* iOldHandler;
	};
 
class CCirBufBase : public CBase
	{
public:
	  ~CCirBufBase();
	inline TInt Count() const;
	inline TInt Length() const;
	  void SetLengthL(TInt aLength);
	  void Reset();
protected:
	  CCirBufBase(TInt aSize);
	  TInt DoAdd(const TUint8* aPtr);
	  TInt DoAdd(const TUint8* aPtr,TInt aCount);
	  TInt DoRemove(TUint8* aPtr);
	  TInt DoRemove(TUint8* aPtr,TInt aCount);
protected:
	TInt iCount;
	TInt iSize;
	TInt iLength;
	TUint8* iPtr;
	TUint8* iPtrE;
	TUint8* iHead;
	TUint8* iTail;
	};
 
template <class T>
class CCirBuf : public CCirBufBase
	{
public:
	inline CCirBuf();



	inline TInt Add(const T* aPtr);
	inline TInt Add(const T* aPtr,TInt aCount);
	inline TInt Remove(T* aPtr);
	inline TInt Remove(T* aPtr,TInt aCount);
	};
 
class CCirBuffer : public CCirBuf<TUint8>
	{
public:
	  CCirBuffer();
	  ~CCirBuffer();
	  TInt Get();
	  TInt Put(TInt aVal);
	};
 
class CSecurityEncryptBase : public CBase
	{
public:
	virtual TInt EncryptL(TDes8& aOutput,const TDesC8& aInput) =0;
	virtual TInt CompleteL(TDes8& aOutput,const TDesC8& aInput) =0;
protected:
	  CSecurityEncryptBase();
	};
 
class CSecurityDecryptBase : public CBase
	{
public:
	virtual TInt DecryptL(TDes8& aOutput,const TDesC8& aInput) =0;
protected:
	  CSecurityDecryptBase();
	};
 
class CSecurityBase : public CBase
	{
public:
 
	virtual void SetL(const TDesC& aOldPassword,const TDesC& aNewPassword) =0;
	virtual TPtrC8 SecurityData() const =0;
	virtual CSecurityEncryptBase* NewEncryptL(const TDesC8& aInit) const =0;  
 
	virtual void PrepareL(const TDesC& aPassword) =0;
	virtual CSecurityDecryptBase* NewDecryptL(const TDesC8& aInit) const =0;  
 
	virtual TInt IsEnabled() const =0;
	virtual void SetEnabledL(const TDesC& aPassword,TBool aIsEnabled) =0;
protected:
	  CSecurityBase();
	};
 
class CBoundedSecurityBase : public CSecurityBase
	{
public:
	virtual TInt MaxCipherLength(TInt aPlainTextLength) const =0;
protected:
	inline CBoundedSecurityBase() {}
	};
 
class CActive : public CBase
	{
public:
enum TPriority
	{
	EPriorityIdle=-100,
	EPriorityLow=-20,
	EPriorityStandard=0,
	EPriorityUserInput=10,
	EPriorityHigh=20,
	};
public:
	  ~CActive();
	  void Cancel();
	  void Deque();
	  void SetPriority(TInt aPriority);
	inline TBool IsActive() const;
	inline TBool IsAdded() const;
	inline TInt Priority() const;
protected:
	  CActive(TInt aPriority);
	  void SetActive();
 
	virtual void DoCancel() =0;
	virtual void RunL() =0;
	  virtual TInt RunError(TInt aError);
public:
	TRequestStatus iStatus;
private:
	TBool iActive;
	TPriQueLink iLink;
	friend class CActiveScheduler;
	friend class CServer;
	friend class CServer2;
	};
 
class CIdle : public CActive
	{
public:
	  static CIdle* New(TInt aPriority);
	  static CIdle* NewL(TInt aPriority);
	  ~CIdle();
	  void Start(TCallBack aCallBack);
protected:
	  CIdle(TInt aPriority);
	  void RunL();
	  void DoCancel();
protected:
	TCallBack iCallBack;
	};
 
class CAsyncOneShot : public CActive
	{
public:
	  CAsyncOneShot(TInt aPriority);
	  virtual void DoCancel();
	  virtual void Call();
	  virtual ~CAsyncOneShot();
	inline RThread& Thread();
private:
	void Setup();
	RThread iThread;
	};

class CAsyncCallBack : public CAsyncOneShot
	{
public:
	  CAsyncCallBack(TInt aPriority);
	  CAsyncCallBack(const TCallBack& aCallBack, TInt aPriority);
	  void Set(const TCallBack& aCallBack);
	  void CallBack();
	  virtual ~CAsyncCallBack();
protected:
	virtual void RunL();
 
protected:
	TCallBack iCallBack;
	};
 
class TDeltaTimerEntry
	{
	friend class CDeltaTimer;
public:
	inline TDeltaTimerEntry(TCallBack& aCallback);
	inline TDeltaTimerEntry();
	inline void Set(TCallBack& aCallback);
private:
	TCallBack iCallBack; 
	TDeltaQueLink iLink;
	};
class CDeltaTimer : public CActive
	{
public:
	  virtual void Queue(TTimeIntervalMicroSeconds32 aTimeInMicroSeconds,TDeltaTimerEntry& aHandle);
	  virtual void Remove(TDeltaTimerEntry& anEntry);
	  static CDeltaTimer* NewL(TInt aPriority);
	  static CDeltaTimer* NewL(TInt aPriority,TTimeIntervalMicroSeconds32 aGranularity);
	virtual ~CDeltaTimer();
protected:
	  CDeltaTimer(TInt aPriority,TTimeIntervalMicroSeconds32 aGranularity);
	void DoCancel();
	void RunL();
	inline TTimeIntervalMicroSeconds32 Granularity() const;
protected:
	void Activate();
	RTimer iTimer;
	TDeltaQue<TDeltaTimerEntry> iQueue;
	TTimeIntervalMicroSeconds32 iGranularity;
	};
 
class CTimer : public CActive
	{
public:
	  ~CTimer();
	  void At(const TTime& aTime);
	  void After(TTimeIntervalMicroSeconds32 anInterval);
	  void Lock(TTimerLockSpec aLock);
	  void Inactivity(TTimeIntervalSeconds aSeconds);
protected:
	  CTimer(TInt aPriority);
	  void ConstructL();
	  void DoCancel();
private:
	RTimer iTimer;
	};
 
class CPeriodic : public CTimer
	{
public:
	  static CPeriodic* New(TInt aPriority);
	  static CPeriodic* NewL(TInt aPriority);
	  ~CPeriodic();
	  void Start(TTimeIntervalMicroSeconds32 aDelay,TTimeIntervalMicroSeconds32 anInterval,TCallBack aCallBack);
protected:
	  CPeriodic(TInt aPriority);
	  void RunL();
private:
	TTimeIntervalMicroSeconds32 iInterval;
	TCallBack iCallBack;
	};
 
class MBeating
	{
public:
	virtual void Beat() =0;
	virtual void Synchronize() =0;
	};
 
class CHeartbeat : public CTimer
	{
public:
	  static CHeartbeat* New(TInt aPriority);
	  static CHeartbeat* NewL(TInt aPriority);
	  ~CHeartbeat();
	  void Start(TTimerLockSpec aLock,MBeating *aBeating);
protected:
	  CHeartbeat(TInt aPriority);
	  void RunL();
private:
	TTimerLockSpec iLock;
	MBeating *iBeating;
	};
 



class CServer;
class CSharableSession : public CBase
 



	{
	friend class CServer;
public:
	  ~CSharableSession() =0;
	  virtual void CreateL(const CServer& aServer);
 
	inline const CServer* Server() const;
	inline const RMessage& Message() const;
	  void ResourceCountMarkStart();
	  void ResourceCountMarkEnd();
	  virtual TInt CountResources();
 
	virtual void ServiceL(const RMessage& aMessage) =0;
protected:
	  CSharableSession();
public:
	enum TPanicNo {ESesCountResourcesNotImplemented=1,ESesFoundResCountHeaven};
private:
	TInt iResourceCountMark;
	TDblQueLink iLink;
	const CServer* iServer;
	};

class CSession : public CSharableSession
 



	{
public:
	  ~CSession() =0;
 
	inline const RThread& Client() const;
	  void ReadL(const TAny* aPtr,TDes8& aDes) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes,TInt anOffset) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes,TInt anOffset) const;
	  void Panic(const TDesC& aCategory,TInt aReason) const;
	  void Kill(TInt aReason) const;
	  void Terminate(TInt aReason) const;
protected:
	  CSession(RThread aClient);
private:
	RThread iClient;
	};
 
class CServer : public CActive
 



	{
protected:
	enum TServerType {EUnsharableSessions,ESharableSessions};
public:
	  ~CServer() =0;
	  TInt Start(const TDesC& aName);
	  void StartL(const TDesC& aName);
 
	  void ReStart();
	inline const RMessage& Message() const;
protected:
	  CServer(TInt aPriority,TServerType aType=EUnsharableSessions);
	  void DoCancel();
	  void RunL();
private:
	virtual CSharableSession* NewSessionL(const TVersion& aVersion) const =0;
	void Connect();
private:
	const TServerType iSessionType;
	RServer iServer;
	TDblQue<CSharableSession> iSessionQ;
protected:
	TDblQueIter<CSharableSession> iSessionIter;
	};



class CServer2;
class CSession2 : public CBase
 



	{
	friend class CServer2;
public:
	  virtual ~CSession2() =0;
private:
	  virtual void CreateL();  
public:
	inline const CServer2* Server() const;
	  void ResourceCountMarkStart();
	  void ResourceCountMarkEnd(const RMessage2& aMessage);
	  virtual TInt CountResources();
	 






	virtual void ServiceL(const RMessage2& aMessage) =0;
	  virtual void ServiceError(const RMessage2& aMessage,TInt aError);
protected:
	  CSession2();
	  virtual void Disconnect(const RMessage2& aMessage);
public:
	 

	enum TPanicNo
		{
		 

		ESesCountResourcesNotImplemented=1,
		 

		ESesFoundResCountHeaven
		};
private:
	TInt iResourceCountMark;
	TDblQueLink iLink;
	const CServer2* iServer;
	};

class CServer2 : public CActive
 



	{
protected:
	 

	enum TServerType
		{
		 

		EUnsharableSessions,
		 

		ESharableSessions
		};
public:
	  virtual ~CServer2() =0;
	  TInt Start(const TDesC& aName);
	  void StartL(const TDesC& aName);
	  void ReStart();
	inline RServer2 Server() const;
protected:
	inline const RMessage2& Message() const;
	  CServer2(TInt aPriority,TServerType aType=EUnsharableSessions);
	  void DoCancel();
	  void RunL();
	  TInt RunError(TInt aError);
	  virtual void DoConnect(const RMessage2& aMessage);
private:
	  virtual CSession2* NewSessionL(const TVersion& aVersion,const RMessage2& aMessage) const =0;
	void Connect(const RMessage2& aMessage);
public:
	 

	enum TPanic
		{
		 

		EBadMessageNumber,
		 

		ESessionNotConnected,
		 

		ESessionAlreadyConnected,
		};
private:
	const TServerType iSessionType;
	RServer2 iServer;
	RMessage2 iMessage;
	TDblQue<CSession2> iSessionQ;
protected:
	TDblQueIter<CSession2> iSessionIter;
private:
	void Disconnect(const RMessage2& aMessage);
	void BadMessage(const RMessage2& aMessage);
	void NotConnected(const RMessage2& aMessage);
	};
 
class CActiveSchedulerWait : public CBase
	{
public:
	  ~CActiveSchedulerWait();
	  void Start();
	  void AsyncStop();
	  void AsyncStop(const TCallBack& aCallMeWhenStopped);
	  TBool IsStarted() const;
	  TBool CanStopNow() const;

private:
	friend class CActiveScheduler;
	class TOwnedSchedulerLoop
		{
	public:
		TOwnedSchedulerLoop(CActiveSchedulerWait* aWait);
	public:
		TInt iRunning;
		TCallBack iCb;
		TBool iLevelDropped;
		CActiveSchedulerWait* iWait;
		};
	TOwnedSchedulerLoop* iLoop;
	};
 
class CActiveScheduler : public CBase
	{
public:
	  CActiveScheduler();
	  ~CActiveScheduler();
	  static void Install(CActiveScheduler* aScheduler);
	  static CActiveScheduler* Current();
	  static void Add(CActive* anActive);
	  static void Start();
	  static void Stop();
	  static TBool RunIfReady(TInt& aError, TInt aMinimumPriority);
	  static CActiveScheduler* Replace(CActiveScheduler* aNewActiveScheduler);
	  virtual void WaitForAnyRequest();
	  virtual void Error(TInt anError) const;
private:
	void DoStart();
	void OwnedStartLoop(TInt& aRunning);
	  virtual void OnStarting();
	  virtual void OnStopping();
	  virtual void Reserved_1();
	  virtual void Reserved_2();
private:
	 
	friend class CActiveSchedulerWait;
	static void OwnedStart(CActiveSchedulerWait& aOwner);
protected:
	inline TInt Level() const;
private:
	TInt iLevel;
	TPriQue<CActive> iActiveQ;
	};
 
class CleanupStack
	{
public:
	  static void PushL(TAny* aPtr);
	  static void PushL(CBase* aPtr);
	  static void PushL(TCleanupItem anItem);
	  static void Pop();
	  static void Pop(TInt aCount);
	  static void PopAndDestroy();
	  static void PopAndDestroy(TInt aCount);
	  static void Check(TAny* aExpectedItem);
	inline static void Pop(TAny* aExpectedItem);
	inline static void Pop(TInt aCount, TAny* aLastExpectedItem);
	inline static void PopAndDestroy(TAny* aExpectedItem);
	inline static void PopAndDestroy(TInt aCount, TAny* aLastExpectedItem);
	};
 
template <class T>
class CleanupDelete
	{
public:
	inline static void PushL(T* aPtr);
private:
	static void Delete(TAny *aPtr);
	};
template <class T>
inline void CleanupDeletePushL(T* aPtr);
 
template <class T>
class CleanupArrayDelete
	{
public:
	inline static void PushL(T* aPtr);
private:
	static void ArrayDelete(TAny *aPtr);
	};
template <class T>
inline void CleanupArrayDeletePushL(T* aPtr);
 
template <class T>
class CleanupClose
	{
public:
	inline static void PushL(T& aRef);
private:
	static void Close(TAny *aPtr);
	};
template <class T>
inline void CleanupClosePushL(T& aRef);
 
template <class T>
class CleanupRelease
	{
public:
	inline static void PushL(T& aRef);
private:
	static void Release(TAny *aPtr);
	};
template <class T>
inline void CleanupReleasePushL(T& aRef);
 
class CConsoleBase;
class Console
	{
public:
	  static CConsoleBase* NewL(const TDesC& aTitle,TSize aSize);
	};
 
class Security
	{
public:
	  static CBoundedSecurityBase* NewL();
	  static CBoundedSecurityBase* NewL(const TDesC8& aSecurityData);
	};
 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.inl" 1
 
 
 
 
 






 
inline TAny* CBase::operator new(TUint aSize, TAny* aBase)
	{Mem::FillZ(aBase,aSize);return(aBase);}
inline TAny* CBase::operator new(TUint aSize, TLeave)
	{return newL(aSize);}
inline TAny* CBase::operator new(TUint aSize, TLeave, TUint aExtraSize)
	{return newL(aSize + aExtraSize);}

 
inline TInt CBufBase::Size() const
	{return(iSize);}

 
inline TInt CBufFlat::Capacity() const
	{return(iMaxSize);}

 
inline TInt CArrayFixBase::Count() const
	{return(iCount);}
inline TInt CArrayFixBase::Length() const
	{return(iLength);}

 
template <class T>
inline CArrayFix<T>::CArrayFix(TBufRep aRep,TInt aGranularity)
	: CArrayFixBase(aRep,sizeof(T),aGranularity)
	{}
template <class T>
inline const T &CArrayFix<T>::operator[](TInt anIndex) const
	{return(*((const T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline T &CArrayFix<T>::operator[](TInt anIndex)
	{return(*((T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline const T &CArrayFix<T>::At(TInt anIndex) const
	{return(*((const T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline const T *CArrayFix<T>::End(TInt anIndex) const
	{return((const T *)CArrayFixBase::End(anIndex));}
template <class T>
inline const T *CArrayFix<T>::Back(TInt anIndex) const
	{return((const T *)CArrayFixBase::Back(anIndex));}
template <class T>
inline T &CArrayFix<T>::At(TInt anIndex)
	{return(*((T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline T *CArrayFix<T>::End(TInt anIndex)
	{return(((T *)CArrayFixBase::End(anIndex)));}
template <class T>
inline T *CArrayFix<T>::Back(TInt anIndex)
	{return(((T *)CArrayFixBase::Back(anIndex)));}
template <class T>
inline void CArrayFix<T>::AppendL(const T &aRef)
	{CArrayFixBase::InsertL(Count(),&aRef);}
template <class T>
inline void CArrayFix<T>::AppendL(const T *aPtr,TInt aCount)
	{CArrayFixBase::InsertL(Count(),aPtr,aCount);}
template <class T>
inline void CArrayFix<T>::AppendL(const T &aRef,TInt aReplicas)
	{CArrayFixBase::InsertRepL(Count(),&aRef,aReplicas);}
template <class T>
inline T &CArrayFix<T>::ExpandL(TInt anIndex)
	{return(*new(CArrayFixBase::ExpandL(anIndex)) T);}
template <class T>
inline T &CArrayFix<T>::ExtendL()
	{return(*new(CArrayFixBase::ExpandL(Count())) T);}
template <class T>
inline TInt CArrayFix<T>::Find(const T &aRef,TKeyArrayFix &aKey,TInt &anIndex) const
	{return(CArrayFixBase::Find(&aRef,aKey,anIndex));}
template <class T>
inline TInt CArrayFix<T>::FindIsq(const T &aRef,TKeyArrayFix &aKey,TInt &anIndex) const
	{return(CArrayFixBase::FindIsq(&aRef,aKey,anIndex));}
template <class T>
inline void CArrayFix<T>::InsertL(TInt anIndex,const T &aRef)
	{CArrayFixBase::InsertL(anIndex,&aRef);}
template <class T>
inline void CArrayFix<T>::InsertL(TInt anIndex,const T *aPtr,TInt aCount)
	{CArrayFixBase::InsertL(anIndex,aPtr,aCount);}
template <class T>
inline void CArrayFix<T>::InsertL(TInt anIndex,const T &aRef,TInt aReplicas)
	{CArrayFixBase::InsertRepL(anIndex,&aRef,aReplicas);}
template <class T>
inline TInt CArrayFix<T>::InsertIsqL(const T &aRef,TKeyArrayFix &aKey)
	{return(CArrayFixBase::InsertIsqL(&aRef,aKey));}
template <class T>
inline TInt CArrayFix<T>::InsertIsqAllowDuplicatesL(const T &aRef,TKeyArrayFix &aKey)
	{return(CArrayFixBase::InsertIsqAllowDuplicatesL(&aRef,aKey));}
template <class T>
inline void CArrayFix<T>::ResizeL(TInt aCount)
	{TUint8 b[sizeof(T)]; new(&b[0]) T; CArrayFixBase::ResizeL(aCount,&b[0]);}
template <class T>
inline void CArrayFix<T>::ResizeL(TInt aCount,const T &aRef)
	{CArrayFixBase::ResizeL(aCount,&aRef);}
template <class T>
inline const TArray<T> CArrayFix<T>::Array() const
	{return(TArray<T>(CountR,AtR,this));}
inline CArrayFix<TAny>::CArrayFix(TBufRep aRep,TInt aRecordLength,TInt aGranularity)
	: CArrayFixBase(aRep,aRecordLength,aGranularity)
	{}
inline const TAny *CArrayFix<TAny>::At(TInt anIndex) const
	{return(CArrayFixBase::At(anIndex));}
inline const TAny *CArrayFix<TAny>::End(TInt anIndex) const
	{return(CArrayFixBase::End(anIndex));}
inline const TAny *CArrayFix<TAny>::Back(TInt anIndex) const
	{return(CArrayFixBase::Back(anIndex));}
inline TAny *CArrayFix<TAny>::At(TInt anIndex)
	{return(CArrayFixBase::At(anIndex));}
inline TAny *CArrayFix<TAny>::End(TInt anIndex)
	{return(CArrayFixBase::End(anIndex));}
inline TAny *CArrayFix<TAny>::Back(TInt anIndex)
	{return(CArrayFixBase::Back(anIndex));}
inline void CArrayFix<TAny>::AppendL(const TAny *aPtr)
	{CArrayFixBase::InsertL(Count(),aPtr);}
inline void CArrayFix<TAny>::AppendL(const TAny *aPtr,TInt aCount)
	{CArrayFixBase::InsertL(Count(),aPtr,aCount);}
inline TAny *CArrayFix<TAny>::ExtendL()
	{return(CArrayFixBase::ExpandL(Count()));}

 
template <class T>
inline CArrayFixFlat<T>::CArrayFixFlat(TInt aGranularity)
	: CArrayFix<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}
template <class T>
inline void CArrayFixFlat<T>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}
inline CArrayFixFlat<TAny>::CArrayFixFlat(TInt aRecordLength,TInt aGranularity)
	: CArrayFix<TAny>((TBufRep)CBufFlat::NewL,aRecordLength,aGranularity)
	{}
inline void CArrayFixFlat<TAny>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}
inline void CArrayFixFlat<TInt>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}
inline void CArrayFixFlat<TUid>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}

 
template <class T>
inline CArrayFixSeg<T>::CArrayFixSeg(TInt aGranularity)
	: CArrayFix<T>((TBufRep)CBufSeg::NewL,aGranularity)
	{}
inline CArrayFixSeg<TAny>::CArrayFixSeg(TInt aRecordLength,TInt aGranularity)
	: CArrayFix<TAny>((TBufRep)CBufSeg::NewL,aRecordLength,aGranularity)
	{}

 
template <class T>
inline CArrayPtr<T>::CArrayPtr(TBufRep aRep,TInt aGranularity)
	: CArrayFix<T*>(aRep,aGranularity)
	{}
template <class T>
void CArrayPtr<T>::ResetAndDestroy()
	{
	for (TInt i=0;i<Count();++i)
		delete At(i);
	Reset();
	}

 
template <class T>
inline CArrayPtrFlat<T>::CArrayPtrFlat(TInt aGranularity)
	: CArrayPtr<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}
template <class T>
inline void CArrayPtrFlat<T>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}

 
template <class T>
inline CArrayPtrSeg<T>::CArrayPtrSeg(TInt aGranularity)
	: CArrayPtr<T>((TBufRep)CBufSeg::NewL,aGranularity)
	{}

 
inline TInt CArrayVarBase::Count() const
	{return(iCount);}

 
template <class T>
inline CArrayVar<T>::CArrayVar(TBufRep aRep,TInt aGranularity)
	: CArrayVarBase(aRep,aGranularity)
	{}
template <class T>
inline const T &CArrayVar<T>::operator[](TInt anIndex) const
	{return(*((const T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline T &CArrayVar<T>::operator[](TInt anIndex)
	{return(*((T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline const T &CArrayVar<T>::At(TInt anIndex) const
	{return(*((const T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline T &CArrayVar<T>::At(TInt anIndex)
	{return(*((T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline void CArrayVar<T>::AppendL(const T &aRef,TInt aLength)
	{CArrayVarBase::InsertL(Count(),&aRef,aLength);}
template <class T>
inline T &CArrayVar<T>::ExpandL(TInt anIndex,TInt aLength)
	{return(*new(CArrayVarBase::ExpandL(anIndex,aLength)) T);}
template <class T>
inline T &CArrayVar<T>::ExtendL(TInt aLength)
	{return(*new(CArrayVarBase::ExpandL(Count(),aLength)) T);}
template <class T>
inline TInt CArrayVar<T>::Find(const T &aRef,TKeyArrayVar &aKey,TInt &anIndex) const
	{return(CArrayVarBase::Find(&aRef,aKey,anIndex));}
template <class T>
inline TInt CArrayVar<T>::FindIsq(const T &aRef,TKeyArrayVar &aKey,TInt &anIndex) const
	{return(CArrayVarBase::FindIsq(&aRef,aKey,anIndex));}
template <class T>
inline void CArrayVar<T>::InsertL(TInt anIndex,const T &aRef,TInt aLength)
	{CArrayVarBase::InsertL(anIndex,&aRef,aLength);}
template <class T>
inline TInt CArrayVar<T>::InsertIsqL(const T &aRef,TInt aLength,TKeyArrayVar &aKey)
	{return(CArrayVarBase::InsertIsqL(&aRef,aLength,aKey));}
template <class T>
inline TInt CArrayVar<T>::InsertIsqAllowDuplicatesL(const T &aRef,TInt aLength,TKeyArrayVar &aKey)
	{return(CArrayVarBase::InsertIsqAllowDuplicatesL(&aRef,aLength,aKey));}
template <class T>
inline const TArray<T> CArrayVar<T>::Array() const
	{return(TArray<T>(CountR,AtR,this));}
inline const TAny *CArrayVar<TAny>::At(TInt anIndex) const
	{return(CArrayVarBase::At(anIndex));}
inline CArrayVar<TAny>::CArrayVar(TBufRep aRep,TInt aGranularity)
	: CArrayVarBase(aRep,aGranularity)
	{}
inline TAny *CArrayVar<TAny>::At(TInt anIndex)
	{return(CArrayVarBase::At(anIndex));}
inline void CArrayVar<TAny>::AppendL(const TAny *aPtr,TInt aLength)
	{CArrayVarBase::InsertL(Count(),aPtr,aLength);}
inline TAny *CArrayVar<TAny>::ExtendL(TInt aLength)
	{return(CArrayVarBase::ExpandL(Count(),aLength));}

 
template <class T>
inline CArrayVarFlat<T>::CArrayVarFlat(TInt aGranularity)
	: CArrayVar<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}

 
template <class T>
inline CArrayVarSeg<T>::CArrayVarSeg(TInt aGranularity)
	: CArrayVar<T>((TBufRep)CBufSeg::NewL,aGranularity)
	{}

 
inline TInt CArrayPakBase::Count() const
	{return(iCount);}

 
template <class T>
inline CArrayPak<T>::CArrayPak(TBufRep aRep,TInt aGranularity)
	: CArrayPakBase(aRep,aGranularity)
	{}
template <class T>
inline const T &CArrayPak<T>::operator[](TInt anIndex) const
	{return(*((const T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline T &CArrayPak<T>::operator[](TInt anIndex)
	{return(*((T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline const T &CArrayPak<T>::At(TInt anIndex) const
	{return(*((const T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline T &CArrayPak<T>::At(TInt anIndex)
	{return(*((T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline void CArrayPak<T>::AppendL(const T &aRef,TInt aLength)
	{CArrayPakBase::InsertL(Count(),&aRef,aLength);}
template <class T>
inline T &CArrayPak<T>::ExpandL(TInt anIndex,TInt aLength)
	{return(*new(CArrayPakBase::ExpandL(anIndex,aLength)) T);}
template <class T>
inline T &CArrayPak<T>::ExtendL(TInt aLength)
	{return(*new(CArrayPakBase::ExpandL(Count(),aLength)) T);}
template <class T>
inline TInt CArrayPak<T>::Find(const T &aRef,TKeyArrayPak &aKey,TInt &anIndex) const
	{return(CArrayPakBase::Find(&aRef,aKey,anIndex));}
template <class T>
inline TInt CArrayPak<T>::FindIsq(const T &aRef,TKeyArrayPak &aKey,TInt &anIndex) const
	{return(CArrayPakBase::FindIsq(&aRef,aKey,anIndex));}
template <class T>
inline void CArrayPak<T>::InsertL(TInt anIndex,const T &aRef,TInt aLength)
	{CArrayPakBase::InsertL(anIndex,&aRef,aLength);}
template <class T>
inline TInt CArrayPak<T>::InsertIsqL(const T &aRef,TInt aLength,TKeyArrayPak &aKey)
	{return(CArrayPakBase::InsertIsqL(&aRef,aLength,aKey));}
template <class T>
inline TInt CArrayPak<T>::InsertIsqAllowDuplicatesL(const T &aRef,TInt aLength,TKeyArrayPak &aKey)
	{return(CArrayPakBase::InsertIsqAllowDuplicatesL(&aRef,aLength,aKey));}
template <class T>
inline const TArray<T> CArrayPak<T>::Array() const
	{return(TArray<T>(CountR,AtR,this));}
inline CArrayPak<TAny>::CArrayPak(TBufRep aRep,TInt aGranularity)
	: CArrayPakBase(aRep,aGranularity)
	{}
inline const TAny *CArrayPak<TAny>::At(TInt anIndex) const
	{return(CArrayPakBase::At(anIndex));}
inline TAny *CArrayPak<TAny>::At(TInt anIndex)
	{return(CArrayPakBase::At(anIndex));}
inline void CArrayPak<TAny>::AppendL(const TAny *aPtr,TInt aLength)
	{CArrayPakBase::InsertL(Count(),aPtr,aLength);}
inline TAny *CArrayPak<TAny>::ExtendL(TInt aLength)
	{return(CArrayPakBase::ExpandL(Count(),aLength));}

 
template <class T>
inline CArrayPakFlat<T>::CArrayPakFlat(TInt aGranularity)
	: CArrayPak<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}

 
inline TInt CObject::UniqueID() const
	{return(iContainer->UniqueID());}
inline TInt CObject::AccessCount() const
	{return(iAccessCount);}
inline void CObject::Inc()
	{iAccessCount++;}
inline void CObject::Dec()
	{iAccessCount--;}
inline CObject * CObject::Owner() const
	{return(iOwner);}
inline void CObject::SetOwner(CObject *anOwner)
	{iOwner=anOwner;}

 
inline TInt CObjectIx::Count() const
	{return iHighWaterMark;}
inline TInt CObjectIx::ActiveCount() const
	{return iNumEntries;}

 
inline TInt CObjectCon::UniqueID() const
	{return iUniqueID;}
inline TInt CObjectCon::Count() const
	{return iCount;}

 
inline TInt CCirBufBase::Count() const
	{return(iCount);}
inline TInt CCirBufBase::Length() const
	{return(iLength);}

 
template <class T>
inline CCirBuf<T>::CCirBuf()
	: CCirBufBase(sizeof(T))
	{}
template <class T>
inline TInt CCirBuf<T>::Add(const T *aPtr)
	{return(DoAdd((const TUint8 *)aPtr));}
template <class T>
inline TInt CCirBuf<T>::Add(const T *aPtr,TInt aCount)
	{return(DoAdd((const TUint8 *)aPtr,aCount));}
template <class T>
inline TInt CCirBuf<T>::Remove(T *aPtr)
	{return(DoRemove((TUint8 *)aPtr));}
template <class T>
inline TInt CCirBuf<T>::Remove(T *aPtr,TInt aCount)
	{return(DoRemove((TUint8 *)aPtr,aCount));}

 
inline TBool CActive::IsActive() const
	{return(iActive);}
inline TBool CActive::IsAdded() const
	{return(iLink.iNext!= 0L );}
inline TInt CActive::Priority() const
	{return iLink.iPriority;}

 
inline TDeltaTimerEntry::TDeltaTimerEntry(TCallBack& aCallback)
	{iCallBack=aCallback;}
inline TDeltaTimerEntry::TDeltaTimerEntry()
	{}
inline void TDeltaTimerEntry::Set(TCallBack& aCallback)
	{iCallBack=aCallback;}
inline TTimeIntervalMicroSeconds32 CDeltaTimer::Granularity() const
	{return iGranularity;}



 
inline const RMessage &CServer::Message() const
	{return iServer.Message();}
 
inline const CServer *CSharableSession::Server() const
	{return iServer;}
inline const RMessage& CSharableSession::Message() const
	{return iServer->Message();}
 
inline const RThread &CSession::Client() const
	{return iClient;}



 
inline const RMessage2 &CServer2::Message() const
 




	{return iMessage;}
inline RServer2 CServer2::Server() const
 




	{return iServer;}

 
inline const CServer2 *CSession2::Server() const
 




	{return iServer;}

 
inline RThread& CAsyncOneShot::Thread()
	{ return iThread; }

 
inline TInt CActiveScheduler::Level() const
	{return(iLevel);}

 
# 460 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.inl"

inline void CleanupStack::Pop(TAny*)
	{ CleanupStack::Pop(); }
inline void CleanupStack::Pop(TInt aCount, TAny*)
	{ CleanupStack::Pop(aCount); }
inline void CleanupStack::PopAndDestroy(TAny*)
	{ CleanupStack::PopAndDestroy(); }
inline void CleanupStack::PopAndDestroy(TInt aCount, TAny*)
	{ CleanupStack::PopAndDestroy(aCount); }


 
inline TCleanupItem::TCleanupItem(TCleanupOperation anOperation)
	: iOperation(anOperation)
	{}
inline TCleanupItem::TCleanupItem(TCleanupOperation anOperation,TAny *aPtr)
	: iOperation(anOperation), iPtr(aPtr)
	{}

 
inline CCleanup &TCleanupTrapHandler::Cleanup()
	{return(*iCleanup);}

 
template <class T>
inline TAutoClose<T>::~TAutoClose()
	{iObj.Close();}
template <class T>
inline void TAutoClose<T>::PushL()
	{CleanupStack::PushL(TCleanupItem(Close, (TAny *)&iObj));}
template <class T>
inline void TAutoClose<T>::Pop()
	{CleanupStack::Pop();}
template <class T>
void TAutoClose<T>::Close(TAny *aObj)
	{((T *)aObj)->Close();}

 
template <class T>
inline void CleanupDelete<T>::PushL(T* aPtr)
	{CleanupStack::PushL(TCleanupItem(&Delete,aPtr));}
template <class T>
void CleanupDelete<T>::Delete(TAny *aPtr)
	{delete (static_cast< T* >( aPtr )) ;}
template <class T>
inline void CleanupDeletePushL(T* aPtr)
	{CleanupDelete<T>::PushL(aPtr);}

 
template <class T>
inline void CleanupArrayDelete<T>::PushL(T* aPtr)
	{CleanupStack::PushL(TCleanupItem(&ArrayDelete,aPtr));}
template <class T>
void CleanupArrayDelete<T>::ArrayDelete(TAny *aPtr)
	{delete [] (static_cast< T* >( aPtr )) ;}
template <class T>
inline void CleanupArrayDeletePushL(T* aPtr)
	{CleanupArrayDelete<T>::PushL(aPtr);}

 
template <class T>
inline void CleanupClose<T>::PushL(T& aRef)
	{CleanupStack::PushL(TCleanupItem(&Close,&aRef));}
template <class T>
void CleanupClose<T>::Close(TAny *aPtr)
	{((static_cast< T* >( aPtr )) )->Close();}
template <class T>
inline void CleanupClosePushL(T& aRef)
	{CleanupClose<T>::PushL(aRef);}

 
template <class T>
inline void CleanupRelease<T>::PushL(T& aRef)
	{CleanupStack::PushL(TCleanupItem(&Release,&aRef));}
template <class T>
void CleanupRelease<T>::Release(TAny *aPtr)
	{((static_cast< T* >( aPtr )) )->Release();}
template <class T>
inline void CleanupReleasePushL(T& aRef)
	{CleanupRelease<T>::PushL(aRef);}



# 1261 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.h" 2



# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 1
 
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32keys.h" 1
 
 
 
 
 








 

 



 



enum TEventModifier
	{
	EModifierAutorepeatable=0x00000001,
	EModifierKeypad=0x00000002,
	EModifierLeftAlt=0x00000004,
	EModifierRightAlt=0x00000008,
	EModifierAlt=0x00000010,
	EModifierLeftCtrl=0x00000020,
	EModifierRightCtrl=0x00000040,
	EModifierCtrl=0x00000080,
	EModifierLeftShift=0x00000100,
	EModifierRightShift=0x00000200,
	EModifierShift=0x00000400,
	EModifierLeftFunc=0x00000800,
	EModifierRightFunc=0x00001000,
	EModifierFunc=0x00002000,
	EModifierCapsLock=0x00004000,
	EModifierNumLock=0x00008000,
	EModifierScrollLock=0x00010000,
	EModifierKeyUp=0x00020000,
	EModifierSpecial=0x00040000,
	EModifierDoubleClick=0x00080000,
    EModifierPureKeycode=0x00100000,
	EModifierKeyboardExtend=0x00200000,
	EAllModifiers=0x002fffff
	};

enum TModifierState
    {
    ETurnOnModifier=0x40,
    ETurnOffModifier,
    EToggleModifier
    };

enum TStdScanCode
	{
	EStdKeyNull=0x00,
	EStdKeyBackspace=0x01,
	EStdKeyTab=0x02,
	EStdKeyEnter=0x03,
	EStdKeyEscape=0x04,
	EStdKeySpace=0x05,
	EStdKeyPrintScreen=0x06,
	EStdKeyPause=0x07,
	EStdKeyHome=0x08,
	EStdKeyEnd=0x09,
	EStdKeyPageUp=0x0a,
	EStdKeyPageDown=0x0b,
	EStdKeyInsert=0x0c,
	EStdKeyDelete=0x0d,
	EStdKeyLeftArrow=0x0e,
	EStdKeyRightArrow=0x0f,
	EStdKeyUpArrow=0x10,
	EStdKeyDownArrow=0x11,
	EStdKeyLeftShift=0x12,
	EStdKeyRightShift=0x13,
	EStdKeyLeftAlt=0x14,
	EStdKeyRightAlt=0x15,
	EStdKeyLeftCtrl=0x16,
	EStdKeyRightCtrl=0x17,
	EStdKeyLeftFunc=0x18,
	EStdKeyRightFunc=0x19,
	EStdKeyCapsLock=0x1a,
	EStdKeyNumLock=0x1b,
	EStdKeyScrollLock=0x1c,
	EStdKeyF1=0x60,
	EStdKeyF2=0x61,
	EStdKeyF3=0x62,
	EStdKeyF4=0x63,
	EStdKeyF5=0x64,
	EStdKeyF6=0x65,
	EStdKeyF7=0x66,
	EStdKeyF8=0x67,
	EStdKeyF9=0x68,
	EStdKeyF10=0x69,
	EStdKeyF11=0x6a,
	EStdKeyF12=0x6b,
	EStdKeyF13=0x6c,
	EStdKeyF14=0x6d,
	EStdKeyF15=0x6e,
	EStdKeyF16=0x6f,
	EStdKeyF17=0x70,
	EStdKeyF18=0x71,
	EStdKeyF19=0x72,
	EStdKeyF20=0x73,
	EStdKeyF21=0x74,
	EStdKeyF22=0x75,
	EStdKeyF23=0x76,
	EStdKeyF24=0x77,
	EStdKeyXXX=0x78,
	EStdKeyComma=0x79,
	EStdKeyFullStop=0x7a,
	EStdKeyForwardSlash=0x7b,
	EStdKeyBackSlash=0x7c,
	EStdKeySemiColon=0x7d,
	EStdKeySingleQuote=0x7e,
	EStdKeyHash=0x7f,
	EStdKeySquareBracketLeft=0x80,
	EStdKeySquareBracketRight=0x81,
	EStdKeyMinus=0x82,
	EStdKeyEquals=0x83,
	EStdKeyNkpForwardSlash=0x84,
	EStdKeyNkpAsterisk=0x85,
	EStdKeyNkpMinus=0x86,
	EStdKeyNkpPlus=0x87,
	EStdKeyNkpEnter=0x88,
	EStdKeyNkp1=0x89,
	EStdKeyNkp2=0x8a,
	EStdKeyNkp3=0x8b,
	EStdKeyNkp4=0x8c,
	EStdKeyNkp5=0x8d,
	EStdKeyNkp6=0x8e,
	EStdKeyNkp7=0x8f,
	EStdKeyNkp8=0x90,
	EStdKeyNkp9=0x91,
	EStdKeyNkp0=0x92,
	EStdKeyNkpFullStop=0x93,
    EStdKeyMenu=0x94,
    EStdKeyBacklightOn=0x95,
    EStdKeyBacklightOff=0x96,
    EStdKeyBacklightToggle=0x97,
    EStdKeyIncContrast=0x98,
    EStdKeyDecContrast=0x99,
    EStdKeySliderDown=0x9a,
    EStdKeySliderUp=0x9b,
    EStdKeyDictaphonePlay=0x9c,
    EStdKeyDictaphoneStop=0x9d,
    EStdKeyDictaphoneRecord=0x9e,
    EStdKeyHelp=0x9f,
    EStdKeyOff=0xa0,
    EStdKeyDial=0xa1,
    EStdKeyIncVolume=0xa2,
    EStdKeyDecVolume=0xa3,
    EStdKeyDevice0=0xa4,
    EStdKeyDevice1=0xa5,
    EStdKeyDevice2=0xa6,
    EStdKeyDevice3=0xa7,
    EStdKeyDevice4=0xa8,
    EStdKeyDevice5=0xa9,
    EStdKeyDevice6=0xaa,
    EStdKeyDevice7=0xab,
    EStdKeyDevice8=0xac,
    EStdKeyDevice9=0xad,
    EStdKeyDeviceA=0xae,
    EStdKeyDeviceB=0xaf,
    EStdKeyDeviceC=0xb0,
    EStdKeyDeviceD=0xb1,
    EStdKeyDeviceE=0xb2,
    EStdKeyDeviceF=0xb3,
    EStdKeyApplication0=0xb4,
    EStdKeyApplication1=0xb5,
    EStdKeyApplication2=0xb6,
    EStdKeyApplication3=0xb7,
    EStdKeyApplication4=0xb8,
    EStdKeyApplication5=0xb9,
    EStdKeyApplication6=0xba,
    EStdKeyApplication7=0xbb,
    EStdKeyApplication8=0xbc,
    EStdKeyApplication9=0xbd,
    EStdKeyApplicationA=0xbe,
    EStdKeyApplicationB=0xbf,
    EStdKeyApplicationC=0xc0,
    EStdKeyApplicationD=0xc1,
    EStdKeyApplicationE=0xc2,
    EStdKeyApplicationF=0xc3,
	EStdKeyYes=0xc4,
	EStdKeyNo=0xc5,
	EStdKeyIncBrightness=0xc6,
	EStdKeyDecBrightness=0xc7,
	EStdKeyKeyboardExtend=0xc8 
	};

enum TKeyCode
	{
	EKeyNull=0x0000,
	EKeyBell=0x0007,
	EKeyBackspace=0x0008,
	EKeyTab=0x0009,
	EKeyLineFeed=0x000a,
	EKeyVerticalTab=0x000b,
	EKeyFormFeed=0x000c,
	EKeyEnter=0x000d,
	EKeyEscape=0x001b,
	EKeySpace=0x0020,
	EKeyDelete=0x007f,
	EKeyPrintScreen= 0xf800 ,
	EKeyPause,
	EKeyHome,
	EKeyEnd,
	EKeyPageUp,
	EKeyPageDown,
	EKeyInsert,
	EKeyLeftArrow,
	EKeyRightArrow,
	EKeyUpArrow,
	EKeyDownArrow,
	EKeyLeftShift,
	EKeyRightShift,
	EKeyLeftAlt,
	EKeyRightAlt,
	EKeyLeftCtrl,
	EKeyRightCtrl,
	EKeyLeftFunc,
	EKeyRightFunc,
	EKeyCapsLock,
	EKeyNumLock,
	EKeyScrollLock,
	EKeyF1,
	EKeyF2,
	EKeyF3,
	EKeyF4,
	EKeyF5,
	EKeyF6,
	EKeyF7,
	EKeyF8,
	EKeyF9,
	EKeyF10,
	EKeyF11,
	EKeyF12,
	EKeyF13,
	EKeyF14,
	EKeyF15,
	EKeyF16,
	EKeyF17,
	EKeyF18,
	EKeyF19,
	EKeyF20,
	EKeyF21,
	EKeyF22,
	EKeyF23,
	EKeyF24,
    EKeyOff,
    EKeyIncContrast,
    EKeyDecContrast,
    EKeyBacklightOn,
    EKeyBacklightOff,
    EKeyBacklightToggle,
    EKeySliderDown,
    EKeySliderUp,
    EKeyMenu,
    EKeyDictaphonePlay,
    EKeyDictaphoneStop,
    EKeyDictaphoneRecord,
    EKeyHelp,
    EKeyDial,
	EKeyScreenDimension0,
	EKeyScreenDimension1,
	EKeyScreenDimension2,
	EKeyScreenDimension3,
	EKeyIncVolume,
	EKeyDecVolume,
	EKeyDevice0,
	EKeyDevice1,
	EKeyDevice2,
	EKeyDevice3,
	EKeyDevice4,
	EKeyDevice5,
	EKeyDevice6,
	EKeyDevice7,
	EKeyDevice8,
	EKeyDevice9,
	EKeyDeviceA,
	EKeyDeviceB,
	EKeyDeviceC,
	EKeyDeviceD,
	EKeyDeviceE,
	EKeyDeviceF,
	EKeyApplication0,
	EKeyApplication1,
	EKeyApplication2,
	EKeyApplication3,
	EKeyApplication4,
	EKeyApplication5,
	EKeyApplication6,
	EKeyApplication7,
	EKeyApplication8,
	EKeyApplication9,
	EKeyApplicationA,
	EKeyApplicationB,
	EKeyApplicationC,
	EKeyApplicationD,
	EKeyApplicationE,
	EKeyApplicationF,
	EKeyYes,
	EKeyNo,
	EKeyIncBrightness,
	EKeyDecBrightness,
	EKeyKeyboardExtend
	};



# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32hal.h" 1
 
 
 
 
 









const TInt KMaxRomDevices=8;

enum TDigitizerCalibrationType
    {
    EFactory,
    ESaved
    };

class TDigitizerCalibration
    {
public:
    TPoint iTl;
    TPoint iBl;
    TPoint iTr;
    TPoint iBr;
    };

 







enum TMachineStartupType
	{
	EStartupCold,EStartupColdReset,EStartupNewOs,
	EStartupPowerFail,EStartupWarmReset,EStartupKernelFault,
	EStartupSafeReset
	};

 





enum TXYInputType
	{
	EXYInputNone,
	EXYInputPointer,
	EXYInputMouse,
	EXYInputDeltaMouse
	};

 





class TMachineInfoV1
	{
public:
	TVersion iRomVersion;
	TXYInputType iXYInputType;
	TBool iKeyboardPresent;
	TBool iBacklightPresent;
    TSize iDisplaySizeInPixels;
    TSize iXYInputSizeInPixels;
    TSize iPhysicalScreenSize;
	TPoint iOffsetToDisplayInPixels;
	TInt iKeyboardId;
	TInt iDisplayId;
	TInt64 iMachineUniqueId;
    TUint iLedCapabilities;
    TInt iProcessorClockInKHz;
    TInt iSpeedFactor;
    TInt iMaximumDisplayColors;
	};
typedef TPckgBuf<TMachineInfoV1> TMachineInfoV1Buf;

 





class TMachineInfoV2 : public TMachineInfoV1
	{
public:
	TInt iLanguageIndex;
    TInt iKeyboardIndex;
    };
typedef TPckgBuf<TMachineInfoV2> TMachineInfoV2Buf;

 





class TMemoryInfoV1
    {
public:
    TInt iTotalRamInBytes;
    TInt iTotalRomInBytes;
    TInt iMaxFreeRamInBytes;
    TInt iFreeRamInBytes;
    TInt iInternalDiskRamInBytes;
    TBool iRomIsReprogrammable;
    };
typedef TPckgBuf<TMemoryInfoV1> TMemoryInfoV1Buf;

 





class TRomInfoEntryV1
	{
public:
    enum TRomTypeV1
    	{
    	ERomTypeRom=0,
    	ERomTypeFlash=1
    	};
	TInt iSize;		     
	TInt iWidth;		 
	TInt iSpeed;		 
	TRomTypeV1 iType;	 
	};

 





class TRomInfoV1
	{
public:
	TRomInfoEntryV1	iEntry[KMaxRomDevices];
	};
typedef TPckgBuf<TRomInfoV1> TRomInfoV1Buf;

const TUint KRuggedFileSystem=0x01;
class TDriveInfoV1
    {
public:
	TInt iTotalSupportedDrives;
	TInfoName iDriveName[KMaxLocalDrives];
	TInt iTotalSockets;
	TInfoName iSocketName[KMaxPBusSockets];
	TInt iRuggedFileSystem;
	};
typedef TPckgBuf<TDriveInfoV1> TDriveInfoV1Buf;

class TExcInfo
	{
public:
	TAny *iCodeAddress;
	TAny *iDataAddress;
	TInt iExtraData;
	};

 





class UserHal
	{
public:
	  static TInt MachineInfo(TDes8& anInfo);
	  static TInt MemoryInfo(TDes8& anInfo);
	  static TInt DriveInfo(TDes8& anInfo);
	  static TInt RomInfo(TDes8& anInfo);
	  static TInt StartupReason(TMachineStartupType& aReason);
	  static TInt FaultReason(TInt &aReason);
	  static TInt ExceptionId(TInt &anId);
	  static TInt ExceptionInfo(TExcInfo &aInfo);
	  static TInt PageSizeInBytes(TInt& aSize);
	  static TInt TickPeriod(TTimeIntervalMicroSeconds32& aPeriod);
   	  static TInt SwitchOff();
	  static TInt SetXYInputCalibration(const TDigitizerCalibration& aCalibration);
	  static TInt CalibrationPoints(TDigitizerCalibration& aCalibration);
	  static TInt SaveXYInputCalibration();
	  static TInt RestoreXYInputCalibration(TDigitizerCalibrationType aType);
	};


# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32pccd.h" 1
 
 
 
 
 









typedef signed int TSocket;

 
enum TMediaDevice
	{EFixedMedia0,EFixedMedia1,EFixedMedia2,EFixedMedia3,
	EFixedMedia4,EFixedMedia5,EFixedMedia6,EFixedMedia7,
	ERemovableMedia0,ERemovableMedia1,ERemovableMedia2,ERemovableMedia3,EInvalidMedia};



class TLDriveAssignInfo
	{
public:
	TMediaDevice iDevice;
	TInt iPriority;
	};

class TMediaDeviceAssignInfo
	{
public:
	TInt iFirstMedia;
	TInt iLastMedia;	
	};



# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 2


 
 
 
class TRealTimeThreadCreate
	{
public:
	TThreadFunction iFunction;
	TInt iStackSize;
	TInt iHeapSize;
	TAny *iPtr;
	TInt iHandle;
	TInt iSpare;
	};
 
 
 
const TInt KLoaderMajorVersionNumber=1;
const TInt KLoaderMinorVersionNumber=0;
 
const TInt KFormatSectorSize=0x00000200;		 
const TInt KFormatSectorShift=9;	
const TUint KFormatSectorMask=0xFFFFFE00;
 
enum TBlockType {EBlocked,EUnBlocked,ERelease};
 
class TRawEvent
	{
public:
	enum TType
		{
		ENone,
		EPointerMove,
        EPointerSwitchOn,
		EKeyDown,EKeyUp,
		ERedraw,
		ESwitchOn,
        EActive,
		EInactive,
		EUpdateModifiers,
		EButton1Down,EButton1Up,
		EButton2Down,EButton2Up,
		EButton3Down,EButton3Up,
		ESwitchOff, EKeyRepeat,
		ECaseOpen, ECaseClose
		};
public:
	inline TRawEvent()
		: iType(ENone)
		{}
	inline TType Type() const
		{return iType;}
	  TPoint Pos() const;
	  TInt ScanCode() const;
      TInt Modifiers() const;
	inline TUint Ticks() const
		{return iTicks;}
	  void Set(TType aType,TInt aScanCode);
	  void Set(TType aType,TInt aX,TInt aY);
	  void Set(TType aType);
protected:
	TType iType;
	TUint iTicks;
	union
		{
		struct {TInt x;TInt y;} pos;
		TInt scanCode;
		TInt modifiers;
		} iU;
	};
 
class TRawEventBuf : public TPckgBuf<TRawEvent>
	{
public:
	inline TRawEvent &Event() const {return(*((TRawEvent *)&iBuf[0]));}
	};
 
class TScreenInfoV01
	{
public:
	TBool iWindowHandleValid;
	TAny *iWindowHandle;
	TBool iScreenAddressValid;
	TAny *iScreenAddress;
	TSize iScreenSize;
	};
 
enum TLoaderMsg {ELoadProcess=1,ELoadLibrary=2};
 
class RLoader : public RSessionBase
	{
public:
	  TInt Connect();
	TVersion Version() const;
	TInt LoadProcess(TInt &aHandle,const TDesC &aFileName,const TDesC &aCommand,const TUidType &aUidType, TOwnerType aType);
	  TInt LoadLibrary(TInt &aHandle,const TDesC &aFileName,const TDesC &anExt, const TDesC &aPath, const TUidType &aType);
	};
 
class TLoaderInfo
	{
public:
	  TLoaderInfo();
public:
	TUidType iType;
	TUint32 iCheck;
	TUint32 iCheckSumCode;
	TInt iCodeSize;
	TInt iDataSize;
	TInt iHeapSizeMin;
	TInt iHeapSizeMax;
	TInt iStackSize;
	TInt iBssSize;
	TUint iEntryPoint;
	TDllRefTable* iDllRefTable;
	TInt iDllRefTableCount;
	TUint iExportDir;
	TInt iExportDirCount;
	TUint iTargetCodeAddress;
	TUint32 iTargetCodeBase;
	TUint iTargetDataAddress;
	TUint32 iTargetDataBase;
	TFileName iFileName;
	TFileName iRootName;
	TPath iPath;
	TBool isLoadedFromRam;
	TBool isDll;
	TBool isAlreadyLoaded;
	TInt iHandle;
	TInt iThreadHandle;
	TInt iProcessHandle;  
	TInt iLibraryHandle;  
	TUint iHandleMask;
	TProcessPriority iPriority;
	TInt iTextSize;
	TAny *iLibPtr;		 
	};
 

enum TNotifierMessage 
	{
	ENotifierNotify,
	ENotifierInfoPrint,
	EStartNotifier,
	ECancelNotifier,
	EUpdateNotifier,
	EStartNotifierAndGetResponse,
	EStartNotifierFromSpecifiedDll,
	EStartNotifierFromSpecifiedDllAndGetResponse,
	ENotifierNotifyCancel,
	ENotifierNotifySync,
	};
 
class TBusDevOpenModeData
   {
public:
   	inline TBusDevOpenModeData(const TDesC &aDeviceName,TInt aUnit) 
	: iDeviceName(aDeviceName), iUnit(aUnit) {}
public:
	const TDesC &iDeviceName;
	TInt iUnit;
   	};
 
class TLocalDriveCaps
	{
public:
	  TLocalDriveCaps();
public:
	TInt64 iSize;
	TMediaType iType;
	TBatteryState iBattery;
	TUint iDriveAtt;
	TUint iMediaAtt;
    TUint8* iBaseAddress;
	TUint iFileSystemId;
	};
typedef TPckgBuf<TLocalDriveCaps> TLocalDriveCapsBuf;
 
class TLocalDriveCapsV2 : public TLocalDriveCaps
	{
public:
	TUint iHiddenSectors;
	TUint iEraseBlockSize;
    };
typedef TPckgBuf<TLocalDriveCapsV2> TLocalDriveCapsV2Buf;
 
class TLDFormatInfo
	{
public:
	TInt64 iCapacity;
	TUint16 iSectorsPerCluster;
	TUint16 iSectorsPerTrack;
	TUint16 iNumberOfSides;
	enum TFATBits {EFBDontCare, EFB12 = 12, EFB16 = 16};
	TFATBits iFATBits;
	};
 
class TLocalDriveCapsV3 : public TLocalDriveCapsV2
	{
public:
	TLDFormatInfo iFormatInfo;
    };
typedef TPckgBuf<TLocalDriveCapsV3> TLocalDriveCapsV3Buf;
 
class TLocalDriveCapsV4 : public TLocalDriveCapsV3
	{
public:
	TInt iPrefFormatSizeInBytes;
    };
typedef TPckgBuf<TLocalDriveCapsV4> TLocalDriveCapsV4Buf;
 
class TFormatInfo
	{
public:
	  TFormatInfo();
public:
	TBool iFormatIsCurrent;
	TInt i512ByteSectorsFormatted; 
	};
 
class TLocalDriveData
	{
public:
	TLocalDriveData(TInt64& aPos,TInt *aLength) : iPos(aPos), iLength(aLength) {}
public:
	TInt64 iPos;
	TInt *iLength;
	};
 
class TLocalDriveMessageData
	{
public:
	TLocalDriveMessageData(const TAny* aPtr,TInt aHandle,TInt anOffset) : iPtr(aPtr), iHandle(aHandle), iOffset(anOffset) {}
public:
	const TAny* iPtr;
	TInt iHandle;
	TInt iOffset;
	};
 
class TPBusPasswordData
	{
public:
	TDesC8 *iCurrentPassword;
	TDesC8 *iNewPassword;
	TBool iStorePassword;
	};
typedef TPckgBuf<TPBusPasswordData> TPBusPasswordDataPckg;
 
 
 
const TUint KLocDrvRemountForceMediaChange=0x00000001;
const TUint KLocDrvRemountPostponeRemount=0x00000010;
const TUint KLocDrvRemountKernelSideFlags=0x0000000F;
const TUint KLocDrvRemountReserved=0xFFFF0000;
 
class TBusLocalDrive : public MBusDev
	{
public:
	  TBusLocalDrive();
	  TInt Connect(TInt aDriveNumber,TBool &aChangedFlag);
	  void Disconnect();
	  TInt Enlarge(TInt aLength);
	  TInt ReduceSize(TInt aPos,TInt aLength);
	  TInt Read(TInt64 aPos,TInt aLength,const TAny* aTrg,TInt aThreadHandle,TInt anOffset);
	  TInt Read(TInt64 aPos,TInt aLength,TDes8& aTrg);
	  TInt Write(TInt64 aPos,TInt aLength,const TAny* aSrc,TInt aThreadHandle,TInt anOffset);
	  TInt Write(TInt64 aPos,const TDesC8& aSrc);
	  TInt Caps(TDes8& anInfo);
	  TInt Format(TFormatInfo &anInfo);
	  TInt Format(TInt64 aPos,TInt aLength);
	  TInt SetMountInfo(const TDesC8* aMountInfo,TInt aMountInfoThreadHandle=KCurrentThreadHandle);
	  TInt ForceRemount(TUint aFlags=0);

	  TInt Unlock(TMediaPassword &aPassword, TBool aStorePassword);
	  TInt Lock(TMediaPassword &aOldPassword, TMediaPassword &aNewPassword, TBool aStorePassword);
	  TInt Clear(TMediaPassword &aPassword);
	  static TInt ReadPasswordData(TDes8 &aBuf);
	  static TInt WritePasswordData(TDesC8 &aBuf);
	  static TInt PasswordStoreLengthInBytes();
	  TInt ControlIO(TInt aCommand,TAny* aParam1, TAny* aParam2);
	  TInt ErasePassword();
private:
	TInt CheckMount();
    void Open(TInt aStartResult);
private:
	TAny *iDrive;
	};
 
struct TFatUtilityFunctions;  
class UserExec
	{
public:
	  static const TFatUtilityFunctions* FatUtilityFunctions();
	};
 
class UserSvr
	{
public:
	  static void InitRegisterCallback(TCallBack aCallBack, TInt aPriority);
	  static void CaptureEventHook();
	  static void ReleaseEventHook();
	  static void RequestEvent(TRawEventBuf &anEvent,TRequestStatus &aStatus);
	  static void RequestEventCancel();
	  static TInt AddEvent(const TRawEvent& anEvent);
	  static void ScreenInfo(TDes8& anInfo);
 
	  static TInt DllGlobalAlloc(TInt aHandle,TInt aSize);
	  static TBool DllGlobalAllocated(TInt aHandle);
	  static TInt DllGlobalRead(TInt aHandle,TInt aPos,TInt aLength,TDes8 &aDes);
	  static TInt DllGlobalWrite(TInt aHandle,TInt aPos,const TDesC8 &aDes);
	  static TInt DllSetTls(TInt aHandle,TAny *aPtr);
	  static TAny *DllTls(TInt aHandle);
	  static void DllFreeTls(TInt aHandle);
	  static TInt DllInitialiseData(TInt aHandle);
	  static void DllFreeData(TInt aHandle);
	  static void DllFileName(TInt aHandle, TDes &aFileName);
 
	  static void KernelStartup(TThreadFunction aFunction);
	  static void FsRegisterThread(TThreadFunction aFileServer);
	  static void WsRegisterThread(TThreadFunction aWindowServer);
	  static void ServerStarted();
	  static void BlockThreads(TBlockType aType);
 
	  static TInt ProcessCreate(TLoaderInfo &anInfo, HBufC *aCommand);
	  static void ProcessLoaded(TLoaderInfo &anInfo);
	  static TInt LibraryCreateExact(TLoaderInfo &anInfo);
	  static TInt LibraryLoaded(TLoaderInfo &anInfo);
 
	static TInt StaticCallList(TInt aHandle, TInt& aCount, TUint*& aList);
	static TInt DynamicCallList(TInt aHandle, TInt& aCount, TUint*& aList);
 
      static TBool TestBootSequence();
 
      static void WsRegisterSwitchOnScreenHandling(TBool aState);
      static void WsSwitchOnScreen();
 
      static TInt ChangeLocale(RLibrary aLibrary);   
 
	  static TInt DllAddDependency(TAny *anImportingDll, TAny *anExportingDll);
	  static TInt ExeAddDependency(TAny *anImportingExe, TAny *anExportingDll);
	  static TInt ResetMachine(TMachineStartupType aType);
	  static void UnlockRamDrive();
	  static void LockRamDrive();
	  static TUint32 RomRootDirectoryAddress();

	  static void ForceRemountMedia(TMediaDevice aDevice);
	  static TInt MediaChangeNotify(TMediaDevice aDevice,TRequestStatus *aReqStat);
	  static TUint32 RomHeaderAddress();
	  static TUint32 DebugMask();  

	  static TInt HalGet(TInt aFunction, TAny* aParam);
	  static TInt HalSet(TInt aFunction, TAny* aParam);

	  static TInt SetMemoryThresholds(TInt aLowThreshold, TInt aGoodThreshold);
	};
 
class TMaskedModifiers
	{
public:
	TUint iMask;
	TUint iValue;
	};
 
enum TPattern
	{
	EAnyKey=0x00,
	EAnyAlphaNumeric,
	EAnyAlpha,
	EAnyAlphaLowerCase,
	EAnyAlphaUpperCase,
	EAnyDecimalDigit,
	EAnyDigitGivenRadix,
	EAnyModifierKey,
	EMatchKey=0x40,
	EMatchKeyCaseInsens,
	EMatchLeftOrRight
	};
 
class TKeyCodePattern
	{
public:
	TUint16 iKeyCode;
	TInt8   iPattern;
	TInt8   iFiller;
	};
 
class TCaptureKey
	{
public:
	TMaskedModifiers iModifiers;
	TKeyCodePattern  iKeyCodePattern;
	TUint iApp;
	TUint iHandle;
	};
 
class TKeyData
	{
public:
	TInt  iModifiers;
	TInt  iApp;
	TInt  iHandle;
	TBool iIsCaptureKey;
	TUint iKeyCode;
	};
 
class CCaptureKeys: public CBase
	{
public:
	  CCaptureKeys();
	  ~CCaptureKeys();
	  void Construct();
	  void AddCaptureKeyL(const TCaptureKey &aCaptureKey);
	  void AddCaptureKeyL(const TCaptureKey &aCaptureKey, TUint8 aPriority);
	  void SetCaptureKey(TUint32 aHandle, const TCaptureKey &aCaptureKey);
	  void SetCaptureKey(TUint32 aHandle, const TCaptureKey &aCaptureKey, TUint8 aPriority);
	  void CancelCaptureKey(TUint32 aHandle);
	  void CancelAllCaptureKeys(TUint32 aApp);
	  void ProcessCaptureKeys(TKeyData &aKeyData) const;
protected:
	void CheckCaptureKey(const TCaptureKey &aCaptureKey);
	void removeCaptureKey(TUint index);
protected:
	RArray<TCaptureKey> iCKarray;
	};
 
class CKeyTranslator: public CBase
	{
public:
	  static CKeyTranslator *New();
	virtual TInt GetModifierState()=0;
	virtual void SetModifierState(TEventModifier aModifier,TModifierState aState)=0;
	virtual TBool TranslateKey(TUint aScanCode,TBool aKeyUp,const CCaptureKeys &aCaptureKeys,TKeyData &aKeyData)=0;
    virtual void UpdateModifiers(TInt aModifiers)=0;
    virtual TInt ChangeKeyData(const TDesC& aLibraryName)=0;
	};
 
enum TDebugExceptionType
    {
    EPanic,
    EBreakPoint,
    EException,
	ENewThread
    };
 
class DThread;
 
const TInt KMaxProfiles=64;
 
class TProfile
    {
public:
    TInt iTime;
    TInt iCount;
    };
 
struct SDebugInfo
    {
    TBuf<0x20> iCategory;
    TFullName iName;
    TThreadId iId;
    TUint iCodeAddr;
	TUint iDataAddr;
    TUint iBssSize;
    TUint iCodeSize;
    TInt iPanicType;
    TDebugExceptionType iDebugType;
    };
 
struct SRegisterInfo
    {
    TInt iNumberOfPcRegister;
    TInt iNumberOfStatusRegister;
    TInt iNumberOfRegisters;
    TInt iThreadStartRegister;
    };
 
enum TDebugFunctionNo
    {
    EDebugFunctionContinue,
    EDebugFunctionSingleStep,
    EDebugFunctionGetRegister,
    EDebugFunctionSetRegister,
    EDebugFunctionSetBreakPoint,
    EDebugFunctionClrBreakPoint,
    EDebugFunctionSetWatchPoint,
    EDebugFunctionClrWatchPoint,
    EDebugFunctionReadMemory,
    EDebugFunctionWriteMemory,
    EDebugFunctionGetException,
    EDebugFunctionSuspendThread,
    EDebugFunctionRegisterInfo,
    EDebugFunctionSupervisorMode,
    EDebugFunctionPrint,
    EDebugFunctionProfileResult,
    EDebugFunctionProfileReset,
	EDebugFunctionFault,
	EDebugFunctionReadXtalError,
	EDebugFunctionSetXtalError,
    EDebugFunctionResumeThread,
    };
 
class TDebugFunction
    {
public:
    TDebugFunctionNo iFunction;		 
    TThreadId iThread;				 
    };
 
class RDebug
	{
public:
      static TInt Open(TInt aMaxBreak=16,TInt aMaxWatch=16,TInt aMaxPanic=16,TUint aDebugLimit=0x50000000);
      static TInt Close();
      static TInt SetBreakPoint(const TThreadId aId,TUint aAddr);
      static TInt SetBreakPoint(const TThreadId aId,TUint32 aAddr, TUint32 aFlags, TUint32 aCpuInfo);
      static TInt ClrBreakPoint(const TThreadId aId,TUint aAddr);
      static TInt SetWatchPoint(const TThreadId aId,TUint aAddr,TInt aLength);
      static TInt ClrWatchPoint(const TThreadId aId,TUint aAddr);
      static TInt GetRegister(const TThreadId aId,TInt aReg,TUint& aValue);
      static TInt SetRegister(const TThreadId aId,TInt aReg,TUint aValue);
      static TInt Continue(const TThreadId aId);
      static TInt SingleStep(const TThreadId aId);
      static TInt GetException(SDebugInfo& aReason,TRequestStatus& aStatus);
      static void CancelGetException();
      static TInt ReadMemory(const TThreadId aId,TUint aAddr,TDes8& aDes,TInt aLength);
      static TInt WriteMemory(const TThreadId aId,TUint aAddr,TDesC8& aDes,TInt aLength);
      static TInt KillThread(const TThreadId aId);
      static TInt RegisterInfo(SRegisterInfo& aInfo);
      static TInt Print(TRefByValue<const TDesC> aFmt,...);
	  static TInt RawPrint(const TDesC& aDes);
      static TInt SupervisorMode(TBool aState);
      static TInt Fault(TInt aFault);
      static TInt ProfileResult(TProfile* aProfile,TInt aStart,TInt aCount);
      static TInt ProfileReset(TInt aStart,TInt aCount);
      static TInt ProfileStart(TInt aProfile);
      static TInt ProfileEnd(TInt aProfile);
      static TInt SuspendThread(const TThreadId aId);
	  static TInt ReadXtalError();
	  static void SetXtalError(TInt anError);
      static TInt ResumeThread(const TThreadId aId);
};
 
const TInt KMaxLocaleMessageText=0x80;
 
enum TLocaleMessage
	{
	EFileServer_Button1,
	EFileServer_Button2,
	EFileServer_PutTheCardBackLine1,
	EFileServer_PutTheCardBackLine2,
	EFileServer_LowPowerLine1,
	EFileServer_LowPowerLine2,
	EFileServer_DiskErrorLine1,
	EFileServer_DiskErrorLine2,
	ESoundDriver_Chimes,
	ESoundDriver_Rings,
	ESoundDriver_Signal,
	EMediaDriver_DiskNameInternal,
	EMediaDriver_DiskNameExternal1,
	EMediaDriver_DiskNameExternal2,
	EMediaDriver_DiskNameExternal3,
	EMediaDriver_DiskNameExternal4,
	EMediaDriver_DiskNameExternal5,
	EMediaDriver_DiskNameExternal6,
	EMediaDriver_DiskNameExternal7,
	EMediaDriver_DiskNameExternal8,
	EMediaDriver_SocketName0,
	EMediaDriver_SocketName1,
	EMediaDriver_SocketName2,
	EMediaDriver_SocketName3,
	ELocaleMessages_LastMsg
	};

class TLocaleMessageText : public TBuf<KMaxLocaleMessageText>
	{
public:
	  TLocaleMessageText();
	  TLocaleMessageText(TLocaleMessage aMessageNo);
	  void Set(TLocaleMessage aMessageNo);
	};

class TModuleInfo
	{
public:
	TInt iCodeSize;
	TInt iConstDataSize;
	TInt iDataSize;
	TInt iBssSize;
	TUint8 *iCodeRunAddress;
	TUint8 *iCodeHomeAddress;
	TUint8 *iDataRunAddress;
	TUint8 *iDataHomeAddress;
	};





# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 2





 
const TInt KDefaultDrive=KMaxTInt;
const TInt KDriveAbsent=0x00;
const TInt KFileServerDefaultMessageSlots=4;
const TInt KEntryArraySize=(0x200*sizeof(TText));
const TInt KPathDelimiter='\\';
const TInt KDriveDelimiter=':';
const TInt KExtDelimiter='.';
 
const TInt KMaxDrives=26;
typedef TBuf8<KMaxDrives> TDriveList;
const TInt KMaxDriveName=0x02;
typedef TBuf<KMaxDriveName> TDriveName;
 
const TUint KEntryAttNormal=0x0000;
const TUint KEntryAttReadOnly=0x0001;
const TUint KEntryAttHidden=0x0002;
const TUint KEntryAttSystem=0x0004;
const TUint KEntryAttVolume=0x0008;
const TUint KEntryAttDir=0x0010;
const TUint KEntryAttArchive=0x0020;
const TUint KEntryAttMatchMask=(KEntryAttHidden|KEntryAttSystem|KEntryAttDir);
const TUint KEntryAttMaskSupported=0x3f;
 
const TUint KEntryAttMatchExclusive=0x40000000;
const TUint KEntryAttMatchExclude=0x08000000;
const TUint KEntryAttAllowUid=0x10000000;
 
const TUint KDebugNotifyMask=0xFF000000;  
enum TNotifyType {ENotifyEntry=0x00,ENotifyAll=0x01,ENotifyFile=0x04,ENotifyDir=0x08,
				  ENotifyAttributes=0x10,ENotifyWrite=0x20,ENotifyDisk=0x40};

 
enum TDriveNumber
	{
	EDriveA,   EDriveB,   EDriveC,   EDriveD,   EDriveE,
	EDriveF,   EDriveG,   EDriveH,   EDriveI,   EDriveJ,
	EDriveK,   EDriveL,   EDriveM,   EDriveN,   EDriveO, 
	EDriveP,   EDriveQ,   EDriveR,   EDriveS,   EDriveT,
	EDriveU,   EDriveV,   EDriveW,   EDriveX,   EDriveY,
	EDriveZ
	};
 
enum TEntryKey
	{
	ESortNone=0,ESortByName,ESortByExt,ESortBySize,ESortByDate,ESortByUid,
	EDirsAnyOrder=0,EDirsFirst=0x100,EDirsLast=0x200,
	EAscending=0,EDescending=0x400,EDirDescending=0x800
	};
 
enum TFileMode
	{
	EFileShareExclusive,EFileShareReadersOnly,EFileShareAny,
	EFileStream=0,EFileStreamText=0x100,
	EFileRead=0,EFileWrite=0x200
	};
 
const TUint KFileShareMask=0xff;
const TUint KFileNotShareMask = 0xffffff00;
 
enum TFormatMode 
	{
	EHighDensity,ELowDensity,
	EFullFormat=0,EQuickFormat=0x100,ESpecialFormat=0x200
	};
 
enum TSeek {ESeekAddress,ESeekStart,ESeekCurrent,ESeekEnd};
 
class TEntry
	{
public:
	  TEntry();
	  TEntry(const TEntry& aEntry);
	  TEntry& operator=(const TEntry& aEntry);
	  TBool IsReadOnly() const;
	  TBool IsHidden() const;
	  TBool IsSystem() const;
	  TBool IsDir() const;
	  TBool IsArchive() const;
	inline const TUid& operator[](TInt anIndex) const;
	inline TBool IsUidPresent(TUid aUid) const;
	inline TBool IsTypeValid() const;
	inline TUid MostDerivedUid() const;
public:
	TUint iAtt;
	TInt iSize;
	TTime iModified;
	TUidType iType;
	TBufC<KMaxFileName> iName;
	};
 
class TEntryArray
	{
public:
	  TEntryArray();
	  TInt Count() const;
	  const TEntry& operator[](TInt anIndex) const;
private:
	TInt iCount;
	TInt iIndex;
	const TEntry* iPos;
	TBuf8<KEntryArraySize> iBuf;
	friend class RDir;
	friend class RFs;
	};
 
class TDriveInfo
	{
public:
	TMediaType iType;
	TBatteryState iBattery;
	TUint iDriveAtt;
	TUint iMediaAtt;
	};
 
class TVolumeInfo
	{
public:
	  TVolumeInfo();
	TDriveInfo iDrive;
	TUint iUniqueID;
	TInt64 iSize;
	TInt64 iFree;
	TBufC<KMaxFileName> iName;
	};
 
class TDriveUnit
	{
public:
	inline TDriveUnit() {};
	  TDriveUnit(TInt aDrive);
	  TDriveUnit(const TDesC& aDrive);
	  TDriveUnit& operator=(TInt aDrive);
	  TDriveUnit& operator=(const TDesC& aDrive);
	inline operator TInt() const;
	  TDriveName Name() const;
private:
	TInt iDrive;
	};
 
class RFs;
 
class TParseBase
	{
private:
	struct SField {TUint8 pos;TUint8 len;TUint8 present;TUint8 filler;};
	enum TField {EDrive,EPath,EName,EExt,EMaxFields};
	enum TWild {EWildName=0x01,EWildExt=0x02,EWildEither=0x04,EIsRoot=0x08,EWildIsKMatchOne=0x10,EWildIsKMatchAny=0x20};
public:
	  TParseBase();
	  TInt PopDir();
	  TInt AddDir(const TDesC& aName);
	  const TDesC& FullName() const;
	  TPtrC Drive() const;
	  TPtrC Path() const;
	  TPtrC DriveAndPath() const;
	  TPtrC Name() const;
	  TPtrC Ext() const;
	  TPtrC NameAndExt() const;
	  TBool DrivePresent() const;
	  TBool PathPresent() const;
	  TBool NamePresent() const;
	  TBool ExtPresent() const;
	  TBool NameOrExtPresent() const;
	  TBool IsRoot() const;
	  TBool IsWild() const;
	  TBool IsKMatchOne() const;
	  TBool IsKMatchAny() const;
	  TBool IsNameWild() const;
	  TBool IsExtWild() const;
protected:
	virtual TDes& NameBuf() = 0;
	virtual const TDesC& NameBufC() const = 0;
	TInt Set(const TDesC* aName,const TDesC* aRelated,const TDesC* aDefault,TBool allowWild);
private:
	TInt ParseDrive(TLex& aName,TBool& aDone);
	TInt ParsePath(TLex& aName,TBool& aDone);
	TInt ParseName(TLex& aName,TBool& aDone);
	TInt ParseExt(TLex& aName,TBool& aDone);
private:
	TInt iWild;
	SField iField[EMaxFields];
	};
 
class TParsePtr : public TParseBase
	{
public:
	  TParsePtr(TDes& aName);
protected:
	  TDes& NameBuf();
	  const TDesC& NameBufC() const;
private:
	TPtr iNameBuf;
	};
 
class TParsePtrC : public TParseBase
	{
public:
	  TParsePtrC(const TDesC& aName);
protected:
	  TDes& NameBuf();
	  const TDesC& NameBufC() const;
private:
	TPtrC iNameBuf;
	};
 
class TParse : public TParseBase
	{
public:
	  TParse();
	  TInt Set(const TDesC& aName,const TDesC* aRelated,const TDesC* aDefault);
	  TInt SetNoWild(const TDesC& aName,const TDesC* aRelated,const TDesC* aDefault);
protected:
	  TDes& NameBuf();
	  const TDesC& NameBufC() const;
private:
	TFileName iNameBuf;
	};
 
class CDir : public CBase
	{
public:
	  virtual ~CDir();
	  TInt Count() const;
	  const TEntry& operator[](TInt anIndex) const;
	  TInt Sort(TUint aEntrySortKey);
protected:
	  CDir();
	  static CDir* NewL();
	  void AddL(const TEntry& anEntry);
	  void ExtractL(TBool aRemove,CDir*& aDir);
	  void Compress();
protected:
	CArrayPakFlat<TEntry>* iArray;
	friend class RFs;
	friend class TOpenFileScan;
	};
 
class RFs : public RSessionBase
	{
public:
	  TInt Connect(TInt aMessageSlots=KFileServerDefaultMessageSlots);
	  TVersion Version() const;
	  TInt AddFileSystem(const TDesC& aFileName) const;
	  TInt MountFileSystem(const TDesC& aFileSystemName,TInt aDrive) const;
	  TInt MountFileSystemAndScan(const TDesC& aFileSystemName,TInt aDrive,TBool& aIsMountSuccess) const;
	  TInt MountFileSystem(const TDesC& aFileSystemName,const TDesC& aExtensionName,TInt aDrive);
	  TInt DismountFileSystem(const TDesC& aFileSystemName,TInt aDrive) const;
	  TInt RemoveFileSystem(const TDesC& aFileSystemName) const;
	  TInt SwapFileSystem(const TDesC& aOldFileSystemName,const TDesC& aNewFileSystemName,TInt aDrive) const;
	  TInt FileSystemName(TDes& aName,TInt aDrive) const;
	  TInt AddExtension(const TDesC& aFileName);
	  TInt MountExtension(const TDesC& aExtensionName,TInt aDrive);
	  TInt DismountExtension(const TDesC& aExtensionName,TInt aDrive);
	  TInt RemoveExtension(const TDesC& aExtensionName);
	  TInt ExtensionName(TDes& aExtensionName,TInt aDrive,TInt aPos);
	  TInt RemountDrive(TInt aDrive,const TDesC8* aMountInfo= 0L ,TUint aFlags=0);
	  void NotifyChange(TNotifyType aType,TRequestStatus& aStat);
	  void NotifyChange(TNotifyType aType,TRequestStatus& aStat,const TDesC& aPathName);
	  void NotifyChangeCancel();
	  void NotifyChangeCancel(TRequestStatus& aStat);
	  void NotifyDiskSpace(TInt64 aThreshold,TInt aDrive,TRequestStatus& aStat);
	  void NotifyDiskSpaceCancel(TRequestStatus& aStat);
	  void NotifyDiskSpaceCancel();
	  TInt DriveList(TDriveList& aList) const;
	  TInt Drive(TDriveInfo& anInfo,TInt aDrive=KDefaultDrive) const;
	  TInt Volume(TVolumeInfo& aVol,TInt aDrive=KDefaultDrive) const;
	  TInt SetVolumeLabel(const TDesC& aName,TInt aDrive=KDefaultDrive);
	  TInt Subst(TDes& aPath,TInt aDrive=KDefaultDrive) const;
	  TInt SetSubst(const TDesC& aPath,TInt aDrive=KDefaultDrive);
	  TInt RealName(const TDesC& aName,TDes& aResult) const;
	  TInt DefaultPath(TDes& aPath) const;
	  TInt SetDefaultPath(const TDesC& aPath);
	  TInt SessionPath(TDes& aPath) const;
	  TInt SetSessionPath(const TDesC& aPath);
	  TInt Parse(const TDesC& aName,TParse& aParse) const;
	  TInt Parse(const TDesC& aName,const TDesC& aRelated,TParse& aParse) const;
	  TInt MkDir(const TDesC& aPath);
	  TInt MkDirAll(const TDesC& aPath);
	  TInt RmDir(const TDesC& aPath);
	  TInt GetDir(const TDesC& aName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList) const;
	  TInt GetDir(const TDesC& aName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList,CDir*& aDirList) const;
	  TInt GetDir(const TDesC& aName,const TUidType& anEntryUid,TUint anEntrySortKey,CDir*& aFileList) const;
	  TInt Delete(const TDesC& aName);
	  TInt Rename(const TDesC& anOldName,const TDesC& aNewName);
	  TInt Replace(const TDesC& anOldName,const TDesC& aNewName);
	  TInt Att(const TDesC& aName,TUint& aAttValue) const;
	  TInt SetAtt(const TDesC& aName,TUint aSetAttMask,TUint aClearAttMask);
	  TInt Modified(const TDesC& aName,TTime& aTime) const;
	  TInt SetModified(const TDesC& aName,const TTime& aTime);
	  TInt Entry(const TDesC& aName,TEntry& anEntry) const;
	  TInt SetEntry(const TDesC& aName,const TTime& aTime,TUint aSetAttMask,TUint aClearAttMask);
	  TInt ReadFileSection(const TDesC& aName,TInt aPos,TDes8& aDes,TInt aLength) const;
	  static TBool IsValidDrive(TInt aDrive);
	  static TInt CharToDrive(TChar aChar,TInt& aDrive);
	  static TInt DriveToChar(TInt aDrive,TChar& aChar);
	  static TBool IsRomAddress(TAny* aAny);
	  void ResourceCountMarkStart() const;
	  void ResourceCountMarkEnd() const;
	  TInt ResourceCount() const;
	  TInt IsFileOpen(const TDesC& aFile,TBool& anAnswer) const;
	  TInt CheckDisk(const TDesC& aDrive) const;
	  TInt ScanDrive(const TDesC& aDrive) const;
	  TInt GetShortName(const TDesC& aLongName,TDes& aShortName) const;
	  TInt GetLongName(const TDesC& aShortName,TDes& aLongName) const;
	  TBool GetNotifyUser();
	  void SetNotifyUser(TBool aValue);
	  TUint8* IsFileInRom(const TDesC& aFileName) const;
	  TBool IsValidName(const TDesC& anEntryName) const;
	  TBool IsValidName(const TDesC& aFileName,TText& aBadChar) const;
	  TInt GetDriveName(TInt aDrive,TDes& aDriveName) const;
	  TInt SetDriveName(TInt aDrive,const TDesC& aDriveName);
	  TInt LoaderHeapFunction(TInt aFunction, TAny *aArg1= 0L , TAny *aArg2= 0L );
	  TInt SetErrorCondition(TInt anError,TInt aCount=0);
	  TInt SetDebugRegister(TInt aVal);
	  TInt SetAllocFailure(TInt aAllocNum);
	  void DebugNotify(TInt aDrive,TUint aNotifyType,TRequestStatus& aStat);
	  TInt ControlIo(TInt aDrive,TInt aCommand,TAny* aParam1,TAny* aParam2);
	  TInt LockDrive(TInt aDrv, const TMediaPassword &aOld, const TMediaPassword &aNew, TBool aStr);
	  TInt UnlockDrive(TInt aDrv, const TMediaPassword &Pswd, TBool aStr);
	  TInt ClearPassword(TInt aDrv, const TMediaPassword &aPswd);
	  TInt ErasePassword(TInt aDrv);
	  void StartupInitComplete(TRequestStatus& aStat);
	  TInt LoadVirusScanner(const TDesC& aFileName, TRequestStatus& aStat);
	  TInt VirusScannerName(TDes& aVsName);
	  TInt SetSessionToPrivate(TInt aDrive);
	  TInt PrivatePath(TDes& aPath);
	  TInt CreatePrivatePath(TInt aDrive);	
	  TInt ReserveDriveSpace(TInt aDriveNo, TInt aSpace);
	  TInt GetReserveAccess(TInt aDriveNo);
	  TInt ReleaseReserveAccess(TInt aDriveNo);
private:
	void GetDirL(const TDesC& aMatchName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList,CDir*& aDirList,RDir& aDir) const;
	void GetDirL(const TDesC& aMatchName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList,RDir& aDir) const;
	void GetDirL(const TDesC& aMatchName,const TUidType& aUidType,TUint anEntrySortKey,CDir*& anEntryList,RDir& aDir) const;
	void DoGetDirL(TUint anEntrySortKey,CDir*& anEntryList,RDir& aDir) const;
	TInt GetOpenFileList(TInt& aSessionNum,TInt& aLocalPos,TThreadId& aThreadId,TEntryArray& anArray) const;
	friend class TOpenFileScan;
	};
 
class RFsBase : public RSubSessionBase
	{
public:
	  void Close();
	};
 
class RFile : public RFsBase
	{
public:
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	  TInt Read(TDes8& aDes) const;
	  void Read(TDes8& aDes,TRequestStatus& aStatus) const;
	  TInt Read(TDes8& aDes,TInt aLength) const;
	  void Read(TDes8& aDes,TInt aLength,TRequestStatus& aStatus) const;
	  TInt Read(TInt aPos,TDes8& aDes) const;
	  void Read(TInt aPos,TDes8& aDes,TRequestStatus& aStatus) const;
	  TInt Read(TInt aPos,TDes8& aDes,TInt aLength) const;
	  void Read(TInt aPos,TDes8& aDes,TInt aLength,TRequestStatus& aStatus) const;
	  TInt Write(const TDesC8& aDes);
	  void Write(const TDesC8& aDes,TRequestStatus& aStatus);
	  TInt Write(const TDesC8& aDes,TInt aLength);
	  void Write(const TDesC8& aDes,TInt aLength,TRequestStatus& aStatus);
	  TInt Write(TInt aPos,const TDesC8& aDes);
	  void Write(TInt aPos,const TDesC8& aDes,TRequestStatus& aStatus);
	  TInt Write(TInt aPos,const TDesC8& aDes,TInt aLength);
	  void Write(TInt aPos,const TDesC8& aDes,TInt aLength,TRequestStatus& aStatus);
	  TInt Lock(TInt aPos,TInt aLength) const;
	  TInt UnLock(TInt aPos,TInt aLength) const;
	  TInt Seek(TSeek aMode,TInt& aPos) const;
	  TInt Flush();
	  TInt Size(TInt& aSize) const;
	  TInt SetSize(TInt aSize);
	  TInt Att(TUint& aAttValue) const;
	  TInt SetAtt(TUint aSetAttMask,TUint aClearAttMask);
	  TInt Modified(TTime& aTime) const;
	  TInt SetModified(const TTime& aTime);
	  TInt Set(const TTime& aTime,TUint aSetAttMask,TUint aClearAttMask);
	  TInt ChangeMode(TFileMode aNewMode);
	  TInt Rename(const TDesC& aNewName);
	  TInt Drive(TInt &aDriveNumber, TDriveInfo &aDriveInfo) const;
	};
 
class RDir : public RFsBase
	{
public:
	  TInt Open(RFs& aFs,const TDesC& aMatchName,const TUidType& aUidType);
	  TInt Open(RFs& aFs,const TDesC& aMatchName,TUint anEntryAttMask);
	  TInt Read(TEntryArray& anArray) const;
	  void Read(TEntryArray& anArray,TRequestStatus& aStatus) const;
	  TInt Read(TEntry& anEntry) const;
	  void Read(TPckg<TEntry>& anEntry,TRequestStatus& aStatus) const;
	};
 
class RFormat : public RFsBase
	{
public:
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFormatMode,TInt& aCount);
	  TInt Next(TInt& aStep);
	  void Next(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus);
	};
 
class RRawDisk : public RSubSessionBase
	{
public:
	  TInt Open(RFs& aFs,TInt aDrive);
	  void Close();
	  TInt Read(TInt aPos,TDes8& aDes);
	  TInt Write(TInt aPos,TDesC8& aDes);
	  TInt Read(TInt64 aPos,TDes8& aDes);
	  TInt Write(TInt64 aPos,TDesC8& aDes);
private:
	TInt iDrive;
	};
 
class CDirStack;
class CDirScan : public CBase
    {
public:
	enum TScanDirection {EScanUpTree,EScanDownTree};
public:
	  static CDirScan* NewL(RFs& aFs);
	  static CDirScan* NewLC(RFs& aFs);
	  ~CDirScan();
	  void SetScanDataL(const TDesC& aMatchName,TUint anEntryAttMask,TUint anEntrySortMask,TScanDirection aScanDir=EScanDownTree);
	  void NextL(CDir*& aDirEntries);
	  TPtrC AbbreviatedPath();
	  TPtrC FullPath();
protected:
	CDirScan(RFs& aFs);
private:
	inline RFs& Fs();
	void UpdateAbbreviatedPath();
	void ScanUpTreeL(CDir*& aDirEntries);
	void ScanDownTreeL(CDir*& aDirEntries);
	void GetDirEntriesL(CDir*& aDirEntries);
private:
	RFs* const iFs;
	TParse iFullPath;
	TPtrC iAbbreviatedPath;
	TInt iAbbreviatedPathPos;
	TUint iEntryAttMask;
	TUint iEntrySortMask;
	TBool iScanning;
	TScanDirection iScanDir;
	CDirStack* iStack;
	};
 
enum TFileManError
	{
	ENoExtraInformation,
	EInitializationFailed,
	EScanNextDirectoryFailed,
	ESrcOpenFailed,
	ETrgOpenFailed,
	ENoFilesProcessed
	};

class MFileManObserver
	{
public:
	enum TControl {EContinue,ERetry,EAbort,ECancel};
public:
	  virtual TControl NotifyFileManStarted();
	  virtual TControl NotifyFileManOperation();
	  virtual TControl NotifyFileManEnded();
	};

class CFileBase : public CBase
	{
public:
	  void SetObserver(MFileManObserver* anObserver);
public:
	  const TEntry& CurrentEntry();
	  TPtrC AbbreviatedPath();
	  TPtrC FullPath();
	  TInt GetLastError();
	  TFileManError GetMoreInfoAboutError();
protected:
	  CFileBase(RFs& anFs);
	  void ConstructL();
	  ~CFileBase();
	  void RunL();
	  void RunInSeparateThreadL(TThreadFunction aThreadFunction);
 
	virtual void CompleteOperationL() {};
	virtual void DoOperationL() = 0;
protected:
	RFs iFs;
	RFs iFsOld;
	RThread iFManThread;
	RSemaphore iSynchronizer;
	CDirScan* iScanner;
	CDir* iDirList;
	TInt iCurrentEntry;
	TUint iMatchEntry;
	TUint iSwitches;
	TParse iSrcFile;
	MFileManObserver* iObserver;
	TInt iLastError;
	TFileManError iErrorInfo;
	TRequestStatus* iStatus;
	HBufC* iSessionPath;
	TInt iNumberOfFilesProcessed;

friend void DoFManBaseOperationL(TAny* aPtr);
friend TInt FManBaseThreadFunction(TAny* aPtr);
	};

class CFileMan : public CFileBase
	{
public:
	enum TAction {ENone,EAttribs,ECopy,EDelete,EMove,ERename,ERmDir,ERenameInvalidEntry,ECopyShareAny};
	enum TSwitch {EOverWrite=1,ERecurse=2,EShareAnyCopy=0x10000};
public:
	  static CFileMan* NewL(RFs& aFs);
	  static CFileMan* NewL(RFs& aFs,MFileManObserver* anObserver);
	  TAction CurrentAction();
	  void GetCurrentTarget(TFileName& aFile);
	  void GetCurrentSource(TFileName& aFile);
	  TInt BytesTransferredByCopyStep();
public:
	  TInt Attribs(const TDesC& aName,TUint aSetMask,TUint aClearMask,const TTime& aTime,TUint aSwitch=0);
	  TInt Attribs(const TDesC& aName,TUint aSetMask,TUint aClearMask,const TTime& aTime,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Copy(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
	  TInt Copy(const TDesC& anOld,const TDesC& aNew,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Delete(const TDesC& aName,TUint aSwitch=0);
	  TInt Delete(const TDesC& aName,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Move(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
	  TInt Move(const TDesC& anOld,const TDesC& aNew,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Rename(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
	  TInt Rename(const TDesC& anOld,const TDesC& aNew,TUint aSwitch,TRequestStatus& aStatus);
	  TInt RmDir(const TDesC& aDirName);
	  TInt RmDir(const TDesC& aDirName,TRequestStatus& aStatus);
protected:
	CFileMan(RFs& aFs);
	TInt RenameInvalidEntry(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
private:
	void CompleteOperationL();
	void DoOperationL();
	void CheckForDirectory();
	void SetFlags(TBool aOverWrite,TBool aRecurse,TBool aScanDirection);
	TInt GetSrcAndTrg(TParse& aSrcName,TFileName& aTrgName);
	void DoSynchronize(TInt aRetVal);
	TInt CheckRenameAllowed(const TDesC& aSrcName,const TDesC& aTrgName);
private:
	void DoAttribsL();
	void DoCopyOrMoveL();
	void DoDeleteL();
	void DoRenameL();
	void DoRmDirL();
private:
	TParse iTrgFile;
	TAction iAction;
	TUint iSetMask;
	TUint iClearMask;
	TTime iTime;
	TInt iBytesTransferred;
friend void RenameInvalidEntryL(RFs& aFs,TParse& aSrcFile);
	};

class TFindFile
	{
public:
	  TFindFile(RFs& aFs);
	  TInt FindByPath(const TDesC& aFileName,const TDesC* aPathList);
	  TInt FindByDir(const TDesC& aFileName,const TDesC& aDirPath);
	  TInt Find();
	  TInt FindWildByPath(const TDesC& aFileName,const TDesC* aPathList,CDir*& aDirList);
	  TInt FindWildByDir(const TDesC& aFileName,const TDesC& aDirPath,CDir*& aDir);
	  TInt FindWild(CDir*& aDirList);
	inline const TDesC& File() const;
private:
	TInt DoFind();
	TInt DoFindByPath(const TDesC& aFileName,const TDesC* aPathList);
	TInt DoFindByDir(const TDesC& aFileName,const TDesC& aDir);
	TInt DoFindInDir();
	TInt DoFindNextInPath();
	TInt DoFindNextInDriveList();
private:
	RFs* const iFs;
	TParse iFile;
	TInt iPathPos;
	TInt iCurrentDrive;
	TInt iMode;
	const TDesC* iPath;
	TDriveList iDrvList;
	CDir** iDir;
	};
 
typedef CDir CFileList;
class TOpenFileScan
	{
public:
	  TOpenFileScan(RFs& aFs);
	  void NextL(CFileList*& aFileList);
	  TThreadId ThreadId() const;
private:
	RFs* iFs;
	TThreadId iThreadId;
	TInt iScanPos;
	TInt iEntryListPos;
	};
 
class TFileText
	{
public:
	enum TFileState{EStartOfFile,ENormal,EReverse};
public:
	  TFileText();
	  void Set(RFile& aFile);
	  TInt Read(TDes& aDes);
	  TInt Write(const TDesC& aDes);
	  TInt Seek(TSeek aMode);
private:
	void NextRecord();
	TInt CheckForTerminator(TBool& anAnswer);
	TInt FillBuffer();
private:
	const TText* iNext;
	const TText* iEnd;
	TFileState iState;
	RFile iFile;
	TBuf8<0x100> iReadBuf; 
	};
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.inl" 1
 
 
 
 
 






 
inline const TUid& TEntry::operator[](TInt anIndex) const
    {return(iType[anIndex]);}
inline TBool TEntry::IsUidPresent(TUid aUid) const
    {return(iType.IsPresent(aUid));}
inline TBool TEntry::IsTypeValid() const
    {return(iType.IsValid());}
inline TUid TEntry::MostDerivedUid() const
    {return(iType.MostDerived());}
 
inline TInt EntrySize(const TEntry& anEntry)
	{return(sizeof(TUint)+sizeof(TInt)+sizeof(TTime)+sizeof(TInt)+sizeof(TUidType)+anEntry.iName.Size());}

 
inline const TDesC& TFindFile::File() const
	{return iFile.FullName();}

 
inline RFs& CDirScan::Fs()
	{return(*iFs);}

 
inline TDriveUnit::operator TInt() const
	{return(iDrive);}
# 649 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 2


# 69 "../../libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h" 1
 
 
 
 






 
const TInt KMaxCardinality=0x1fffffff;
 
class MStreamBuf;
class RWriteStream;

 









class RReadStream
	{
public:
	inline RReadStream();
	inline RReadStream(MStreamBuf* aSource);
	inline MStreamBuf* Source();
	inline void Close();
	  void Release();
 
	  void PushL();
	inline void Pop();
 
	  void ReadL(TDes8& aDes);
	  void ReadL(TDes8& aDes,TInt aLength);
	  void ReadL(TDes8& aDes,TChar aDelim);
	  void ReadL(TUint8* aPtr,TInt aLength);
	  void ReadL(TInt aLength);
	inline void ReadL(RWriteStream& aStream);
	inline void ReadL(RWriteStream& aStream,TInt aLength);
 
	  void ReadL(TDes16& aDes);
	  void ReadL(TDes16& aDes,TInt aLength);
	  void ReadL(TDes16& aDes,TChar aDelim);
	  void ReadL(TUint16* aPtr,TInt aLength);
 
	  TInt8 ReadInt8L();
	  TInt16 ReadInt16L();
	  TInt32 ReadInt32L();
	  TUint8 ReadUint8L();
	  TUint16 ReadUint16L();
	  TUint32 ReadUint32L();
	  TReal32 ReadReal32L();
	  TReal64 ReadReal64L();
protected:
	inline void Attach(MStreamBuf* aSource);
	inline void Detach();
private:
	MStreamBuf* iSrc;
private:
	friend class RWriteStream;
	};
template <class T>
class MExternalizer;
class TStreamRef;

 









class RWriteStream
	{
public:
	inline RWriteStream();
	inline RWriteStream(const MExternalizer<TStreamRef>& anExter);
	inline RWriteStream(MStreamBuf* aSink);
	inline MStreamBuf* Sink();
	  void Close();
	  void Release();
	  void CommitL();
 
	  void PushL();
	inline void Pop();
 
	  void WriteL(const TDesC8& aDes);
	  void WriteL(const TDesC8& aDes,TInt aLength);
	  void WriteL(const TUint8* aPtr,TInt aLength);
	  void WriteL(RReadStream& aStream);
	  void WriteL(RReadStream& aStream,TInt aLength);
 
	  void WriteL(const TDesC16& aDes);
	  void WriteL(const TDesC16& aDes,TInt aLength);
	  void WriteL(const TUint16* aPtr,TInt aLength);
 
	  void WriteInt8L(TInt aValue);
	  void WriteInt16L(TInt aValue);
	  void WriteInt32L(TInt32 aValue);
	  void WriteUint8L(TUint aValue);
	  void WriteUint16L(TUint aValue);
	  void WriteUint32L(TUint32 aValue);
	  void WriteReal32L(TReal aValue);
	  void WriteReal64L(TReal64 aValue);
protected:
	inline void Attach(MStreamBuf* aSink);
	inline void Detach();
private:
	  void WriteRefL(TStreamRef aRef);
private:
	MStreamBuf* iSnk;
	const MExternalizer<TStreamRef>* iExterL;
private:
	friend class TStreamRef;
	};
 
template <class T>
inline RWriteStream& operator<<(RWriteStream& aStream,const T& anObject);
template <class T>
inline RReadStream& operator>>(RReadStream& aStream,T& anObject);

 










class TCardinality
	{
public:
	TCardinality() {}
	inline TCardinality(TInt aCount);
	inline operator TInt() const;
 
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
private:
	TInt iCount;
private:
	  static void __DbgChkRange(TInt aCount);
	};
 
 

typedef void (*TExternalizeFunction)(const TAny* aPtr,RWriteStream& aStream);
 
typedef void (*TInternalizeFunction)(TAny* aPtr,RReadStream& aStream);

 







template <class T>
class TExternalizer
	{
public:
	inline void operator()(const T& anObject,RWriteStream& aStream) const;
	inline static TExternalizeFunction Function();
private:
	static void ExternalizeAsL(const TAny* aPtr,RWriteStream& aStream);
	};

 






  class TExternalizer<TAny>
	{
public:
	 
	TExternalizer() {}
	
	 


	inline TExternalizer(TExternalizeFunction aFunction);
	inline void operator()(const TAny* aPtr,RWriteStream& aStream) const;
	
	 


	inline TExternalizeFunction Function() const;
private:
	TExternalizeFunction iFunc;
	};

 





template <class T>
class TInternalizer
	{
public:
	inline void operator()(T& anObject,RReadStream& aStream) const;
	inline static TInternalizeFunction Function();
private:
	static void InternalizeAsL(TAny* aPtr,RReadStream& aStream);
	};

 





  class TInternalizer<TAny>
	{
public:
	 
	TInternalizer() {}
	
	 


	inline TInternalizer(TInternalizeFunction aFunction);
	inline void operator()(TAny* aPtr,RReadStream& aStream) const;
	
	 


	inline TInternalizeFunction Function() const;
private:
	TInternalizeFunction iFunc;
	};

 







template <class T>
class MExternalizer
	{
public:
	inline void operator()(const T& anObject,RWriteStream& aStream) const;
private:
	 





	virtual void ExternalizeL(const T& anObject,RWriteStream& aStream) const=0;
	};

 







template <class T>
class MInternalizer
	{
public:
	inline void operator()(T& anObject,RReadStream& aStream) const;
private:
	 





	virtual void InternalizeL(T& anObject,RReadStream& aStream) const=0;
	};

 





class TStreamRef
	{
public:
	inline TStreamRef(const TAny* aPtr,TExternalizeFunction aFunction);
	inline const TAny* Ptr() const;
	inline TExternalizeFunction Function() const;
 
	inline void ExternalizeL(RWriteStream& aStream) const;
private:
	const TAny* iPtr;
	TExternalizeFunction iFunc;
	};

 





class Externalize
	{
public:
	 

	class Member {};

	 

	class Function {};
	};

 





class Internalize
	{
public:
	 

	class Member {};

	 

	class Function {};
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.inl" 1
 
 
 
 

 
inline RReadStream::RReadStream()
	: iSrc(0L )
 


	{}
inline RReadStream::RReadStream(MStreamBuf* aSource)
	: iSrc(aSource)
 



	{}
inline MStreamBuf* RReadStream::Source()
 










	{return iSrc;}
inline void RReadStream::Close()
 


	{Release();}
inline void RReadStream::ReadL(RWriteStream& aStream)
 


	{aStream.WriteL(*this);}
inline void RReadStream::ReadL(RWriteStream& aStream,TInt aLength)
 



	{aStream.WriteL(*this,aLength);}
inline void RReadStream::Pop()
 
	{CleanupStack::Pop();}
inline void RReadStream::Attach(MStreamBuf* aSource)
 












	{iSrc=aSource;}
inline void RReadStream::Detach()
 






	{iSrc= 0L ;}

 
inline RWriteStream::RWriteStream()
	: iSnk(0L ),iExterL(0L )
 

	{}
inline RWriteStream::RWriteStream(const MExternalizer<TStreamRef>& anExter)
	: iSnk(0L ),iExterL(&anExter)
 




	{}
inline RWriteStream::RWriteStream(MStreamBuf* aSink)
	: iSnk(aSink),iExterL(0L )
 



	{}
inline MStreamBuf* RWriteStream::Sink()
 



	{return iSnk;}
inline void RWriteStream::Pop()
 
	{CleanupStack::Pop();}
inline void RWriteStream::Attach(MStreamBuf* aSink)
 










	{iSnk=aSink;}
inline void RWriteStream::Detach()
 





	{iSnk= 0L ;}

 
inline TCardinality::TCardinality(TInt aCount)
	:iCount(aCount)
 


	{



	}
inline TCardinality::operator TInt() const
	{



	return iCount;
	}

 
template <class T>
inline void TExternalizer<T>::operator()(const T& anObject,RWriteStream& aStream) const
	{aStream<<anObject;}
template <class T>
inline TExternalizeFunction TExternalizer<T>::Function()
 




	{return &ExternalizeAsL;}
template <class T>
void TExternalizer<T>::ExternalizeAsL(const TAny* aPtr,RWriteStream& aStream)
	{aStream<<*((const T*)aPtr);}
inline TExternalizer<TAny>::TExternalizer(TExternalizeFunction aFunction)
	: iFunc(aFunction)
	{}
inline void TExternalizer<TAny>::operator()(const TAny* aPtr,RWriteStream& aStream) const
	{(*iFunc)(aPtr,aStream);}
inline TExternalizeFunction TExternalizer<TAny>::Function() const
	{return iFunc;}

 
template <class T>
inline void TInternalizer<T>::operator()(T& anObject,RReadStream& aStream) const
	{aStream>>anObject;}
template <class T>
inline TInternalizeFunction TInternalizer<T>::Function()
 




	{return &InternalizeAsL;}
template <class T>
void TInternalizer<T>::InternalizeAsL(TAny* aPtr,RReadStream& aStream)
	{aStream>>*((T*)aPtr);}
inline TInternalizer<TAny>::TInternalizer(TInternalizeFunction aFunction)
	: iFunc(aFunction)
	{}
inline void TInternalizer<TAny>::operator()(TAny* aPtr,RReadStream& aStream) const
	{(*iFunc)(aPtr,aStream);}
inline TInternalizeFunction TInternalizer<TAny>::Function() const
	{return iFunc;}

 
template <class T>
inline void MExternalizer<T>::operator()(const T& anObject,RWriteStream& aStream) const
	{ExternalizeL(anObject,aStream);}

 
template <class T>
inline void MInternalizer<T>::operator()(T& anObject,RReadStream& aStream) const
	{InternalizeL(anObject,aStream);}

 
inline TStreamRef::TStreamRef(const TAny* aPtr,TExternalizeFunction aFunction)
	: iPtr(aPtr),iFunc(aFunction)
 



	{}
inline const TAny* TStreamRef::Ptr() const
 


	{return iPtr;}
inline TExternalizeFunction TStreamRef::Function() const
 


	{return iFunc;}
inline void TStreamRef::ExternalizeL(RWriteStream& aStream) const
 


	{aStream.WriteRefL(*this);}

 
  void ExternalizeL(TInt64 anInt64,RWriteStream& aStream);
  void InternalizeL(TInt64& anInt64,RReadStream& aStream);

  void ExternalizeL(const TDesC8& aDes8,RWriteStream& aStream);
  void ExternalizeL(const TDesC16& aDes16,RWriteStream& aStream);
  void InternalizeL(TDes8& aDes8,RReadStream& aStream);
  void InternalizeL(TDes16& aDes16,RReadStream& aStream);

  void ExternalizeL(const TCheckedUid& aUid,RWriteStream& aStream);
  void InternalizeL(TCheckedUid& aUid,RReadStream& aStream);

  void ExternalizeL(TPoint aPoint,RWriteStream& aStream);
  void ExternalizeL(TSize aSize,RWriteStream& aStream);
  void ExternalizeL(const TRect& aRect,RWriteStream& aStream);
  void InternalizeL(TPoint& aPoint,RReadStream& aStream);
  void InternalizeL(TSize& aSize,RReadStream& aStream);
  void InternalizeL(TRect& aRect,RReadStream& aStream);

  void ExternalizeL(const CBufBase& aBuf,RWriteStream& aStream);
  void InternalizeL(CBufBase& aBuf,RReadStream& aStream);

  void ArrayExternalizeCountL(TInt aCount,RWriteStream& aStream);
  void DoExternalizeAllL(const CArrayFixBase& anArray,RWriteStream& aStream,TExternalizer<TAny> anExter);
  TInt ArrayInternalizeCountL(RReadStream& aStream);
  void DoInternalizeAllL(CArrayFixBase& anArray,RReadStream& aStream,TInternalizer<TAny> anInter);

template <class T>
inline void ExternalizeCountL(const CArrayFix<T>& anArray,RWriteStream& aStream)
	{ArrayExternalizeCountL(anArray.Count(),aStream);}
template <class T>
inline void ExternalizeAllL(const CArrayFix<T>& anArray,RWriteStream& aStream)
	{DoExternalizeAllL(anArray,aStream,TExternalizer<T>::Function());}
template <class T>
void InternalizeCountL(CArrayFix<T>& anArray,RReadStream& aStream)
	{
	TInt n=ArrayInternalizeCountL(aStream);
	anArray.ResizeL(n);
	}
template <class T>
inline void InternalizeAllL(CArrayFix<T>& anArray,RReadStream& aStream)
	{DoInternalizeAllL(anArray,aStream,TInternalizer<T>::Function());}

template <class T>
void ExternalizeL(const CArrayFix<T>& anArray,RWriteStream& aStream)
	{
	ExternalizeCountL(anArray,aStream);
	ExternalizeAllL(anArray,aStream);
	}
template <class T>
void InternalizeL(CArrayFix<T>& anArray,RReadStream& aStream)
	{
	InternalizeCountL(anArray,aStream);
	InternalizeAllL(anArray,aStream);
	}

template <class T>
inline void ExternalizeL(const T* aPtr,RWriteStream& aStream)
	{aStream<<TStreamRef(aPtr,TExternalizer<T>::Function());}

template <class T>
inline void DoExternalizeL(const T& anObject,RWriteStream& aStream,Externalize::Member)
	{anObject.ExternalizeL(aStream);}
template <class T>
inline void DoInternalizeL(T& anObject,RReadStream& aStream,Internalize::Member)
	{anObject.InternalizeL(aStream);}

template <class T>
inline void DoExternalizeL(const T& anObject,RWriteStream& aStream,Externalize::Function)
	{ExternalizeL(anObject,aStream);}
template <class T>
inline void DoInternalizeL(T& anObject,RReadStream& aStream,Internalize::Function)
	{InternalizeL(anObject,aStream);}

 
inline Externalize::Member Externalization(const TAny*)
	{return Externalize::Member();}
inline Internalize::Member Internalization(TAny*)
	{return Internalize::Member();}

inline Externalize::Function Externalization(const TDesC8*)
	{return Externalize::Function();}
inline Externalize::Function Externalization(const TDesC16*)
	{return Externalize::Function();}
inline Internalize::Function Internalization(TDes8*)
	{return Internalize::Function();}
inline Internalize::Function Internalization(TDes16*)
	{return Internalize::Function();}

inline Externalize::Function Externalization(const CBufBase*)
	{return Externalize::Function();}
inline Externalize::Function Externalization(const CArrayFixBase*)
	{return Externalize::Function();}
inline Internalize::Function Internalization(CBufBase*)
	{return Internalize::Function();}
inline Internalize::Function Internalization(CArrayFixBase*)
	{return Internalize::Function();}

template <class T>
inline Externalize::Function Externalization(T*const*)
	{return Externalize::Function();}

 
template <class T>
inline RWriteStream& operator<<(RWriteStream& aStream,const T& anObject)
	{DoExternalizeL(anObject,aStream,Externalization(&anObject));return aStream;}
template <class T>
inline RReadStream& operator>>(RReadStream& aStream,T& anObject)
	{DoInternalizeL(anObject,aStream,Internalization(&anObject));return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TInt8& anInt8)
	{aStream.WriteInt8L(anInt8);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TInt16& anInt16)
	{aStream.WriteInt16L(anInt16);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TInt32& anInt32)
	{aStream.WriteInt32L(anInt32);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TUint8& aUint8)
	{aStream.WriteUint8L(aUint8);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TUint16& aUint16)
	{aStream.WriteUint16L(aUint16);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TUint32& aUint32)
	{aStream.WriteUint32L(aUint32);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TReal32& aReal32)
	{aStream.WriteReal32L(aReal32);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TReal64& aReal64)
	{aStream.WriteReal64L(aReal64);return aStream;}

inline RReadStream& operator>>(RReadStream& aStream,TInt8& anInt8)
	{anInt8=aStream.ReadInt8L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TInt16& anInt16)
	{anInt16=aStream.ReadInt16L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TInt32& anInt32)
	{anInt32=aStream.ReadInt32L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUint8& aUint8)
	{aUint8=aStream.ReadUint8L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUint16& aUint16)
	{aUint16=aStream.ReadUint16L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUint32& aUint32)
	{aUint32=aStream.ReadUint32L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TReal32& aReal32)
	{aReal32=aStream.ReadReal32L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TReal64& aReal64)
	{aReal64=aStream.ReadReal64L();return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TInt64& anInt64)
	{ExternalizeL(anInt64,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TInt64& anInt64)
	{InternalizeL(anInt64,aStream);return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TUid& aUid)
	{return aStream<<aUid.iUid;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TCheckedUid& aUid)
	{ExternalizeL(aUid,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUid& aUid)
	{return aStream>>aUid.iUid;}
inline RReadStream& operator>>(RReadStream& aStream,TCheckedUid& aUid)
	{InternalizeL(aUid,aStream);return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TPoint& aPoint)
	{ExternalizeL(aPoint,aStream);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TSize& aSize)
	{ExternalizeL(aSize,aStream);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TRect& aRect)
	{ExternalizeL(aRect,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TPoint& aPoint)
	{InternalizeL(aPoint,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TSize& aSize)
	{InternalizeL(aSize,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TRect& aRect)
	{InternalizeL(aRect,aStream);return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TStreamRef& aRef)
	{aRef.ExternalizeL(aStream);return aStream;}

# 351 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h" 2


# 8 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 2



 
const TUint32 KNullStreamIdValue=0;
const TUint32 KMaxStreamIdValue=0xfffffff;
const TUint32 KMaskStreamIdValue=0xfffffff;
const TInt KShiftStreamIdValue=28;

 










class TStreamId
	{
public:
	 

	TStreamId() {}
	inline TStreamId(TUint32 aValue);
 
	inline TBool operator==(TStreamId anId) const;
	inline TBool operator!=(TStreamId anId) const;
 
	inline void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
 
	inline TUint32 Value() const;
private:
	TUint32 iVal;
private:
	  static void __DbgChkRange(TUint32 aValue);
	};






 
class CStreamStore;

 




class RStoreReadStream : public RReadStream
	{
public:
	  void OpenL(const CStreamStore& aStore,TStreamId anId);
	  void OpenLC(const CStreamStore& aStore,TStreamId anId);
	};

 














class RStoreWriteStream : public RWriteStream
	{
public:
	 

	RStoreWriteStream() {}
	inline RStoreWriteStream(const MExternalizer<TStreamRef>& anExter);
	  TStreamId CreateL(CStreamStore& aStore);
	  TStreamId CreateLC(CStreamStore& aStore);
	  void OpenL(CStreamStore& aStore,TStreamId anId);
	  void OpenLC(CStreamStore& aStore,TStreamId anId);
	  void ReplaceL(CStreamStore& aStore,TStreamId anId);
	  void ReplaceLC(CStreamStore& aStore,TStreamId anId);
	  void AppendL(CStreamStore& aStore,TStreamId anId);
	  void AppendLC(CStreamStore& aStore,TStreamId anId);
	};

 













class TSwizzleCBase
	{
public:
	inline TBool operator==(const TSwizzleCBase& aSwizzle) const;
	inline TBool operator==(const TAny* aPtr) const;
	inline TBool operator!=(const TSwizzleCBase& aSwizzle) const;
	inline TBool operator!=(const TAny* aPtr) const;
 
	inline TBool IsPtr() const;
	inline TBool IsId() const;
	  TStreamId AsId() const;
	  void InternalizeL(RReadStream& aStream);
protected:
	TSwizzleCBase() {}
	inline TSwizzleCBase(const TAny* aPtr);
	  TSwizzleCBase(TStreamId anId);
	inline TSwizzleCBase(TStreamRef aRef);
	inline const TAny* Ptr() const;
	  void DoExternalizeL(RWriteStream& aStream,TExternalizer<TAny> anExter) const;
private:
	  static TBool IsPtrRep(const TAny* aPtr);
	  static TBool IsIdRep(const TAny* aPtr);
private:
	const TAny* iPtr;
private:
	  static void __DbgChkPtr(const TAny* aPtr);
	  static void __DbgChkRef(TStreamRef aRef);
	};
inline TBool operator==(const TAny* aPtr,const TSwizzleCBase& aSwizzle);
inline TBool operator!=(const TAny* aPtr,const TSwizzleCBase& aSwizzle);

 











class TSwizzleBase : public TSwizzleCBase
	{
protected:
	TSwizzleBase() {}
	inline TSwizzleBase(TAny* aPtr);
	inline TSwizzleBase(TStreamId anId);
	inline TAny* Ptr() const;
	};

 
















template <class T>
class TSwizzle : public TSwizzleBase
	{
public:
	 

	TSwizzle() {}
	inline TSwizzle(T* aPtr);
	inline TSwizzle(TStreamId anId);
	inline TSwizzle<T>& operator=(T* aPtr);
	inline T* AsPtr() const;
	inline operator T*() const;
	inline T& operator*() const;
	inline T* operator->() const;
	inline void ExternalizeL(RWriteStream& aStream) const;
	};

 






  class TSwizzle<TAny> : public TSwizzleBase
	{
public:
	 


	TSwizzle() {}
	inline TSwizzle(TAny* aPtr);
	inline TSwizzle(TStreamId anId);
	inline TSwizzle(const TSwizzleBase& aSwizzle);
	inline TSwizzle<TAny>& operator=(TAny* aPtr);
	inline TSwizzle<TAny>& operator=(const TSwizzleBase& aSwizzle);
	inline TAny* AsPtr() const;
	inline operator TAny*() const;
	};

 

















template <class T>
class TSwizzleC : public TSwizzleCBase
	{
public:
	 

	TSwizzleC() {}
	inline TSwizzleC(const T* aPtr);
	inline TSwizzleC(TStreamId anId);
	inline TSwizzleC(TSwizzle<T> aSwizzle);
	inline TSwizzleC<T>& operator=(const T* aPtr);
	inline const T* AsPtr() const;
	inline operator const T*() const;
	inline const T& operator*() const;
	inline const T* operator->() const;
	inline void ExternalizeL(RWriteStream& aStream) const;
	};

 





  class TSwizzleC<TAny> : public TSwizzleCBase
	{
public:
	 


	TSwizzleC() {}
	inline TSwizzleC(const TAny* aPtr);
	inline TSwizzleC(TStreamId anId);
	inline TSwizzleC(const TSwizzleCBase& aSwizzle);
	inline TSwizzleC(TStreamRef aRef);
	inline TSwizzleC<TAny>& operator=(const TAny* aPtr);
	inline TSwizzleC<TAny>& operator=(const TSwizzleCBase& aSwizzle);
	inline const TAny* AsPtr() const;
	inline operator const TAny*() const;
	};

 












class CStoreMap : public CBase,public MExternalizer<TStreamRef>
	{
public:
	 



	struct TEntry {TSwizzleC<TAny> swizzle;TStreamId id;};
	typedef const TEntry* TIterator;
public:
	  static CStoreMap* NewL(CStreamStore& aStore);
	  static CStoreMap* NewLC(CStreamStore& aStore);
	  CStoreMap(CStreamStore& aStore);
	  ~CStoreMap();
 
	  void BindL(TSwizzleC<TAny> aSwizzle,TStreamId anId);
	  void Unbind(TSwizzleC<TAny> aSwizzle);
	  void Forget(TStreamId anId);
	  void Reset();
	  void ResetAndDestroy();
 
	  TStreamId At(TSwizzleC<TAny> aSwizzle) const;
	  TSwizzleC<TAny> Label(TStreamId anId) const;
	  TIterator Begin() const;
	  TIterator End() const;
private:
	void ExternalizeL(const TStreamRef& aRef,RWriteStream& aStream) const;
private:
	CArrayFixFlat<TEntry> iArray;
	TStreamId iFree;
	CStreamStore* iStore;
	};

 













class CStreamDictionary : public CBase
	{
public:
	  static CStreamDictionary* NewL();
	  static CStreamDictionary* NewLC();
	  CStreamDictionary();
	  ~CStreamDictionary();
 
	  void AssignL(TUid aUid,TStreamId anId);
	  void Remove(TUid aUid);
	  TStreamId At(TUid aUid) const;
	  TBool IsNull() const;
	 
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
private:
	
	class TEntry
		{
	public:
		TEntry() {}
		inline TEntry(TUid aUid,TStreamId anId);
		void ExternalizeL(RWriteStream& aStream) const;
		void InternalizeL(RReadStream& aStream);
	public:
		TUid iUid;
		TStreamId iId;
		};
private:
	CArrayFixSeg<TEntry> iArray;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.inl" 1
 
 
 
 

 
inline TStreamId::TStreamId(TUint32 aValue)
	: iVal(aValue)
 












	{



	}
inline TBool TStreamId::operator==(TStreamId anId) const
 




	{return iVal==anId.iVal;}
inline TBool TStreamId::operator!=(TStreamId anId) const
 




	{return iVal!=anId.iVal;}
inline void TStreamId::ExternalizeL(RWriteStream& aStream) const
 





	{



	aStream<<iVal;
	}
inline TUint32 TStreamId::Value() const
 


	{



	return iVal;
	}

 
inline RStoreWriteStream::RStoreWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
 



	{}

 
inline TSwizzleCBase::TSwizzleCBase(TStreamRef aRef)
	: iPtr(aRef.Ptr())
	{



    }
inline TBool TSwizzleCBase::operator==(const TSwizzleCBase& aSwizzle) const
 













	{return iPtr==aSwizzle.iPtr;}
inline TBool TSwizzleCBase::operator==(const TAny* aPtr) const
 










	{return iPtr==aPtr;}
inline TBool TSwizzleCBase::operator!=(const TSwizzleCBase& aSwizzle) const
 













	{return iPtr!=aSwizzle.iPtr;}
inline TBool TSwizzleCBase::operator!=(const TAny* aPtr) const
 










	{return iPtr!=aPtr;}
inline TBool TSwizzleCBase::IsPtr() const
 




	{return IsPtrRep(iPtr);}
inline TBool TSwizzleCBase::IsId() const
 




	{return IsIdRep(iPtr);}
inline TSwizzleCBase::TSwizzleCBase(const TAny* aPtr)
	: iPtr(aPtr)
	{



    }
inline const TAny* TSwizzleCBase::Ptr() const
	{



	return iPtr;
	}
inline TBool operator==(const TAny* aPtr,const TSwizzleCBase& aSwizzle)
	{return aSwizzle==aPtr;}
inline TBool operator!=(const TAny* aPtr,const TSwizzleCBase& aSwizzle)
	{return aSwizzle!=aPtr;}

 
inline TSwizzleBase::TSwizzleBase(TAny* aPtr)
	: TSwizzleCBase(aPtr)
	{}
inline TSwizzleBase::TSwizzleBase(TStreamId anId)
	: TSwizzleCBase(anId)
	{}
inline TAny* TSwizzleBase::Ptr() const
	{return (TAny*)TSwizzleCBase::Ptr();}

 
template <class T>
inline TSwizzle<T>::TSwizzle(T* aPtr)
	: TSwizzleBase(aPtr)
 


	{}
template <class T>
inline TSwizzle<T>::TSwizzle(TStreamId anId)
	: TSwizzleBase(anId)
 



	{}
template <class T>
inline TSwizzle<T>& TSwizzle<T>::operator=(T* aPtr)
 




	{return *this=TSwizzle<T>(aPtr);}
template <class T>
inline T* TSwizzle<T>::AsPtr() const
 





	{return (T*)Ptr();}
template <class T>
inline TSwizzle<T>::operator T*() const
	{return AsPtr();}
template <class T>
inline T& TSwizzle<T>::operator*() const
 


	{return *AsPtr();}
template <class T>
inline T* TSwizzle<T>::operator->() const
 




	{return AsPtr();}
template <class T>
inline void TSwizzle<T>::ExternalizeL(RWriteStream& aStream) const
 
















	{TSwizzleBase::DoExternalizeL(aStream,TExternalizer<T>::Function());}
inline TSwizzle<TAny>::TSwizzle(TAny* aPtr)
	: TSwizzleBase(aPtr)
 


	{}
inline TSwizzle<TAny>::TSwizzle(TStreamId anId)
	: TSwizzleBase(anId)
 



	{}
inline TSwizzle<TAny>::TSwizzle(const TSwizzleBase& aSwizzle)
	: TSwizzleBase(aSwizzle)
 




	{}
inline TSwizzle<TAny>& TSwizzle<TAny>::operator=(TAny* aPtr)
 




	{return *this=TSwizzle<TAny>(aPtr);}
inline TSwizzle<TAny>& TSwizzle<TAny>::operator=(const TSwizzleBase& aSwizzle)
	 





	{return *this=TSwizzle<TAny>(aSwizzle);}
inline TAny* TSwizzle<TAny>::AsPtr() const
 


	{return Ptr();}
inline TSwizzle<TAny>::operator TAny*() const
	{return AsPtr();}

 
template <class T>
inline TSwizzleC<T>::TSwizzleC(const T* aPtr)
	: TSwizzleCBase(aPtr)
 



	{}
template <class T>
inline TSwizzleC<T>::TSwizzleC(TStreamId anId)
	: TSwizzleCBase(anId)
 




	{}
template <class T>
inline TSwizzleC<T>::TSwizzleC(TSwizzle<T> aSwizzle)
	: TSwizzleCBase(aSwizzle)
 









	{}
template <class T>
inline TSwizzleC<T>& TSwizzleC<T>::operator=(const T* aPtr)
 





	{return *this=TSwizzleC<T>(aPtr);}
template <class T>
inline const T* TSwizzleC<T>::AsPtr() const
 









	{return (const T*)Ptr();}
template <class T>
inline TSwizzleC<T>::operator const T*() const
	{return AsPtr();}
template <class T>
inline const T& TSwizzleC<T>::operator*() const
 



	{return *AsPtr();}
template <class T>
inline const T* TSwizzleC<T>::operator->() const
 









	{return AsPtr();}
template <class T>
inline void TSwizzleC<T>::ExternalizeL(RWriteStream& aStream) const
 
















	{TSwizzleCBase::DoExternalizeL(aStream,TExternalizer<T>::Function());}
inline TSwizzleC<TAny>::TSwizzleC(const TAny* aPtr)
	: TSwizzleCBase(aPtr)
 


	{}
inline TSwizzleC<TAny>::TSwizzleC(TStreamId anId)
	: TSwizzleCBase(anId)
 



	{}
inline TSwizzleC<TAny>::TSwizzleC(const TSwizzleCBase& aSwizzle)
	: TSwizzleCBase(aSwizzle)
 




	{}
inline TSwizzleC<TAny>::TSwizzleC(TStreamRef aRef)
	: TSwizzleCBase(aRef)
 


 	{}
inline TSwizzleC<TAny>& TSwizzleC<TAny>::operator=(const TAny* aPtr)
 



	{return *this=TSwizzleC<TAny>(aPtr);}
inline TSwizzleC<TAny>& TSwizzleC<TAny>::operator=(const TSwizzleCBase& aSwizzle)
 





	{return *this=TSwizzleC<TAny>(aSwizzle);}
inline const TAny* TSwizzleC<TAny>::AsPtr() const
 


	{return Ptr();}
inline TSwizzleC<TAny>::operator const TAny*() const
	{return AsPtr();}

# 375 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 2


# 70 "../../libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 1
 
 
 
 



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32buf.h" 1
 
 
 
 






 





enum TStreamLocation 
	 

	{EStreamBeginning,
	 
	EStreamMark,
	 

	EStreamEnd};

 


















class TStreamPos
	{
public:
	 
	TStreamPos() {}
	inline TStreamPos(TInt anOffset);
 
	inline TBool operator==(TStreamPos aPos) const;
	inline TBool operator!=(TStreamPos aPos) const;
	inline TBool operator<(TStreamPos aPos) const;
	inline TBool operator<=(TStreamPos aPos) const;
	inline TBool operator>(TStreamPos aPos) const;
	inline TBool operator>=(TStreamPos aPos) const;
 
	inline TInt operator-(TStreamPos aPos) const;
	inline TStreamPos operator+(TInt anOffset) const;
	inline TStreamPos operator-(TInt anOffset) const;
 
	inline TStreamPos& operator+=(TInt anOffset);
	inline TStreamPos& operator-=(TInt anOffset);
 
	inline TInt Offset() const;
private:
	TInt iOff;
	};
inline TStreamPos operator+(TInt anOffset,TStreamPos aPos);

 








 















class TStreamTransfer
	{
public:
	 


	enum TUnlimited {EUnlimited};
public:
	 








	TStreamTransfer() {}
	inline TStreamTransfer(TInt aMaxLength);
	inline TStreamTransfer(TUnlimited);
 
	inline TBool operator==(TInt aLength) const;
	inline TBool operator>(TInt aLength) const;
	inline TStreamTransfer operator-(TInt aLength) const;
	inline TInt operator[](TInt aMaxLength) const;
 
	inline TStreamTransfer& operator-=(TInt aLength);
 
	inline TInt Left() const;
private:
	TInt iVal;
private:
	  static void __DbgChkNonNegative(TInt aLength);
	};
inline TBool operator==(TInt aLength,TStreamTransfer aTransfer);
inline TBool operator<(TInt aLength,TStreamTransfer aTransfer);

 









 
class MStreamInput;
class MStreamOutput;

 


































class MStreamBuf
	{
public:
	 

	enum TRead {ERead=0x01};

	 

	enum TWrite {EWrite=0x02};

	 












	typedef TInt TMark;
public:
	  void Close();
	inline void Release();
	  TInt Synch();
	inline void SynchL();
 
	  void PushL();
 
	inline TInt ReadL(TAny* aPtr,TInt aMaxLength);
	  TInt Read(TDes8& aDes,TRequestStatus& aStatus);
	  TInt Read(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TInt ReadL(TDes8& aDes,TRequestStatus& aStatus);
	inline TInt ReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer ReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	  TInt ReadL(MStreamInput& anInput,TInt aMaxLength);
	inline void ReadL(MStreamInput& anInput);
 
	inline void WriteL(const TAny* aPtr,TInt aLength);
	  TInt Write(const TDesC8& aDes,TRequestStatus& aStatus);
	  TInt Write(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TInt WriteL(const TDesC8& aDes,TRequestStatus& aStatus);
	inline TInt WriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer WriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
	  TInt WriteL(MStreamOutput& anOutput,TInt aMaxLength);
	inline void WriteL(MStreamOutput& anOutput);
 
	inline void SeekL(TMark aMark,TStreamPos aPos);
	inline TStreamPos SeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TRead,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TWrite,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TRead,TInt anOffset);
	inline TStreamPos SeekL(TWrite,TInt anOffset);
 
	inline TStreamPos TellL(TRead) const;
	inline TStreamPos TellL(TWrite) const;
	inline TInt SizeL() const;
protected:
	MStreamBuf() {}
private:
	MStreamBuf(const MStreamBuf&);
	MStreamBuf& operator=(const MStreamBuf&);
 
	virtual   void DoRelease();
	virtual   void DoSynchL();
	virtual   TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	virtual   TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	virtual   TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	virtual   void DoWriteL(const TAny* aPtr,TInt aLength);
	virtual   TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	virtual   TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
	virtual   TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
	};

 













class MStreamInput
	{
public:
	 











	virtual TInt PushL(const TAny* aPtr,TInt aMaxLength)=0;

	 












	virtual	TStreamTransfer ReadFromL(MStreamBuf& aSource,TStreamTransfer aTransfer)=0;
	};

 













class MStreamOutput
	{
public:
	 











	virtual TInt PullL(TAny* aPtr,TInt aMaxLength)=0;

	 












	virtual TStreamTransfer WriteToL(MStreamBuf& aSink,TStreamTransfer aTransfer)=0;
	};

 


















class TStreamBuf : public MStreamBuf
	{
protected:
	 












	typedef TInt TArea;
protected:
	  TStreamBuf();
 
	  void SetBuf(TArea anArea,TUint8* aPtr,TUint8* anEnd);
	  void SetPtr(TArea anArea,TUint8* aPtr);
	  void SetEnd(TArea anArea,TUint8* anEnd);
	  TUint8* Ptr(TArea anArea) const;
	  TUint8* End(TArea anArea) const;
	  TInt Avail(TArea anArea) const;
 
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
 
	inline void SetBuf(TRead,TUint8* aPtr,TUint8* anEnd);
	inline void SetBuf(TWrite,TUint8* aPtr,TUint8* anEnd);
	inline void SetPtr(TRead,TUint8* aPtr);
	inline void SetPtr(TWrite,TUint8* aPtr);
	inline void SetEnd(TRead,TUint8* anEnd);
	inline void SetEnd(TWrite,TUint8* anEnd);
	inline TUint8* Ptr(TRead) const;
	inline TUint8* Ptr(TWrite) const;
	inline TUint8* End(TRead) const;
	inline TUint8* End(TWrite) const;
	inline TInt Avail(TRead) const;
	inline TInt Avail(TWrite) const;
private:
	 








	virtual TInt UnderflowL(TInt aMaxLength)=0;

	 




	virtual void OverflowL()=0;
private:
	TUint8* iRPtr;
	TUint8* iREnd;
	TUint8* iWPtr;
	TUint8* iWEnd;
	};

 









class TStreamFilter : public MStreamBuf
	{
public:
	enum {EAttached=0x10};
protected:
	  TStreamFilter();
	inline void Set(MStreamBuf* aHost,TInt aMode);
	inline void Committed();
	inline TBool IsCommitted() const;
	  void EmitL(const TAny* aPtr,TInt aLength);
 
	  void DoRelease();
	  void DoSynchL();
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
private:
	 





	virtual TInt Capacity(TInt aMaxLength)=0;

	 









	virtual TInt FilterL(TAny* aPtr,TInt aMaxLength,const TUint8*& aFrom,const TUint8* anEnd)=0;
private:
	MStreamBuf* iHost;
	TInt iMode;
private:
	friend class TFilterInput;
	friend class TFilterOutput;
private:
	  static void __DbgChkMode(TInt aMode);
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32buf.inl" 1
 
 
 
 

 
inline TStreamPos::TStreamPos(TInt anOffset)
	: iOff(anOffset)
 


	{}
inline TBool TStreamPos::operator==(TStreamPos aPos) const
 




	{return iOff==aPos.iOff;}
inline TBool TStreamPos::operator!=(TStreamPos aPos) const
 




	{return iOff!=aPos.iOff;}
inline TBool TStreamPos::operator<(TStreamPos aPos) const
 




	{return iOff<aPos.iOff;}
inline TBool TStreamPos::operator<=(TStreamPos aPos) const
 





	{return iOff<=aPos.iOff;}
inline TBool TStreamPos::operator>(TStreamPos aPos) const
 




	{return iOff>aPos.iOff;}
inline TBool TStreamPos::operator>=(TStreamPos aPos) const
 





	{return iOff>=aPos.iOff;}
inline TInt TStreamPos::operator-(TStreamPos aPos) const
 




	{return iOff-aPos.iOff;}
inline TStreamPos TStreamPos::operator+(TInt anOffset) const
 




	{return TStreamPos(iOff+anOffset);}
inline TStreamPos TStreamPos::operator-(TInt anOffset) const
 




	{return TStreamPos(iOff-anOffset);}
inline TStreamPos& TStreamPos::operator+=(TInt anOffset)
 



	{iOff+=anOffset;return *this;}
inline TStreamPos& TStreamPos::operator-=(TInt anOffset)
 



	{iOff-=anOffset;return *this;}
inline TInt TStreamPos::Offset() const
 


	{return iOff;}
inline TStreamPos operator+(TInt anOffset,TStreamPos aPos)
	{return aPos+anOffset;}

 
inline TStreamTransfer::TStreamTransfer(TInt aMaxLength)
	: iVal(aMaxLength)
 






	{



	}
inline TStreamTransfer::TStreamTransfer(TUnlimited)
	: iVal(-1)
 








	{}
inline TBool TStreamTransfer::operator==(TInt aLength) const
 





	{



	return iVal==aLength;
	}
inline TBool TStreamTransfer::operator>(TInt aLength) const
 





	{



	return TUint(iVal)>TUint(aLength);
	}
inline TStreamTransfer TStreamTransfer::operator-(TInt aLength) const
 








	{



	return iVal<0?*this:TStreamTransfer(iVal-aLength);
	}
inline TInt TStreamTransfer::operator[](TInt aMaxLength) const
	{return *this>aMaxLength?aMaxLength:iVal;}
inline TStreamTransfer& TStreamTransfer::operator-=(TInt aLength)
 













	{



	if (iVal>=0)
		{
		iVal-=aLength;



		}
	return *this;
	}
inline TInt TStreamTransfer::Left() const
 


	{



	return iVal;
	}
inline TBool operator==(TInt aLength,TStreamTransfer aTransfer)
	{return aTransfer==aLength;}
inline TBool operator<(TInt aLength,TStreamTransfer aTransfer)
	{return aTransfer>aLength;}

 
inline void MStreamBuf::Release()
 








	{DoRelease();}
inline void MStreamBuf::SynchL()
 






	{DoSynchL();}
inline TInt MStreamBuf::ReadL(TAny* aPtr,TInt aMaxLength)
 









	{return DoReadL(aPtr,aMaxLength);}
inline TInt MStreamBuf::ReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 














	{return DoReadL(aDes,aMaxLength,aStatus);}
inline TStreamTransfer MStreamBuf::ReadL(MStreamInput& anInput,TStreamTransfer aTransfer)
 







	{return DoReadL(anInput,aTransfer);}
inline void MStreamBuf::ReadL(MStreamInput& anInput)
 







	{DoReadL(anInput,TStreamTransfer(TStreamTransfer::EUnlimited) );}
inline void MStreamBuf::WriteL(const TAny* aPtr,TInt aLength)
 








	{DoWriteL(aPtr,aLength);}
inline TInt MStreamBuf::WriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 















	{return DoWriteL(aDes,aMaxLength,aStatus);}
inline TStreamTransfer MStreamBuf::WriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer)
 








	{return DoWriteL(anOutput,aTransfer);}
inline void MStreamBuf::WriteL(MStreamOutput& anOutput)
 








	{DoWriteL(anOutput,TStreamTransfer(TStreamTransfer::EUnlimited) );}
inline void MStreamBuf::SeekL(TMark aMark,TStreamPos aPos)
 











	{DoSeekL(aMark,EStreamBeginning,aPos.Offset());}
inline TStreamPos MStreamBuf::SeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset)
 























	{return DoSeekL(aMark,aLocation,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TRead,TStreamLocation aLocation,TInt anOffset)
 



















	{return DoSeekL(ERead,aLocation,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TWrite,TStreamLocation aLocation,TInt anOffset)
 



















	{return DoSeekL(EWrite,aLocation,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TRead,TInt anOffset)
 










	{return DoSeekL(ERead,EStreamMark,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TWrite,TInt anOffset)
 










	{return DoSeekL(EWrite,EStreamMark,anOffset);}
inline TStreamPos MStreamBuf::TellL(TRead) const
 






	{return (const_cast< MStreamBuf* >( this )) ->DoSeekL(ERead,EStreamMark,0);}
inline TStreamPos MStreamBuf::TellL(TWrite) const
 






	{return (const_cast< MStreamBuf* >( this )) ->DoSeekL(EWrite,EStreamMark,0);}
inline TInt MStreamBuf::SizeL() const
 


	{return (const_cast< MStreamBuf* >( this )) ->DoSeekL(0,EStreamEnd,0).Offset();}

 
inline void TStreamBuf::SetBuf(TRead,TUint8* aPtr,TUint8* anEnd)
 








	{iRPtr=aPtr;iREnd=anEnd;}
inline void TStreamBuf::SetBuf(TWrite,TUint8* aPtr,TUint8* anEnd)
 








	{iWPtr=aPtr;iWEnd=anEnd;}
inline void TStreamBuf::SetPtr(TRead,TUint8* aPtr)
 






	{iRPtr=aPtr;}
inline void TStreamBuf::SetPtr(TWrite,TUint8* aPtr)
 






	{iWPtr=aPtr;}
inline void TStreamBuf::SetEnd(TRead,TUint8* anEnd)
	{iREnd=anEnd;}
inline void TStreamBuf::SetEnd(TWrite,TUint8* anEnd)
	{iWEnd=anEnd;}
inline TUint8* TStreamBuf::Ptr(TRead) const
 




	{return iRPtr;}
inline TUint8* TStreamBuf::Ptr(TWrite) const
 




	{return iWPtr;}
inline TUint8* TStreamBuf::End(TRead) const
 






	{return iREnd;}
inline TUint8* TStreamBuf::End(TWrite) const
 






	{return iWEnd;}
inline TInt TStreamBuf::Avail(TRead) const
 





	{return iREnd-iRPtr;}
inline TInt TStreamBuf::Avail(TWrite) const
 





	{return iWEnd-iWPtr;}

 
inline void TStreamFilter::Set(MStreamBuf* aHost,TInt aMode)
 













	{



	iHost=aHost;iMode=aMode;
	}
inline void TStreamFilter::Committed()
 
	{iMode&=~EWrite;}
inline TBool TStreamFilter::IsCommitted() const
 


	{return iHost== 0L ||!(iMode&EWrite);}

# 499 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32buf.h" 2


# 8 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h" 1
 
 
 
 
# 352 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h"

# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 2


class TStreamExchange;
 
















class TStreamMark
	{
public:
	inline TStreamMark();
	inline TStreamMark(TStreamPos aPos);
	inline TStreamMark& operator=(TStreamPos aPos);
	inline operator TStreamMark*();
	inline operator const TStreamMark*() const;
 
	inline TBool operator==(const TStreamMark& aMark) const;
	inline TBool operator==(const TStreamMark* aPtr) const;
	inline TBool operator!=(const TStreamMark& aMark) const;
	inline TBool operator!=(const TStreamMark* aPtr) const;
 
	inline TBool IsEmpty() const;
	inline void Clear();
	inline TStreamPos Position() const;
 
	inline TBool IsWith(TStreamExchange& aHost) const;
	inline TBool RelatesTo(TStreamExchange& aHost) const;
	inline void Withdraw(TStreamExchange& aHost);
	inline void ExtractL(TStreamExchange& aHost);
 
	inline TInt ReadL(TStreamExchange& aHost,TAny* aPtr,TInt aMaxLength);
	  TInt ReadL(TStreamExchange& aHost,TDes8& aDes,TRequestStatus& aStatus);
	inline TInt ReadL(TStreamExchange& aHost,TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer ReadL(TStreamExchange& aHost,MStreamInput& anInput,TStreamTransfer aTransfer);
	inline TInt ReadL(TStreamExchange& aHost,MStreamInput& anInput,TInt aMaxLength);
	inline void ReadL(TStreamExchange& aHost,MStreamInput& anInput);
 
	inline void WriteL(TStreamExchange& aHost,const TAny* aPtr,TInt aLength);
	  TInt WriteL(TStreamExchange& aHost,const TDesC8& aDes,TRequestStatus& aStatus);
	inline TInt WriteL(TStreamExchange& aHost,const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TStreamTransfer aTransfer);
	inline TInt WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TInt aMaxLength);
	inline void WriteL(TStreamExchange& aHost,MStreamOutput& anOutput);
 
	inline void SeekL(TStreamExchange& aHost,TStreamPos aPos);
	inline TStreamPos SeekL(TStreamExchange& aHost,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TStreamExchange& aHost,TInt anOffset);
 
	inline TStreamPos TellL(TStreamExchange& aHost) const;
private:
	 






	TStreamMark(const TStreamMark&);
	TStreamMark& operator=(const TStreamMark&);
private:
	TStreamPos iPos;
private:
	inline TBool IsTracking(TStreamMark*const& aRef) const;
	inline void Track(TStreamMark*const& aRef);
private:
	friend class TStreamExchange;
private:
	  static void __DbgChkPos(TStreamPos aPos);
	};

 













class TStreamExchange
	{
public:
	inline TStreamExchange();
	inline TStreamExchange(MStreamBuf* aHost);
	inline void Share(MStreamBuf* aHost);
	inline TBool IsActive() const;
	  MStreamBuf* Host();
	  MStreamBuf* HostL();
	  void Release();
 
	  TInt SizeL() const;
private:
 












	typedef MStreamBuf::TMark TMark;
private:
	 


	TStreamExchange(const TStreamExchange&);
	TStreamExchange& operator=(const TStreamExchange&);
 
	  TBool RefersTo(const TStreamMark& aMark);
	  void Drop(const TStreamMark& aMark);
	  void GetL(TStreamMark& aMark);
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength,TStreamMark& aMark);
	  TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	  TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer,TStreamMark& aMark);
	  void DoWriteL(const TAny* aPtr,TInt aLength,TStreamMark& aMark);
	  TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	  TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer,TStreamMark& aMark);
	  TStreamPos DoSeekL(TStreamMark& aMark,TStreamLocation aLocation,TInt anOffset);
 
	void PrepareForReadingL(TStreamMark& aMark);
	void PrepareForWritingL(TStreamMark& aMark);
 
	TInt PrepareAndReadL(TAny* aPtr,TInt aMaxLength,TStreamMark& aMark);
	TInt PrepareAndReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	TStreamTransfer PrepareAndReadL(MStreamInput& anInput,TStreamTransfer aTransfer,TStreamMark& aMark);
	void PrepareAndWriteL(const TAny* aPtr,TInt aLength,TStreamMark& aMark);
	TInt PrepareAndWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	TStreamTransfer PrepareAndWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer,TStreamMark& aMark);
	TStreamPos MarkSeekL(TStreamMark& aMark,TStreamLocation aLocation,TInt anOffset);
 
	inline MStreamBuf& BufL() const;
	inline MStreamBuf& Buf() const;
private:
	MStreamBuf* iHost;
	TStreamMark* iRMrk;
	TStreamMark* iWMrk;
private:
	friend class TStreamMark;
	};

 
























class RShareBuf : public MStreamBuf
	{
public:
	  RShareBuf();
	  void Open(TStreamExchange& aHost,TStreamPos aPos,TInt aMode=ERead|EWrite);
	inline void Open(TStreamExchange& aHost,TInt aMode=ERead|EWrite);
protected:
	  void DoRelease();
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline TStreamExchange& Host() const;
private:
	TStreamExchange* iHost;
	TStreamMark iRMark;
	TStreamMark iWMark;
	};

 












class RShareReadStream : public RReadStream
	{
public:
	 




	RShareReadStream() {}
	  RShareReadStream(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
	  void Open(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
private:
	RShareBuf iSource;
	};

 












class RShareWriteStream : public RWriteStream
	{
public:
	 




	RShareWriteStream() {}
	inline RShareWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RShareWriteStream(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
	  void Open(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
private:
	RShareBuf iSink;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.inl" 1
 
 
 
 

 
inline TStreamMark::TStreamMark()
	: iPos(TStreamPos(0) -1)
 






	{}
inline TStreamMark::TStreamMark(TStreamPos aPos)
	: iPos(aPos)
 






	{



	}
inline TStreamMark& TStreamMark::operator=(TStreamPos aPos)
 



	{



	iPos=aPos;
	return *this;
	}
inline TStreamMark::operator TStreamMark*()
	{return this;}
inline TStreamMark::operator const TStreamMark*() const
	{return this;}
inline TBool TStreamMark::operator==(const TStreamMark& aMark) const
 




	{return this==&aMark;}
inline TBool TStreamMark::operator==(const TStreamMark* aPtr) const
	{return this==aPtr;}
inline TBool TStreamMark::operator!=(const TStreamMark& aMark) const
 




	{return this!=&aMark;}
inline TBool TStreamMark::operator!=(const TStreamMark* aPtr) const
	{return this!=aPtr;}
inline TBool TStreamMark::IsEmpty() const
 


	{return iPos< TStreamPos(0) ;}
inline void TStreamMark::Clear()
 





	{iPos= TStreamPos(0) -1;}
inline TStreamPos TStreamMark::Position() const
 


	{



	return iPos;
	}
inline TBool TStreamMark::IsWith(TStreamExchange& aHost) const
 




	{return aHost.RefersTo(*this);}
inline TBool TStreamMark::RelatesTo(TStreamExchange& aHost) const
 







	{return iPos>= TStreamPos(0) ||aHost.RefersTo(*this);}
inline void TStreamMark::Withdraw(TStreamExchange& aHost)
 



	{aHost.Drop(*this);}
inline void TStreamMark::ExtractL(TStreamExchange& aHost)
 



	{aHost.GetL(*this);}
inline TInt TStreamMark::ReadL(TStreamExchange& aHost,TAny* aPtr,TInt aMaxLength)
 






	{return aHost.DoReadL(aPtr,aMaxLength,*this);}
inline TInt TStreamMark::ReadL(TStreamExchange& aHost,TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 











	{return aHost.DoReadL(aDes,aMaxLength,aStatus,*this);}
inline TStreamTransfer TStreamMark::ReadL(TStreamExchange& aHost,MStreamInput& anInput,TStreamTransfer aTransfer)
 






	{return aHost.DoReadL(anInput,aTransfer,*this);}
inline TInt TStreamMark::ReadL(TStreamExchange& aHost,MStreamInput& anInput,TInt aMaxLength)
 






	{return aMaxLength-aHost.DoReadL(anInput,TStreamTransfer(aMaxLength),*this).Left();}
inline void TStreamMark::ReadL(TStreamExchange& aHost,MStreamInput& anInput)
 





	{aHost.DoReadL(anInput,TStreamTransfer(TStreamTransfer::EUnlimited) ,*this);}
inline void TStreamMark::WriteL(TStreamExchange& aHost,const TAny* aPtr,TInt aLength)
 





	{aHost.DoWriteL(aPtr,aLength,*this);}
inline TInt TStreamMark::WriteL(TStreamExchange& aHost,const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 













	{return aHost.DoWriteL(aDes,aMaxLength,aStatus,*this);}
inline TStreamTransfer TStreamMark::WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TStreamTransfer aTransfer)
 






	{return aHost.DoWriteL(anOutput,aTransfer,*this);}
inline TInt TStreamMark::WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TInt aMaxLength)
 





	{return aMaxLength-aHost.DoWriteL(anOutput,TStreamTransfer(aMaxLength),*this).Left();}
inline void TStreamMark::WriteL(TStreamExchange& aHost,MStreamOutput& anOutput)
 





	{aHost.DoWriteL(anOutput,TStreamTransfer(TStreamTransfer::EUnlimited) ,*this);}
inline void TStreamMark::SeekL(TStreamExchange& aHost,TStreamPos aPos)
	{aHost.DoSeekL(*this,EStreamBeginning,aPos.Offset());}
inline TStreamPos TStreamMark::SeekL(TStreamExchange& aHost,TStreamLocation aLocation,TInt anOffset)
 














	{return aHost.DoSeekL(*this,aLocation,anOffset);}
inline TStreamPos TStreamMark::SeekL(TStreamExchange& aHost,TInt anOffset)
 





	{return aHost.DoSeekL(*this,EStreamMark,anOffset);}
inline TStreamPos TStreamMark::TellL(TStreamExchange& aHost) const
 



	{return aHost.DoSeekL((const_cast< TStreamMark& >( *this )) ,EStreamMark,0);}

 
inline TStreamExchange::TStreamExchange()
	: iHost(0L ),iRMrk(0L ),iWMrk(0L )
 


	{}
inline TStreamExchange::TStreamExchange(MStreamBuf* aHost)
	: iHost(aHost),iRMrk(0L ),iWMrk(0L )
 



	{}
inline void TStreamExchange::Share(MStreamBuf* aHost)
 



	{iHost=aHost;}
inline TBool TStreamExchange::IsActive() const
 



	{return iHost!= 0L ;}
	
 
inline void RShareBuf::Open(TStreamExchange& aHost,TInt aMode)
 










	{Open(aHost,TStreamPos(0) ,aMode);}

 
inline RShareWriteStream::RShareWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

# 277 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 2


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.h" 1
 
 
 
 






 
const TInt KPoolPageSize=512;
 
const TUint32 KNullPageRefValue=0;

 






class TPageRef
	{
public:
	 
	inline TPageRef() {}
	inline TPageRef(TUint32 aValue);
 
	inline TBool operator==(TPageRef aRef) const;
	inline TBool operator!=(TPageRef aRef) const;
 
	inline void ExternalizeL(RWriteStream& aStream) const;
	inline void InternalizeL(RReadStream& aStream);
 
	inline TUint32 Value() const;
private:
	TUint32 iVal;
	};







class MPagePool;
 



typedef void (*TPageAbandonFunction)(MPagePool& aPool);

 




enum TPageReclamation 
	 



	{EPageDeleteOnly,
	 



	EPageReclaimable};

 
enum TPageChange 
	 
	{EPageNoChange,
	 
	EPageDirty,
	 
	EPageUpdate,
	 
	EPageAbandon=-1};


 








class MPagePool
	{
public:
	  void PushL();
	inline void Pop();

	 


	virtual TPageAbandonFunction AcquireL()=0;
 
	virtual TAny* AllocL()=0;

	 



	virtual TAny* LockL(TPageRef aRef)=0;
 
	virtual TPageRef AssignL(const TAny* aPage,TPageReclamation aReclamation=EPageDeleteOnly)=0;

	 




	virtual void UpdateL(const TAny* aPage)=0;

	 



	virtual void Unlock(const TAny* aPage,TPageChange aChange=EPageNoChange)=0;
 
	  void Delete(TPageRef aRef);
	  void DeleteL(TPageRef aRef);
protected:
	virtual void DoDeleteL(TPageRef aRef)=0;
	};

 







class CMemPagePool : public CBase,public MPagePool
	{
public:
	  static CMemPagePool* NewL();
	  static CMemPagePool* NewLC();
	  CMemPagePool();
	  ~CMemPagePool();
 
	  TPageAbandonFunction AcquireL();
	  TAny* AllocL();
	  TAny* LockL(TPageRef aRef);
	  TPageRef AssignL(const TAny* aPage,TPageReclamation aReclamation=EPageDeleteOnly);
	  void UpdateL(const TAny* aPage);
	  void Unlock(const TAny* aPage,TPageChange aChange=EPageNoChange);
protected:
	  void DoDeleteL(TPageRef aRef);
private:
	TAny*& PageL(TPageRef aRef);
	static void DoAbandon(MPagePool& aPool);
private:
	CArrayFixSeg<TAny*> iPages;
	};
 



 
class TCachePage;
struct SCachePage;
class TCachePagePool;

 







class CPageCache : public CBase
	{
public:
	enum {EDefaultPages=20};
# 205 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.h"

public:
	  static CPageCache* NewL(TInt aPages=EDefaultPages);
	  static CPageCache* NewLC(TInt aPages=EDefaultPages);
	  CPageCache();
	  void ConstructL(TInt aPages=EDefaultPages);
	  ~CPageCache();
 




private:
	TCachePage* Find(TCachePagePool* aPool,TPageRef aRef);
private:
	SCachePage* iPages;
	SCachePage* iEnd;
	TDblQue<TCachePage> iFree;



private:
	friend class TCachePagePool;
	};

 










class TCachePagePool : public MPagePool
	{
public:
	inline void Set(CPageCache& aCache);
 
	  TPageAbandonFunction AcquireL();
	  TAny* AllocL();
	  TAny* LockL(TPageRef aRef);
	  TPageRef AssignL(const TAny* aPage,TPageReclamation aReclamation=EPageDeleteOnly);
	  void UpdateL(const TAny* aPage);
	  void Unlock(const TAny* aPage,TPageChange aChange=EPageNoChange);
 
	  TInt Flush();
	  void FlushL();
	  void Purge();
protected:
	inline TCachePagePool();
	inline TCachePagePool(CPageCache& aCache);
	  void DoDeleteL(TPageRef aRef);
private:
	virtual TPageRef ExtendL(const TAny* aPage,TPageReclamation aReclamation)=0;
	virtual void WriteL(TPageRef aRef,const TAny* aPage,TPageChange aChange)=0;
	virtual void ReadL(TPageRef aRef,TAny* aPage)=0;
 
	static void DoAbandon(MPagePool& aPool);
	static TCachePage* DoAllocL(CPageCache& aCache);
private:
	CPageCache* iCache;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.inl" 1
 
 
 
 

 
inline TPageRef::TPageRef(TUint32 aValue)
	: iVal(aValue)
 


	{}
inline TBool TPageRef::operator==(TPageRef aRef) const
 



	{return iVal==aRef.iVal;}
inline TBool TPageRef::operator!=(TPageRef aRef) const
 




	{return iVal!=aRef.iVal;}
inline void TPageRef::ExternalizeL(RWriteStream& aStream) const
 


	{aStream<<iVal;}
inline void TPageRef::InternalizeL(RReadStream& aStream)
 


	{aStream>>iVal;}
inline TUint32 TPageRef::Value() const
 


	{return iVal;}

 
inline void MPagePool::Pop()
 
	{CleanupStack::Pop();}

 
# 57 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.inl"


 







 
inline void TCachePagePool::Set(CPageCache& aCache)
 


	{iCache=&aCache;}
inline TCachePagePool::TCachePagePool()
	: iCache(0L )
	{}
inline TCachePagePool::TCachePagePool(CPageCache& aCache)
	: iCache(&aCache)
	{}

# 271 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.h" 2


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 2



class MIncrementalCollector;
 





class CStreamStore : public CBase
	{
public:
	inline TStreamId ExtendL();
	  void Delete(TStreamId anId);
	  void DeleteL(TStreamId anId);
 
	  TInt Commit();
	inline void CommitL();
	  void Revert();
	inline void RevertL();
 
	  TInt ReclaimL();
	  TInt CompactL();
private:
	virtual   TStreamId DoExtendL();
	virtual   void DoDeleteL(TStreamId anId);
	
	 









	virtual MStreamBuf* DoReadL(TStreamId anId) const=0;
	
	 






	virtual MStreamBuf* DoCreateL(TStreamId& anId)=0;
	virtual   MStreamBuf* DoWriteL(TStreamId anId);
	virtual   MStreamBuf* DoReplaceL(TStreamId anId);
	virtual   void DoCommitL();
	virtual   void DoRevertL();
	virtual   MIncrementalCollector* DoReclaimL();
	virtual   MIncrementalCollector* DoCompactL();
private:
	friend class RStoreReadStream;
	friend class RStoreWriteStream;
	friend class RStoreReclaim;
	};

 











class CPersistentStore : public CStreamStore
	{
public:
	inline TStreamId Root() const;
	inline void SetRootL(TStreamId anId);
protected:
	inline CPersistentStore();
private:
	virtual   void DoSetRootL(TStreamId anId);
protected:
	TStreamId iRoot;
	};

 























class RStoreReclaim
	{
public:
	inline RStoreReclaim();
	  void OpenL(CStreamStore& aStore,TInt& aCount);
	  void OpenLC(CStreamStore& aStore,TInt& aCount);
	  void CompactL(CStreamStore& aStore,TInt& aCount);
	  void CompactLC(CStreamStore& aStore,TInt& aCount);
	inline void Close();
	  void Release();
 
	  void ResetL(TInt& aCount);
	  void NextL(TInt& aStep);
	  void Next(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus);
	  void NextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus);
	  TInt Next(TInt& aStep);
 
	inline TInt Available() const;
private:
	MIncrementalCollector* iCol;
	TPckgBuf<TInt> iAvail;
	};

 















class CEmbeddedStore : public CPersistentStore
	{
public:
	  static CEmbeddedStore* FromL(RReadStream& aHost);
	  static CEmbeddedStore* FromLC(RReadStream& aHost);
	  static CEmbeddedStore* NewL(RWriteStream& aHost);
	  static CEmbeddedStore* NewLC(RWriteStream& aHost);
 
	inline static TStreamPos Position(TStreamId anId);
 
	  void Detach();
	inline void Reattach(MStreamBuf* aHost);
	inline MStreamBuf* Host() const;
	inline TStreamPos Start() const;
 
	  CEmbeddedStore(MStreamBuf* aHost);
	  void MarshalL(RReadStream& aStream);
	  void ConstructL(RWriteStream& aStream);
	  ~CEmbeddedStore();
protected:
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
private:
	  void DoSetRootL(TStreamId anId);
	  void DoCommitL();
 
	static CEmbeddedStore* DoNewLC(MStreamBuf* aHost);
private:
	  TStreamExchange iHost;
	TStreamPos iStart;
	};

 























class CDictionaryStore : public CBase
	{
public:
	  TBool IsNullL() const;
	  TBool IsPresentL(TUid aUid) const;
	  void Remove(TUid aUid);
	  void RemoveL(TUid aUid);
 
	  TInt Commit();
	  void CommitL();
	  void Revert();
	  void RevertL();
 
	  ~CDictionaryStore();
protected:
	  void ConstructL();
private:
	CStreamDictionary* DictionaryL() const;
	MStreamBuf* GetSourceL(TUid aUid) const;
	MStreamBuf* GetSinkL(TUid aUid);
protected:
	CPersistentStore* iStore;
private:
	  CStreamDictionary* iDictionary;
	TBool iDictionaryHasChanged;
private:
	friend class RDictionaryReadStream;
	friend class RDictionaryWriteStream;
	friend class HDictionaryStoreBuf;
	};
 
const TInt KDictionaryCommitThreshold = 1024;

 









class RDictionaryReadStream : public RReadStream
{
public:
	  void OpenL(const CDictionaryStore& aDictStore,TUid aUid);
	  void OpenLC(const CDictionaryStore& aDictStore,TUid aUid);
	};

 






class RDictionaryWriteStream : public RWriteStream
	{
public:
	 

	RDictionaryWriteStream() {}
	inline RDictionaryWriteStream(const MExternalizer<TStreamRef>& anExter);
	  void AssignL(CDictionaryStore& aDictStore,TUid aUid);
	  void AssignLC(CDictionaryStore& aDictStore,TUid aUid);
	};

 






class TStorePagePoolToken
	{
public:
	 
	enum TEmpty 
		 
		{EEmpty};
public:
	 
	TStorePagePoolToken() {}

	 


	inline TStorePagePoolToken(TEmpty);
	inline void Touch();
 
	inline TBool HasAvailable() const;
	inline TBool IsEmpty() const;
 
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
private:
	inline TStorePagePoolToken(TStreamId aHead,TPageRef anAvail);
private:
	TStreamId iHead;
	TPageRef iAvail;
private:
	friend class RStorePagePool;
	};







 























class RStorePagePool : public TCachePagePool
	{
	friend class StorePagePool;
public:
	  RStorePagePool();
	  RStorePagePool(CPageCache& aCache);
	  RStorePagePool(CStreamStore& aStore);
	  RStorePagePool(CStreamStore& aStore,const TStorePagePoolToken& aToken);
	  void Create(CStreamStore& aStore);
	  void Open(CStreamStore& aStore,const TStorePagePoolToken& aToken);
	  TStorePagePoolToken Token() const;
	  void Close();
	inline void Release();
 
	inline TBool IsDirty() const;
	inline void MarkCurrent();
	inline void MarkDirty();
 
	inline TBool HasAvailable() const;
	inline void Discard();
 
	inline TBool IsEmpty() const;
	  TBool ReclaimL();
	  void ReclaimAllL();
protected:
	  TPageRef ExtendL(const TAny* aPage,TPageReclamation aReclamation);
	  void WriteL(TPageRef aRef,const TAny* aPage,TPageChange aChange);
	  void ReadL(TPageRef aRef,TAny* aPage);
	  void DoDeleteL(TPageRef aRef);
private:
	inline void CacheDeleteL(TPageRef aRef);
private:
	CStreamStore* iStore;
	TStreamId iHead;
	TPageRef iAvail;
	TBool iDirty;
	};

 




















class MIncrementalCollector
	{
public:
	inline void Close();
	inline void Release();
 
	inline void ResetL(TInt& aCount);
	inline void NextL(TInt& aStep,TInt& aTotal);
	inline void NextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus,TPckgBuf<TInt>& aTotal);
protected:
	 







	MIncrementalCollector() {}
private:
	 







	MIncrementalCollector(const MIncrementalCollector&);
	MIncrementalCollector& operator=(const MIncrementalCollector&);
 
	virtual   void DoRelease();
	
	 





	virtual void DoResetL(TInt& aCount)=0;

	 











	virtual void DoNextL(TInt& aStep,TInt& aTotal)=0;
	virtual   void DoNextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus,TPckgBuf<TInt>& aTotal);
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.inl" 1
 
 
 
 

 
inline TStreamId CStreamStore::ExtendL()
 






	{return DoExtendL();}
inline void CStreamStore::CommitL()
 


	{DoCommitL();}
inline void CStreamStore::RevertL()
 






	{DoRevertL();}

 
inline CPersistentStore::CPersistentStore()
 
	{}
inline TStreamId CPersistentStore::Root() const
 


	{return iRoot;}
inline void CPersistentStore::SetRootL(TStreamId anId)
 


	{DoSetRootL(anId);}

 
inline RStoreReclaim::RStoreReclaim()
	: iCol(0L )
	{}
inline void RStoreReclaim::Close()
 










	{Release();}
inline TInt RStoreReclaim::Available() const
 



	{return (const_cast< TPckgBuf<TInt>& >( iAvail )) ();}

 
inline TStreamPos CEmbeddedStore::Position(TStreamId anId)
 




	{return TStreamPos(anId.Value());}
inline void CEmbeddedStore::Reattach(MStreamBuf* aHost)
 




	{iHost.Share(aHost);}
inline MStreamBuf* CEmbeddedStore::Host() const
 



	{return (const_cast< TStreamExchange& >( iHost )) .Host();}
inline TStreamPos CEmbeddedStore::Start() const
 


	{return iStart;}

 
inline RDictionaryWriteStream::RDictionaryWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
 




	{}

 
inline TStorePagePoolToken::TStorePagePoolToken(TEmpty)
	: iHead(TStreamId(KNullStreamIdValue) ),iAvail(TPageRef(KNullPageRefValue) )
 


	{}
inline void TStorePagePoolToken::Touch()
 
	{iAvail= TPageRef(KNullPageRefValue) ;}
inline TBool TStorePagePoolToken::HasAvailable() const
 


	{return iAvail!= TPageRef(KNullPageRefValue) ;}
inline TBool TStorePagePoolToken::IsEmpty() const
 


	{return iHead== TStreamId(KNullStreamIdValue) ;}

 
inline void RStorePagePool::Release()
 
	{Purge();iStore= 0L ;}
inline TBool RStorePagePool::IsDirty() const
 


	{return iDirty;}
inline void RStorePagePool::MarkCurrent()
 
	{iDirty=EFalse;}
inline void RStorePagePool::MarkDirty()	
 
	{iDirty=ETrue;}
inline TBool RStorePagePool::HasAvailable() const
 


	{return iAvail!= TPageRef(KNullPageRefValue) ;}
inline void RStorePagePool::Discard()
 




	{iAvail= TPageRef(KNullPageRefValue) ;}
inline TBool RStorePagePool::IsEmpty() const
 


	{return iHead== TStreamId(KNullStreamIdValue) ;}

 
inline void MIncrementalCollector::Close()
 


	{DoRelease();}
inline void MIncrementalCollector::Release()
 




	{DoRelease();}
inline void MIncrementalCollector::ResetL(TInt& aCount)
 






	{DoResetL(aCount);}
inline void MIncrementalCollector::NextL(TInt& aStep,TInt& aTotal)
 













	{DoNextL(aStep,aTotal);}
inline void MIncrementalCollector::NextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus,TPckgBuf<TInt>& aTotal)
 
















	{DoNextL(aStep,aStatus,aTotal);}

# 470 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 2


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h" 2



 
const TInt KDefaultFileBufSize=0x600;

template <class T>
class TCapture;
class RPermanentFileStoreIter;

 


















class RFileBuf : public TStreamBuf
	{
public:
	  RFileBuf();
	  RFileBuf(TInt aSize);
	RFileBuf(TCapture<RFileBuf> aCapture);
	  void Reset();
	inline void Reset(TInt aSize);
 
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	  void Attach(RFile& aFile,TInt aPos=0);
	  void Close();
	inline void Detach();
	inline void Reattach(RFile& aFile);
 
	  void SetSizeL(TInt aSize);
	inline RFile& File() const;
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  void DoRelease();
	  void DoSynchL();
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
 
	inline void SetBuf(TRead,TUint8* aPtr,TUint8* anEnd);
	inline void SetBuf(TWrite,TUint8* aPtr,TUint8* anEnd);
	inline void SetBuf(TArea anArea,TUint8* aPtr,TUint8* anEnd);
private:
	TUint8* AllocL();
	void Free();
 
	void SetPos(TMark aMark,TInt aPos);
	inline void SetPos(TRead,TInt aPos);
	inline void SetPos(TWrite,TInt aPos);
	inline TInt Pos(TRead) const;
	inline TInt Pos(TWrite) const;
	inline TInt MovePos(TRead,TInt anOffset);
	inline TInt MovePos(TWrite,TInt anOffset);
	TInt FileReadL(TAny* aPtr,TInt aMaxLength);
	void FileWriteL(const TAny* aPtr,TInt aLength,TInt aSeek);
	void FileWriteL(const TAny* aPtr,TInt aLength);
	TInt EndL();
 
	inline TInt Lag(TRead) const;
	inline TInt Lag(TWrite) const;
	TInt Mark(TMark aMark) const;
	inline TInt Mark(TRead) const;
	inline TInt Mark(TWrite) const;
	inline TUint8* Limit(TWrite) const;
	inline void SetLimit(TWrite,TUint8* aLimit);
	inline TInt Span(TWrite) const;
	inline TInt Reach(TWrite) const;
private:
	TUint8* iBase;
	TInt iSize;
	  RFile iFile;
	TInt iRPos;
	TInt iWPos;
	TInt iExt;
	TUint8* iWLim;
	};

 




class RFileReadStream : public RReadStream
	{
public:
	 
	RFileReadStream() {}
	  RFileReadStream(RFile& aFile,TInt aPos=0);
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  void Attach(RFile& aFile,TInt aPos=0);
private:
	RFileBuf iSource;
	};

 




class RFileWriteStream : public RWriteStream
	{
public:
	 
	RFileWriteStream() {}
	inline RFileWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RFileWriteStream(RFile& aFile,TInt aPos=0);
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	  void Attach(RFile& aFile,TInt aPos=0);
private:
	RFileBuf iSink;
	};
 
class CFileStore;

 





class FileStoreFactory
	{
public:
	  static CFileStore* DirectLC(RFileBuf& aBuf,const TUidType& aType);
	  static CFileStore* PermanentLC(RFileBuf& aBuf,const TUidType& aType);
	};
 
const TInt KDirectFileStoreLayoutUidValue=268435511;
 
const TInt KPermanentFileStoreLayoutUidValue=268435536;
 
const TUid KDirectFileStoreLayoutUid={KDirectFileStoreLayoutUidValue};
 
const TUid KPermanentFileStoreLayoutUid={KPermanentFileStoreLayoutUidValue};
 
typedef CFileStore* (*TFileStoreFactoryFunction)(RFileBuf& aBuf,const TUidType& aType);
 



 


















class CFileStore : public CPersistentStore
	{
public:
	  static CFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  static CFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  static CFileStore* FromL(RFile& aFile);
	  static CFileStore* FromLC(RFile& aFile);
 
	  static CFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode,const TFileStoreFactoryFunction aFactory[]);
	  static CFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode,const TFileStoreFactoryFunction aFactory[]);
	  static CFileStore* FromL(RFile& aFile,const TFileStoreFactoryFunction aFactory[]);
	  static CFileStore* FromLC(RFile& aFile,const TFileStoreFactoryFunction aFactory[]);
 
	inline const TUidType& Type() const;
	  void SetTypeL(const TUidType& aType);
	 








	virtual TUid Layout() const=0;
 
	inline void Reset();
	inline void Reset(TInt aSize);
	inline void Detach();
	inline void Reattach(RFile& aFile);
	inline RFile& File() const;
 
	  void MarshalL();
	  ~CFileStore();
protected:
	typedef CFileStore* (*TNewFunction)(RFile& aFile);
protected:
	  static CFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode,TFileStoreFactoryFunction aFunction);
	  static CFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode,TFileStoreFactoryFunction aFunction);
	  static CFileStore* CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode,TNewFunction aFunction);
 
	  static CFileStore* FromL(RFile& aFile,TFileStoreFactoryFunction aFunction);
	  static CFileStore* FromLC(RFile& aFile,TFileStoreFactoryFunction aFunction);
	  static CFileStore* NewL(RFile& aFile,TNewFunction aFunction);
	  static CFileStore* NewLC(RFile& aFile,TNewFunction aFunction);
 
	  CFileStore(RFile& aFile);
	  CFileStore(RFileBuf& aBuf,const TUidType& aType);
	  void Destruct();
 
	inline TStreamExchange& Host() const;
	inline TBool IsHost(const MStreamBuf* aBuf) const;
	  void SynchL();
	inline void SetSizeL(TInt aSize);
	  void ChangedL();
	  void RefreshL();
 
	  void DoCommitL();
	  void DoRevertL();
private:
	virtual void ExternalizeL(RWriteStream& aStream) const=0;
	virtual void InternalizeL(RReadStream& aStream)=0;
 
	static CFileStore* DoNewL(RFile& aFile,TNewFunction aFunction);
private:
	RFileBuf iBuf;
	TUidType iType;
	  TStreamExchange iHost;
	};
const TInt KFileStoreStartOffset=sizeof(TCheckedUid);






 










class CDirectFileStore : public CFileStore
	{
public:
	inline static CDirectFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	inline static CDirectFileStore* TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
 
	inline static CDirectFileStore* FromL(RFile& aFile);
	inline static CDirectFileStore* FromLC(RFile& aFile);
	inline static CDirectFileStore* NewL(RFile& aFile);
	inline static CDirectFileStore* NewLC(RFile& aFile);
 
	  TUid Layout() const;
 
	  CDirectFileStore(RFile& aFile);
	  CDirectFileStore(RFileBuf& aBuf,const TUidType& aType);
protected:
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
private:
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
	  void DoSetRootL(TStreamId anId);
 
	  static CFileStore* DoNewL(RFile& aFile);
	};
 
class CPermanentStoreCoord;

 







class CPermanentFileStore : public CFileStore
	{
	friend class RPermanentFileStoreIter;
public:
	inline static CPermanentFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	inline static CPermanentFileStore* TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
 
	inline static CPermanentFileStore* FromL(RFile& aFile);
	inline static CPermanentFileStore* FromLC(RFile& aFile);
	inline static CPermanentFileStore* NewL(RFile& aFile);
	inline static CPermanentFileStore* NewLC(RFile& aFile);
 
	  TUid Layout() const;
 
	  CPermanentFileStore(RFile& aFile);
	  CPermanentFileStore(RFileBuf& aBuf,const TUidType& aType);
	  void MarshalL();
	  ~CPermanentFileStore();
protected:
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
	  MStreamBuf* DoWriteL(TStreamId anId);
	  MStreamBuf* DoReplaceL(TStreamId anId);
private:
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
	  void DoSetRootL(TStreamId anId);
	  TStreamId DoExtendL();
	  void DoDeleteL(TStreamId anId);
	  void DoCommitL();
	  void DoRevertL();
	  MIncrementalCollector* DoReclaimL();
	  MIncrementalCollector* DoCompactL();
 
	inline CPermanentStoreCoord& Coord() const;
	CPermanentStoreCoord& CoordL() const;
	CPermanentStoreCoord& TrimL();
 
	  static CFileStore* DoNewL(RFile& aFile);
private:
	  CPermanentStoreCoord* iCoord;
	};

 









class CDictionaryFileStore : public CDictionaryStore
	{
public:
	  static CDictionaryFileStore* SystemL(RFs& aFs);
	  static CDictionaryFileStore* SystemLC(RFs& aFs);
	  static CDictionaryFileStore* OpenL(RFs& aFs,const TDesC& aName,TUid aUid3);
	  static CDictionaryFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUid aUid3);
private:
	void ConstructL(RFs& aFs,const TDesC& aName,TUid aUid3);
	void CreateStoreL(RFile& aFile,const TUidType& aType);
	};

 














class RFilePagePool : public TCachePagePool
	{
public:
	  RFilePagePool();
	  RFilePagePool(CPageCache& aCache);
 
	inline TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	inline void Attach(RFile& aFile);
	  void Close();
	  void Release();
	  TInt Flush();
	  void FlushL();
	inline void Detach();
 
	inline RFile& File() const;
protected:
	  TPageRef ExtendL(const TAny* aPage,TPageReclamation aReclamation);
	  void WriteL(TPageRef aRef,const TAny* aPage,TPageChange aChange);
	  void ReadL(TPageRef aRef,TAny* aPage);
private:
	  RFile iFile;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.inl" 1
 
 
 
 

 
inline void RFileBuf::Reset(TInt aSize)
 






	{Reset();iSize=aSize;}
inline void RFileBuf::Detach()
 







	{iFile=RFile();}
inline void RFileBuf::Reattach(RFile& aFile)
 









	{iFile=aFile;}
inline RFile& RFileBuf::File() const
 


	{return (const_cast< RFile& >( iFile )) ;}

 
inline RFileWriteStream::RFileWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

 
inline const TUidType& CFileStore::Type() const
 



	{return iType;}
inline void CFileStore::Reset()
 








	{iBuf.Reset();}
inline void CFileStore::Reset(TInt aSize)
 











	{iBuf.Reset(aSize);}
inline void CFileStore::Detach()
 











	{iBuf.Detach();}
inline void CFileStore::Reattach(RFile& aFile)
 




	{iBuf.Reattach(aFile);}
inline RFile& CFileStore::File() const
 





	{return iBuf.File();}
inline TStreamExchange& CFileStore::Host() const
	{return (const_cast< TStreamExchange& >( iHost )) ;}
inline TBool CFileStore::IsHost(const MStreamBuf* aBuf) const
	{return aBuf==&iBuf;}
inline void CFileStore::SetSizeL(TInt aSize)
	{iBuf.SetSizeL(aSize);}

 
inline CDirectFileStore* CDirectFileStore::OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CDirectFileStore* >( CFileStore::OpenL(aFs,aName,aFileMode,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CDirectFileStore* >( CFileStore::OpenLC(aFs,aName,aFileMode,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::CreateL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::CreateLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CDirectFileStore* >( CFileStore::ReplaceL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CDirectFileStore* >( CFileStore::ReplaceLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CDirectFileStore* >( CFileStore::TempL(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CDirectFileStore* >( CFileStore::TempLC(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::FromL(RFile& aFile)
 








	{return (static_cast< CDirectFileStore* >( CFileStore::FromL(aFile,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::FromLC(RFile& aFile)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::FromLC(aFile,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::NewL(RFile& aFile)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::NewL(aFile,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::NewLC(RFile& aFile)
 










	{return (static_cast< CDirectFileStore* >( CFileStore::NewLC(aFile,&DoNewL) )) ;}

 
inline CPermanentFileStore* CPermanentFileStore::OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CPermanentFileStore* >( CFileStore::OpenL(aFs,aName,aFileMode,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CPermanentFileStore* >( CFileStore::OpenLC(aFs,aName,aFileMode,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::CreateL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::CreateLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CPermanentFileStore* >( CFileStore::ReplaceL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CPermanentFileStore* >( CFileStore::ReplaceLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CPermanentFileStore* >( CFileStore::TempL(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CPermanentFileStore* >( CFileStore::TempLC(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::FromL(RFile& aFile)
 








	{return (static_cast< CPermanentFileStore* >( CFileStore::FromL(aFile,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::FromLC(RFile& aFile)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::FromLC(aFile,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::NewL(RFile& aFile)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::NewL(aFile,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::NewLC(RFile& aFile)
 










	{return (static_cast< CPermanentFileStore* >( CFileStore::NewLC(aFile,&DoNewL) )) ;}

 
inline TInt RFilePagePool::Open(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return iFile.Open(aFs,aName,aFileMode);}
inline TInt RFilePagePool::Create(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return iFile.Create(aFs,aName,aFileMode);}
inline TInt RFilePagePool::Replace(RFs& aFs,const TDesC& aName,TUint aFileMode)
 












	{return iFile.Replace(aFs,aName,aFileMode);}
inline TInt RFilePagePool::Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 









	{return iFile.Temp(aFs,aPath,aName,aFileMode);}
inline void RFilePagePool::Attach(RFile& aFile)
 


	{iFile=aFile;}
inline void RFilePagePool::Detach()
 
	{iFile=RFile();}
inline RFile& RFilePagePool::File() const
	{return (const_cast< RFile& >( iFile )) ;}

# 440 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h" 2


# 71 "../../libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 1
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/w32std.h" 1
 
 
 
 

 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 2


class TOpenFontCharMetrics;

 




const TInt KTwipsPerInch=1440;

 




const TInt KTwipsPerPoint=20;

 




const TInt KPointsPerInch=72;

 




const TInt KTwipsPerCm=567;

 






 





 





 






 






 






 






 





# 109 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h"



 


enum TGdiPanic
	{
	 
	EGdiPanic_Unknown				= 0,
	 
	EGdiPanic_InvalidInputParam		= 1,
	 
	EGdiPanic_OutOfText				= 2,
	 
	EGdiPanic_Invariant				= 3
	};

 
































class TRgb
	{
public:
	inline TRgb();
	inline TRgb(TUint32 aValue);
	inline TRgb(TInt aRed,TInt aGreen,TInt aBlue);
	inline TInt Red() const;
	inline TInt Green() const;
	inline TInt Blue() const;
	  void SetRed(TInt aRed);
	  void SetGreen(TInt aGreen);
	  void SetBlue(TInt aBlue);
	  static TRgb Gray2(TInt aGray2);
	  static TRgb Gray4(TInt aGray4);
	  static TRgb Gray16(TInt aGray16);
	  static TRgb Gray256(TInt aGray256);
	  static TRgb Color16(TInt aColor16);
	  static TRgb Color256(TInt aColor256);
	  static TRgb Color4K(TInt aColor4K);
	  static TRgb Color64K(TInt aColor64K);
	  static TRgb Color16M(TInt aColor16M);
	  TInt Gray2() const;
	  TInt Gray4() const;
	  TInt Gray16() const;
	  TInt Gray256() const;
	  TInt Color16() const;
	  TInt Color256() const;
	  TInt Color4K() const;
	  TInt Color64K() const;
	  TInt Color16M() const;
	inline TBool operator==(const TRgb& aColor) const;
	inline TBool operator!=(const TRgb& aColor) const;
	inline TRgb operator~() const;
	inline TRgb operator&(const TRgb& aColor);
	inline TRgb operator|(const TRgb& aColor);
	inline TRgb operator^(const TRgb& aColor);
	inline TRgb& operator&=(const TRgb& aColor);
	inline TRgb& operator|=(const TRgb& aColor);
	inline TRgb& operator^=(const TRgb& aColor);
	inline TUint32 Value() const;
	  TInt Difference(const TRgb& aColor) const;
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  static TRgb Color16MU(TInt a0RGB);
	  TInt Color16MU() const;

	inline TInt _Gray2() const;
	inline TInt _Gray4() const;
	inline TInt _Gray16() const;
	inline TInt _Gray256() const;
	inline TInt _Color4K() const;
	inline TInt _Color64K() const;
	inline TInt _Color16M() const;
	inline TInt _Color16MU() const;
	inline static TRgb _Gray2(TInt aGray2);
	inline static TRgb _Gray4(TInt aGray4);
	inline static TRgb _Gray16(TInt aGray16);
	inline static TRgb _Gray256(TInt aGray256);
	inline static TRgb _Color4K(TInt aColor4K);
	inline static TRgb _Color64K(TInt aColor64K);
	inline static TRgb _Color16M(TInt aColor16M);
	inline static TRgb _Color16MU(TInt a0RGB);

private:
	TUint32 iValue;
	};

 





















 



enum TDisplayMode
	{
	 
	ENone,
	 
	EGray2,
	 
	EGray4,
	 
	EGray16,
	 
	EGray256,
	 
	EColor16,
	 
	EColor256,
	 
	EColor64K,
	 
	EColor16M,
	 
	ERgb,
	 
	EColor4K,
	EColor16MU,
	 
	 
	 
	 
	EColorLast
	};



 



class TDisplayModeUtils
	{
public:
	  static TBool IsDisplayModeColor(TDisplayMode aDispMode);
	  static TInt NumDisplayModeColors(TDisplayMode aDispMode);
	  static TInt NumDisplayModeBitsPerPixel(TDisplayMode aDispMode);
	};


 






















class CPalette : public CBase
	{
public:
	  static CPalette* NewL(TInt aNumberOfEntries);
	  static CPalette* NewDefaultL(TDisplayMode aDispMode);
	  ~CPalette();
	  void Clear();
	inline TInt Entries() const;
	  TRgb GetEntry(TInt aPaletteIndex) const;
	  TRgb NearestEntry(const TRgb& aColor) const;
	  TInt NearestIndex(const TRgb& aColor) const;
	  void SetEntry(TInt aPaletteIndex,const TRgb& aPaletteEntry);
	  void GetDataPtr(TInt aFirstColor,TInt aNumColors,TPtr8& aPtr);
protected:
	  CPalette();
	void ConstructL(TInt aNumberOfEntries);
protected:
	TRgb* iArray;
	TInt iNumEntries;
	};


 




class TColor256Util
	{
public:
	  void Construct(const CPalette& aPalette);
	  TInt Color256(TRgb aRgb) const;
	  void Color256(TUint8* aDestination,const TRgb* aSource,TInt aNumPixels) const;
	inline TRgb Color256(TInt aColor256) const;
	  static const TColor256Util* Default();
public:
	 





	TUint32	iColorTable[256];

	 








	TUint8	iInverseColorTable[0x1000];
	};


 










class TLinearDDA
	{
public:
	 
	enum TLineMode
		{
		 
		ECenter,
		 

		ELeft
		};
public:
	  TLinearDDA();
	  TLinearDDA(const TLinearDDA& aLine);
	  void Construct(const TPoint& aStart,const TPoint& aFinish,TLineMode aMode=ECenter);
	  TBool SingleStep(TPoint& aPosition);
	  TBool SingleScanline(TPoint& aStartPosition,TPoint& aEndPosition);
	  TBool NextStep(TPoint& aPosition);
	  void JumpToRect(const TRect& aRect);
	  void JumpToXCoord(const TInt aXCoord,TInt& aYCoord);
	  void JumpToYCoord(TInt& aXCoord,const TInt aYCoord);
private:
	void UpdatePosition();
private:
	enum TLineStatus
		{
		EInitialised,
		ECurrent,
		EComplete
		};
private:
	TInt iCount;
	TSize iDifference;
	TPoint iFinish;
	TInt iGradient;
	TPoint iInc;
	TPoint iPos;
	TPoint iStart;
	TRect iBoundingRect;
	TBool iBoundingRectSet;
	TBool iInside;
	TLineStatus iStatus;
	};


 





enum TFontPosture
	{
	 
	EPostureUpright,
	 
	EPostureItalic
	};

 




enum TFontStrokeWeight
	{
	 
	EStrokeWeightNormal,
	 
	EStrokeWeightBold
	};

 





enum TFontPrintPosition
	{
	 
	EPrintPosNormal,
	 
	EPrintPosSuperscript,
	 
	EPrintPosSubscript
	};

 




enum TFontUnderline
	{
	 
	EUnderlineOff,
	 
	EUnderlineOn
	};

 




enum TFontStrikethrough
	{
	 
	EStrikethroughOff,
	 
	EStrikethroughOn
	};

 




const TInt KMaxTypefaceNameLength=0x18;


 













class TTypeface
    {
public:

	enum
		{
		 
		EProportional=1,
		 
		ESerif=2,
		 
		ESymbol=4
		};
public:
	  TTypeface();
	  TBool operator==(const TTypeface& aTypeface) const;
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  void SetAttributes(TInt aMask);
	  void SetIsProportional(TBool aIsProportional);
	  void SetIsSerif(TBool aIsSerif);
	  void SetIsSymbol(TBool aIsSymbol);
	  TInt Attributes() const;
	  TBool IsProportional() const;
	  TBool IsSerif() const;
	  TBool IsSymbol() const;
public:
	 
    TBufC<KMaxTypefaceNameLength> iName;
private:
    TUint32 iFlags;
    };


 









enum TGlyphBitmapType
	{
	 
	EDefaultGlyphBitmap = 0,	
	 

	EMonochromeGlyphBitmap,	
	 
	EAntiAliasedGlyphBitmap		
	};


 

















class TFontStyle
	{
public:
	  TFontStyle();
	  TFontStyle(TFontPosture aPost,TFontStrokeWeight aStrWgt,TFontPrintPosition aPrintPos);
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  TFontPosture Posture() const;
	  TFontStrokeWeight StrokeWeight() const;
	  TFontPrintPosition PrintPosition() const;
	  void SetPosture(TFontPosture aPosture);
	  void SetStrokeWeight(TFontStrokeWeight aStrokeWeight);
	  void SetPrintPosition(TFontPrintPosition aPrintPosition);
	inline TGlyphBitmapType BitmapType() const;
	inline void SetBitmapType(TGlyphBitmapType aBitmapType);
	inline TBool operator==(const TFontStyle& aFontStyle) const;
private:
	enum
		{
		EItalic=0x1,
		EBold=0x2,
		ESuper=0x4,
		ESub=0x8
		};
private:
	TUint32 iFlags;  
	};



 





class TFontSpec
	{
public:
	  TFontSpec();
	  TFontSpec(const TDesC& aTypefaceName,TInt aHeight);
	  TBool operator==(const TFontSpec& aFontSpec) const;
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
public:
	 
	TTypeface iTypeface;
	 
	TInt iHeight;
	 
	TFontStyle iFontStyle;
	};



 








class TTypefaceSupport
    {
public:
	 
    TTypeface iTypeface;
	 
    TInt iNumHeights;
	 
    TInt iMinHeightInTwips;
	 
    TInt iMaxHeightInTwips;
	 

    TBool iIsScalable;  
    };

 





const TInt KSuperSubScalingPercentage=67;

 





const TInt KSuperscriptOffsetPercentage=-28;

 





const TInt KSubscriptOffsetPercentage=14;

class CFont;



 







class CTypefaceStore : public CBase
	{
public:
	  ~CTypefaceStore();

	 








	virtual TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec)=0;

	 


	virtual TInt NumTypefaces() const=0;

	 










	virtual void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const=0;

	 








	virtual TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const=0;
	  void ReleaseFont(CFont* aFont);
	  static TInt BaselineOffset(TInt aHeight,TFontPrintPosition aPos);
	  static TInt SuperSubHeight(TInt aHeight,TFontPrintPosition aPos);
protected:
	  CTypefaceStore();
	  void ConstructL();
	  void AddFontL(CFont* aFont);
protected:
	class TFontAccess
	 





		{
	public:
		 
		CFont* iFont;
		 
		TInt iAccessCount;
		};
protected:
	 







	CArrayFixFlat<TFontAccess>* iFontAccess;
	};

 


const TInt KMaxFontCacheEntries=32;

 














class CFontCache : public CBase
	{
public:
	  CFontCache();
	  CFontCache(TInt aMaxEntries);
	  ~CFontCache();
	  CFont* Search(const TFontSpec& aFontSpec);
	  CFont* AddEntryL(CFont* aFont,const TFontSpec& aFontSpec);
	  CFont* RemoveFirstEntry();
public:
	 

	TInt iNumHits;
	 

	TInt iNumMisses;
private:
	class CFontCacheEntry : public CBase
		{
	public:
		CFontCacheEntry(CFont* aFont,const TFontSpec& aFontSpec,CFontCacheEntry* aNext);
	public:
		CFont* iFont;
		TFontSpec iSpec;
		CFontCacheEntry* iNext;
		};
private:
	TInt iNumEntries;
	TInt iMaxEntries;
	CFontCacheEntry* iFirst;
	};

 








class MGraphicsDeviceMap
    {
public:
	  MGraphicsDeviceMap();
	  virtual ~MGraphicsDeviceMap();
	  TPoint TwipsToPixels(const TPoint& aTwipPoint) const;
	  TRect TwipsToPixels(const TRect& aTwipRect) const;
	  TPoint PixelsToTwips(const TPoint& aPixelPoint) const;
	  TRect PixelsToTwips(const TRect& aPixelRect) const;

	 





	virtual TInt HorizontalTwipsToPixels(TInt aTwips) const=0;

	 





	virtual TInt VerticalTwipsToPixels(TInt aTwips) const=0;

	 





	virtual TInt HorizontalPixelsToTwips(TInt aPixels) const=0;

	 





	virtual TInt VerticalPixelsToTwips(TInt aPixels) const=0;

	 











	virtual TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec)=0;

	 









	virtual void ReleaseFont(CFont* aFont)=0;
    };

class CGraphicsContext;

 









class CGraphicsDevice : public CBase , public MGraphicsDeviceMap
    {
public:
	 


	virtual TDisplayMode DisplayMode() const=0;

	 


	virtual TSize SizeInPixels() const=0;

	 


	virtual TSize SizeInTwips() const=0;

 	 




    virtual TInt CreateContext(CGraphicsContext*& aGC)=0;

	 


    virtual TInt NumTypefaces() const=0;

 	 















    virtual void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const=0;

	 











	virtual TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const=0;

	 





	virtual void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const=0;

	 


	virtual void SetPalette(CPalette* aPalette)=0;

	 




	virtual TInt GetPalette(CPalette*& aPalette) const=0;
    };


 







class TCodeSection
	{
public:
	 
	TInt iStart;
	 
	TInt iEnd;
	};


 












class CFont: public CBase
    {
	friend class CTypefaceStore;
public:

	 






	enum TTextDirection
		{
	 
		EHorizontal,
	 
		EVertical
		};

	 










	class TPositionParam
		{
	public:
		TPositionParam():
			iDirection(EHorizontal),
			iFlags(0),
			iPosInText(0),
			iOutputGlyphs(0)
		 
			{
			}

		enum
			{
			EMaxInputChars = 18,	 
			EMaxOutputGlyphs = 8	 
			};

		 
		enum TFlags
			{
			 
			EFLogicalOrder = 1
			};
		 
		 
		TInt16 iDirection;
		 
		TUint16 iFlags;
		 
		TPtrC iText;

		 
		 
		TInt iPosInText;		
		 
		TPoint iPen;			

		 
		class TOutput
		 




			{
		public:
			 
			TOutput() : iBitmapSize(TSize::EUninitialized),
				iBounds(TRect::EUninitialized) {}
			 
			TUint iCode;			
			 
			const TUint8* iBitmap;	
			 

			TSize iBitmapSize;		
			 
			TRect iBounds;			
			};

		 
		TOutput iOutput[EMaxOutputGlyphs];	
		 
		TInt iOutputGlyphs;					
		};	


	 








	class TMeasureTextInput
		{
	public:
		TMeasureTextInput():
			iStartInputChar(0),
			iEndInputChar(KMaxTInt),
			iDirection(EHorizontal),
			iFlags(0),
			iMaxAdvance(KMaxTInt),
			iMaxBounds(KMaxTInt),
			iCharJustNum(0),
			iCharJustExcess(0),
			iWordJustNum(0),
			iWordJustExcess(0)
			{
			}

		 
		enum TFlags
			{
			 
			EFVisualOrder = 1
			};

		 




		TInt iStartInputChar;	
	
		 




		TInt iEndInputChar;		
	
		 
		TUint16 iDirection;
	
		 
		TUint16 iFlags;
	
		 
		TInt iMaxAdvance;		
		
		 
		TInt iMaxBounds;		
	
		 
		TInt iCharJustNum;		
	
		 
		TInt iCharJustExcess;	
		
		 
		TInt iWordJustNum;		
	
		 
		TInt iWordJustExcess;	
		};

	 








	class TMeasureTextOutput
		{
		public:
		 



		TInt iChars;			
		 
		TInt iGlyphs;			
		 


		TInt iGroups;			
		 
		TInt iSpaces;			
		 
		TRect iBounds;			
		 
		TSize iMaxGlyphSize;	
		};

	 










	enum TCharacterDataAvailability
		{
		 
		ENoCharacterData,
		 
		ECharacterWidthOnly,
		 
		EAllCharacterData
		};
public:
	 







	virtual TUid TypeUid() const=0;

	 


	virtual TInt HeightInPixels() const=0;

	 


	virtual TInt AscentInPixels() const=0;
	  virtual TInt DescentInPixels() const;

	 



	virtual TInt CharWidthInPixels(TChar aChar) const=0;

	 





	virtual TInt TextWidthInPixels(const TDesC& aText) const=0;

	 





	virtual TInt BaselineOffsetInPixels() const=0;

	 












	virtual TInt TextCount(const TDesC& aText,TInt aWidthInPixels) const=0;

	 













	virtual TInt TextCount(const TDesC& aText,TInt aWidthInPixels,TInt& aExcessWidthInPixels) const=0;

	 


	virtual TInt MaxCharWidthInPixels() const=0;

	 





	virtual TInt MaxNormalCharWidthInPixels() const=0;

	 


	virtual TFontSpec FontSpecInTwips() const=0;
	  virtual TCharacterDataAvailability GetCharacterData(TUint aCode,
		TOpenFontCharMetrics& aMetrics,const TUint8*& aBitmap,TSize& aBitmapSize) const;
	  virtual TBool GetCharacterPosition(TPositionParam& aParam) const;
	  virtual void Reserved();
	  TInt WidthZeroInPixels() const;
	  TInt MeasureText(const TDesC& aText,
		const TMeasureTextInput* aInput = 0L ,
		TMeasureTextOutput* aOutput = 0L ) const;
	  static TBool CharactersJoin(TInt aLeftCharacter,
		TInt aRightCharacter);
protected:
	  virtual ~CFont();
    };

class CFbsBitmap;


 




























class CGraphicsContext : public CBase
	{
public:


	 



	enum TTextAlign
		{
		 
		ELeft,
		 
		ECenter,
		 
		ERight
		};

	 






	enum TDrawModeComponents
		{
		 
		EInvertScreen=1,
		 
		EXor=2,
		 
		EOr=4,
		 
		EAnd=8,
		 
		ELogicalOp=14,
		 
		EInvertPen=16,
		 
		EPenmode=32
		};


	 















	enum TDrawMode
		{
		 

		EDrawModeAND=EAnd,
		 

		EDrawModeNOTAND=EInvertScreen|EAnd,
		 
		EDrawModePEN=EPenmode,
		 
		EDrawModeANDNOT=EAnd|EInvertPen,
		 

		EDrawModeXOR=EXor,
		 

		EDrawModeOR=EOr,
		 

		EDrawModeNOTANDNOT=EInvertScreen|EAnd|EInvertPen,
		 

		EDrawModeNOTXOR=EInvertScreen|EXor,
		 

		EDrawModeNOTSCREEN=EInvertScreen,
		 

		EDrawModeNOTOR=EInvertScreen|EOr,
		 
		EDrawModeNOTPEN=EInvertPen|EPenmode,
		 

		EDrawModeORNOT=EOr|EInvertPen,
		 
		EDrawModeNOTORNOT=EInvertScreen|EOr|EInvertPen
		};

	 






	enum TPenStyle
		{
		 
		ENullPen,
		 
		ESolidPen,
		 
		EDottedPen,
		 
		EDashedPen,
		 

		EDotDashPen,
		 

		EDotDotDashPen
		};

	 




	enum TBrushStyle
		{
		 
		ENullBrush,
		 

		ESolidBrush,
		 

		EPatternedBrush,
		 

		EVerticalHatchBrush,
		 

		EForwardDiagonalHatchBrush,
		 

		EHorizontalHatchBrush,
		 

		ERearwardDiagonalHatchBrush,
		 


		ESquareCrossHatchBrush,
		 


		EDiamondCrossHatchBrush
		};

	 













	enum TFillRule
		{
		 
		EAlternate,
		 
		EWinding
		};

	 
	struct TDrawTextParam
		{
	public:
		TDrawTextParam():
			iDirection(CFont::EHorizontal),
			iCharJustNum(0),
			iCharJustExcess(0),
			iWordJustNum(0),
			iWordJustExcess(0)
	 
			{}
	public:
		 
		CFont::TTextDirection iDirection;	
		 
		TInt iCharJustNum;					
		 
		TInt iCharJustExcess;				
		 
		TInt iWordJustNum;					
		 
		TInt iWordJustExcess;				
		};


	 


	struct TDrawTextExtendedParam : public TDrawTextParam
		{
	public:
		 
		TDrawTextExtendedParam():
			iParRightToLeft(EFalse)
			{}
	public:
		 

		TBool iParRightToLeft;	
		};
public:
	 


	virtual CGraphicsDevice* Device() const=0;

	 





	virtual void SetOrigin(const TPoint& aPos=TPoint(0,0))=0;

	 








































	virtual void SetDrawMode(TDrawMode aDrawingMode)=0;

	 





	virtual void SetClippingRect(const TRect& aRect)=0;

	 




	virtual void CancelClippingRect()=0;

	 











	virtual void Reset()=0;

    




















	virtual void UseFont(const CFont* aFont)=0;

	 




	virtual void DiscardFont()=0;

	 




	virtual void SetUnderlineStyle(TFontUnderline aUnderlineStyle)=0;

	 




	virtual void SetStrikethroughStyle(TFontStrikethrough aStrikethroughStyle)=0;
	  static TInt JustificationInPixels(TInt aExcessPixels,TInt aTotalUnits,TInt aFirstUnit,TInt aNumUnits);
	  static TInt JustificationInPixels(TInt& aExcessPixels,TInt& aTotalUnits);

	 












































	virtual void SetWordJustification(TInt aExcessWidth,TInt aNumGaps)=0;

	 









































































	virtual void SetCharJustification(TInt aExcessWidth,TInt aNumChars)=0;

	 












	virtual void SetPenColor(const TRgb& aColor)=0;

	 





































	virtual void SetPenStyle(TPenStyle aPenStyle)=0;

	 




































	virtual void SetPenSize(const TSize& aSize)=0;

	 














	virtual void SetBrushColor(const TRgb& aColor)=0;

	 


















	virtual void SetBrushStyle(TBrushStyle aBrushStyle)=0;

	 

























	virtual void SetBrushOrigin(const TPoint& aOrigin)=0;

	 






















	virtual void UseBrushPattern(const CFbsBitmap* aBitmap)=0;

	 











	virtual void DiscardBrushPattern()=0;


	 














	virtual void MoveTo(const TPoint& aPoint)=0;

	 














	virtual void MoveBy(const TPoint& aVector)=0;

	 











	virtual void Plot(const TPoint& aPoint)=0;

	 




































	virtual void DrawArc(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd)=0;

	 



	virtual void DrawLine(const TPoint& aPoint1,const TPoint& aPoint2)=0;

	 





	virtual void DrawLineTo(const TPoint& aPoint)=0;

	 










	virtual void DrawLineBy(const TPoint& aVector)=0;

	 





	virtual void DrawPolyLine(const CArrayFix<TPoint>* aPointList)=0;

	 






	virtual void DrawPolyLine(const TPoint* aPointList,TInt aNumPoints)=0;

	 












































	virtual void DrawPie(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd)=0;

	 













	virtual void DrawEllipse(const TRect& aRect)=0;

	 


	virtual void DrawRect(const TRect& aRect)=0;

	 

















	virtual void DrawRoundRect(const TRect& aRect,const TSize& aCornerSize)=0;

	 














	virtual TInt DrawPolygon(const CArrayFix<TPoint>* aPointList,TFillRule aFillRule=EAlternate)=0;

	 
















	virtual TInt DrawPolygon(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule=EAlternate)=0;

	 




















	virtual void DrawBitmap(const TPoint& aTopLeft,const CFbsBitmap* aSource)=0;

	 




















	virtual void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource)=0;

	 




















	virtual void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource,const TRect& aSourceRect)=0;

	 













	virtual void DrawText(const TDesC& aText,const TPoint& aPosition) = 0;

	 





















































	virtual void DrawText(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TTextAlign aAlignment = ELeft,
		TInt aLeftMargin = 0) = 0;
	  virtual void DrawText(const TDesC& aText,const TPoint& aPosition,const TDrawTextParam& aParam);
	  virtual void Reserved();
	  TInt DrawTextExtended(const TDesC& aText,const TPoint& aPosition,const TDrawTextExtendedParam& aParam);
	};


 






















class CBitmapContext : public CGraphicsContext
	{
public:
	 




	virtual void Clear()=0;

	 






	virtual void Clear(const TRect& aRect)=0;

	 






	virtual void CopyRect(const TPoint& aOffset,const TRect& aRect)=0;

	 






	virtual void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap)=0;

	 












	virtual void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aRect)=0;

	 































	virtual void BitBltMasked(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect,const CFbsBitmap* aMaskBitmap,TBool aInvertMask)=0;

	 


	virtual void SetFaded(TBool aFaded)=0;

	 


















	virtual void SetFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap)=0;
	};

 











class CBitmapDevice : public CGraphicsDevice
	{
public:
	 







	virtual void GetPixel(TRgb& aColor,const TPoint& aPixel) const=0;

	 















	virtual void GetScanLine(TDes8& aBuf,const TPoint& aStartPixel,TInt aLength,TDisplayMode aDispMode) const=0;

	 







	virtual TInt AddFile(const TDesC& aName,TInt& aId)=0;

	 




	virtual void RemoveFile(TInt aId=0)=0;

	 












	virtual TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec)=0;

	 




















	virtual TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const=0;
    inline TInt CreateBitmapContext(CBitmapContext*& aGC);
	};

 





class TMargins
    {
public:
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  TBool operator==(const TMargins& aMargins) const;
	  TBool operator!=(const TMargins& aMargins) const;
public:
	 
	TInt iLeft;
	 
	TInt iRight;
	 
    TInt iTop;
	 
	TInt iBottom;
	};

 






class TPictureCapability
	{
public:
	 
	enum TScalingType
		{
		 
		ENotScaleable,
		 
		EFullyScaleable,
		 

		EScaleableMaintainingAspectRatio
		};
public:
	inline TPictureCapability(TScalingType aScalingType,TBool aCroppable);
public:
	 
	TScalingType iScalingType;
	 
	TBool iIsCroppable;
	};

 


























class CPicture : public CBase
    {
public:
	 
	enum TDetach
		{
		 

		EDetachFull,
		 

		EDetachDraw
		};
public:
	  virtual ~CPicture();
	 











	virtual void Draw(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,MGraphicsDeviceMap* aMap) const=0;
	  virtual TStreamId StoreL(CStreamStore& aStore) const;  
	virtual void DetachFromStoreL(TDetach  =EDetachFull) {}

	 







	virtual void ExternalizeL(RWriteStream& aStream) const =0;

	 


	virtual void GetOriginalSizeInTwips(TSize& aSize) const =0;
	  virtual void SetScaleFactor(TInt aScaleFactorWidth,TInt aScaleFactorHeight);  
	  virtual void SetCropInTwips(const TMargins& aMargins);  
	  virtual TPictureCapability Capability() const;  
	  virtual void GetCropInTwips(TMargins& aMargins) const;  
	  virtual TInt ScaleFactorWidth() const;  
	  virtual TInt ScaleFactorHeight() const;  
	  virtual TBool LineBreakPossible(TUint aClass,TBool aBeforePicture,TBool aHaveSpaces) const;
	  virtual TBool NativePixelSize(TSize& aPixelSize);

	  void GetSizeInPixels(MGraphicsDeviceMap* aMap, TSize& aSize) const;
	  void SetSizeInPixels(MGraphicsDeviceMap* aMap, const TSize& aSize);
	  void AddCropInPixels(MGraphicsDeviceMap* aMap, const TMargins& aMargins);
	  void GetSizeInTwips(TSize& aSize) const;
	  void SetSizeInTwips(const TSize& aSize);
	  void ResetToOriginal();
protected:
	  CPicture();
	};


 











class TPictureHeader
	{
public:
	  TPictureHeader();
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  void DeletePicture();
public:
	 

	TSwizzle<CPicture> iPicture;
	 
	TUid iPictureType;
	 
	TSize iSize;
	};


 








class MPictureFactory
	{
public:
	 
















	virtual void NewPictureL(TPictureHeader& aHeader,const CStreamStore& aDeferredPictureStore)const=0;
	};

 

 





const TInt KMaxPrinterModelNameLength=0x20;

 






typedef TBuf<KMaxPrinterModelNameLength> TPrinterModelName;

 









	
class TPageSpec
	{
public:
	 
	enum TPageOrientation
		{
		 
		EPortrait,
		 
		ELandscape
		};
public:
	  TPageSpec();
	  TPageSpec(TPageOrientation aOrientation,const TSize& aSize);
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  TSize OrientedPageSize() const;
	  TBool operator==(const TPageSpec& aPageSpec) const;
	  TBool operator!=(const TPageSpec& aPageSpec) const;
public:
	 




	TSize iPortraitPageSize;
	 
	TPageOrientation iOrientation;
	};


 








	
class TBandAttributes
    {
public:
	 
	TRect iRect;
	 
	TBool iTextIsIgnored;  
	 
	TBool iGraphicsIsIgnored;  
	 
	TBool iFirstBandOnPage;
	};

 











class CPrinterPort : public CBase
	{
public:
	 





	virtual void WriteRequest(const TDesC8& aBuf,TRequestStatus& aRequestStatus)=0;
 
	 
	virtual void Cancel()=0;
	};


 





class TPrinterModelEntry
  	{
public:
	 
	TPrinterModelName iModelName;
	 
	TBool iRequiresPrinterPort;
	 
	TUid iUid;
public:
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	};


 








class TPrinterModelHeader
    {
public:
	 
	TPrinterModelEntry iEntry;
	 
	TStreamId iModelDataStreamId;
public:
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	};


 













class CPrinterControl : public CBase
    {
public:
	 
	enum TMoreOnPage
		{
		 
		EMoreOnPage,
		 
		ENoMoreOnPage
		};
public:
	  ~CPrinterControl();

	 


	virtual TInt BandsPerPage()=0;

	 












	virtual TMoreOnPage QueueGetBand(TRequestStatus& aStatus, TBandAttributes& aBand)=0;  

	 








	virtual void QueueEndPrint(TRequestStatus& aStatus)=0; 

	 


	virtual void AbortPrint()=0;  
protected:
	  CPrinterControl(CPrinterPort* aPrinterPort);
protected:
	 
	enum TState 
		{
		 
		ENotPrinting, 
		 
		EPrinting
		};
	 
	TState iState;
	 
	CPrinterPort* iPrinterPort;
	};

class CDictionaryStore;
class RFs;

 
























class CPrinterDevice : public CGraphicsDevice
	{
public:
	  ~CPrinterDevice();

	 


	inline TPageSpec CurrentPageSpecInTwips() const {return(iCurrentPageSpecInTwips);}

	 


	  virtual void SelectPageSpecInTwips(const TPageSpec& aPageSpec);
	  virtual TRect PrintablePageInPixels() const;

	 


	virtual TPrinterModelEntry Model()const =0;

	 





	virtual TInt SetModel(const TPrinterModelHeader& aModel,CStreamStore& aStore)=0;

	 







	virtual void CreateControlL(CPrinterPort* aPrinterPort)=0;
	  virtual void DeleteControl();

	 




	virtual void InternalizePropertiesL(RReadStream&  ) {}

	 




	virtual void ExternalizePropertiesL(RWriteStream&  ) const {}
	  void RestorePropertiesL();
	  void StorePropertiesL() const;
protected:
	  CPrinterDevice();
public:
	 



	CPrinterControl* iControl;
protected:
	 
	TPageSpec iCurrentPageSpecInTwips;
	};


 









class CPrinterModelList : public CBase
     {
public:
	 


    virtual TInt ModelCount() const=0;

	 








    virtual const TPrinterModelEntry operator[](TInt anIndex)=0;

	 



	virtual TInt UidToNum(TUid aModelUid) const=0;
    };


 








class MPageRegionPrinter
	{
public:
	 









	virtual void PrintBandL(CGraphicsDevice* aDevice,TInt aPageNo,const TBandAttributes& aBandInPixels)=0;
	};

 




const TInt KPdrStoreFileUidVal=268435514;

const TInt KPdlUidVal=268450588;
const TInt KUdlUidVal=268450589;


 













class CPrinterDriverUI : public CBase
    {
protected:
	  CPrinterDriverUI();
public:
	  virtual TBool BeforePrintL();
	  virtual void AfterPrintL();
	  virtual void SetPropertiesL();
	  virtual TBool CanSetProperties();

	 


	virtual TInt SetPrinterDevice(CPrinterDevice* aPrinterDevice)=0;
	};
								   
class CFileStore;


 
























class CPrinterDriver : public CBase
     {
public:
	  static CPrinterDriver* NewL();
	  ~CPrinterDriver();
	  void OpenPdrL(const TDesC &aName);
	  void Close();
	  TInt NumModels() const;
	  TPrinterModelEntry Model(TInt aNum) const;

	 


	inline CPrinterDevice* PrinterDevice() {return iPrinterDevice;}
	  CPrinterDevice* CreatePrinterDeviceL(TUid aModelUid);
	  CPrinterDriverUI* CreatePrinterDriverUIL();
private:
	CPrinterDriver();
	void DeletePrinterDevice();
	void DoOpenPdrL(const TDesC &aName);
	void DoCreatePrinterDeviceL(TUid aModelUid);
	void LoadLibraryL(RLibrary& aLibrary,const TDesC& aExt,TUid aUid2);
private:
	RFs iFs;
	CFileStore *iPdrStore;
	TInt iNumModels;
	TPrinterModelHeader* iModelList;
	TFileName iPdlName;
	TUid iPdlUid;
	RLibrary iPdlLibrary;
	CPrinterDevice* iPrinterDevice;
	RLibrary iUdlLibrary;
	};

class RResourceFile;


 



class CPdrModelList : public CPrinterModelList
    {
public:
	  static CPdrModelList* NewL();
	  virtual ~CPdrModelList();
      TInt ModelCount() const;
      const TPrinterModelEntry operator [] (TInt anIndex);
	  TInt UidToNum(TUid aModelUid) const;   
	  void AddDirectoryL(const TDesC& aDir);
	  CPrinterModelList* ScanForModelsL();
	  CPrinterDriver* CreatePrinterDriverL(TInt anIndex);
private:
	CPdrModelList();
	void ConstructL();
private:
	class TFileEntry
		{
	public:
		TFileName iFileName;
		TDesC* iDirectory;
		};
	class TModelEntry
		{
	public:
		TPrinterModelEntry iEntry;
		TFileEntry* iFile; 
		};
private:
	void ScanDirectoryL(TInt aDirIndex);
	void ListModelsL(TInt aFileIndex, TParse& aParser, TFileName& aNameOfLoadedResourceFile, TFileName& aTempFileName, RResourceFile& aResourceFile, HBufC8*& aResource);
	HBufC* NewPathBufL(const TFileEntry& aFileEntry);
private:
	CArrayFixSeg<TModelEntry>* iModelArray;
	CArrayFixFlat<TFileEntry>* iFileArray;
	CArrayFixFlat<HBufC*>* iDirectoryArray;
	RFs iFileServer;
	};

 
 










class TZoomFactor : public MGraphicsDeviceMap
	{
public:
	  TZoomFactor();
	  ~TZoomFactor();
	inline TZoomFactor(const MGraphicsDeviceMap* aDevice);
	  TInt ZoomFactor() const;
	  void SetZoomFactor(TInt aZoomFactor);
	inline void SetGraphicsDeviceMap(const MGraphicsDeviceMap* aDevice);
	inline const MGraphicsDeviceMap* GraphicsDeviceMap() const;
	  void SetTwipToPixelMapping(const TSize& aSizeInPixels,const TSize& aSizeInTwips);
	  TInt HorizontalTwipsToPixels(TInt aTwipWidth) const;
	  TInt VerticalTwipsToPixels(TInt aTwipHeight) const;
	  TInt HorizontalPixelsToTwips(TInt aPixelWidth) const;
	  TInt VerticalPixelsToTwips(TInt aPixelHeight) const;
	  TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  void ReleaseFont(CFont* aFont);
public:

	 
	enum {EZoomOneToOne=1000};
private:
	TInt iZoomFactor;
	const MGraphicsDeviceMap* iDevice;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.inl" 1
 
 
 
 

 
 
 


inline TRgb::TRgb():
	iValue(0x00ffffff)
	 
	{}

 
inline TRgb::TRgb(TUint32 aValue):
	iValue(aValue)
 







	{}

 
inline TRgb::TRgb(TInt aRed,TInt aGreen,TInt aBlue):
	iValue(aRed|aGreen<<8|aBlue<<16)
 






	{}


inline TInt TRgb::Red() const
 


	{return(iValue&0xff);}


inline TInt TRgb::Green() const
 


	{return((iValue&0xff00)>>8);}


inline TInt TRgb::Blue() const
 


	{return((iValue&0xff0000)>>16);}

 
inline TBool TRgb::operator==(const TRgb& aColor) const
 






 
	{return(iValue==aColor.iValue);}

 
inline TBool TRgb::operator!=(const TRgb& aColor) const
 







	{return(!(*this==aColor));}
 
inline TRgb& TRgb::operator&=(const TRgb& aColor)
 











	{iValue&=aColor.iValue;return(*this);}

inline TRgb& TRgb::operator|=(const TRgb& aColor)
 











	{iValue|=aColor.iValue;return(*this);}

 
inline TRgb& TRgb::operator^=(const TRgb& aColor)
 











	{iValue^=aColor.iValue;return(*this);}

 
inline TUint32 TRgb::Value() const
 


	{return(iValue);}

 
inline TRgb TRgb::operator~() const
 


	{return(TRgb(iValue^0x00ffffff));}

 
inline TRgb TRgb::operator&(const TRgb& aColor)
 



	{return(TRgb(iValue&aColor.iValue));}

 
inline TRgb TRgb::operator|(const TRgb& aColor)
 



	{return(TRgb(iValue|aColor.iValue));}

 
inline TRgb TRgb::operator^(const TRgb& aColor)
 



	{return(TRgb(iValue^aColor.iValue));}


 







inline TRgb TRgb::_Gray2(TInt aGray2)
	{
	if(aGray2) return(TRgb(TUint32(0x00ffffff)));
	return(TRgb(TUint32(0)));
	}
 
 







inline TRgb TRgb::_Gray4(TInt aGray4)
	{
	aGray4&=3;
	aGray4|=aGray4<<2;
	aGray4|=aGray4<<4;
	return(TRgb(aGray4,aGray4,aGray4));
	}
 
 







inline TRgb TRgb::_Gray16(TInt aGray16)
	{
	aGray16&=0xf;
	aGray16|=aGray16<<4;
	return(TRgb(aGray16,aGray16,aGray16));
	}

 







inline TRgb TRgb::_Gray256(TInt aGray256)
	{
	aGray256&=0xff;
	return(TRgb(aGray256,aGray256,aGray256));
	}

 






inline TRgb TRgb::_Color4K(TInt aColor4K)
	{
	TUint32 value = (aColor4K & 0xf00) >> 8;
	value |= (aColor4K & 0x0f0) << 4;
	value |= (aColor4K & 0x00f) << 16;
	return TRgb(value | (value << 4));
	}

 






inline TRgb TRgb::_Color64K(TInt aColor64K)
	{
	TInt red = (aColor64K&0xF800)>>8;
	red += red>>5;
	TInt green = (aColor64K&0x07E0)>>3;
	green += green>>6;
	TInt blue = (aColor64K&0x001F)<<3;
	blue += blue>>5;
	return TRgb(red,green,blue);
	}

 






inline TRgb TRgb::_Color16M(TInt aColor16M)
	{
	return TRgb(((aColor16M & 0xff0000) >> 16) | (aColor16M & 0x00ff00) | ((aColor16M & 0x0000ff) << 16));
	}

 





inline TRgb TRgb::_Color16MU(TInt a0RGB)
	{
	 
	return TRgb(((a0RGB & 0xff0000) >> 16) | (a0RGB & 0x00ff00) | ((a0RGB & 0x0000ff) << 16));
	 
	}

 


	
inline TInt TRgb::_Gray2() const
	{
	return(Gray256()>>7);
	}

 


	
inline TInt TRgb::_Gray4() const
	{
	return(Gray256()>>6);
	}

 


	
inline TInt TRgb::_Gray16() const
	{
	return(Gray256()>>4);
	}

 


	
inline TInt TRgb::_Gray256() const
	{
	return(((Red()<<1)+Green()+(Green()<<2)+Blue())>>3);
	}

 


	
inline TInt TRgb::_Color4K() const
	{
	TInt color4K = (iValue & 0x0000f0) << 4;
	color4K |= (iValue & 0x00f000) >> 8;
	color4K |= (iValue & 0xf00000) >> 20;
	return color4K;
	}

 


	
inline TInt TRgb::_Color64K() const
	{
	TInt color64K = (iValue & 0x0000f8) << 8;
	color64K |= (iValue & 0x00fc00) >> 5;
	color64K |= (iValue & 0xf80000) >> 19;
	return color64K;
	}

 


	
inline TInt TRgb::_Color16M() const
{
	TInt color16M = (iValue & 0x0000ff) << 16;
	color16M |= iValue & 0x00ff00;
	color16M |= (iValue & 0xff0000) >> 16;
	return color16M;
	}

 

inline TInt TRgb::_Color16MU() const
	{
	 
	return ((iValue & 0x0000ff) << 16) | (iValue & 0x00ff00) | ((iValue & 0xff0000) >> 16);
	 
	}

 
 
 

 
inline TInt CPalette::Entries() const
 


	{return(iNumEntries);}

 
 
 

 
inline TRgb TColor256Util::Color256(TInt aColor256) const
 




	{ return TRgb(iColorTable[aColor256]); }

 
 
 

 
inline TBool TFontStyle::operator==(const TFontStyle& aFontStyle) const
 



	{return(iFlags==aFontStyle.iFlags);}

 
inline TGlyphBitmapType TFontStyle::BitmapType() const
 


	{
	return (TGlyphBitmapType)(iFlags >> 16);
	}

 
inline void TFontStyle::SetBitmapType(TGlyphBitmapType aBitmapType)
 








	{
	iFlags &= 0xFFFF;
	iFlags |= (aBitmapType << 16);
	}

 
 
 

 
inline TInt CBitmapDevice::CreateBitmapContext(CBitmapContext*& aGC)
 




	{return(CreateContext((CGraphicsContext*&)aGC));}  

 
 
 

inline TPictureCapability::TPictureCapability(TScalingType aScalingType,TBool aCroppable):
	iScalingType(aScalingType),iIsCroppable(aCroppable)
 



	{}

 
 
 

 
inline TZoomFactor::TZoomFactor(const MGraphicsDeviceMap* aDevice):
	iZoomFactor(TZoomFactor::EZoomOneToOne),
	iDevice(aDevice)
 






	{}

 
inline void TZoomFactor::SetGraphicsDeviceMap(const MGraphicsDeviceMap* aDevice)
 


	{iDevice=aDevice;}

 
inline const MGraphicsDeviceMap* TZoomFactor::GraphicsDeviceMap() const
 


	{return(iDevice);}

# 3519 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 2


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/openfont.h" 1
 
 
 
 

 











class CFont;
class COpenFontFile;
class COpenFontGlyph;
class COpenFontGlyphCache;
class COpenFontGlyphTreeEntry;
class COpenFontPositioner;
class COpenFontSessionCache;
class COpenFontSessionCacheList;
class RFs;
class TCharacterMetrics;
class TFontSpec;
class TOpenFontFaceAttrib;
class CFontStore;
class TOpenFontFileData;

 





const TInt KUidOpenFontRasterizerValue = 0x10003B1F;

 











const TUint KReplacementCharacter = 0xF6DB;

 





const TInt KFillCharacterOffset = 0x7FFF;

class TOpenFontMetrics
 






	{
public:
	inline TOpenFontMetrics();
	  TOpenFontMetrics(const CFont* aFont);
	inline TInt Size() const;
	inline TInt Ascent() const;
	inline TInt Descent() const;
	inline TInt MaxHeight() const;
	inline TInt MaxDepth() const;
	inline TInt MaxWidth() const;
	inline void SetSize(TInt aSize);
	inline void SetAscent(TInt aAscent);
	inline void SetDescent(TInt aDescent);
	inline void SetMaxHeight(TInt aMaxHeight);
	inline void SetMaxDepth(TInt aMaxDepth);
	inline void SetMaxWidth(TInt aMaxWidth);
private:
	TInt16 iSize;			 
	TInt16 iAscent;			 
	TInt16 iDescent;		 
	TInt16 iMaxHeight;		 
	TInt16 iMaxDepth;		 
	TInt16 iMaxWidth;		 
	TInt32 iReserved;
	};

 
class TOpenFontCharMetrics
 


















	{
public:
	enum TUninitialized { EUninitialized };
public:
	inline TOpenFontCharMetrics();
 
	 



	TOpenFontCharMetrics(TUninitialized) {}
	  TOpenFontCharMetrics(const TCharacterMetrics& aMetrics);
	  TBool GetTCharacterMetrics(TCharacterMetrics& aMetrics) const;
	inline TInt Width() const;
	inline TInt Height() const;
	inline TInt HorizBearingX() const;
	inline TInt HorizBearingY() const;
	inline TInt HorizAdvance() const;
	inline TInt VertBearingX() const;
	inline TInt VertBearingY() const;
	inline TInt VertAdvance() const;
	inline void GetHorizBounds(TRect& aBounds) const;
	inline void GetVertBounds(TRect& aBounds) const;
	inline void SetWidth(TInt aWidth);
	inline void SetHeight(TInt aHeight);
	inline void SetHorizBearingX(TInt aHorizBearingX);
	inline void SetHorizBearingY(TInt aHorizBearingY);
	inline void SetHorizAdvance(TInt aHorizAdvance);
	inline void SetVertBearingX(TInt aVertBearingX);
	inline void SetVertBearingY(TInt aVertBearingY);
	inline void SetVertAdvance(TInt aVertAdvance);
private:
	TInt16 iWidth;			 
	TInt16 iHeight;			 
	TInt16 iHorizBearingX;	 
	TInt16 iHorizBearingY;	 
	TInt16 iHorizAdvance;	 
	TInt16 iVertBearingX;	 
	TInt16 iVertBearingY;	 
	TInt16 iVertAdvance;	 
	TInt32 iReserved;
	};

 
class TOpenFontGlyphData
 













	{
public:
	  static TOpenFontGlyphData* New(RHeap* aHeap,TInt aBufferSize);
	inline TBool Overflow() const;
	inline TInt BytesNeeded() const;
	inline TPtrC8 Bitmap() const;
	inline const TUint8* BitmapPointer() const;
	inline const TOpenFontCharMetrics* Metrics() const;
	inline TInt GlyphIndex() const;
	inline TUint8* BufferStart();
	inline TUint8* BufferEnd();
	inline void SetBytesNeeded(TInt aBytes);
	inline void SetBitmapPointer(const TUint8* aBitmap);
	inline void SetMetricsPointer(const TOpenFontCharMetrics* aMetrics);
	inline void SetPointersToInternalBuffers();
	inline void SetMetrics(TOpenFontCharMetrics& aMetrics);
	inline void SetGlyphIndex(TInt aGlyphIndex);
private:
	 



	TOpenFontGlyphData();
	~TOpenFontGlyphData();
private:
	TInt iBitmapBufferSize;					 
	TInt iBytesNeeded;						 
	TOpenFontCharMetrics iMetricsBuffer;	 
	const TUint8* iBitmap;					 
											 
	const TOpenFontCharMetrics* iMetrics;	 
											 
	TInt iGlyphIndex;						 
	TAny* iReserved;						 
	TUint8 iBitmapBuffer[1];				 
											 
	};

 class COpenFont: public CBase
 



























	{
public:
	 
























	virtual void RasterizeL(TInt aCode,TOpenFontGlyphData* aGlyphData) = 0;
	  virtual void Reserved();  
	  COpenFont(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,COpenFontFile* aFile);
	  COpenFont(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,COpenFontFile* aFile,TInt aFaceIndex);
	  ~COpenFont();
	  void operator delete(TAny*);
	inline const TOpenFontMetrics& Metrics() const;
	inline const TOpenFontFaceAttrib* FaceAttrib() const;
	inline COpenFontFile* File() const;
	inline TInt FaceIndex() const;
	inline TBool CharacterNeedsToBeRasterized(TInt aSessionHandle,TInt aCode) const;
	TBool Rasterize(TInt aSessionHandle,TInt aCode,TOpenFontGlyphData* aGlyphData);
	TBool HasCharacterL(TInt aCode) const;
	TBool GetCharacterData(TInt aSessionHandle,TInt aCode,const TOpenFontCharMetrics*& aMetrics,const TUint8*& aBitmap) const;
	void OnFileDeleted();
protected:
	RHeap* iHeap;
	TOpenFontMetrics iMetrics;
	const COpenFontPositioner* iPositioner;					 
															 
															 
private:
	const COpenFontGlyph* Glyph(TInt aSessionHandle,TInt aCode) const;
	const COpenFontGlyph* FontCacheGlyph(TInt aCode,COpenFontGlyphTreeEntry**& aNode);
	const COpenFontGlyph* SessionCacheGlyph(RHeap* aHeap,TInt aSessionHandle,TInt aCode,
											COpenFontSessionCache*& aCache,TInt& aIndex,TBool aCreate) const;
	void RasterizeHelperL(TInt aCode,TOpenFontGlyphData* aGlyphData,TOpenFontGlyphData*& aTempGlyphData);
private:
	COpenFontFile* iFile;									 
															 
	TInt iFaceIndex;										 
	COpenFontGlyphCache* iGlyphCache;						 
	COpenFontSessionCacheList* iSessionCacheList;			 
	TAny* iReserved;  
	};

 
class TOpenFontFaceAttribBase
 









	{
public:
	inline TOpenFontFaceAttribBase();
	inline TBool HasLatin() const;
	inline TBool HasGreek() const;
	inline TBool HasCyrillic() const;
	inline TBool HasKana() const;
	inline TBool HasHangul() const;
	inline TBool HasCJK() const;
	inline TBool IsSymbol() const;
	inline TBool IsBold() const;
	inline TBool IsItalic() const;
	inline TBool IsSerif() const;
	inline TBool IsMonoWidth() const;
	inline TPtrC Name() const;
	inline const TUint* Coverage() const;
	inline void SetName(const TDesC& aName);
	inline void SetCoverage(TUint aCoverage0,TUint aCoverage1 = 0,TUint aCoverage2 = 0,TUint aCoverage3 = 0);
	inline void SetBold(TBool aBold);
	inline void SetItalic(TBool aItalic);
	inline void SetSerif(TBool aSerif);
	inline void SetMonoWidth(TBool aMonoWidth);
	inline TBool operator==(const TOpenFontFaceAttribBase& aAttrib) const;

	 
	enum
		{
		ELatinSet = 0x1,			 
		EGreekSet = 0x80,			 
		ECyrillicSet = 0x200,		 
		EArmenianSet = 0x400,		 
		EHebrewSet = 0x800,			 
		EArabicSet = 0x2000,		 
		EDevanagariSet = 0x8000,	 
		EBengaliSet = 0x10000,		 
		EGurmukhiSet = 0x20000,		 
		EGujuratiSet = 0x40000,		 
		EOriyaSet = 0x80000,		 
		ETamilSet = 0x100000,		 
		ETeluguSet = 0x200000,		 
		EKannadaSet = 0x400000,		 
		EMalayalamSet = 0x800000,	 
		EThaiSet = 0x1000000,		 
		ELaoSet = 0x2000000,		 
		EGeorgianSet = 0x8000000,	 
		EHangulJamoSet = 0x10000000, 
		};

	 
	enum
		{
		ESymbolSets = 0xFFFE,
		EKanaSets = 0x60000,
		EHangulSet = 0x100000,
		ECJKSet = 0x8000000
		};

	 
	enum
		{
		EBold = 0x1,			 
		EItalic = 0x2,			 
		ESerif = 0x4,			 
		EMonoWidth = 0x8		 
		};

	 
	enum
		{
		ENameLength = 32		 
		};
protected:
	TBufC<ENameLength> iName;				 
											 
	TUint iCoverage[4];						 
											 
											 
	TInt iStyle;							 
	TInt32 iReserved;
	};

 
class TOpenFontFaceAttrib: public TOpenFontFaceAttribBase
 








	{
public:
	inline TOpenFontFaceAttrib();
	inline TBool operator==(const TOpenFontFaceAttrib& aAttrib) const;
	inline TPtrC FullName() const;
	inline TPtrC FamilyName() const;
	inline TPtrC LocalFullName() const;
	inline TPtrC LocalFamilyName() const;
	inline TPtrC ShortFullName() const;
	inline TPtrC ShortFamilyName() const;
	inline TPtrC ShortLocalFullName() const;
	inline TPtrC ShortLocalFamilyName() const;
	inline void SetFullName(const TDesC& aName);
	inline void SetFamilyName(const TDesC& aName);
	inline void SetLocalFullName(const TDesC& aName);
	inline void SetLocalFamilyName(const TDesC& aName);
	inline TInt MinSizeInPixels() const;
	inline void SetMinSizeInPixels(TInt aSize);
private:
	TBufC<ENameLength> iFamilyName;			 
	TBufC<ENameLength> iLocalFullName;		 
	TBufC<ENameLength> iLocalFamilyName;	 
	TInt iMinSizeInPixels;					 
	TInt32 iReserved2;
	};

 
class TOpenFontSpec: public TOpenFontFaceAttribBase
 
















	{
public:
	  TOpenFontSpec();
	  TOpenFontSpec(const TFontSpec& aFontSpec);
	  void operator=(const TFontSpec& aFontSpec);
	inline TBool operator==(const TOpenFontSpec& aFontSpec) const;
	  void SetAttrib(const TOpenFontFaceAttribBase& aAttrib);
	  void GetTFontSpec(TFontSpec& aFontSpec) const;
	  void CompensateForAspectRatio(TInt aKPixelWidth,TInt aKPixelHeight);
	  void CompensateForAspectRatio(const MGraphicsDeviceMap& aMap);
	inline TInt Height() const;
	inline TInt32 WidthFactor() const;
	inline TInt32 SlantFactor() const;
	inline TGlyphBitmapType BitmapType() const;
	inline TUint32 Effects() const;
	inline TFontPrintPosition PrintPosition() const;
	inline void SetHeight(TInt aHeight);
	inline void SetWidthFactor(TInt32 aWidthFactor);
	inline void SetSlantFactor(TInt32 aSlantFactor);
	inline void SetBitmapType(TGlyphBitmapType aBitmapType);
	inline void SetEffects(TUint32 aEffects);

	 


	enum
		{
		 
		EAlgorithmicBold = 1,
		 
		EDropShadow = 2,
		 
		EOutline = 4
		};
private:
	TInt iHeight;						 
	TInt32 iWidthFactor;				 
	TInt32 iSlantFactor;				 
	TInt iBitmapType;					 
	TUint32 iEffects;					 

	 
	TBool iSymbol;						 
	TFontPrintPosition iPrintPosition;	 

	TInt iReserved2;
	};

 



enum TOpenFontAttachment
	{
	EBaselineLeft,
	EBaselineRight,
	ETopLeft,
	ETopCenter,
	ETopRight,
	EBottomLeft,
	EBottomCenter,
	EBottomRight
	};


 
class COpenFontFile: public CBase
 





































	{
public:
	virtual void GetNearestFontInPixelsL(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,
										 const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
										 COpenFont*& aFont,TOpenFontSpec& aActualFontSpec) = 0;

	 




	virtual TBool HasUnicodeCharacterL(TInt aFaceIndex,TInt aCode) const = 0; 
	  virtual void Reserved();  
	  COpenFontFile(TInt aUid,const TDesC& aFileName);
	  ~COpenFontFile();
	  TBool GetNearestFontHelper(const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
										TInt& aFaceIndex,TOpenFontSpec& aActualFontSpec) const;
	  void AddFaceL(const TOpenFontFaceAttrib& aAttrib);
	inline TUid Uid() const;
	inline const TDesC& FileName() const;
	inline const TOpenFontFaceAttrib& FaceAttrib(TInt aFaceIndex) const;
	inline TInt FaceCount() const;
	inline void IncRefCount();
	inline TBool DecRefCount();
	TInt GetNearestFontInPixels(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,
								const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
								COpenFont*& aFont,TOpenFontSpec& aActualFontSpec);
	void RemoveFontFromList(const COpenFont* aFont);
	void SetFontStoreL(CFontStore* aFontStore);
protected:
	  TBool GetNearestFontHelperOld(const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
										TInt& aFaceIndex,TOpenFontSpec& aActualFontSpec) const;
private:
	 
	class TAttrib: public TOpenFontFaceAttrib
		{
		public:
		COpenFontPositioner* iPositioner;	 
		};
private:
	CArrayFixFlat<TAttrib> iFaceAttrib;
	TUid iUid;
	TBuf<KMaxFileName> iFileName;
	TInt iRefCount;
	CArrayPtrFlat<COpenFont> iFontList;
	TOpenFontFileData* iData;
	};

 
class COpenFontRasterizer: public CBase
 
































	{
public:
 	 





























	virtual COpenFontFile* NewFontFileL(TInt aUid,const TDesC& aFileName,RFs& aFileSession) = 0;
	  virtual void Reserved();  
private:
	TAny* iReserved;  
	};

 
class COpenFontRasterizerContext: public CBase
 













	{
public:
	inline COpenFontRasterizerContext();
	inline void StartGlyph(TOpenFontGlyphData* aGlyphData);
	inline void WriteGlyphBit(TInt aBit);
	inline void WriteGlyphByte(TInt aByte);
	inline void EndGlyph();
private:
	TOpenFontGlyphData* iGlyphData;
	TUint8* iGlyphDataStart;
	TUint8* iGlyphDataPtr;
	TUint8* iGlyphDataEnd;
	TInt iGlyphBit;
	TInt iBytesNeeded;
	TBool iOverflow;
	TAny* iReserved;  
	};


 
inline TOpenFontMetrics::TOpenFontMetrics()
 


	{
	Mem::FillZ(this,sizeof(*this));
	}

inline TInt TOpenFontMetrics::Size() const
 



	{
	return iSize;
	}
 
inline TInt TOpenFontMetrics::Ascent() const
 





	{
	return iAscent;
	}

inline TInt TOpenFontMetrics::Descent() const
 






	{
	return iDescent;
	}
 
inline TInt TOpenFontMetrics::MaxHeight() const
 













	{
	return iMaxHeight;
	}
 
inline TInt TOpenFontMetrics::MaxDepth() const
 









	{
	return iMaxDepth;
	}
 
inline TInt TOpenFontMetrics::MaxWidth() const
 



	{
	return iMaxWidth;
	}
 
inline void TOpenFontMetrics::SetSize(TInt aSize)
 



	{
	iSize = static_cast<TInt16>(aSize);
	}

inline void TOpenFontMetrics::SetAscent(TInt aAscent)
 



	{
	iAscent = static_cast<TInt16>(aAscent);
	}

inline void TOpenFontMetrics::SetDescent(TInt aDescent)
 



	{
	iDescent = static_cast<TInt16>(aDescent);
	}
 
inline void TOpenFontMetrics::SetMaxHeight(TInt aMaxHeight)
 



	{
	iMaxHeight = static_cast<TInt16>(aMaxHeight);
	}
 
inline void TOpenFontMetrics::SetMaxDepth(TInt aMaxDepth)
 



	{
	iMaxDepth = static_cast<TInt16>(aMaxDepth);
	}
 
inline void TOpenFontMetrics::SetMaxWidth(TInt aMaxWidth)
 



	{
	iMaxWidth = static_cast<TInt16>(aMaxWidth);
	}
 
inline TOpenFontCharMetrics::TOpenFontCharMetrics()
 



	{
	Mem::FillZ(this,sizeof(*this));
	}
 
inline TInt TOpenFontCharMetrics::Width() const
 


	{
	return iWidth;
	}
 
inline TInt TOpenFontCharMetrics::Height() const
 


	{
	return iHeight;
	}
 
inline TInt TOpenFontCharMetrics::HorizBearingX() const
 






	{
	return iHorizBearingX;
	}
 
inline TInt TOpenFontCharMetrics::HorizBearingY() const
 






	{
	return iHorizBearingY;
	}
 
inline TInt TOpenFontCharMetrics::HorizAdvance() const
 






	{
	return iHorizAdvance;
	}

inline TInt TOpenFontCharMetrics::VertBearingX() const
 






	{
	return iVertBearingX;
	}
 
inline TInt TOpenFontCharMetrics::VertBearingY() const
 






	{
	return iVertBearingY;
	}
 
inline TInt TOpenFontCharMetrics::VertAdvance() const
 









	{
	return iVertAdvance;
	}
 
inline void TOpenFontCharMetrics::GetHorizBounds(TRect& aBounds) const
 





	{
	aBounds.iTl.iX = iHorizBearingX;
	aBounds.iTl.iY = -iHorizBearingY;
	aBounds.iBr.iX = aBounds.iTl.iX + iWidth;
	aBounds.iBr.iY = aBounds.iTl.iY + iHeight;
	}
 
inline void TOpenFontCharMetrics::GetVertBounds(TRect& aBounds) const
 





	{
	aBounds.iTl.iX = -iVertBearingX;
	aBounds.iTl.iY = iVertBearingY;
	aBounds.iBr.iX = aBounds.iTl.iX + iWidth;
	aBounds.iBr.iY = aBounds.iTl.iY + iHeight;
	}
 
inline void TOpenFontCharMetrics::SetWidth(TInt aWidth)
 


	{
	iWidth = (TInt16)aWidth;
	}
 
inline void TOpenFontCharMetrics::SetHeight(TInt aHeight)
 


	{
	iHeight = (TInt16)aHeight;
	}
 
inline void TOpenFontCharMetrics::SetHorizBearingX(TInt aHorizBearingX)
 






	{
	iHorizBearingX = (TInt16)aHorizBearingX;
	}
 
inline void TOpenFontCharMetrics::SetHorizBearingY(TInt aHorizBearingY)
 






	{
	iHorizBearingY = (TInt16)aHorizBearingY;
	}
 
inline void TOpenFontCharMetrics::SetHorizAdvance(TInt aHorizAdvance)
 






	{
	iHorizAdvance = (TInt16)aHorizAdvance;
	}
 
inline void TOpenFontCharMetrics::SetVertBearingX(TInt aVertBearingX)
 






	{
	iVertBearingX = (TInt16)aVertBearingX;
	}
 
inline void TOpenFontCharMetrics::SetVertBearingY(TInt aVertBearingY)
 






	{
	iVertBearingY = (TInt16)aVertBearingY;
	}
 
inline void TOpenFontCharMetrics::SetVertAdvance(TInt aVertAdvance)
 









	{
	iVertAdvance = (TInt16)aVertAdvance;
	}
 
inline const TOpenFontMetrics& COpenFont::Metrics() const
 


	{
	return iMetrics;
	}

inline TInt TOpenFontGlyphData::GlyphIndex() const
 









	{
	return iGlyphIndex;
	}
 
inline const TOpenFontFaceAttrib* COpenFont::FaceAttrib() const
 




	{
	return iFile ? &iFile->FaceAttrib(iFaceIndex) : 0L ;
	}
 
inline COpenFontFile* COpenFont::File() const
 






	{
	return iFile;
	}
 
inline TInt COpenFont::FaceIndex() const
 


	{
	return iFaceIndex;
	}
 
inline TBool COpenFont::CharacterNeedsToBeRasterized(TInt aSessionHandle,TInt aCode) const
 








	{
	return Glyph(aSessionHandle,aCode) == 0L ;
	}
 
inline TOpenFontFaceAttribBase::TOpenFontFaceAttribBase()
 



	{
	Mem::FillZ(this,sizeof(*this));
	}
 
inline TOpenFontFaceAttrib::TOpenFontFaceAttrib():
	iMinSizeInPixels(0),
	iReserved2(0)
 



	{
	}
 
inline TBool TOpenFontFaceAttribBase::HasLatin() const
 





	{
	return iCoverage[0] & ELatinSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasGreek() const
 





	{
	return iCoverage[0] & EGreekSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasCyrillic() const
 





	{
	return iCoverage[0] & ECyrillicSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasKana() const
 










	{
	return iCoverage[1] & EKanaSets;
	}
 
inline TBool TOpenFontFaceAttribBase::HasHangul() const
 








	{
	return iCoverage[1] & EHangulSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasCJK() const
 







	{
	return iCoverage[1] & ECJKSet;
	}
 
inline TBool TOpenFontFaceAttribBase::IsSymbol() const
 


	{
	return iCoverage[0] == 0 && iCoverage[2] == 0 && iCoverage[3] == 0 &&
		   iCoverage[1] & ESymbolSets && !(iCoverage[1] & ~ESymbolSets);
	}
 
inline TBool TOpenFontFaceAttribBase::IsBold() const
 


	{
	return iStyle & EBold;
	}
 
inline TBool TOpenFontFaceAttribBase::IsItalic() const
 


	{
	return iStyle & EItalic;
	}
 
inline TBool TOpenFontFaceAttribBase::IsSerif() const
 


	{
	return iStyle & ESerif;
	}
 
inline TBool TOpenFontFaceAttribBase::IsMonoWidth() const
 


	{
	return iStyle & EMonoWidth;
	}
 
inline TPtrC TOpenFontFaceAttribBase::Name() const
 


	{
	return iName;
	}
 
inline TPtrC TOpenFontFaceAttrib::FullName() const
 






	{
	return Name();
	}
 
inline TPtrC TOpenFontFaceAttrib::FamilyName() const
 






	{
	return iFamilyName;
	}
 
inline TPtrC TOpenFontFaceAttrib::LocalFullName() const
 









	{
	return iLocalFullName;
	}
 
inline TPtrC TOpenFontFaceAttrib::LocalFamilyName() const
 









	{
	return iLocalFamilyName;
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortFullName() const
 










	{
	 
	return TPtrC(iName.Ptr(),Min(iName.Length(),KMaxTypefaceNameLength));
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortFamilyName() const
 









	{
	return TPtrC(iFamilyName.Ptr(),Min(iFamilyName.Length(),KMaxTypefaceNameLength));
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortLocalFullName() const
 










	{
	return TPtrC(iLocalFullName.Ptr(),Min(iLocalFullName.Length(),KMaxTypefaceNameLength));
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortLocalFamilyName() const
 










	{
	return TPtrC(iLocalFamilyName.Ptr(),Min(iLocalFamilyName.Length(),KMaxTypefaceNameLength));
	}
 
inline const TUint* TOpenFontFaceAttribBase::Coverage() const
 











	{
	return iCoverage;
	}
 
inline TInt TOpenFontFaceAttrib::MinSizeInPixels() const
 




	{
	return iMinSizeInPixels;
	}
 
inline void TOpenFontFaceAttribBase::SetName(const TDesC& aName)
 


	{
	iName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttrib::SetFullName(const TDesC& aName)
 



	{
	SetName(aName);
	}
 
inline void TOpenFontFaceAttrib::SetFamilyName(const TDesC& aName)
 



	{
	iFamilyName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttrib::SetLocalFullName(const TDesC& aName)
 



	{
	iLocalFullName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttrib::SetLocalFamilyName(const TDesC& aName)
 



	{
	iLocalFamilyName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttribBase::SetCoverage(TUint aCoverage0,TUint aCoverage1,TUint aCoverage2,TUint aCoverage3)
 













	{
	iCoverage[0] = aCoverage0;
	iCoverage[1] = aCoverage1;
	iCoverage[2] = aCoverage2;
	iCoverage[3] = aCoverage3;
	}
 
inline void TOpenFontFaceAttrib::SetMinSizeInPixels(TInt aSize)
 





	{
	iMinSizeInPixels = aSize;
	}
 
inline TBool TOpenFontFaceAttrib::operator==(const TOpenFontFaceAttrib& aAttrib) const
 







	{
	return TOpenFontFaceAttribBase::operator==(aAttrib) &&
		   iFamilyName == aAttrib.iFamilyName &&
		   iLocalFullName == aAttrib.iLocalFullName &&
		   iLocalFamilyName == aAttrib.iLocalFamilyName &&
		   iMinSizeInPixels == aAttrib.iMinSizeInPixels;
	}
 
inline void TOpenFontFaceAttribBase::SetBold(TBool aBold)
 


	{
	if (aBold)
		iStyle |= EBold;
	else
		iStyle &= ~EBold;
	}
 
inline void TOpenFontFaceAttribBase::SetItalic(TBool aItalic)
 


	{
	if (aItalic)
		iStyle |= EItalic;
	else
		iStyle &= ~EItalic;
	}
 
inline void TOpenFontFaceAttribBase::SetSerif(TBool aSerif)
 


	{
	if (aSerif)
		iStyle |= ESerif;
	else
		iStyle &= ~ESerif;
	}
 
inline void TOpenFontFaceAttribBase::SetMonoWidth(TBool aMonoWidth)
 


	{
	if (aMonoWidth)
		iStyle |= EMonoWidth;
	else
		iStyle &= ~EMonoWidth;
	}
 
inline TBool TOpenFontFaceAttribBase::operator==(const TOpenFontFaceAttribBase& aAttrib) const
 









	{
	return iStyle == aAttrib.iStyle &&
		   iCoverage[0] == aAttrib.iCoverage[0] &&
		   iCoverage[1] == aAttrib.iCoverage[1] &&
		   iCoverage[2] == aAttrib.iCoverage[2] &&
		   iCoverage[3] == aAttrib.iCoverage[3] &&
		   iName.CompareF(aAttrib.iName) == 0;
	}
 
inline TBool TOpenFontSpec::operator==(const TOpenFontSpec& aFontSpec) const
 






	{
	return TOpenFontFaceAttribBase::operator==(aFontSpec) &&
		   iHeight == aFontSpec.iHeight &&
		   iWidthFactor == aFontSpec.iWidthFactor &&
		   iSlantFactor == aFontSpec.iSlantFactor &&
		   iBitmapType == aFontSpec.iBitmapType &&
		   iEffects == aFontSpec.iEffects &&
		   iSymbol == aFontSpec.iSymbol &&
		   iPrintPosition == aFontSpec.iPrintPosition;
	}
 
inline TInt TOpenFontSpec::Height() const
 



	{
	return iHeight;
	}
 
inline TInt32 TOpenFontSpec::WidthFactor() const
 



	{
	return iWidthFactor;
	}
 
inline TInt32 TOpenFontSpec::SlantFactor() const
 



	{
	return iSlantFactor;
	}
 
inline TGlyphBitmapType TOpenFontSpec::BitmapType() const
 


	{
	return (TGlyphBitmapType)iBitmapType;
	}
 
inline TUint32 TOpenFontSpec::Effects() const
 






	{
	return iEffects;
	}

inline TFontPrintPosition TOpenFontSpec::PrintPosition() const
 


	{
	return iPrintPosition;
	}
 
inline void TOpenFontSpec::SetHeight(TInt aHeight)
 



	{
	iHeight = aHeight;
	}

inline void TOpenFontSpec::SetWidthFactor(TInt32 aWidthFactor)
 








	{
	iWidthFactor = aWidthFactor;
	}
 
inline void TOpenFontSpec::SetSlantFactor(TInt32 aSlantFactor)
 














	{
	iSlantFactor = aSlantFactor;
	}
 
inline void TOpenFontSpec::SetBitmapType(TGlyphBitmapType aBitmapType)
 








	{
	iBitmapType = aBitmapType;
	}
 
inline void TOpenFontSpec::SetEffects(TUint32 aEffects)
 






	{
	iEffects = aEffects;
	}
 
inline TUid COpenFontFile::Uid() const
 


	{
	return iUid;
	}
 
inline const TDesC& COpenFontFile::FileName() const
 





	{
	return iFileName;
	}
 
inline const TOpenFontFaceAttrib& COpenFontFile::FaceAttrib(TInt aFaceIndex) const
 





	{
	return iFaceAttrib[aFaceIndex];
	}
 
inline TInt COpenFontFile::FaceCount() const
 







	{
	return iFaceAttrib.Count();
	}
 
inline void COpenFontFile::IncRefCount()
 


	{
	iRefCount++;
	}
 
inline TBool COpenFontFile::DecRefCount()
 





	{
	iRefCount--;
	return iRefCount <= 0;
	}
 
inline COpenFontRasterizerContext::COpenFontRasterizerContext():
	iGlyphData(0L )
 
	{
	}
 
inline void COpenFontRasterizerContext::StartGlyph(TOpenFontGlyphData* aGlyphData)
 





	{
	aGlyphData->SetPointersToInternalBuffers();
	iGlyphData = aGlyphData;
	iGlyphDataStart = iGlyphDataPtr = aGlyphData->BufferStart();
	 
	iGlyphDataEnd = aGlyphData->BufferEnd() - 4;
	iGlyphBit = 1;
	*iGlyphDataPtr = 0;
	iBytesNeeded = 1;
	iOverflow = 0 ;
	}
 
inline void COpenFontRasterizerContext::WriteGlyphBit(TInt aBit)
 




	{
	if (aBit && !iOverflow)
		*iGlyphDataPtr |= iGlyphBit;
	iGlyphBit <<= 1;
	if (iGlyphBit == 256)
		{
		iGlyphBit = 1;
		iBytesNeeded++;
		if (++iGlyphDataPtr < iGlyphDataEnd)
			*iGlyphDataPtr = 0;
		else
			iOverflow = 1 ;
		}
	}

inline void COpenFontRasterizerContext::WriteGlyphByte(TInt aByte)
 



	
 	{
	if (iGlyphDataPtr < iGlyphDataEnd)
		*iGlyphDataPtr++ = (TUint8)aByte;
	else
		iOverflow = 1 ;
	iBytesNeeded++;
	}
 
inline void COpenFontRasterizerContext::EndGlyph()
 



	{
	 
	iGlyphData->SetBytesNeeded(iBytesNeeded + 4);
	iGlyphData = 0L ;
	}
    
inline TBool TOpenFontGlyphData::Overflow() const
 


	{
	return iBytesNeeded > iBitmapBufferSize;
	}
 
inline TInt TOpenFontGlyphData::BytesNeeded() const
 



	{
	return iBytesNeeded;
	}
 
inline TPtrC8 TOpenFontGlyphData::Bitmap() const
 



	{
	return TPtrC8(iBitmap,iBytesNeeded);
	}
 
inline const TUint8* TOpenFontGlyphData::BitmapPointer() const
 





	{
	return iBitmap;
	}
 
inline const TOpenFontCharMetrics* TOpenFontGlyphData::Metrics() const
 


	{
	return iMetrics;
	}
 
inline TUint8* TOpenFontGlyphData::BufferStart()
 


	{
	return iBitmapBuffer;
	}
 
inline TUint8* TOpenFontGlyphData::BufferEnd()
 


	{
	return iBitmapBuffer + iBitmapBufferSize;
	}
 
inline void TOpenFontGlyphData::SetBytesNeeded(TInt aBytes)
 



	{
	iBytesNeeded = aBytes;
	}
 
inline void TOpenFontGlyphData::SetBitmapPointer(const TUint8* aBitmap)
 


	{
	iBitmap = aBitmap;
	}
 
inline void TOpenFontGlyphData::SetMetricsPointer(const TOpenFontCharMetrics* aMetrics)
 


	{
	iMetrics = aMetrics;
	}
 
inline void TOpenFontGlyphData::SetPointersToInternalBuffers()
 



	{
	iBitmap = iBitmapBuffer;
	iMetrics = &iMetricsBuffer;
	}
 
inline void TOpenFontGlyphData::SetMetrics(TOpenFontCharMetrics& aMetrics)
 



	{
	iMetricsBuffer = aMetrics;
	iMetrics = &iMetricsBuffer;
	}
 
inline void TOpenFontGlyphData::SetGlyphIndex(TInt aGlyphIndex)
 


	{
	iGlyphIndex = aGlyphIndex;
	}


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 2


class CFontStoreFile;
class CFontBitmap;
class RReadStream;
class TTypefaceFontBitmap;

class TCharacterMetrics
 


	{
	public:
	  TCharacterMetrics();

	TInt16 iAscentInPixels;
	TInt16 iHeightInPixels;
	TInt16 iLeftAdjustInPixels;
	TInt16 iMoveInPixels;
	TInt16 iRightAdjustInPixels;
	};

class TAlgStyle
 







	{
public:
	  TAlgStyle();
	  void SetIsBold(TBool aIsBold);
	  void SetIsItalic(TBool aIsItalic);
	  void SetIsMono(TBool aIsMono);
	  void SetWidthFactor(TInt aWidthFactor);
	  void SetHeightFactor(TInt aHeightFactor);
	  TBool IsBold() const;
	  TBool IsItalic() const;
	  TBool IsMono() const;
	  TInt WidthFactor() const;
	  TInt HeightFactor() const;
	  TBool operator==(const TAlgStyle& aAlgStyle) const;

public:
	 
	TInt iBaselineOffsetInPixels;
private:
	enum
		{
		EBold=1,
		EItalic=2,
		EMono=4,
		};
	 
    TInt8 iFlags;
	 
	TInt8 iWidthFactor;
	 
	TInt8 iHeightFactor;
	};

class CBitmapFont : public CFont
 









	{
	friend class CFontStore;
private:
	CBitmapFont(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,CFontBitmap* aFontBitmap);
	CBitmapFont(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,COpenFont* aOpenFont);
	void ConstructL();
	~CBitmapFont();
	  static CBitmapFont* NewL(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,CFontBitmap* aFontBitmap);
	static CBitmapFont* NewL(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,COpenFont* aOpenFont);
public:
	  TUid TypeUid() const;
	TUid Uid() const;
	  TInt HeightInPixels() const;
	  TInt AscentInPixels() const;
	  TInt CharWidthInPixels(TChar aChar) const;
	  TInt TextWidthInPixels(const TDesC &aText) const;
	  TInt BaselineOffsetInPixels() const;
	  TInt TextCount(const TDesC &aText,TInt aWidthInPixels) const;
	  TInt TextCount(const TDesC &aText,TInt aWidthInPixels,TInt &aExcessWidthInPixels) const;
	  TInt MaxCharWidthInPixels() const;
	  TInt MaxNormalCharWidthInPixels() const;
	  TFontSpec FontSpecInTwips() const;
	  TCharacterMetrics CharacterMetrics(TInt aCode,const TUint8*& aBytes) const;
	  TBool GetCharacterData(TInt aSessionHandle,TInt aCode,TOpenFontCharMetrics& aMetrics,
									const TUint8*& aBitmap) const;
	  TBool Rasterize(TInt aSessionHandle,TInt aCode,TOpenFontGlyphData* aGlyphData) const;
	  void GetFontMetrics(TOpenFontMetrics& aMetrics) const;
	  TBool GetFaceAttrib(TOpenFontFaceAttrib& aAttrib) const;
	  TInt BitmapEncoding() const;
	  TBool HasCharacterL(TInt aCode) const;
	  TBool CharacterNeedsToBeRasterized(TInt aSessionHandle,TInt aCode) const;
	  void operator delete(TAny*);
	inline TBool IsOpenFont() const;
	inline COpenFont* OpenFont() const;
	inline TGlyphBitmapType GlyphBitmapType() const;
private:
	TInt Width(TInt aNum) const;
	TInt Height(TInt aNum) const;
	CFontBitmap* FontBitmap() const;
private:
	TFontSpec iFontSpecInTwips;
public:
	 
	TAlgStyle iAlgStyle;	 
private:
	RHeap* iHeap;
	TInt iFontBitmapOffset;
	COpenFont* iOpenFont;	 
	};

class CFontStore : public CTypefaceStore
 











    {
private:
	CFontStore();
	void ConstructL();
public:
	  static CFontStore* NewL(RHeap* aHeap);
	  ~CFontStore();
	  TUid AddFileL(const TDesC& aName);
	  void RemoveFile(TUid aFileUid);
	  TInt GetNearestFontInTwips(CFont *&aFont,const TFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont *&aFont,const TFontSpec &aFontSpec);
	  TInt GetNearestFontInTwips(CFont *&aFont,const TOpenFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont *&aFont,const TOpenFontSpec &aFontSpec);
 	  TInt GetFontById(CFont *&aFont,TUid aUid,const TAlgStyle& aAlgStyle);
	  TInt NumTypefaces() const;
	  void TypefaceSupport(TTypefaceSupport &aTypefaceSupport,TInt aTypefaceIndex) const;
	  TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  void InstallRasterizerL(COpenFontRasterizer* aRasterizer);
	  void DeleteSessionCache(TInt aSessionHandle);
	inline TGlyphBitmapType DefaultBitmapType() const;
	inline void SetDefaultBitmapType(TGlyphBitmapType aType);
	TInt BitmapFontFilesCount() const;
private:
	void InternalizeFontStoreFileL(CFontStoreFile* aFontStoreFile);
	TTypeface* GetNearestTypeface(const TTypeface& aTypeface) const;
	TTypefaceFontBitmap GetNearestTypefaceFontBitmap(const TFontSpec& aFontSpecInPixels);
	CFontBitmap* GetFontBitmapById(TUid aUid);
	CBitmapFont* FindFont(const TFontSpec& aFontSpecInPixels,const TAlgStyle& aAlgStyle,TUid aUid) const;
	CBitmapFont* FindFont(const TOpenFontSpec& aFontSpecInPixels,const TAlgStyle& aAlgStyle) const;
	CBitmapFont* NewFontL(const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,CFontBitmap* aFontBitmap);
	CBitmapFont* NewFontL(const TOpenFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,COpenFont* aOpenFont);
	TInt VerticalPixelsToTwips(TInt aPixelHeight) const;
	TInt VerticalTwipsToPixels(TInt aTwipsHeight) const;
	TInt GetNearestBitmapFontInPixels(CBitmapFont *&aFont,TFontSpec &aFontSpec);
	TInt GetNearestOpenFontInPixels(CBitmapFont *&aFont,TOpenFontSpec &aFontSpec,
									const TOpenFontSpec& aIdealFontSpecInPixels);
	void UpdateTypefaceSupportListL();

public:
	 




	TInt iKPixelWidthInTwips;
	
	 




	TInt iKPixelHeightInTwips;
private:
	RFs iFs;
	RHeap* iHeap;
	CArrayPtrFlat<CFontStoreFile> iFontStoreFileList;
	CArrayPtrFlat<TTypeface> iTypefaceList;
	CArrayPtrFlat<CFontBitmap> iFontBitmapList;
	CArrayFixFlat<TTypefaceFontBitmap> iTypefaceFontBitmapList;
	CArrayPtrFlat<COpenFontFile> iOpenFontFileList;
	CArrayFixFlat<TTypefaceSupport> iOpenFontTypefaceSupportList;
	CArrayPtrFlat<COpenFontRasterizer> iOpenFontRasterizerList;
	COpenFontSessionCacheList* iOpenFontSessionCacheList;
	TInt iOpenFontUid;
	TGlyphBitmapType iDefaultBitmapType;
	};

 
inline TBool CBitmapFont::IsOpenFont() const
 




	{
	return iOpenFont != 0L ;
	}

inline COpenFont* CBitmapFont::OpenFont() const
 


	{ 
	return iOpenFont;
	}

inline TGlyphBitmapType CBitmapFont::GlyphBitmapType() const
 







	{
	return iFontSpecInTwips.iFontStyle.BitmapType();
	}

inline TGlyphBitmapType CFontStore::DefaultBitmapType() const
 


	{
	return iDefaultBitmapType;
	}

inline void CFontStore::SetDefaultBitmapType(TGlyphBitmapType aType)
 


	{
	iDefaultBitmapType = aType;
	}


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/w32std.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fbs.h" 1
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitmap.h" 1
 
 
 
 












 


const TUid KCBitwiseBitmapUid={268435520};
const TUid KCBitwiseBitmapHardwareUid={0x10009a3d};
const TUid KMultiBitmapFileImageUid={268435522};
const TInt KMaxLargeBitmapAlloc=0x1000;
const TInt KCompressionBookMarkThreshold=0x2000;

 
class CChunkPile;
class TCompressionBookMark;

 



enum TBitmapfileCompression
	{
	 
	ENoBitmapCompression,
	 
	EByteRLECompression,
	 
	ETwelveBitRLECompression,
	 
	ESixteenBitRLECompression,
	 
	ETwentyFourBitRLECompression,
	 
	ERLECompressionLast
	};

class TRgb24bit
 


	{
public:
	TUint8 iRed;
	TUint8 iGreen;
	TUint8 iBlue;
	};

 




class SEpocBitmapHeader
	{
public:
	 
	TInt iBitmapSize;
	 
	TInt iStructSize;
	 
	TSize iSizeInPixels;
	 
	TSize iSizeInTwips;
	 
	TInt iBitsPerPixel;
	 

	TBool iColor;
	 
	TInt iPaletteEntries;
	 
	TBitmapfileCompression iCompression;
	};

class TLineScanningPosition
 


	{
public:
	TLineScanningPosition(TUint32* aSrcDataPtr): iSrcDataPtr((TUint8*)aSrcDataPtr), iCursorPos(0), iScanLineBuffer(0L ) {}
public:
	TUint8* iSrcDataPtr;
	TInt iCursorPos;
	HBufC8* iScanLineBuffer;
	};

class CShiftedFileStore;
 




class CBitwiseBitmap
	{
	friend class CFbTop;
	friend class CFbClient;
	friend class CFbsBitmap;
	friend class CBitmapObject;
	friend class CFbsBitmapAsyncStreamer;
public:
	  TUid Uid() const;
	  void ExternalizeL(RWriteStream& aStream,const CFbsBitmap& aHandleBitmap) const;
	  void ExternalizeRectangleL(RWriteStream& aStream,const TRect& aRect,const CFbsBitmap& aHandleBitmap) const;
	  void InternalizeL(RReadStream& aStream);
	  static void InternalizeHeaderL(RReadStream& aStream,SEpocBitmapHeader& aHeader);
	  TSize SizeInPixels() const;
	  TSize SizeInTwips() const;
	  TDisplayMode DisplayMode() const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  void GetPixel(TRgb& aColor,const TPoint& aPos,TUint32* aBase) const;
	  TInt GetScanLinePtr(TUint32*& aSlptr, TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  TInt GetScanLinePtr(TUint32*& aSlptr, TInt& aLength, TPoint& aPixel,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  void GetScanLine(TUint32*& aSlptr, TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode) const;
	  void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase) const;
	  void GetVerticalScanLine(TDes8& aBuf,TInt aX,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase) const;
	  void StretchScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase) const;
	  void StretchScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  TUint32* ScanLineAddress(TUint32* aBase,TUint aY) const;
	  TBool IsMonochrome(TUint32* aBase) const;
	  void Compress(TUint8* aNewData,TUint8* aOldData);
	  TBool IsLargeBitmap() const;
	  TInt CompressData();
	  void SetCompressionBookmark(TLineScanningPosition& aLineScanningPosition, TUint32* aBase, const CFbsBitmap* aFbsBitmap);
	  TInt HardwareBitmapHandle() const;
	  TBool IsCompressedInRAM() const;
private:
	  void operator delete(TAny*);
	  CBitwiseBitmap(RHeap* aHeap,CChunkPile* aPile);
	  ~CBitwiseBitmap();
	  void Reset();
	  TInt Construct(const TSize& aSize,TDisplayMode aDispMode,TUid aCreatorUid);
	  void ConstructL(RFs& aFs,const TDesC& aFilename,TInt32 aId,TUint aFileOffset);
	  void ConstructL(CShiftedFileStore* aFileStore,TStreamId aStreamId);
	  TInt Resize(const TSize& aSize);
private:
	void GenerateLineFromCompressedTwelveBitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	void GenerateLineFromCompressedEightBitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	TUint8 GetGrayPixelEx(TInt aX,TUint32* aScanLineAddress) const;
	TRgb GetRgbPixelEx(TInt aX,TUint32* aScanLineAddress) const;
	void GetScanLineGray2(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TUint32* aScanlinePtr) const;
	void GetScanLineGray4(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TUint32* aScanlinePtr) const;
	void GetScanLineGray16(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineGray256(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor16(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor256(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor4K(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor64K(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor16M(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor16MU(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColorRgb(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineExBits(TDes8& aBuf,TInt aX,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineExBytes(TDes8& aBuf,TInt aX,TInt aLength,TUint32* aScanlinePtr) const;
	void DoExternalizeDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeByteDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeTwelveBitDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeSixteenBitDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeTwentyFourBitDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfByteDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfTwelveBitDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfSixteenBitDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfTwentyFourBitDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TBool TrueColorPointerCompare(TUint8* aColorPointer,TUint8 aComponent1,TUint8 aComponent2,TUint8 aComponent3) const;
	void DoInternalizeL(RReadStream& aStream,TInt aSrceSize,TUint32* aBase);
	void DoInternalizeCompressedDataL(RReadStream& aStream,TInt aSrceSize,TUint32* aBase,TBitmapfileCompression aCompression);
	void DoDecompressByteData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);

	void DoDecompressByteDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoDecompressTwelveBitData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);
	void DoDecompressTwelveBitDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoDecompressSixteenBitData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);
	void DoDecompressSixteenBitDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoDecompressTwentyFourBitData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);
	void DoDecompressTwentyFourBitDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoStretchScanLine(TDes8& aBuf,TInt x,TInt y,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase,TLineScanningPosition& aLineScanningPosition) const;
	void DoCompressScanLine(TDes8& aBuf,TInt x,TInt y,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase,TLineScanningPosition& aLineScanningPosition) const;
	TUint32 HashTo1bpp(TUint32 aGray256,TBool aOddX,TBool aOddY) const;
	TUint32 HashTo2bpp(TUint32 aGray256,TInt aDitherIndex) const;
	TBool IsWordMonochrome(TUint32 aWord) const;
	TUint32* DataAddress() const;
	static void WhiteFill(TUint8* aData,TInt aDataSize,TDisplayMode aDispMode);
	static TInt ByteWidth(TInt aPixelWidth,TDisplayMode aDispMode);
	static TInt Bpp(TDisplayMode aDispMode);
	static TBool IsColor(TDisplayMode aDispMode);
	static TDisplayMode DisplayMode(TInt aBpp,TBool aColor);
	static TBitmapfileCompression CompressionType(TInt aBpp);
	TInt DoGetScanLinePtr(TUint32*& aSlptr, TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	void GenerateLineFromCompressedSixteenBitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	TDisplayMode InitialDisplayMode() const;
	TInt SetDisplayMode(TDisplayMode aDisplayMode, TUint32* aDataAddress);
	TInt DisplayModeArgCheck(TDisplayMode aDisplayMode, TUint32* aDataAddress) const;
	void ChangeDisplayMode( TDisplayMode aNewDisplayMode,
							TInt aScanLineWidthNew,
							TUint8* aDataAddrNew,
							TUint32* aDataAddress,
							TInt aYStart,
							TInt aYInc,
							TInt aYEnd);
	void UpdateBitmapProperties(TDisplayMode aNewDisplayMode);
	TInt SwapWidthAndHeight(TUint32* aDataAddress);
	void CopyOldData(TUint8* aDest, const TUint8* aSrc, TInt aNewByteWidth, const TSize aNewSize);
	void DecompressOldData(TUint8* aDest, TInt aNewByteWidth, const TSize aNewSize, HBufC8* aScanLineBuf);
	TInt ResizeConditionsCheck(const TSize& aSize, TInt aNewByteWidth, TInt& aNewBitmapSize) const;
	TInt Alloc(TInt aNewBitmapSize, const TSize& aNewSize, TUint8*& aNewBuf, TInt& aNewDataOffset);
	void MoveData(TUint8* aDest, TUint8* aSrc, TInt aNewByteWidth, const TSize& aNewSize, HBufC8* aScanLineBuf);
	void ReinitializeHeader(const TSize& aNewSize, TInt aNewBitmapSize);
	void Free(TUint8* aSrc, TBool aLargeBmp, HBufC8* aScanLineBuf);
	void GenerateLineFromCompressed24BitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	void AdjustXCoord(TInt& aX) const;
	void GetLineScanPos(TLineScanningPosition& aLineScanPos, 
						const TCompressionBookMark*& aComprBookMark, 
						const TUint8* aBase) const;
	void UpdateBookMark(const TLineScanningPosition& aLineScanPos, 
						TCompressionBookMark* aComprBookMark, 
						const TUint8* aBase) const;
private:
	TUid iUid;
	struct TSettings
		{
		TSettings(TDisplayMode aDisplayMode);
		void SetDisplayModes(TDisplayMode aDisplayMode);
		void SetCurrentDisplayMode(TDisplayMode aDisplayMode);
		TDisplayMode CurrentDisplayMode() const;
		TDisplayMode InitialDisplayMode() const;
		TUint32 iData;
		} iSettings;
	RHeap* iHeap;
	CChunkPile* iPile;
	TInt iByteWidth;
	SEpocBitmapHeader iHeader;
	RChunk iLargeChunk;
	TInt iDataOffset;  
	TBool iIsCompressedInRAM;  
	};


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fbs.h" 2

 


const TUid KCFbsFontUid = { 268435518 };
 


const TUid KMultiBitmapRomImageUid = { 268435521 };
const TUint32 KFontBitmapServerUidValue = 0x10003a16;
const TUid KFontBitmapServerUid = { KFontBitmapServerUidValue };
 


  TInt FbsStartup();

 





  void DummyReserved1();


 




class SCharWidth
	{
public:
	 
	TInt iLeftAdjust;
	 
	TInt iRightAdjust;
	 
	TInt iMove;
	 
	TInt iWidth;
	};

class CFbsRalCache;

 




class RFbsSession : protected RSessionBase
	{
	 
	friend class RClean;
	friend class TestFbs;
	friend class RTestBitmap;
	
	friend class CFbsBitmap;
	friend class CFbsBitmapAsyncStreamer;
public:
	  RFbsSession();
	  static TInt Connect();
	  static void Disconnect();
	  static RFbsSession* GetSession();
	  void CallBack();
	  void SetCallBack(TCallBack aCallBack);
	  void ResetCallBack();
	  TInt ResourceCount();
	  TInt SendCommand(TInt aMessage,TInt aInt0=0,TInt aInt1=0,TInt aInt2=0,TInt aInt3=0) const;
	  TVersion Version();
	  TUint8* HeapBase() const;
	TInt SessionHandle() const { return Handle(); }
	TInt AllocScanLineBuffer(TInt aSize);
	HBufC8* GetScanLineBuffer();
private:
	TBool LookupBitmapInROM(const TDesC& aFilename, TAny*& aAddr);
private:
	TInt iConnections;
	TCallBack iCallBack;
	RChunk iSharedChunk;
	RMutex iAddressMutex;
	RChunk iLargeBitmapChunk;
	RFs iFileServer;
	CFbsRalCache* iRomFileAddrCache;
	TAny* iUnused;
	HBufC8* iScanLineBuffer;
	TUint32* iSpare;
	};

 











class CFbsFont: public CFont
	{
	friend class CFbsTypefaceStore;
public:
	 
	 




	TUid TypeUid() const { return KCFbsFontUid; }
	  TInt HeightInPixels() const;
	  TInt AscentInPixels() const;
	  TInt CharWidthInPixels(TChar aChar) const;
	  TInt TextWidthInPixels(const TDesC& aText) const;
	  TInt BaselineOffsetInPixels() const;
	  TInt TextCount(const TDesC& aText,TInt aWidthInPixels) const;
	  TInt TextCount(const TDesC& aText,TInt aWidthInPixels,TInt& aExcessWidthInPixels) const;
	  TInt MaxCharWidthInPixels() const;
	  TInt MaxNormalCharWidthInPixels() const;
	  TFontSpec FontSpecInTwips() const;
	  CFont::TCharacterDataAvailability GetCharacterData(TUint aCode,TOpenFontCharMetrics& aMetrics,
	const TUint8*& aBitmap,TSize& aBitmapSize) const;
	  TBool GetFontMetrics(TOpenFontMetrics& aMetrics) const;
	  void TextWidthInPixels(const TDesC& aText,SCharWidth& aCharWidth) const;
	  TInt Handle() const;
	  TCharacterMetrics CharacterMetrics(TInt aCode,const TUint8*& aBytes) const;
	  TInt RawTextWidthInPixels(const TDesC& aText) const;
	  TBool GetFaceAttrib(TOpenFontFaceAttrib& aAttrib) const;
	  TBool IsOpenFont() const;
	  TBool HasCharacter(TInt aCode) const;
protected:
	  CFbsFont();
	  ~CFbsFont();
	  CFbsFont(const CFbsFont& aFont);
	  CBitmapFont* Address() const;
	  TInt Duplicate(TInt aHandle);
	  void Reset();
protected:
	RFbsSession* iFbs;
	CBitmapFont* iAddressPointer;
	TInt iHandle;
	TInt iServerHandle;
	};

 













class CFbsBitmap : public CBase
	{
	friend class TBitmapUtil;
	friend class CBitwiseBitmap;
	friend class CFbsBitmapAsyncStreamer;
public:
	  CFbsBitmap();
	  ~CFbsBitmap();
	  void Reset();
	  static TInt ScanLineLength(TInt aLength,TDisplayMode aDispMode);
	  TDisplayMode DisplayMode() const;
	  TDisplayMode InitialDisplayMode() const;
	  TInt SetDisplayMode(TDisplayMode aDisplayMode);
	  TInt Create(const TSize& aSizeInPixels,TDisplayMode aDispMode);
	  TInt Duplicate(TInt aHandle);
	  TBool IsRomBitmap() const;
	  void SetRomBitmapL(CBitwiseBitmap* aRomBitmapPointer,TInt& aBitmapSizeInBytes);
	  TInt Load(const TDesC& aFileName,TInt32 aId=0,TBool aShareIfLoaded=ETrue);
	  TInt Load(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	  TInt LoadAndCompress(const TDesC& aFileName,TInt32 aId=0,TBool aShareIfLoaded=ETrue);
	  TInt LoadAndCompress(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	  TInt Save(const TDesC& aFilename);
	  static void StoreL(const TDesC& aFilename,TInt aNumSources,const TDesC* aSources[],TInt32 aSourceIds[]);
      void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TDisplayMode aDispMode) const;
      void SetScanLine(TDes8& aBuf,TInt aY) const;
	  void GetVerticalScanLine(TDes8& aBuf,TInt aX,TDisplayMode aDispMode) const;
	  void GetVerticalScanLine(TDes8& aBuf,TInt aX,const TPoint& aDitherOffset,TDisplayMode aDispMode) const;
	  TInt Handle() const;
	  SEpocBitmapHeader Header() const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  void GetPixel(TRgb& aColor,const TPoint& aPixel) const;
	  TInt Resize(const TSize& aSizeInPixels);
	  TSize SizeInPixels() const;
	  TSize SizeInTwips() const;
	  void SetSizeInTwips(const MGraphicsDeviceMap* aMap);
	  void SetSizeInTwips(const TSize& aSizeInTwips);
	  void ExternalizeL(RWriteStream& aStream) const;
	  void ExternalizeRectangleL(RWriteStream& aStream,const TRect& aRect) const;
	  void InternalizeL(RReadStream& aStream);
	  TInt Compress();
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  static TBool IsFileInRom(const TDesC& aFilename,TUint32*& aWord);
	  TBool IsMonochrome() const;
	  TBool IsLargeBitmap() const;
	  void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  void SetPalette(CPalette* aPalette);
	  TInt GetPalette(CPalette*& aPalette) const;
	  TUint32* DataAddress() const;
	  TInt CreateHardwareBitmap(const TSize& aSizeInPixels,TDisplayMode aDispMode,TUid aCreatorUid);
	  TInt HardwareBitmapHandle() const;
	  void LockHeap(TBool aAlways=EFalse) const;
	  void UnlockHeap(TBool aAlways=EFalse) const;
	  void LockHeapLC(TBool aAlways=EFalse) const;
	  static void UnlockHeap(TAny* aFbsBitmap);
	  TBool IsCompressedInRAM() const;
	  TInt SwapWidthAndHeight();
protected:
      void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,const TPoint& aDitherOffset,TDisplayMode aDispMode) const;
	CBitwiseBitmap* Address() const;
	void DoSaveL(RFile& aFile);
	TInt DoCreate(const TSize& aSizeInPixels,TDisplayMode aDispMode,TUid aCreatorUid);
private:
	TInt DoLoad(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	TInt DoLoadAndCompress(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	TBool LoadShiftedRomBmpL(const TDesC& aFileName,TInt32 aId,TUint aFileOffset);
protected:
	RFbsSession* iFbs;
	CBitwiseBitmap* iAddressPointer;
	CBitwiseBitmap* iRomPointer;
	TInt iHandle;
	TInt iServerHandle;
	};

class CDirectFileStore;

 



class CFbsBitmapAsyncStreamer : public CBase
	{
public:
	enum TMode {ELoad, ESave};
public:
	  ~CFbsBitmapAsyncStreamer();
	  static CFbsBitmapAsyncStreamer* NewL(TMode aMode);
	  TInt Load(const TDesC& aFilename,TInt32 aId,TInt& aScanLines);
	  TBool LoadScanLinesL(TInt aNumberOfScanLines,CFbsBitmap*& aBitmap);
	  TInt Save(const TDesC& aFilename,CFbsBitmap* aBitmap,TInt32& aId,TInt& aScanLines);
	  TBool SaveScanLinesL(TInt aNumberOfScanLines);
private:
	CFbsBitmapAsyncStreamer(TMode aMode);
	void ConstructL();
	void DoLoadL(const TDesC& aFilename,TInt32 aId);
	void DoSaveL(RFile& aFile);
private:
	RFbsSession* iFbs;
	RStoreReadStream iReadStream;
	RStoreWriteStream iWriteStream;
	TStreamId iId;
	CDirectFileStore* iStore;
	TInt iCurrentScanLine;
	TUint32* iScanLineBase;
	CFbsBitmap* iBitmap;
	SEpocBitmapHeader iHeader;
	TDisplayMode iDispMode;
	TMode iMode;
	};


 

























class TBitmapUtil
	{
public:
	  void Begin(const TPoint& aPosition);
	  void Begin(const TPoint& aPosition,const TBitmapUtil& aUtil);
	  void End();
	  TBitmapUtil(CFbsBitmap* aBitmap);
	  TUint32 GetPixel() const;
	  void SetPixel(TUint32 aValue);
	  void SetPixel(const TBitmapUtil& aSource);
	  void SetPos(const TPoint& aPosition);
	  void DecXPos();
	  void DecYPos();
	  void IncXPos();
	  void IncYPos();
private:
	void DoBegin(const TPoint& aPosition,const TBitmapUtil* aUtil);
private:
	CFbsBitmap* iFbsBitmap;
	TUint32* iWordPos;
	TUint32* iMinWordPos;
	TUint32* iMaxWordPos;
	TInt iBpp;
	TInt iPixelShift;
	TInt iBitShift;
	TUint32 iMask;
	TInt iScanlineWordLength;
	TBool iHeapLocked;
	};

class TFontInfo;

 




class CFbsTypefaceStore : public CTypefaceStore
	{
public:
	  static CFbsTypefaceStore* NewL(CGraphicsDevice* aDevice);
	  ~CFbsTypefaceStore();
	  TInt AddFile(const TDesC& aName,TInt& aId);
	  TInt InstallFile(const TDesC& aName,TInt& aId);
	  void RemoveFile(TInt aId=0);
	  virtual TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec);
 	  TInt GetFontById(CFont *&aFont,TUid aUid,const TAlgStyle& aAlgStyle);
	  virtual TInt NumTypefaces() const;
	  virtual void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const;
	  virtual TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TGlyphBitmapType DefaultBitmapType() const;
	  void SetDefaultBitmapType(TGlyphBitmapType aType) const;
	  void SetFontNameAliasL(const TDesC& aFontAlias,const TDesC& aFontName) const;
	  static void RemoveFontFileLocksL();  
	  static void RemoveFontFileLocksL(const TDesC& aDrive, TBool aAllFonts);  
	  static void RemoveFontFileLocksL(const TDesC& aFileName);  
private:
	CFbsTypefaceStore(CGraphicsDevice* aDevice);
	TInt CreateFont(CFont*& aFont,const TFontInfo& aFontInfo);
	TInt FontHeight(TInt aTypefaceIndex,TInt aHeightIndex,TInt aMessage) const;
	void SetSize() const;
	TInt GetNearestFontInTwipsL(CFont*& aFont,const TFontSpec& aFontSpec);
private:
	RFbsSession* iFbs;
	CGraphicsDevice* iDevice;
	CFontCache* iTwipsCache;
	};

class CDitherColor256;

 





class CFbsColor256BitmapUtil : public CBase
	{
public:
	 
	enum TDither
		{
		 
		ENoDither,
		 
		EFloydSteinberg
		};
public:

	  static CFbsColor256BitmapUtil* NewL(const CPalette* aPalette);

	  TInt CopyBitmap(CFbsBitmap* aColor256Destination,CFbsBitmap* aSource,TDither aDither=ENoDither);

	~CFbsColor256BitmapUtil();
private:
	CFbsColor256BitmapUtil();
private:
	TColor256Util* iColor256Util;
	CDitherColor256* iDither;
	};


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitbase.h" 1
 
 
 
 






 


class TSpriteBase
	{
public:
	virtual void Hide(const TRect& aRect,const TRegion* aRegion)=0;
	virtual void Reveal(const TRect& aRect,const TRegion* aRegion)=0;
	};



# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitstd.h" 1
 
 
 
 









 



class CFbsBitGcFont : public CFbsFont
	{
public:
	  CFbsBitGcFont();
	  virtual ~CFbsBitGcFont();
	  CBitmapFont* Address() const;
	  TInt Duplicate(TInt aHandle);
	  void Reset();
	  void operator=(const CFbsBitGcFont& aFont);
protected:
	TBool iCopy;
	};


 




class CFbsBitGcBitmap : public CFbsBitmap

	{
public:
	  CBitwiseBitmap* Address() const;
	  void LockHeap() const;
	  void UnlockHeap() const;
	};

 



class TEllipse
	{
public:
	enum TEllipseStatus
		{
		EInitialised,
		EFirstSector,
		ESecondSector,
		EComplete,
		ELine
		};
public:
	  void Construct(const TRect& aRect);
	  TBool SingleStep(TPoint& aTopLeft,TPoint& aTopRight,TPoint& aBottomLeft,TPoint& aBottomRight);
	  TBool NextStep(TPoint& aTopLeft,TPoint& aTopRight,TPoint& aBottomLeft,TPoint& aBottomRight);
	  TPoint Intersection(const TRect& aRect,const TPoint& aPoint);
protected:
	  TBool Output(TPoint& aTopLeft,TPoint& aTopRight,TPoint& aBottomLeft,TPoint& aBottomRight);
protected:
	TEllipseStatus iStatus;
	TInt iA;
	TInt iB;
	TInt64 iASquared;
	TInt64 iBSquared;
	TInt64 iASquBSqu;
	TInt iX;
	TInt iY;
	TInt iXAdj;
	TInt iYAdj;
	TPoint iOffset;
	TInt64 iD1;
	TInt64 iD2;
	};

 



class CPolygonFiller : public CBase

	{
public:
	enum TUsage
		{
		EGetAllPixelRunsSequentially,
		EGetPixelRunsSequentiallyForSpecifiedScanLines
		};
public:
	  CPolygonFiller();
	  ~CPolygonFiller();
	  void Construct(const CArrayFix<TPoint>* aPointArray,CGraphicsContext::TFillRule aFillRule,TUsage aUsage=EGetAllPixelRunsSequentially);  
	  void Construct(const TPoint* aPointList,TInt aNumPoints, CGraphicsContext::TFillRule aFillRule, TUsage aUsage=EGetAllPixelRunsSequentially);  
	  void Reset();
	  void GetNextPixelRun(TBool& aExists, TInt& aScanLine, TInt& aStart, TInt& aEnd);
	  void GetNextPixelRunOnSpecifiedScanLine(TBool& aExists, TInt aScanLine, TInt& aStart, TInt& aEnd);
private:  
	struct SFastEdge
		{
		TInt upperVertex;
		TInt lowerVertex;
		TInt firstVertex;
		};
	struct SFastScanLineIntersection;
	struct SFastActiveEdge
		{
		SFastEdge* edgePtr;
		TLinearDDA lineGenerator;
		SFastScanLineIntersection* scanLineIntersectionPtr;
		};
	struct SFastScanLineIntersection
		{
		TInt firstPixel;
		TInt lastPixel;
		SFastActiveEdge* activeEdgePtr;
		};
private:  
	struct SSlowScanLineIntersection
		{
		TInt firstPixel;
		TInt lastPixel;
		TInt firstVertexOfEdge;
		};
private:  
	struct SFastData
		{
		TPoint* vertexList;
		SFastEdge* edgeList;
		SFastActiveEdge* activeEdgeList;
		SFastScanLineIntersection* scanLineIntersectionList;
		TInt numActiveEdges;
		TInt numScanLineIntersections;
		TInt nextEdgeToActivate;
		};
	struct SSlowData
		{
		enum {EStoreSize=8};
		TLinearDDA lineGenerator;
		SSlowScanLineIntersection scanLineIntersectionList[EStoreSize];
		TInt numIntersectionsWithSameFirstPixelPreviouslyMet;
		TInt numIntersectionsWithSameFirstPixelMetThisTime;
		TInt numScanLineIntersections;
		TBool scanLineComplete;
		TInt firstPixelOfLastIntersectionInPrevBuffer;
		};
private:
	void Construct(CGraphicsContext::TFillRule aFillRule,TUsage aUsage);
	void FastHandleVertexIntersection(TInt& aCurrentActiveEdge, TBool aIsLowerVertex);
	void SetFastIntersection(SFastActiveEdge& aActiveEdge, SFastScanLineIntersection& aScanLineIntersection);
	void SlowHandleVertexIntersection(SSlowScanLineIntersection& aScanLineIntersection, TInt& aVertexStartingCurrentEdge,TBool aIsLowerVertex);
	void JumpToCurrentScanLine(TLinearDDA& aLineGenerator, const TPoint& aUpper, const TPoint& aLower,TPoint& aStartPos, TPoint& aEndPos) const;
	const TPoint& Point(TInt aIndex);
private:
	const CArrayFix<TPoint>* iPointArray;  
	const TPoint* iPointList;  
	CGraphicsContext::TFillRule iFillRule;
	TBool iUseFastAlgorithm;
	TInt iNumVertexes;
	TBool iToggler;  
	TInt iNestingLevel;  
	TInt iScanLineIntersection;
	TInt iRightMostPixelOnScanLine;
	TInt iFirstVertex;
	TBool iPolygonIsAllHorizontal;
	TInt iFirstScanLine;
	TInt iLastScanLine;
	TInt iCurrentScanLine;
	SFastData iFastData;
	SSlowData iSlowData;
private:
	friend class TCompareEdgesUpperY;
	friend class TCompareActiveEdgesFirstVertex;
	friend class TCompareScanLineIntersectionsFirstPixel;
	friend class TSwapEdges;
	friend class TSwapActiveEdges;
	friend class TSwapScanLineIntersections;
	};

class CFbsDevice;
class TOpenFontCharMetrics;
class CGraphicsAccelerator;

 







class CFbsBitGc : public CBitmapContext
	{
public:


 
	enum TGraphicsOrientation
		{
	 
		EGraphicsOrientationNormal,
	 
		EGraphicsOrientationRotated90,
	 
		EGraphicsOrientationRotated180,
	 
		EGraphicsOrientationRotated270
		};
public:
	  static CFbsBitGc* NewL();
	  virtual ~CFbsBitGc();
	  void Activate(CFbsDevice* aDevice);
	  void ActivateNoJustAutoUpdate(CFbsDevice* aDevice);
	  void BitBlt(const TPoint& aPoint,const CFbsBitGc& aGc);
	  void BitBlt(const TPoint& aPoint,const CFbsBitGc& aGc,const TRect& aSourceRect);
	  void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap);
	  void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect);
	  void BitBltMasked(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect,const CFbsBitmap* aMaskBitmap,TBool aInvertMask);
	  void CancelClipping();
	  void CancelClippingRect();
	  void CancelClippingRegion();
	  void Clear();
	  void Clear(const TRect& aRect);
	  void CopyRect(const TPoint& aOffset,const TRect& aRect);
	  void CopySettings(const CFbsBitGc& aGc);
	  CGraphicsDevice* Device() const;
	  void DiscardBrushPattern();
	  void DiscardFont();
	  void DrawArc(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd);
	  void DrawPie(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd);
	  void DrawBitmap(const TPoint& aTopLeft,const CFbsBitmap* aSource);
	  void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource);
	  void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource,const TRect& aSourceRect);
	  void DrawRoundRect(const TRect& aRect,const TSize& aEllipse);
	  void DrawPolyLine(const CArrayFix<TPoint>* aPointList);
	  void DrawPolyLineNoEndPoint(const CArrayFix<TPoint>* aPointList);
	  void DrawPolyLine(const TPoint* aPointList,TInt aNumPoints);
	  void DrawPolyLineNoEndPoint(const TPoint* aPointList,TInt aNumPoints);
	  TInt DrawPolygon(const CArrayFix<TPoint>* aPointList,CGraphicsContext::TFillRule aFillRule=CGraphicsContext::EAlternate);
	  TInt DrawPolygon(const TPoint* aPointList,TInt aNumPoints,CGraphicsContext::TFillRule aFillRule=CGraphicsContext::EAlternate);
	  void DrawEllipse(const TRect& aRect);
	  void DrawLine(const TPoint& aStart,const TPoint& aEnd);
	  void DrawLineTo(const TPoint& aPoint);
	  void DrawLineBy(const TPoint& aVector);
	  void DrawRect(const TRect& aRect);
	  void DrawText(const TDesC& aText);
	  void DrawText(const TDesC& aText,const TPoint& aPosition);
	  void DrawText(const TDesC& aText,const TRect& aBox);
	  void DrawText(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TTextAlign aHrz=ELeft,TInt aMargin=0);
	  void DrawText(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TInt aTextWidth,TTextAlign aHrz=ELeft,TInt aMargin=0);
	  void DrawTextVertical(const TDesC& aText,TBool aUp);
	  void DrawTextVertical(const TDesC& aText,const TPoint& aPosition,TBool aUp);
	  void DrawTextVertical(const TDesC& aText,const TRect& aBox,TBool aUp);
	  void DrawTextVertical(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TBool aUp,TTextAlign aVert=ELeft,TInt aMargin=0);
	  void DrawTextVertical(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TInt aTextWidth,TBool aUp,TTextAlign aVert=ELeft,TInt aMargin=0);
	  void MapColors(const TRect& aRect,const TRgb* aColors,TInt aNumPairs=2,TBool aMapForwards=ETrue);
	  void MoveTo(const TPoint& aPoint);
	  void MoveBy(const TPoint& aVector);
	  void OrientationsAvailable(TBool aOrientation[4]);
	  void Plot(const TPoint& aPoint);
	  void RectDrawnTo(TRect& aRect);
	  void Reset();
	  void Resized();
	  void SetBrushColor(const TRgb& aColor);
	  void SetBrushOrigin(const TPoint& aOrigin);
	  void SetBrushStyle(TBrushStyle aBrushStyle);
	  void SetClippingRegion(const TRegion* aRegion);
	  void SetClippingRect(const TRect& aRect);
	  void SetDitherOrigin(const TPoint& aPoint);
	  void SetDrawMode(TDrawMode);
	  void SetOrigin(const TPoint& aPoint=TPoint(0,0));
	  void SetPenColor(const TRgb& aColor);
	  void SetPenStyle(TPenStyle);
	  void SetPenSize(const TSize& aSize);
	  void SetCharJustification(TInt aExcessWidth,TInt aNumGaps);
	  void SetWordJustification(TInt aExcessWidth,TInt aNumChars);
	  void SetUnderlineStyle(TFontUnderline aUnderlineStyle);
	  void SetUserDisplayMode(TDisplayMode aDisplayMode);
	  void SetStrikethroughStyle(TFontStrikethrough aStrikethroughStyle);
	  void SetShadowMode(TBool aShadowMode = EFalse);
	inline void SetFadeMode(TBool aFadeMode = EFalse);			 
	inline void SetFadingParameters(TUint8 aBlackMap = 0);		 
	  void SetFaded(TBool aFaded);		 
	  void SetFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap);	 
	  TBool SetOrientation(TGraphicsOrientation aOrientation);
	  void ShadowArea(const TRegion* aRegion);
	  void FadeArea(const TRegion* aRegion);
	  void UpdateJustification(const TDesC& aText);
	  void UpdateJustificationVertical(const TDesC& aText,TBool aUp);
	  void UseBrushPattern(const CFbsBitmap* aBitmap);
	  TInt UseBrushPattern(TInt aFbsBitmapHandle);
	  void UseFont(const CFont* aFont);
	  TInt UseFont(TInt aFontHandle);
	  void UseFontNoDuplicate(const CFbsBitGcFont* aFont);
	  TBool IsBrushPatternUsed() const;
	  TBool IsFontUsed() const;
	inline static TInt16 Load16(const TUint8* aPtr) { return TInt16(aPtr[0]+(aPtr[1]<<8)); }
	  TInt AlphaBlendBitmaps(const TPoint& aDestPt,
									const CFbsBitmap* aSrcBmp1,
									const CFbsBitmap* aSrcBmp2,
									const TRect& aSrcRect1,
									const TPoint& aSrcPt2,
									const CFbsBitmap* aAlphaBmp,
									const TPoint& aAlphaPt);
	  TInt AlphaBlendBitmaps(const TPoint& aDestPt,
									const CFbsBitmap* aSrcBmp,
									const TRect& aSrcRect,
									const CFbsBitmap* aAlphaBmp,
									const TPoint& aAlphaPt);
	  void ExternalizeL(RWriteStream& aWriteStream);
	  void InternalizeL(RReadStream& aReadStream);
private:
	CFbsBitGc();
	void AddRect(const TRect& aRect);
	void AnalyseEllipse(const TRect& rc,TPoint& srad,TPoint& erad,TPoint& center,TInt& startq,TInt& endq,TBool* quads);
	void BitMultiply(TUint32* aBinaryDataPtr,TInt aBitLength,TInt aMultiplier);
	void CheckDevice() const;
	TBool CheckDevice(const TRect& aRect) const;
	TUint32* ClipBinaryArray(TUint32* aArray,TUint32* aArrayLimit,TInt aArrayWordWd,TInt& aDataWd,TInt& aDataHt,TPoint& aPos);
	void ClipFillLine(TPoint,TPoint);
	void CopyCharWord(TUint32* aBinaryDataPtr,const TUint8* aData,TInt aBitShift);
	void CopyCharLine(TUint32* aBinaryDataPtr,TInt aBufferWords,const TUint8* aData,TInt aBitShift,TInt aCharWidth);
	void DrawText(const TDesC& aText,const TPoint& aPosition,TTextAlign aAlignment,
				  CFont::TTextDirection aDirection,const TRect* aBox = 0L );
	void DoBitBlt(const TPoint& aDest,CFbsDevice* aDevice,const TRect& aSourceRect);
	void DoBitBlt(const TPoint& aDest,CBitwiseBitmap* aBitmap,TUint32* aBase,const TRect& aSourceRect);
	void DoBitBltMasked(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedFlicker(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedNonFlicker(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedNonFlickerSolid(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedNonFlickerPatterned(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltAlpha(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltAlpha(const TPoint& aDestPt,
					   const CBitwiseBitmap* aSrcBmp1,
					   TUint32* aSrcBmpDataAddr1,
					   const CBitwiseBitmap* aSrcBmp2,
					   TUint32* aSrcBmpDataAddr2,
					   const CBitwiseBitmap* aAlphaBmp,
					   TUint32* aAlphaBmpDataAddr,
					   const TRect& aSrcRect1,
					   const TPoint& aSrcPt2,
					   const TPoint& aAlphaPt,
					   TInt aShadowMode);
	void DoCopyRect(const TPoint&,const TRect&);
	void DoDrawBitmap(const TRect&,CBitwiseBitmap*,TUint32* aBase,const TRect&,const TPoint& aDitherOrigin);
	void DoDrawLine(TPoint aStart,TPoint aEnd,TBool aDrawStartPoint);
	void DoDrawDottedWideLine(const TPoint& pt1,const TPoint& pt2,TBool drawstart,const TRect& screenrect);
	void DoDrawSolidWideLine(const TPoint& pt1,const TPoint& pt2,TBool drawstart,const TRect& screenrect);
	void DoDrawText(CFont::TPositionParam& aParam);
	void DoDrawCharacter(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData);
	void DoDrawTextEx(CFont::TPositionParam& aParam,const CBitmapFont* font);
	void DoDrawCharacterEx(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent);
	void DoDrawCharacterAntiAliased(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData);
	void DoDrawTextLarge(CFont::TPositionParam& aParam,const CBitmapFont* font);
	void DoDrawCharacterLarge(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthFactor,TInt aHeightFactor);
	void DoDrawCharacterExLarge(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthFactor,TInt aHeightFactor);
	void DoDrawCharacterMultiplied(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthMultiplier,TInt aHeightMultiplier);
	void DoDrawTextVertical(CFont::TPositionParam& aParam,const CBitmapFont* font,TBool aUp);
	void DoDrawCharacterVertical(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthFactor,TInt aHeightFactor,TBool aUp);
	void DoDrawCharacterVerticalAntiAliased(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,TBool aUp);
	void DoPlot(const TPoint& pt);
	void EllipseFill(const TRect& aRect);
	void EllipseOutline(const TRect& aRect);
	void EllipseOutlineWide(const TRect& aRect);
	void GetUnderlineMetrics(TInt& aTop,TInt& aBottom);
	void GetStrikethroughMetrics(TInt& aTop,TInt& aBottom);
	void OutputCharLine(TPoint aPrintPos,TUint32* aBuffer,TInt aDataLength,TInt aNum,TBool aBold,TInt aWidthFactor,TInt aHeightFactor);
	void OutputCharLineMultiplied(TPoint aPrintPos,TUint32* aBuffer,TInt aDataLength,TInt aNum,TBool aBold,TInt aWidthMultiplier,TInt aHeightMultiplier);
	void OutputCharLineVertical(TPoint aPrintPos,TUint32* aBuffer,TInt aDataLength,TInt aNum,TBool aBold,TInt aWidthFactor,TInt aHeightFactor,TBool aUp);
	void PenAllocate();
	void PenDrawClipped(TPoint aPoint);
	void PenDrawDeferred(TPoint aPoint,TInt* aArray,TInt aFirstElement);
	void PieArcOutline(const TRect& aRect,const TPoint& aStartRadius,const TPoint& aEndRadius,TBool aDoPie);
	void PieFill(const TRect& aRect,const TPoint& aStartRadius,const TPoint& aEndRadius);
	void PieShell(const TRect& ellrect,const TPoint& startradius,const TPoint& endradius,TBool quads[5],TInt startquad,TInt endquad);
	void PieTriangles(TBool aInside,const TPoint& aStart,const TPoint& aEnd);
	void PieSliver(const TRect& ellrect,const TPoint& startradius,const TPoint& endradius,TInt quad);
	void PolyFill(const CArrayFix<TPoint>* aPointList,TFillRule aFillRule);
	void PolyFillLarge(const CArrayFix<TPoint>* aPointList,TFillRule aFillRule);
	void PolyFill(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule);
	void PolyFillLarge(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule);
	void PolyOutline(const CArrayFix<TPoint>* aPointList);
	void PolyOutline(const TPoint* aPointList,TInt aNumPoints);
	void RectFill(const TRect& aRect);
	void RoundRectFill(const TRect& aRect,TSize aSize);
	void RoundRectOutline(const TRect& aRect,TSize aSize);
	void SetupDevice() const;
	void ShadowFadeArea(const TRegion* aRegion,TInt8 aShadowMode);
	TBool UserClipRect(TRect& aRect);
	CGraphicsAccelerator* GraphicsAccelerator();
private:
	CFbsBitGcBitmap iBrushBitmap;
	TBool iBrushUsed;
	TRgb iBrushColor;
	TPoint iBrushOrigin;
	TBrushStyle iBrushStyle;
	TRect iClipRect;
	TRegionFix<1> iDefaultRegion;
	const TRegion* iDefaultRegionPtr;
	TRect iUserClipRect;
	CFbsDevice* iDevice;
	TPoint iDitherOrigin;
	TInt iDotLength;
	TInt iDotMask;
	TInt iDotParam;
	TInt iDotDirection;
	TDrawMode iDrawMode;
	TRect iDrawnTo;
	CFbsBitGcFont iFont;
	TInt iCharJustExcess;
	TInt iCharJustNum;
	TInt iWordJustExcess;
	TInt iWordJustNum;
	TPoint iLastPrintPosition;
	TPoint iLinePosition;
	TPoint iOrigin;
	TInt* iPenArray;
	TRgb iPenColor;
	TPenStyle iPenStyle;
	TSize iPenSize;
	TInt8 iShadowMode;
	TInt8 iAutoUpdateJustification;
	TUint8 iFadeBlackMap;
	TUint8 iFadeWhiteMap;
	TFontStrikethrough iStrikethrough;
	TFontUnderline iUnderline;
	TDisplayMode iUserDisplayMode;
	};

inline void CFbsBitGc::SetFadeMode(TBool aFadeMode  )
	{SetFaded(aFadeMode);}
inline void CFbsBitGc::SetFadingParameters(TUint8 aBlackMap  )
	{SetFadingParameters(aBlackMap,255);}		 



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/graphicsaccelerator.h" 1
 
 
 
 







 
 
 

 
class CFbsBitmap;
class TAcceleratedBitmapSpec;

 











class TAcceleratedBitmapInfo
	{
public:

     
	TDisplayMode	iDisplayMode;

	 
	TUint8*			iAddress;
	
	 
	TSize			iSize;
	
	 
	TInt			iLinePitch;
	
	 
	TInt			iPixelShift;
	
	 


	TUint8*			iPhysicalAddress;
	};

 











class RHardwareBitmap
	{
	friend class CBitwiseBitmap;
	friend class CFbsScreenDevice;
public:

     
	inline RHardwareBitmap();

     
	inline RHardwareBitmap(TInt aHandle);

	  TInt GetInfo(TAcceleratedBitmapInfo& aInfo) const;
private:
	  TInt SetAsScreenReference(TInt aScreen=-1);
	  TInt Create(TDisplayMode aDisplayMode, TSize aSize, TUid aCreatorUid);
	  void Destroy();
public:
	
	 

	TInt iHandle;	 
	};

	 
inline RHardwareBitmap::RHardwareBitmap()
	: iHandle(0)
	{}

	 

inline RHardwareBitmap::RHardwareBitmap(TInt aHandle)
	: iHandle(aHandle)
	{}

 









class TBitmapLockCount
	{
	friend class TAcceleratedBitmapSpec;
public:
	
	 
	inline TBitmapLockCount() : iCount(0) {}
private:
	inline TInt Inc() { return iCount++; }
	inline TInt Dec() { return --iCount; }
private:
	TInt iCount;
	};


 









class TAcceleratedBitmapSpec
	{
public:
	 
	inline TAcceleratedBitmapSpec();
	  TAcceleratedBitmapSpec(CFbsBitmap* aBitmap);
	  TAcceleratedBitmapSpec(RHardwareBitmap aBitmap);
	 
	
	  TInt GetInfo(TAcceleratedBitmapInfo& aInfo) const;
	inline void Lock(TBitmapLockCount& aCount);
	inline void Lock(TBitmapLockCount& aCount,TAcceleratedBitmapInfo& aInfo);
	inline void	Unlock(TBitmapLockCount& aCount);

	 
	 




	enum TAcceleratedBitmapType
		{
	 
		ENoBitmap,
	
	 


		EFbsBitmap,
	
	 


		EHardwareBitmap,
		};
	enum TAcceleratedBitmapLock
		{
		EBitmapIsStatic,
		EBitmapNeedsLocking,
		};
	 
	inline TAcceleratedBitmapType	Type() const;
	inline TInt						Handle() const;
private:
	  void DoLock(TBitmapLockCount& aCount);
	  void DoLock(TBitmapLockCount& aCount,TAcceleratedBitmapInfo& aInfo);
	  void DoUnlock(TBitmapLockCount& aCount);
private:
	TUint8	iType;			 
	TUint8	iLockStatus;	 
	TUint8	iSpare1;
	TUint8	iSpare2;
	TInt	iHandle;
	};

	 

inline TAcceleratedBitmapSpec::TAcceleratedBitmapSpec()
	: iType(ENoBitmap), iLockStatus(EBitmapIsStatic)
	{}

	 









inline void TAcceleratedBitmapSpec::Lock(TBitmapLockCount& aCount)
	{ if(iLockStatus==EBitmapNeedsLocking) DoLock(aCount); }

	 












inline void TAcceleratedBitmapSpec::Lock(TBitmapLockCount& aCount,TAcceleratedBitmapInfo& aInfo)
	{ if(iLockStatus==EBitmapNeedsLocking) DoLock(aCount,aInfo); }

	 







inline void	TAcceleratedBitmapSpec::Unlock(TBitmapLockCount& aCount)
	{ if(iLockStatus==EBitmapNeedsLocking) DoUnlock(aCount); }

	 


inline TAcceleratedBitmapSpec::TAcceleratedBitmapType TAcceleratedBitmapSpec::Type() const
	{ return (TAcceleratedBitmapSpec::TAcceleratedBitmapType)iType; }

	 


inline TInt TAcceleratedBitmapSpec::Handle() const
	{ return iHandle; }

 
 
 


 










enum TTransparencyType
	{
	
	 
	ETransparentPixelZero,
	
	 

	ETransparentPixel,
	
	 

	ETransparentColor,
	
	 


	ETransparent1555,
	};

 














class TGraphicsAcceleratorCaps
	{
public:
     


	enum TClipCaps	 
		{
		EClipToBitmap = 1,	 
	
	     



		EClipping = 2		 
		};

 


	enum TMaskBitmapCaps	 
		{
	 
		EMaskBitmapNone = 0,
	
	 
		EMaskBitmapAnyDisplayMode,
	
	 
		EMaskBitmapMatchingDisplayMode,
	
	 
		EMaskBitmapGray2,
		};

 


	enum TAlphaChannelCaps	 
    	{
	 

		EAlpha4444 = 1,	 
	
	 

		EAlpha8888 = 2,  
	
	 

		EAlpha1555 = 4,  
		};

 


	enum TAlphaBitmapCaps	 
    	{
	 

		EAlphaBitmapGray256 = 1,
	
	 


		EAlphaBitmapColor16M = 2,
	
	 
		EAlphaBitmapMatchingMode = 4,	 
		};

 





	enum TPatternSizeCaps	 
		{
	 
		EPatternSizeAny = 0xFFFFFFFF,
		};

 


	enum TPatternCaps	 
		{
	 
		EPatternAnyDisplayMode = 1,			 
	
	 
		EPatternMatchingDisplayMode = 2,	 
	
	 
		EPatternMustBeSquare = 4,			 
		};
		
 


	enum TPolygonCaps	 
		{
	 
		EPolygonFillAlternate = 1,
	
	 


		EPolygonFillWinding = 2,
		};

	 
	TInt			iStructureSize;	 
	
	 
	TInt			iVersion;		 
	
	 


	TUid			iVendorUid;		 
	
	 





	TUint			iDisplayModes;	 
	
	 



	TUint			iClipping;		 
	
	 



	TMaskBitmapCaps	iMaskType;		 
	
	 



	TUint			iTransparency;	 
	
	 



	TUint			iAlphaChannel;	 
	
	 



	TUint			iAlphaBitmap;	 
	
	 








	TUint			iPatternSizes;	 
	
	 



	TUint			iPattern;		 
	
	 



	TUint			iPolygon;		 
	
	 
	TUint			iReserved[4];	 
	};


 
 
 

 











class TGraphicsOperation
	{
public:
	enum TGopFunction
		{								 

		EFilledRect,					 
		EFilledRectUsingDrawMode,		 
		EFilledRectWithPattern,			 
		EInvertRect,					 
		EFadeRect,						 

		EBitBlt,						 
		EBitBltMasked,					 
		EBitBltTransparent,				 
		EBitBltAlphaChannel,			 
		EBitBltAlphaBitmap,				 

		EScaledBitBlt,					 
		EScaledBitBltMasked,			 
		EScaledBitBltTransparent,		 
		EScaledBitBltAlphaChannel,		 
		EScaledBitBltAlphaBitmap,		 

		EFilledPolygon,					 
		EFilledPolygonWithPattern,		 
		};
public:
	 
	inline TGopFunction Function() const	{ return iFunction; }
	inline TInt Size() const				{ return iSize; }
	 
	inline TGraphicsOperation* Next() const;
	inline void Append(TInt aNumBytes,TAny* aData);
protected:
	inline TGraphicsOperation(TGopFunction aFunction, TInt aArgSize);
	inline TGraphicsOperation() {}
protected:
	TGopFunction iFunction;
	TInt iSize;   
	};

inline TGraphicsOperation::TGraphicsOperation(TGopFunction aFunction, TInt aSize)
	: iFunction(aFunction) , iSize(aSize) {}

inline TGraphicsOperation* TGraphicsOperation::Next() const
	{ return (TGraphicsOperation*)((TUint8*)this+iSize); }

inline void TGraphicsOperation::Append(TInt aNumBytes,TAny* aData)
	{
	Mem::Copy(Next(),aData,aNumBytes);
	iSize += aNumBytes;
	}


 
 
 

 











class CGraphicsAccelerator : public CBase
	{
public:
	 
	
	 


	virtual const TGraphicsAcceleratorCaps* Capabilities() = 0;

	 
	
	 






	virtual TInt Operation(const TGraphicsOperation& aOperation) = 0;
	
	 










	virtual TInt Operation(const TGraphicsOperation& aOperation,TInt aNumClipRects,TRect* aClipRects) = 0;
	
	 
	 
	
	 

















	virtual TInt Operation(TDes8& aBuffer) = 0;
	
	 




















	virtual TInt Operation(TDes8& aBuffer,TInt aNumClipRects,TRect* aClipRects) = 0;
public:
	 
	virtual void Reserved_1() = 0;
	virtual void Reserved_2() = 0;
	virtual void Reserved_3() = 0;
	virtual void Reserved_4() = 0;
	};



 









class CSoftwareGraphicsAccelerator : public CGraphicsAccelerator
	{
public:
	 
	  static CSoftwareGraphicsAccelerator* NewL(CFbsBitmap* aBitmap);

	 
	  static const TGraphicsAcceleratorCaps* GenericCapabilities();
public:
	 
	virtual const TGraphicsAcceleratorCaps* Capabilities() = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation) = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation,TInt aNumClipRects,TRect* aClipRects) = 0;
	virtual TInt Operation(TDes8& aBuffer) = 0;
	virtual TInt Operation(TDes8& aBuffer,TInt aNumClipRects,TRect* aClipRects) = 0;
	 
	virtual void Reserved_1() = 0;
	virtual void Reserved_2() = 0;
	virtual void Reserved_3() = 0;
	virtual void Reserved_4() = 0;
	};


 











class CHardwareGraphicsAccelerator : public CGraphicsAccelerator
	{
public:
	  static CHardwareGraphicsAccelerator* NewL(RHardwareBitmap aBitmap);
	  static const TGraphicsAcceleratorCaps* GenericCapabilities();
public:
	 
	virtual const TGraphicsAcceleratorCaps* Capabilities() = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation) = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation,TInt aNumClipRects,TRect* aClipRects) = 0;
	virtual TInt Operation(TDes8& aBuffer) = 0;
	virtual TInt Operation(TDes8& aBuffer,TInt aNumClipRects,TRect* aClipRects) = 0;
	 
	virtual void Reserved_1() = 0;
	virtual void Reserved_2() = 0;
	virtual void Reserved_3() = 0;
	virtual void Reserved_4() = 0;
	};

 
 
 

 















class TGopFillPattern
	{
public:
	
	 
	TAcceleratedBitmapSpec	iBitmap;
	
	 




	TPoint					iOrigin;
	};

 





















class TGopFadeParams	 
	{
public:
	
	 
	TInt iScale;
	
	 
	TInt iOffset;
	};

 













class TGopTransparency
	{
public:
	
	 


	inline TGopTransparency(TTransparencyType aType)	: iType(aType), iParam(0) {}
	
	 




	inline TGopTransparency(TInt aPixelValue)			: iType(ETransparentPixel), iParam(aPixelValue) {}
	
	 



	inline TGopTransparency(TRgb aRgb)					: iType(ETransparentColor), iParam(aRgb.Value()) {}
	
	 



	inline TRgb Color()	const							{ return TRgb(iParam); }
	
	 




	inline TInt Pixel()	const							{ return iParam; }
public:
	
	 
	TTransparencyType	iType;
	
	 

	TUint32				iParam;
	};


 
 
 





 








class TGopFilledRect : public TGraphicsOperation
	{
public:
	 


	inline TGopFilledRect(const TRect& aRect,TRgb aColor)
			: TGraphicsOperation(EFilledRect,sizeof(*this)), iRect(aRect) , iColor(aColor) {}
public:
	
	 
	TRect	iRect;
	
	 
	TRgb	iColor;
	};

 











class TGopFilledRectUsingDrawMode : public TGraphicsOperation
	{
public:
	 



	inline TGopFilledRectUsingDrawMode(const TRect& aRect,TRgb aColor,CGraphicsContext::TDrawMode aDrawMode)
		: TGraphicsOperation(EFilledRectUsingDrawMode,sizeof(*this)), iRect(aRect) , iColor(aColor) , iDrawMode(aDrawMode) {}
public:
	
	 
	TRect						iRect;
	
	 
	TRgb						iColor;
	
	 
	CGraphicsContext::TDrawMode	iDrawMode;
	};

 








class TGopFilledRectWithPattern : public TGraphicsOperation
	{
public:
	 



	inline TGopFilledRectWithPattern(const TRect& aRect,TGopFillPattern aPattern)
		: TGraphicsOperation(EFilledRectWithPattern,sizeof(*this)), iRect(aRect) , iPattern(aPattern) {}
public:
	
	 
	TRect			iRect;
	
	 

	TGopFillPattern iPattern;
	};

 








class TGopInvertRect : public TGraphicsOperation
	{
public:
	 

	inline TGopInvertRect(const TRect& aRect)
		: TGraphicsOperation(EInvertRect,sizeof(*this)), iRect(aRect) {}
public:
	
	 
	TRect	iRect;
	};

 







class TGopFadeRect : public TGraphicsOperation
	{
public:
	 


	inline TGopFadeRect(const TRect& aRect, const TGopFadeParams aFade)
		: TGraphicsOperation(EFadeRect,sizeof(*this)), iRect(aRect), iFade(aFade) {}
public:
	
	 
	TRect			iRect;
	
	 
	TGopFadeParams	iFade;
	};

 









class TGopBitBlt : public TGraphicsOperation
	{
public:
	 






	inline TGopBitBlt(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EBitBlt,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 














class TGopBitBltMasked : public TGraphicsOperation
	{
public:
	 








	inline TGopBitBltMasked(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aMask)
		: TGraphicsOperation(EBitBltMasked,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iMask(aMask) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iMask;
	};

 











class TGopBitBltTransparent : public TGraphicsOperation
	{
public:
	 











	inline TGopBitBltTransparent(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TGopTransparency aTransparency)
		: TGraphicsOperation(EBitBltTransparent,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iTransparency(aTransparency) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TGopTransparency		iTransparency;
	};

 















class TGopBitBltAlphaChannel : public TGraphicsOperation
	{
public:
	 






	inline TGopBitBltAlphaChannel(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EBitBltAlphaChannel,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 
























class TGopBitBltAlphaBitmap : public TGraphicsOperation
	{
public:
	 








	inline TGopBitBltAlphaBitmap(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aAlphaBitmap)
		: TGraphicsOperation(EBitBltAlphaBitmap,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iAlphaBitmap(aAlphaBitmap) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iAlphaBitmap;
	};

 









class TGopScaledBitBlt : public TGraphicsOperation
	{
public:
	 







	inline TGopScaledBitBlt(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EScaledBitBlt,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 














class TGopScaledBitBltMasked : public TGraphicsOperation
	{
public:
	 









	inline TGopScaledBitBltMasked(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aMask)
		: TGraphicsOperation(EScaledBitBltMasked,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iMask(aMask) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iMask;
	};

 












class TGopScaledBitBltTransparent : public TGraphicsOperation
	{
public:
	 











	inline TGopScaledBitBltTransparent(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TGopTransparency aTransparency)
		: TGraphicsOperation(EScaledBitBltTransparent,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iTransparency(aTransparency) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TGopTransparency		iTransparency;
	};

 












class TGopScaledBitBltAlphaChannel : public TGraphicsOperation
	{
public:
	 








	inline TGopScaledBitBltAlphaChannel(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EScaledBitBltAlphaChannel,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 












class TGopScaledBitBltAlphaBitmap : public TGraphicsOperation
	{
public:
	 








	inline TGopScaledBitBltAlphaBitmap(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aAlphaBitmap)
		: TGraphicsOperation(EScaledBitBltAlphaBitmap,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iAlphaBitmap(aAlphaBitmap) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iAlphaBitmap;
	};

 










class TGopFilledPolygon : public TGraphicsOperation
	{
public:
	 




	inline TGopFilledPolygon(TRgb aColor, CGraphicsContext::TFillRule aFillRule)
		: TGraphicsOperation(EFilledPolygon,sizeof(*this)), iColor(aColor), iFillRule(aFillRule), iNumPoints(0) {}
	inline void AddPoints(TInt aNumPoints, TPoint* aPoints);
public:
	
	 
	TRgb						iColor;
	
	 


	CGraphicsContext::TFillRule iFillRule;
	
	 
	TInt						iNumPoints;
	};

 



inline void TGopFilledPolygon::AddPoints(TInt aNumPoints, TPoint* aPoints)
	{ Append(aNumPoints*sizeof(TPoint),aPoints); iNumPoints += aNumPoints; }

 











class TGopFilledPolygonWithPattern : public TGraphicsOperation
	{
public:
	inline TGopFilledPolygonWithPattern(TGopFillPattern aPattern, CGraphicsContext::TFillRule aFillRule)
		: TGraphicsOperation(EFilledPolygonWithPattern,sizeof(*this)), iPattern(aPattern), iFillRule(aFillRule), iNumPoints(0) {}
	inline void AddPoints(TInt aNumPoints, TPoint* aPoints);
public:
	
	 
	TGopFillPattern				iPattern;
	
	 


	CGraphicsContext::TFillRule iFillRule;
	
	 
	TInt						iNumPoints;
	};

 



inline void TGopFilledPolygonWithPattern::AddPoints(TInt aNumPoints, TPoint* aPoints)
	{ Append(aNumPoints*sizeof(TPoint),aPoints); iNumPoints += aNumPoints; }




# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2


 



enum {EScanBufSize=0x80}; 

class CFbsDrawDevice;


 


















class CFbsDevice : public CBitmapDevice
	{
	friend class CFbsBitGc;
public:
	  ~CFbsDevice();
	  TInt CreateContext(CFbsBitGc*& aGc);
	inline TInt CreateContext(CGraphicsContext*& aGc);
	  TDisplayMode DisplayMode() const;
	  TSize SizeInPixels() const;
	  TBool RectCompare(const TRect& aSourceRect,const CFbsDevice& aDevice,const TRect& aDeviceRect) const;
	  TInt AddFile(const TDesC& aName,TInt& aId);
	  void RemoveFile(TInt aId=0);
	  TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt GetFontById(CFont*& aFont,TUid aFileId,const TAlgStyle& aStyle);
	inline TInt GetNearestFontInTwips(CFbsFont*& aFont,const TFontSpec& aFontSpec);
	inline TInt GetNearestFontInPixels(CFbsFont*& aFont,const TFontSpec& aFontSpec);
	inline TInt GetFontById(CFbsFont*& aFont,TUid aFileId,const TAlgStyle& aStyle);
	  void ReleaseFont(CFont* aFont);
	  TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt NumTypefaces() const;
	  void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const;
	  TInt SetCustomPalette(const CPalette* aPalette);
	inline CGraphicsAccelerator* GraphicsAccelerator() const;
	inline CFbsBitGc::TGraphicsOrientation Orientation() const;
	  static TDisplayMode DisplayMode16M();
	  TInt SetScalingFactor(const TPoint& aOrigin,
								   TInt aFactorX, TInt aFactorY,
								   TInt aDivisorX, TInt aDivisorY);
	  void GetDrawRect(TRect& aRect) const;
protected:
	CFbsDevice();
	virtual void DrawingBegin(TBool=EFalse) {}
	virtual void DrawingEnd(TBool=EFalse) {}
	virtual void SetBits() {}
	virtual void CancelSprite() const {}
	virtual TSpriteBase* HideSprite() const {return(0L );}
	virtual TSpriteBase* HideSprite(const TRect&,const TRegion*) const {return(0L );}
	virtual void ShowSprite(TSpriteBase*) const {}
	virtual void ShowSprite(TSpriteBase*,const TRect&,const TRegion*) const {}
	TInt GetNearestFbsFont(CFbsFont*& aFont,const TFontSpec& aFontSpec);
	void DoGetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TDisplayMode aDispMode);
	void ReadLineDiffMode(TInt,TInt,TInt,TAny*,TDisplayMode) const;
	void TruncateRect(TRect& aRect);
	TBool SetOrientation(CFbsBitGc::TGraphicsOrientation aOrientation);
protected:
	CFbsDrawDevice* iDrawDevice;
	RFbsSession* iFbs;
	CFbsTypefaceStore* iTypefaceStore;
	TBool iLockHeap;
	TBool iScreenDevice;
	TUint8* iBitBltMaskedBuffer;
	CGraphicsAccelerator* iGraphicsAccelerator;
	CFbsBitGc::TGraphicsOrientation iOrientation;
	};

 






class CFbsScreenDevice : public CFbsDevice
	{
public:
	  static CFbsScreenDevice* NewL(const TDesC& aLibname,TDisplayMode aDispMode);
	  static CFbsScreenDevice* NewL(const TDesC& aLibname,TDisplayMode aDispMode, TRgb aWhite);
	  virtual ~CFbsScreenDevice();
	  void GetScanLine(TDes8& aBuf,const TPoint& aStartPixel,TInt aLength,TDisplayMode aDispMode) const;
	  void GetPixel(TRgb& aColor,const TPoint& aPixel) const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  void SetAutoUpdate(TBool aValue);
	  void DrawSpriteBegin();
	  void DrawSpriteEnd();
	  void CancelSprite() const;
	  TSpriteBase* HideSprite() const;
	  TSpriteBase* HideSprite(const TRect& aRect,const TRegion* aClippingRegion) const;
	  void ShowSprite(TSpriteBase* aSprite) const;
	  void ShowSprite(TSpriteBase* aSprite,const TRect& aRect,const TRegion* aClippingRegion) const;
	  void ChangeScreenDevice(CFbsScreenDevice* aOldDevice);
	  void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  void SetPalette(CPalette* aPalette);
	  TInt GetPalette(CPalette*& aPalette) const;
	  void Update();
	  void Update(const TRegion& aRegion);
	  TSize SizeInTwips() const;
	  RHardwareBitmap HardwareBitmap();
private:
	CFbsScreenDevice();
	void ConstructL(TDisplayMode aDispMode);
private:
	TSpriteBase* iSprite;
	TBool iSpriteDraw;
	};

 







class CFbsBitmapDevice : public CFbsDevice
	{
public:
	  static CFbsBitmapDevice* NewL(CFbsBitmap* aFbsBitmap);
	  static CFbsBitmapDevice* NewL(CFbsBitmap* aFbsBitmap,const TDesC& aLibname);
	  virtual ~CFbsBitmapDevice();
	  TInt Resize(const TSize& aSize);
	  virtual void GetScanLine(TDes8& aBuf,const TPoint& aStartPixel,TInt aLength,TDisplayMode iDispMode) const;
	  virtual void GetPixel(TRgb& aColor,const TPoint& aPixel) const;
	  virtual TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  virtual TInt VerticalPixelsToTwips(TInt aPixels) const;
	  virtual TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  virtual TInt VerticalTwipsToPixels(TInt aTwips) const;
	  virtual TSize SizeInTwips() const;
	  virtual void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  virtual void SetPalette(CPalette* aPalette);
	  virtual TInt GetPalette(CPalette*& aPalette) const;
	  virtual void DrawingBegin(TBool aAlways);
	  virtual void DrawingEnd(TBool aAlways);
	  TInt SwapWidthAndHeight();
private:
	CFbsBitmapDevice();
	virtual void SetBits();
	void ConstructL(CFbsBitmap* aFbsBitmap);
	void ConstructL(CFbsBitmap* aFbsBitmap,const TDesC& aLibname);
private:
	CFbsBitGcBitmap* iFbsBmp;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.inl" 1
 
 
 
 


 








TInt CFbsDevice::CreateContext(CGraphicsContext*& aGc)
	{
	return CreateContext((CFbsBitGc*&)aGc); 
	} 

 










TInt CFbsDevice::GetNearestFontInTwips(CFbsFont*& aFont,const TFontSpec& aFontSpec)
	{
	return GetNearestFontInTwips((CFont*&)aFont,aFontSpec); 
	} 

 










TInt CFbsDevice::GetNearestFontInPixels(CFbsFont*& aFont,const TFontSpec& aFontSpec)
	{
	return GetNearestFontInPixels((CFont*&)aFont,aFontSpec); 
	} 

 








TInt CFbsDevice::GetFontById(CFbsFont*& aFont,TUid aFileId,const TAlgStyle& aStyle)
	{
	return GetFontById((CFont*&)aFont,aFileId,aStyle); 
	} 

 




CGraphicsAccelerator* CFbsDevice::GraphicsAccelerator() const
	{
	return iGraphicsAccelerator;
	}


 


CFbsBitGc::TGraphicsOrientation CFbsDevice::Orientation() const
	{
	return iOrientation;
	}

# 179 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2


# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/w32std.h" 2






static const TLitC<sizeof(L"Wserv" )/2>  KWSERVThreadName ={sizeof(L"Wserv" )/2-1,L"Wserv" } ;

class RWindowBase;
class RWindow;
class RWsBuffer;

 




class TSizeMode
	{
public:
	inline TSizeMode(){}
	inline TSizeMode(TSize& aSize);
	static inline TInt ScaledCord(TInt aOrigin,TInt aScale);
	inline TPoint ScaledOrigin();
public:
	CFbsBitGc::TGraphicsOrientation iRotation;
	TPoint iOrigin;
	TSize iScreenSize;
	TSize iScreenTwipsSize;
	TUint iAlternativeRotations;
	TRect iPointerCursorArea;
	TSize iScreenScale;
	};

 












enum TScreenModeEnforcement
	{
	 





	ESizeEnforcementNone,
	 



	ESizeEnforcementPixelsAndRotation,
	 






	ESizeEnforcementPixelsTwipsAndRotation,
	};

struct TPixelsAndRotation
 







	{
	 
	TSize iPixelSize;
	 
	CFbsBitGc::TGraphicsOrientation iRotation;
	};

struct TPixelsTwipsAndRotation
 







	{
	 
	TSize iPixelSize;
	 
	TSize iTwipsSize;
	 
	CFbsBitGc::TGraphicsOrientation iRotation;
	};

 






enum {
	 
	KLogMessageLength=0x80
	};

 





typedef TBuf<KLogMessageLength> TLogMessageText;

 







enum
	{
	  
	KPasswordWindowGroupPriority=1000
	};

 













enum {
	 
	KOrdinalPositionSwitchToOwningWindow=0x80000000
	};

 










enum TCornerType
 
	{
	 
	EWindowCornerSquare,
	 
	EWindowCorner1,
	 


	EWindowCorner2,
	 



	EWindowCorner3,
	 




	EWindowCorner5,
	EWindowCornerRegion,		 
	 




	ECornerTypeMask=0xFFFF
	};

 







enum TCornerFlags
 
	{
	 
	EWindowCornerNotTL=0x10000,
	 
	EWindowCornerNotTR=0x20000,
	 
	EWindowCornerNotBL=0x40000,
	 
	EWindowCornerNotBR=0x80000,
	};

 




enum TWindowBackupType
	{
	 


	EWindowBackupAreaBehind=0x0001,
	 





	EWindowBackupFullScreen=0x0002,
	};

 







enum TEventCode
	{
	 


	EEventNull,
	 










	EEventKey,
	 



	EEventKeyUp,
	 



	EEventKeyDown,
	 






	EEventModifiersChanged,
	 







	EEventPointer,			 
	 





	EEventPointerEnter,
	 





	EEventPointerExit,
	 


	EEventPointerBufferReady,
	 

	EEventDragDrop,
	 


	EEventFocusLost,		 
	 


	EEventFocusGained,
	 




	EEventSwitchOn,
	 






	EEventPassword,
	 





	EEventWindowGroupsChanged,
	 







	EEventErrorMessage,		 
	 


	EEventMessageReady,
	EEventMarkInvalid,	 
	 








	EEventSwitchOff,
	 
	EEventKeySwitchOff,
	 



	EEventScreenDeviceChanged,  
	 


	EEventFocusGroupChanged,
	 




	EEventCaseOpened,
	 







	EEventCaseClosed,
	 






	EEventWindowGroupListChanged,
	 
	 





	EEventKeyRepeat=100,
	 
	 
	 






	EEventUser=1000,
	};


 




enum THotKey
	{
	 





	EHotKeyEnableLogging,
	 


	EHotKeyDisableLogging,
	 



	EHotKeyStateDump,
	 


	EHotKeyOfDeath,
	 




	EHotKeyShutDown,
	 






	EHotKeyHeapDump,
	 



	EHotKeyIncContrast,
	 



	EHotKeyDecContrast,
	 


	EHotKeyOff,
	 



	EHotKeyBacklightOn,
	 



	EHotKeyBacklightOff,
	 



	EHotKeyBacklightToggle,
	 



	EHotKeyScreenDimension0,
	 



	EHotKeyScreenDimension1,
	 
	EHotKeyScreenDimension2,
	 
	EHotKeyScreenDimension3,
	 








	EHotKeyCycleDisplaySize,
	 












	EHotKeyCycleOrientation,
	 



	EHotKeyIncBrightness,
	 


	EHotKeyDecBrightness,
	 



	EHotKeyFirstKeyType=EHotKeyEnableLogging,		 
	 



	EHotKeyLastKeyType=EHotKeyDecBrightness,		 
	};


 



enum TPasswordMode
	{
	 




	EPasswordCancel,
	 

	EPasswordNone,
	 



	EPasswordOnceADay,
	 
	EPasswordAlways,
	 

	EPasswordAlwaysTriggerNow,
	 

	EPasswordOnceADayTriggerNow,
	};

struct TTextCursor
 
















    {
	 
	 
	 
	 
	 
	 
	 





	enum ENamedCursors
		{
		 
		ETypeNone,
		 
		ETypeRectangle,
		 
		ETypeHollowRectangle,
		 



		ETypeFirst=ETypeRectangle,
		 



		ETypeLast=ETypeHollowRectangle,
		 


		ETypeLastBasic = 1000,
		};
	 
	typedef TInt EType;
	 


	enum EFlags
		{
		 
		EFlagNoFlash		= 0x00000001,
		 



		EFlagClipHorizontal	= 0x00000002,
		 





		EFlagClipVertical	= 0x00000004,
		 		
		EUserFlags			= 0x0000FFFF,
		 		
		EFlagClipped		= 0x00010000,
		 		
		EPrivateFlags		= 0xFFFF0000,
		};
	 


	TInt iType;
	 



    TInt iHeight;
	 
    TInt iAscent;
	 



    TInt iWidth;
	 


    TUint iFlags;
	 




	TRgb iColor;
    };

 







enum TSpriteFlags
	{
	 


	ESpriteFlash=0x1,
	 













	ESpriteNoChildClip=0x2,
	 




	ESpriteNoShadows=0x4,
	 
	ESpriteNonSystemFlags=0x0000FFFF,
	 
	ESpriteSystemFlags=	  0xFFFF0000,
	 
	ESpritePointer=0x10000,
	 
	ESpriteOOM=0x20000,
	 
	ESpriteDisabled=0x40000,
	 
	ESpriteActive=0x80000,
	};

struct TSpriteMember
 





	{
	 




	CFbsBitmap *iBitmap;
	 














	CFbsBitmap *iMaskBitmap;
	 

	TBool iInvertMask;
	 
	CGraphicsContext::TDrawMode iDrawMode;
	 



	TPoint iOffset;
	 



	TTimeIntervalMicroSeconds32 iInterval;
	};

 









enum TEventControl
	{
	 
	EEventControlAlways,
	 

	EEventControlOnlyWithKeyboardFocus,
	 

	EEventControlOnlyWhenVisible
	};

 









enum TPointerFilter
	{
	 
	 
	EPointerFilterEnterExit=0x1,
	 
	EPointerFilterMove=0x2,
	 
	EPointerFilterDrag=0x4,
	 



	EPointerGenerateSimulatedMove=0x8,
	 
	 









	EPointerMoveEvents=EPointerFilterMove|EPointerGenerateSimulatedMove,
	};

struct TPointerEvent
 






	{
 



	enum TType
		{
		 
		EButton1Down,
		 
		EButton1Up,
		 


		EButton2Down,
		 


		EButton2Up,
		 
		EButton3Down,
		 
		EButton3Up,
		 


		EDrag,
		 



		EMove,
		 
		EButtonRepeat,
		 
		ESwitchOn,
		};
	 
	TType iType;
	 
	TUint iModifiers;	 
	 





	TPoint iPosition;
	 




	TPoint iParentPosition;
	};

struct TKeyEvent
 













	{
	 


	TUint iCode;
	 


	TInt iScanCode;
	 
	TUint iModifiers;
	 



	TInt iRepeats;
	};

struct TModifiersChangedEvent
 




	{
	 

	TUint iChangedModifiers;
	 

	TUint iModifiers;
	};

struct TWsErrorMessage
 




	{
	 
	enum TErrorCategory
		{
		 





		EDrawingRegion,
		 


		EBackLight,
		 
		ELogging,
		 
		EContrast,
		};
	 
	TErrorCategory iErrorCategory;
	 
	TUint iError;
	};


class TWsRedrawEvent
 








	{
public:
	inline TUint Handle() const;
	inline TRect Rect() const;
public:
	void SetHandle(TUint aHandle);
	void SetRect(TRect aRect);
protected:
	 
	TUint iHandle;
	 
	TRect iRect;			 
	};


class TWsPriorityKeyEvent
 






	{
public:
	inline TKeyEvent *Key() const;
	inline TUint Handle() const;
	inline void SetHandle(TUint aHandle);
protected:
	 
	TUint iHandle;
	 
	TUint8 iEventData[sizeof(TKeyEvent)];
	};


class TWsEvent
 









	{
public:
	 
	enum
		{
		 



		EWsEventDataSize=sizeof(TPointerEvent)
		};
public:
	inline TPointerEvent *Pointer() const;
	inline TKeyEvent *Key() const;
	inline TModifiersChangedEvent *ModifiersChanged() const;
	inline TWsErrorMessage *ErrorMessage() const;
	inline TUint8 *EventData() const;
	inline TInt Type() const;
	inline TUint Handle() const;
	inline TTime Time() const;
	inline void SetType(TInt aType);
	inline void SetHandle(TUint aHandle);
	inline void SetTimeNow();
protected:
	 
	TInt iType;
	 
	TUint iHandle;
	 
	TTime iTime;
	 
	TUint8 iEventData[EWsEventDataSize];
	};


class RWsPointerCursor;

 








enum TPointerCursorMode
	{
	 
	EPointerCursorNone,
	 
	EPointerCursorFixed,
	 

	EPointerCursorNormal,
	 

	EPointerCursorWindow,
	 


	EPointerCursorFirstMode=EPointerCursorNone,
	 



	EPointerCursorLastMode=EPointerCursorWindow,
	};

 













enum TLongCaptureFlags
	{
	 



	ELongCaptureShortEventImmediately=0x01,
	 

	ELongCaptureRepeatEvents=0x02,
	 

	ELongCaptureNormal=ELongCaptureShortEventImmediately,
	 
	ELongCaptureWaitShort=0,
	};


class TIpcArgs;
class TReadDescriptorType;
class TWriteDescriptorType;
class CWindowGc;


class MWsClientClass
 



	{
	friend class CWindowGc;
public:
	MWsClientClass();
	MWsClientClass(RWsBuffer *aBuffer);
	inline TInt WsHandle() const;
protected:
	void Write(const TAny *aData, TInt aLength,const TAny *aData2, TInt aLength2,TUint aOpcode) const;
	void Write(const TAny *aBuf, TInt aBufLen,TUint aOpcode) const;
	void Write(TUint aOpcode) const;
	void WriteInt(TInt aInt, TUint aOpcode) const;
	void WriteRect(const TRect &aRect, TUint aOpcode) const;
	void WritePoint(const TPoint &aPoint, TUint aOpcode) const;
	void WriteSize(const TSize &aSize, TUint aOpcode) const;
	TInt WriteReply(TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReplyInt(TInt aInt, TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReply(const TAny *aBuf, TInt aBufLen,TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReply(const TAny *aBuf, TInt aBufLen,const TAny *aBuf2, TInt aBuflen2,TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReplyP(const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyIntP(TInt aInt, const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyP(const TAny *aBuf, TInt aBufLen, const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyP(const TAny *aBuf, TInt aBufLen,const TAny *aBuf2, TInt aBuflen2, const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyByProvidingRemoteReadAccess(const TAny* aBuf, TInt aBufLen,const TReadDescriptorType& aRemoteReadBuffer,TUint aOpcode) const;
protected:
	 
	TInt32 iWsHandle;
	 
	RWsBuffer *iBuffer;
	};

 
class RWindowTreeNode;
class CWsScreenDevice;
class CWsBitmap;
class RAnimDll;
class RWsSpriteBase;
class RDirectScreenAccess;
class RSoundPlugIn;


class RWsSession : public MWsClientClass, public RSessionBase
 






































	{
	friend class RWsBuffer;
	friend class RWindowTreeNode;
	friend class CWsScreenDevice;
	friend class CWsBitmap;
	friend class RAnimDll;
	friend class RWsSpriteBase;
	friend class RDirectScreenAccess;
	friend class RSoundPlugIn;
public:
	 







	enum TComputeMode
		{
		 




		EPriorityControlDisabled,
		 
		EPriorityControlComputeOn,
		 



		EPriorityControlComputeOff
		};
	enum {ESystemInfoArraySize=16};
	 


	enum TLoggingCommand
		{
		 
		ELoggingEnable,
		 
		ELoggingDisable,
		 

		ELoggingStatusDump,		 
		 

		ELoggingHeapDump,
		};
	struct SSystemInfo
	 
		{
		TInt iInfo[ESystemInfoArraySize];
		};
	 




	enum TCustomTextCursorAlignment
		{
		 
		ECustomTextCursorAlignTop,
		 

		ECustomTextCursorAlignBaseline,
		 

		ECustomTextCursorAlignBottom
		};
 
public:
	  RWsSession();
	  TInt Connect();
	  void Close();
	  TVersion Version();

	  TInt SetHotKey(THotKey aType, TUint aKeyCode, TUint aModifierMask, TUint aModifier);
	  TInt ClearHotKeys(THotKey aType);
	  TInt RestoreDefaultHotKey(THotKey aType);
 
	  void EventReady(TRequestStatus *aStat);
	  void EventReadyCancel();
	  void GetEvent(TWsEvent &aEvent);
	  void PurgePointerEvents();
 
	  void RedrawReady(TRequestStatus *aStat);
	  void RedrawReadyCancel();
	  void GetRedraw(TWsRedrawEvent &aEvent);
 
	  void PriorityKeyReady(TRequestStatus *aStat);
	  void PriorityKeyReadyCancel();
	  void GetPriorityKey(TWsPriorityKeyEvent &aEvent);
 
	  void Flush();
	  TBool SetAutoFlush(TBool aState);
	  void SetKeyboardRepeatRate(const TTimeIntervalMicroSeconds32 &aInitialTime, const TTimeIntervalMicroSeconds32 &aTime);
	  void GetKeyboardRepeatRate(TTimeIntervalMicroSeconds32 &aInitialTime, TTimeIntervalMicroSeconds32 &aTime);
	  void GetDoubleClickSettings(TTimeIntervalMicroSeconds32 &aInterval, TInt &aDistance);
	  void SetDoubleClick(const TTimeIntervalMicroSeconds32 &aInterval, TInt aDistance);
 
	  TInt NumWindowGroups() const;
	  TInt WindowGroupList(CArrayFixFlat<TInt> *aWindowList);
	  TInt NumWindowGroups(TInt aPriority) const;
	  TInt WindowGroupList(TInt aPriority, CArrayFixFlat<TInt> *aWindowList);
	  TInt GetFocusWindowGroup();
	  TInt GetDefaultOwningWindow();
	  TInt SetWindowGroupOrdinalPosition(TInt aIdentifier, TInt aPosition);
	  TInt GetWindowGroupClientThreadId(TInt aIdentifier, TThreadId &aThreadId);
	  TInt GetWindowGroupHandle(TInt aIdentifier);
	  TInt GetWindowGroupOrdinalPriority(TInt aIdentifier);
	  TInt SendEventToWindowGroup(TInt aIdentifier, const TWsEvent &aEvent);
	  TInt SendEventToAllWindowGroups(const TWsEvent &aEvent);
	  TInt SendEventToAllWindowGroups(TInt aPriority, const TWsEvent &aEvent);
	  TInt SendEventToOneWindowGroupsPerClient(const TWsEvent &aEvent);
	  TInt GetWindowGroupNameFromIdentifier(TInt aIdentifier, TDes &aWindowName);
	  TInt FindWindowGroupIdentifier(TInt aPreviousIdentifier,const TDesC& aMatch,TInt aOffset=0);
	  TInt FindWindowGroupIdentifier(TInt aPreviousIdentifier,TThreadId aThreadId);
	  TInt SendMessageToWindowGroup(TInt aIdentifier, TUid aUid, const TDesC8 &aParams);
	  TInt SendMessageToAllWindowGroups(TUid aUid, const TDesC8& aParams);
	  TInt SendMessageToAllWindowGroups(TInt aPriority, TUid aUid, const TDesC8& aParams);
	  TInt FetchMessage(TUid &aUid, TPtr8 &aParams, const TWsEvent& aMessageEvent);
 
	  void SetShadowVector(const TPoint &aVector);
	  TPoint ShadowVector() const;
 
	  void SetBackgroundColor(TRgb aColor);
	  TRgb GetBackgroundColor() const;
 
	  TInt SetSystemPointerCursor(const RWsPointerCursor &aPointerCursor,TInt aCursorNumber);
	  void ClearSystemPointerCursor(TInt aCursorNumber);
	  TInt ClaimSystemPointerCursorList();
	  void FreeSystemPointerCursorList();
 
	  TInt SetCustomTextCursor(TInt aIdentifier, const TArray<TSpriteMember>& aSpriteMemberArray, TUint aSpriteFlags, TCustomTextCursorAlignment aAlignment);
 
	  TInt ResourceCount();
	  void PasswordEntered();
	  void ComputeMode(TComputeMode aMode);
 
	  TInt HeapCount() const;
	  void MarkStart();
	  void CheckNum(TUint aCount);
	  void MarkEnd(TUint aCount);
	  void HeapSetFail(TInt aTAllocFail,TInt aValue);
	  void SetModifierState(TEventModifier aModifier,TModifierState aState);
	  TInt GetModifierState() const;
 
	  TInt RequestOffEvents(TBool aOn,RWindowTreeNode *aWin= 0L );
	  TDisplayMode GetDefModeMaxNumColors(TInt& aColor,TInt& aGray) const;
	  TInt GetColorModeList(CArrayFixFlat<TInt> *aModeList) const;
 
	  void SetPointerCursorArea(const TRect& aArea);
	  void SetPointerCursorArea(TInt aScreenSizeMode,const TRect& aArea);
	  TRect PointerCursorArea() const;
	  TRect PointerCursorArea(TInt aScreenSizeMode) const;
	  void SetPointerCursorMode(TPointerCursorMode aMode);
	  TPointerCursorMode PointerCursorMode() const;
	  void SetDefaultSystemPointerCursor(TInt aCursorNumber);
	  void ClearDefaultSystemPointerCursor();
	  void SetPointerCursorPosition(const TPoint& aPosition);
	  TPoint PointerCursorPosition() const;

	  void SetDefaultFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap);
	  void PrepareForSwitchOff();
	  void SetBufferSizeL(TInt aBufSize);
	  TInt SetSystemFaded(TBool aFaded);
	  TInt SetSystemFaded(TBool aFaded,TUint8 aBlackMap,TUint8 aWhiteMap);







 
	  void SimulateRawEvent(TRawEvent aEvent);
	  void SimulateKeyEvent(TKeyEvent aEvent);
	  void LogCommand(TLoggingCommand aCommand);
	  void LogMessage(const TLogMessageText &aMessage);
 
 
 
	  void SystemInfo(TInt &aSystemInfoNumber, SSystemInfo &aSystemInfo);
	  void TestWrite(TInt aHandle,TInt aOpcode,const TAny *aData, TInt aLength);
	  void TestWriteReply(TInt aHandle,TInt aOpcode,const TAny *aData, TInt aLength);
	  void TestWriteReplyP(TInt aHandle,TInt aOpcode,const TAny *aData,TInt aLength,TDes8 *aReplyPackage);
	  TInt TestWriteReplyByProvidingRemoteReadAccess(TInt aHandle,TInt aOpcode,const TDesC8& aData,const TDesC8& aRemoteReadBuffer);
	  TInt TestWriteReplyByProvidingRemoteReadAccess(TInt aHandle,TInt aOpcode,const TDesC8& aData,const TDesC16& aRemoteReadBuffer);
private:
	TInt doWindowGroupList(TInt aPriority, CArrayFixFlat<TInt> *aWindowList, TInt aNumOpcode, TInt aListOpcode);
	TInt doSetHotKey(TInt aOpcode, TInt aType, TUint aKeycode, TUint aModifierMask, TUint aModifiers);
	void doReadEvent(TRequestStatus *aStat, TInt aOpcode);
private:
	void connectL();
	TInt DoFlush(const TIpcArgs& aIpcArgs);
	void DirectAcessActivation(TBool aIsNowActive);
	};

class RWindowGroup;
class RWsSprite;

 	
typedef TInt (*AnimCommand)(TPtr8 *aBufPtr,TAny *aPackage);


class RWindowTreeNode : public MWsClientClass
 







	{
	friend class RWindowGroup;
	friend class RWindowBase;
	friend class CWindowGc;
	friend class RAnimDll;
	friend class RWsSprite;
public:
	 



	enum TFadeControl
		{
		 
		EFadeIncludeChildren=ETrue,
		 



		EFadeWindowOnly=EFalse,
		};
protected:
	RWindowTreeNode();
	RWindowTreeNode(RWsSession &aWs);
public:
	  void Close();
	  void Destroy();
	  TUint32 Parent() const;
	  TUint32 PrevSibling() const;
	  TUint32 NextSibling() const;
	  TUint32 Child() const;
	  TInt OrdinalPriority() const;
	  TInt OrdinalPosition() const;
	  TInt FullOrdinalPosition() const;
	  void SetOrdinalPosition(TInt aPos);
	  void SetOrdinalPosition(TInt aPos,TInt aOrdinalPriority);
	  TInt SetPointerCursor(TInt aCursorNumber);
	  void SetCustomPointerCursor(const RWsPointerCursor &aPointerCursor);
	  TInt EnableOnEvents(TEventControl aCircumstances=EEventControlOnlyWithKeyboardFocus);
	  void DisableOnEvents();
	  TInt EnableGroupChangeEvents();
	  void DisableGroupChangeEvents();
	  TInt EnableFocusChangeEvents();
	  void DisableFocusChangeEvents();
	  TInt EnableGroupListChangeEvents();
	  void DisableGroupListChangeEvents();
	  TInt EnableErrorMessages(TEventControl aCircumstances);
	  void DisableErrorMessages();
	  TInt EnableModifierChangedEvents(TUint aModifierMask, TEventControl aCircumstances);
	  void DisableModifierChangedEvents();
	  void SetNonFading(TBool aNonFading);
	  void SetFaded(TBool aFaded,TFadeControl aIncludeChildren);
	  void SetFaded(TBool aFaded,TFadeControl aIncludeChildren,TUint8 aBlackMap,TUint8 aWhiteMap);
	  void ClearPointerCursor();
protected:
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


class RWindowBase : public RWindowTreeNode
 









	{
public:
	 



	enum TCaptureFlags
		{
 
		 
		TCaptureFlagEnabled=0x01,
		 

		TCaptureFlagDragDrop=0x02,
		 

		TCaptureFlagAllGroups=0x04,
 
		 
		TCaptureDisabled=0,
		 
		TCaptureEnabled=TCaptureFlagEnabled,
		 
		TCaptureDragDrop=TCaptureFlagEnabled|TCaptureFlagDragDrop|TCaptureFlagAllGroups,
		};
protected:
	RWindowBase();
	RWindowBase(RWsSession &aWs);
public:
	  void Activate();
	  void SetPosition(const TPoint &point);
	  TInt SetSizeErr(const TSize &size);
	  TInt SetExtentErr(const TPoint &point,const TSize &size);
	  TSize Size() const;
	  TPoint InquireOffset(const RWindowTreeNode &aWindow) const;
	  void PointerFilter(TUint32 aFilterMask, TUint32 aFilter);
	  void SetPointerGrab(TBool aState);
	  void ClaimPointerGrab(TBool aSendUpEvent=ETrue);
	  void SetPointerCapture(TInt aFlags);
	  void SetVisible(TBool aState);
	  void SetShadowHeight(TInt aHeight);
	  void SetShadowDisabled(TBool aState);
	  TPoint Position() const;
	  TPoint AbsPosition() const;
	  TInt SetCornerType(TCornerType aCornerType, TInt aCornerFlags=0);
	  TInt SetShape(const TRegion &aRegion);
	  TInt SetRequiredDisplayMode(TDisplayMode aMode);
	  TDisplayMode DisplayMode();
	  void EnableBackup(TUint aBackupType=EWindowBackupAreaBehind);
	  void RequestPointerRepeatEvent(TTimeIntervalMicroSeconds32 aTime,const TRect &aRect);
	  void CancelPointerRepeatEventRequest();
	  TInt AllocPointerMoveBuffer(TInt aMaxPoints, TUint aFlags);
	  void FreePointerMoveBuffer();
	  void EnablePointerMoveBuffer();
	  void DisablePointerMoveBuffer();
	  TInt RetrievePointerMoveBuffer(TDes8 &aBuf);
	  void DiscardPointerMoveBuffer();
	  TInt AddKeyRect(const TRect &aRect, TInt aScanCode, TBool aActivatedByPointerSwitchOn);
	  void RemoveAllKeyRects();
	  TInt PasswordWindow(TPasswordMode aPasswordMode);
	  void FadeBehind(TBool aFade);
	  TBool IsFaded();
	  TBool IsNonFading();
	  TInt MoveToGroup(TInt aIdentifier);
protected:
	TInt construct(const RWindowTreeNode &parent,TUint32 aHandle, TInt aType, TDisplayMode aDisplayMode);
	};


class RBlankWindow : public RWindowBase
 








	{
public:
	  RBlankWindow();
	  RBlankWindow(RWsSession &aWs);
	  TInt Construct(const RWindowTreeNode &parent, TUint32 aHandle);
	  void SetColor(TRgb aColor);
	  void SetSize(const TSize &size);
	  void SetExtent(const TPoint &point,const TSize &size);
	};


class RDrawableWindow : public RWindowBase
 








	{
protected:
	RDrawableWindow();
	RDrawableWindow(RWsSession &aWs);
public:
	  void Scroll(const TPoint &aOffset);
	  void Scroll(const TRect &aClipRect, const TPoint &aOffset);
	  void Scroll(const TPoint &aOffset, const TRect &aRect);
	  void Scroll(const TRect &aClipRect, const TPoint &aOffset, const TRect &aRect);
private:
	void doScroll(const TRect &aClipRect, const TPoint &aOffset, const TRect &aRect, TInt aOpcode);
	};


class RWindow : public RDrawableWindow
 






	{
public:
	  RWindow();
	  RWindow(RWsSession &aWs);
	  TInt Construct(const RWindowTreeNode &parent,TUint32 aHandle);
	  void BeginRedraw();
	  void BeginRedraw(const TRect &aRect);
	  void EndRedraw();
	  void Invalidate();
	  void Invalidate(const TRect &aRect);
	  void GetInvalidRegion(RRegion &aRegion);
	  void SetBackgroundColor(TRgb aColor);
	  void SetBackgroundColor();
	  void SetSize(const TSize &size);
	  void SetExtent(const TPoint &point,const TSize &size);
	  void HandleTransparencyUpdate();
	  TInt SetTransparencyFactor(const TRgb& aTransparencyFactor);
	  TInt SetTransparencyBitmap(const CFbsBitmap& aTransparencyBitmap);
	  void SetNonTransparent();
	  void EnableRedrawStore(TBool aEnabled);
	};


class RBackedUpWindow : public RDrawableWindow
 











	{
public:
	  RBackedUpWindow();
	  RBackedUpWindow(RWsSession &aWs);
	  TInt Construct(const RWindowTreeNode &parent,TDisplayMode aDisplayMode, TUint32 aHandle);
	  TInt BitmapHandle();
	  void UpdateScreen();
	  void UpdateScreen(const TRegion &aRegion);
	  void UpdateBackupBitmap();
	  void MaintainBackup();
	};


class RWindowGroup : public RWindowTreeNode
 



	{
public:
	  RWindowGroup();
	  RWindowGroup(RWsSession &aWs);
	  TInt Construct(TUint32 aClientHandle);
	  TInt Construct(TUint32 aClientHandle, TBool aInitialFocusState);
	  void EnableReceiptOfFocus(TBool aState);
	  void AutoForeground(TBool aState);
	  void SetOrdinalPriorityAdjust(TInt aAdjust);
	  TInt32 CaptureKey(TUint aKeycode, TUint aModifierMask, TUint aModifier);
	  TInt32 CaptureKey(TUint aKeycode, TUint aModifierMask, TUint aModifier, TInt aPriority);
	  void CancelCaptureKey(TInt32 aCaptureKey);
	  TInt32 CaptureKeyUpAndDowns(TUint aScanCode, TUint aModifierMask, TUint aModifier);
	  TInt32 CaptureKeyUpAndDowns(TUint aScanCode, TUint aModifierMask, TUint aModifier, TInt aPriority);
	  void CancelCaptureKeyUpAndDowns(TInt32 aCaptureKey);
	  TInt32 CaptureLongKey(TUint aInputKeyCode,TUint aOutputKeyCode,TUint aModifierMask,TUint aModifier
																										,TInt aPriority,TUint aFlags);
	  TInt32 CaptureLongKey(TTimeIntervalMicroSeconds32 aRepeatTime,TUint aInputKeyCode,TUint aOutputKeyCode
																	,TUint aModifierMask,TUint aModifier,TInt aPriority,TUint aFlags);
	  void CancelCaptureLongKey(TInt32 aCaptureKey);
	  TInt AddPriorityKey(TUint aKeycode, TUint aModifierMask, TUint aModifier);
	  void RemovePriorityKey(TUint aKeycode, TUint aModifierMask, TUint aModifier);
	  void SetTextCursor(RWindowBase &aWin, const TPoint &aPos, const TTextCursor &aCursor);
	  void SetTextCursor(RWindowBase &aWin, const TPoint &aPos, const TTextCursor &aCursor, const TRect &aClipRect);
	  void CancelTextCursor();
	  void SetOwningWindowGroup(TInt aIdentifier);
	  void DefaultOwningWindow();
	  TInt SetName(const TDesC &aName);
	  TInt Name(TDes &aWindowName) const;
	  TInt Identifier() const;
	  void DisableKeyClick(TBool aState);
	  TInt EnableScreenChangeEvents();
	  void DisableScreenChangeEvents();
	  void SimulatePointerEvent(TRawEvent aEvent);
private:
	TInt32 doCaptureKey(TUint aKey, TUint aModifierMask, TUint aModifiers, TInt aPriority, TInt aOpcode);
	void doCancelCaptureKey(TInt32 aCaptureKeyHandle, TInt aOpcode);
	};


class CWsBitmap : public CFbsBitmap, public MWsClientClass
 







	{
public:
	  CWsBitmap();
	  CWsBitmap(RWsSession &aWs);
	  ~CWsBitmap();
	  TInt Create(const TSize& aSizeInPixels,TDisplayMode aDispMode);
	  TInt Duplicate(TInt aHandle);
	  TInt Load(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded=ETrue);
	  void InternalizeL(RReadStream& aStream);
	  void Reset();
private:
	TInt createWsBitmap(TInt aErr);
	};


class CWindowGc : public CBitmapContext, public MWsClientClass
 























	{
	friend class CWsScreenDevice;
public:
	  CWindowGc(CWsScreenDevice *aDevice);
	  virtual ~CWindowGc();
	  virtual TInt Construct();
	  virtual void Activate(RDrawableWindow &aDevice);
	  virtual void Deactivate();
 
	  virtual CGraphicsDevice* Device() const;
	  virtual void SetOrigin(const TPoint &aPoint=TPoint(0,0));
	  virtual void SetDrawMode(TDrawMode aDrawingMode);
	  virtual void SetClippingRect(const TRect& aRect);
	  virtual void CancelClippingRect();
	  virtual void Reset();

	  virtual void UseFont(const CFont *aFont);
	  virtual void DiscardFont();
	  virtual void SetUnderlineStyle(TFontUnderline aUnderlineStyle);
	  virtual void SetStrikethroughStyle(TFontStrikethrough aStrikethroughStyle);
 
	  virtual void SetWordJustification(TInt aExcessWidth,TInt aNumGaps);
 
	  virtual void SetCharJustification(TInt aExcessWidth,TInt aNumChars);

	  virtual void SetPenColor(const TRgb &aColor);
	  virtual void SetPenStyle(TPenStyle aPenStyle);
	  virtual void SetPenSize(const TSize& aSize);

	  virtual void SetBrushColor(const TRgb &aColor);
	  virtual void SetBrushStyle(TBrushStyle aBrushStyle);
	  virtual void SetBrushOrigin(const TPoint &aOrigin);
	  virtual void UseBrushPattern(const CFbsBitmap *aDevice);
	  virtual void DiscardBrushPattern();
 
 
 
	  virtual void MoveTo(const TPoint &aPoint);
	  virtual void MoveBy(const TPoint &aPoint);
	  virtual void Plot(const TPoint &aPoint);
 
 
	  virtual void DrawArc(const TRect &aRect,const TPoint &aStart,const TPoint &aEnd);
	  virtual void DrawLine(const TPoint &aPoint1,const TPoint &aPoint2);
	  virtual void DrawLineTo(const TPoint &aPoint);
	  virtual void DrawLineBy(const TPoint &aPoint);
	  virtual void DrawPolyLine(const CArrayFix<TPoint> *aPointList);
	  virtual void DrawPolyLine(const TPoint* aPointList,TInt aNumPoints);
 
 
 
 
 
 
	  virtual void DrawPie(const TRect &aRect,const TPoint &aStart,const TPoint &aEnd);
	  virtual void DrawEllipse(const TRect &aRect);
	  virtual void DrawRect(const TRect &aRect);
	  virtual void DrawRoundRect(const TRect &aRect,const TSize &aEllipse);
	  virtual TInt DrawPolygon(const CArrayFix<TPoint> *aPointList,TFillRule aFillRule=EAlternate);
	  virtual TInt DrawPolygon(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule=EAlternate);
 
 
	  virtual void DrawBitmap(const TPoint &aTopLeft, const CFbsBitmap *aDevice);
	  virtual void DrawBitmap(const TRect &aDestRect, const CFbsBitmap *aDevice);
	  virtual void DrawBitmap(const TRect &aDestRect, const CFbsBitmap *aDevice, const TRect &aSourceRect);
 
 
 
 
	  virtual void DrawText(const TDesC &aBuf,const TPoint &aPos);
 
 
 
	  virtual void DrawText(const TDesC &aBuf,const TRect &aBox,TInt aBaselineOffset,TTextAlign aHoriz=ELeft,TInt aLeftMrg=0);
 
	  virtual void Clear();
	  virtual void Clear(const TRect &aRect);
	  virtual void CopyRect(const TPoint &anOffset,const TRect &aRect);
	  virtual void BitBlt(const TPoint &aPos, const CFbsBitmap *aBitmap);
	  virtual void BitBlt(const TPoint &aDestination, const CFbsBitmap *aBitmap, const TRect &aSource);
	  virtual void BitBltMasked(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect,const CFbsBitmap* aMaskBitmap,TBool aInvertMask);
	  virtual void BitBlt(const TPoint &aPoint, const CWsBitmap *aBitmap);
	  virtual void BitBlt(const TPoint &aDestination, const CWsBitmap *aBitmap, const TRect &aSource);
	  virtual void BitBltMasked(const TPoint& aPoint,const CWsBitmap *aBitmap,const TRect& aSourceRect,const CWsBitmap *aMaskBitmap,TBool aInvertMask);
	  virtual void MapColors(const TRect& aRect,const TRgb* aColors,TInt aNumPairs=2,TBool aMapForwards=ETrue);

	  virtual void DrawTextVertical(const TDesC& aText,const TPoint& aPos,TBool aUp);
	  virtual void DrawTextVertical(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TBool aUp,TTextAlign aVert=ELeft,TInt aMargin=0);
 
	  virtual void SetDitherOrigin(const TPoint& aPoint);
	  virtual TInt SetClippingRegion(const TRegion &aRegion);
	  virtual void CancelClippingRegion();
	  void SetOpaque(TBool aDrawOpaque=ETrue);
 
	  void SetFaded(TBool aFaded);
	  void SetFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap);
	  void AlphaBlendBitmaps(const TPoint& aDestPt, const CFbsBitmap* aSrcBmp, const TRect& aSrcRect, const CFbsBitmap* aAlphaBmp, const TPoint& aAlphaPt);
	  void AlphaBlendBitmaps(const TPoint& aDestPt, const CWsBitmap* aSrcBmp, const TRect& aSrcRect, const CWsBitmap* aAlphaBmp, const TPoint& aAlphaPt);
 
private:  
	TRgb Color(TInt aOpcode)const;
	void SetJustification(TInt aExcessWidth,TInt aNumGaps, TInt aOpcode);
	void DrawArcOrPie(const TRect &aRect,const TPoint &aStart,const TPoint &aEnd, TInt aOpcode);
	void doDrawPolyLine(const CArrayFix<TPoint> *aPointArray, const TPoint* aPointList,TInt aNumPoints);
	TInt doDrawPolygon(const CArrayFix<TPoint> *aPointArray,const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule);
	void WriteTextPos(TInt aOpcode,TInt aOpcodePtr,const TPoint &aPos,const TDesC &aBuf) const;
	void WriteTextCommand(TAny *aCmd, TInt aLen,const TDesC &aBuf,TInt aOpcode,TInt aOpcodePtr) const;
private:  
	CFbsFont *iFont;
	CWsScreenDevice *iDevice;
	};


class CWsScreenDevice : public CBitmapDevice, public MWsClientClass
 












	{
public:
	 
	enum TSpriteInCompare
		{
		 






		ERemoveSprite=0,
		 



		EIncludeSprite=1,
		};
public:
	  CWsScreenDevice();
	  CWsScreenDevice(RWsSession &aWs);
	  ~CWsScreenDevice();
	  TInt Construct();
 
	  TDisplayMode DisplayMode() const;
	  TSize SizeInPixels() const;
	  TSize SizeInTwips() const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  TRect PointerRect() const;
	  TInt CreateContext(CGraphicsContext *&aGc);
    inline TInt CreateContext(CWindowGc *&aGc);
	  TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt NumTypefaces() const;
	  void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const;
	  TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
 
      void GetPixel(TRgb &aColor,const TPoint &aPixel) const;
      void GetScanLine(TDes8 &aScanLine,const TPoint &aStartPixel,TInt aPixelLength, TDisplayMode aDispMode) const;
	  TInt AddFile(const TDesC& aName,TInt& aId);
	  void RemoveFile(TInt aId=0);
	  TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  void ReleaseFont(CFont* aFont);
 
	  void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  void SetPalette(CPalette* aPalette);
	  TInt GetPalette(CPalette*& aPalette) const;
 
	  TInt SetCustomPalette(const CPalette* aPalette);
 	  TInt GetFontById(CFont *&aFont,TUid aUid,const TAlgStyle& aAlgStyle);
	  TBool RectCompare(const TRect &aRect1,const TRect &aRect2);
	  TBool RectCompare(const TRect& aRect1,const TRect &aRect2,TUint aFlags) const;
	  TInt CopyScreenToBitmap(const CFbsBitmap *aBitmap) const;
	  TInt CopyScreenToBitmap(const CFbsBitmap *aBitmap, const TRect &aRect) const;
 
	  void SetScreenSizeAndRotation(const TPixelsTwipsAndRotation &aSizeAndRotation);
	  void GetDefaultScreenSizeAndRotation(TPixelsTwipsAndRotation &aSizeAndRotation) const;
	  void SetScreenSizeAndRotation(const TPixelsAndRotation &aSizeAndRotation);
	  void GetDefaultScreenSizeAndRotation(TPixelsAndRotation &aSizeAndRotation) const;
	  TScreenModeEnforcement ScreenModeEnforcement() const;
	  void SetScreenModeEnforcement(TScreenModeEnforcement aMode) const;
	  void GetScreenModeSizeAndRotation(TInt aMode, TPixelsTwipsAndRotation &aSizeAndRotation) const;
	  void GetScreenModeSizeAndRotation(TInt aMode, TPixelsAndRotation &aSizeAndRotation) const;
	  void SetCurrentRotations(TInt aMode, CFbsBitGc::TGraphicsOrientation aRotation) const;
	  TInt GetRotationsList(TInt aMode, CArrayFixFlat<TInt> *aRotationList) const;
	  TInt NumScreenModes() const;
	  void SetScreenMode(TInt aMode);
	  TInt CurrentScreenMode() const;
	  void SetAppScreenMode(TInt aMode);
	  TPoint GetDefaultScreenModeOrigin() const;
	  TPoint GetScreenModeOrigin(TInt aMode) const;
	  TSize GetCurrentScreenModeScale() const;
	  TSize GetScreenModeScale(TInt aMode) const;
	  TPoint GetCurrentScreenModeScaledOrigin() const;
	  TPoint GetScreenModeScaledOrigin(TInt aMode) const;
 
	  TSizeMode GetCurrentScreenModeAttributes() const;
	  void SetCurrentScreenModeAttributes(const TSizeMode &aModeAtt);
private:  
	CFbsTypefaceStore* iTypefaceStore;
	TSize iPhysicalScreenSizeInTwips;
	TSize iDisplaySizeInPixels;
	friend class CWindowGc;
	};


class RWsSpriteBase : public MWsClientClass
 
 








	{
protected:
	  RWsSpriteBase();
	  RWsSpriteBase(RWsSession &aWs);
public:
	  TInt Activate();
	  TInt AppendMember(const TSpriteMember &aMemberData);
	  void UpdateMember(TInt aIndex);
	  TInt UpdateMember(TInt aIndex, const TSpriteMember &aMemberData);
	  void Close();
	};


class RWsSprite : public RWsSpriteBase
 






	{
public:
	  RWsSprite();
	  RWsSprite(RWsSession &aWs);
	  TInt Construct(RWindowTreeNode &aWindow, const TPoint &aPos, TInt aFlags);
	  void SetPosition(const TPoint &aPos);
	};


class RWsPointerCursor : public RWsSpriteBase
 




















	{
	friend class RWindowTreeNode;
	friend class RWsSession;
public:
	  RWsPointerCursor();
	  RWsPointerCursor(RWsSession &aWs);
	  TInt Construct(TInt aFlags);
	};


class RAnim;


class RAnimDll : public MWsClientClass
 









	{
public:
	  RAnimDll();
	  virtual ~RAnimDll();
	  RAnimDll(RWsSession &aWs);
	  TInt Load(const TDesC &aFileName);
	  void Destroy();
	  virtual void Close();
private:
	TInt CommandReply(TInt aHandle, TInt aOpcode, const TIpcArgs* aIpcArgs= 0L );
	TInt CommandReply(TInt aHandle, TInt aOpcode, const TDesC8& aArgs, const TIpcArgs* aIpcArgs= 0L );
	void Command(TInt aHandle, TInt aOpcode, const TPtrC8 &aArgs);
	void Command(TInt aHandle, TInt aOpcode);
	void AsyncCommandReply(TRequestStatus& aStatus, TInt aOpcode, TIpcArgs& aIpcArgs);
	TInt CreateInstance(TInt32& aHandle, const MWsClientClass &aDevice, TInt aType, const TDesC8 &aArgs, TInt aOpcode, const TIpcArgs* aIpcArgs);
	void DestroyInstance(TInt aHandle);
private:
	friend class RAnim;
	};


class RAnim
 






	{
public:
	  virtual ~RAnim();
	  virtual void Close();
	  void Destroy();
protected:
	  RAnim();
	  RAnim(RAnimDll &aDll);
	  TInt Construct(const RWindowBase &aDevice, TInt aType, const TDesC8 &aParams);
	  TInt Construct(const RWindowBase &aDevice, TInt aType, const TDesC8 &aParams, const TIpcArgs& aIpcArgs);
	  TInt Construct(const RWsSprite &aDevice, TInt aType, const TDesC8 &aParams);
	  TInt Construct(const RWsSprite &aDevice, TInt aType, const TDesC8 &aParams, const TIpcArgs& aIpcArgs);
	  TInt CommandReply(TInt aOpcode);
	  TInt CommandReply(TInt aOpcode, const TPtrC8 &aArgs);
	  TInt CommandReply(TInt aOpcode, const TDesC8& aArgs, const TIpcArgs& aIpcArgs);
	  void Command(TInt aOpcode, const TPtrC8 &aArgs);
	  void Command(TInt aOpcode);
	  void AsyncCommandReply(TRequestStatus& aRequestStatus,TInt aOpcode, const TIpcArgs& aIpcArgs);
private:
	TInt32 iHandle;
	RAnimDll *iAnimDll;
	};


class RDirectScreenAccess : public MWsClientClass
 








	{
public:
	 








	enum TTerminationReasons
		{
		 
		ETerminateCancel,
		 

		ETerminateRegion,
		 
		ETerminateScreenMode,
		 

		ETerminateRotation,
		};
	 

	enum TPriority
		{
		 


		EPriorityVeryHigh=100,
		};
public:
	  RDirectScreenAccess();
	  RDirectScreenAccess(RWsSession& aWs);
	  TInt Construct();
	  TInt Request(RRegion*& aRegion,TRequestStatus& aStatus,const RWindowBase& aWindow); 
	  void Completed();
	  void Cancel();
	  void Close();
private:
	RWsSession* iWs;
	RThread iWsThread;
	TRequestStatus* iAborted;
	TRequestStatus* iAbortedBackup;
	};


class MAbortDirectScreenAccess
 






	{
public:
	 













	virtual void AbortNow(RDirectScreenAccess::TTerminationReasons aReason)=0;
	};


class MDirectScreenAccess : public MAbortDirectScreenAccess
 









	{
public:
	 











	virtual void Restart(RDirectScreenAccess::TTerminationReasons aReason)=0;
	};


class CDirectScreenAccess : public CActive
 















	{
public:
	  static CDirectScreenAccess* NewL(RWsSession& aWs,CWsScreenDevice& aScreenDevice,RWindowBase& aWin,MDirectScreenAccess& aAbort);
	~CDirectScreenAccess();
	  void StartL();
	inline CFbsBitGc* Gc();
	inline CFbsScreenDevice*& ScreenDevice();
	inline RRegion* DrawingRegion();
private:
	enum TFlags
		{
		EDirectCheckModeChange=0x1,
		EDirectCheckSizeModeChange=0x2,
		};
private:
	inline CDirectScreenAccess(RWsSession& aWs,CWsScreenDevice* aScreenDevice,RWindowBase& aWindow,MDirectScreenAccess& aAbort);
	void ConstructL(RWsSession& aWs);
	void CreateScreenObjectsL(TDisplayMode aCurrentMode);
	void UpdateSizeAndRotation(CFbsBitGc* aGc);
	static TInt Restart(TAny* aDirect);
	void Restart();
	 
	void DoCancel();
	void RunL();
private:
	CFbsBitGc* iGc;
	CFbsScreenDevice* iScreenDevice;
	RRegion* iDrawingRegion;
	RWindowBase& iWindow;
	CWsScreenDevice* iWsScreenDevice;
	MDirectScreenAccess& iAbort;
	RDirectScreenAccess iDirectAccess;
	RDirectScreenAccess::TTerminationReasons iReason;
	CIdle* iRestart;
	TSize iScreenSize;
	TBool iAborting;
	TUint iFlags;
	};


class RSoundPlugIn : public MWsClientClass
 






	{
public:
	 
	enum 
		{
		 



		ESoundWrongPlugIn=KMinTInt
		};
public:
	  RSoundPlugIn();
	  RSoundPlugIn(RWsSession &aWs);
	  TInt Construct(TUid aUid= TUid::Null() );
	  void Close();
	  void Destroy();
	  TBool IsLoaded(TBool& aIsChangeable);
	  TInt Unload();
	  TInt Load(const TDesC &aFileName);
	  void SetKeyClick(TBool aEnabled);
	  void SetPenClick(TBool aEnabled);
	  TBool KeyClickEnabled();
	  TBool PenClickEnabled();
	  TInt CommandReply(TInt aOpcode, const TPtrC8 &aArgs);
	};

inline TInt MWsClientClass::WsHandle() const
	 


	{return(iWsHandle);}

inline TInt CWsScreenDevice::CreateContext(CWindowGc *&aGc)
	 







	{return(CreateContext((CGraphicsContext *&)aGc));}

inline TUint TWsRedrawEvent::Handle() const
	 






	{return(iHandle);}

inline TRect TWsRedrawEvent::Rect() const
	 



	{return(iRect);}

inline TPointerEvent *TWsEvent::Pointer() const
	 





	{return((TPointerEvent *)&iEventData);}

inline TKeyEvent *TWsEvent::Key() const
	 





	{return((TKeyEvent *)&iEventData);}

inline TModifiersChangedEvent *TWsEvent::ModifiersChanged() const
	 





	{return((TModifiersChangedEvent *)&iEventData);}

inline TWsErrorMessage *TWsEvent::ErrorMessage() const
	 





	{return((TWsErrorMessage *)&iEventData);}

inline TUint8 *TWsEvent::EventData() const
	 







	{return((TUint8 *)&iEventData);}

inline TInt TWsEvent::Type() const
	 


	{return(iType);}

inline TUint TWsEvent::Handle() const
	 






	{return(iHandle);}

inline TTime TWsEvent::Time() const
	 


	{return(iTime);}

inline void TWsEvent::SetType(TInt aType)
	 


	{iType=aType;}

inline void TWsEvent::SetHandle(TUint aHandle)
	 




	{iHandle=aHandle;}

inline void TWsEvent::SetTimeNow()
	 
	{iTime.HomeTime();}

inline TUint TWsPriorityKeyEvent::Handle() const
	 






	{return(iHandle);}

inline TKeyEvent *TWsPriorityKeyEvent::Key() const
	 


	{return((TKeyEvent *)&iEventData);}

inline void TWsPriorityKeyEvent::SetHandle(TUint aHandle)
	 




	{iHandle=aHandle;}

inline CDirectScreenAccess::CDirectScreenAccess(RWsSession& aWs,CWsScreenDevice* aScreenDevice,RWindowBase& aWindow,MDirectScreenAccess& aAbort)
		:CActive(RDirectScreenAccess::EPriorityVeryHigh), iWindow(aWindow), iAbort(aAbort), iDirectAccess(aWs)
		{iWsScreenDevice=aScreenDevice;}

inline CFbsBitGc* CDirectScreenAccess::Gc()
	 










	{ return iGc; }

inline CFbsScreenDevice*& CDirectScreenAccess::ScreenDevice()
	 






	{ return iScreenDevice; }

inline RRegion* CDirectScreenAccess::DrawingRegion()
	 










	{ return iDrawingRegion; }

inline TSizeMode::TSizeMode(TSize& aSize) :
	iOrigin(0, 0), iScreenSize(aSize)
	{}

inline TInt TSizeMode::ScaledCord(TInt aOrigin,TInt aScale)
	{return (aOrigin+aScale-1)/aScale;}

inline TPoint TSizeMode::ScaledOrigin()
	{return TPoint(ScaledCord(iOrigin.iX,iScreenScale.iWidth),ScaledCord(iOrigin.iY,iScreenScale.iHeight));}


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/barsc.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/barsc.h" 2


 
class RResourceFileImpl;

 



















class RResourceFile
	{
public:
	  RResourceFile();
	  void Close();
	  void OpenL(RFs &aFs,const TDesC &aName);
	  TUidType UidType() const;
	  void ReadL(TDes8 &aDes,TInt aResourceId) const;
	  HBufC8 *AllocReadL(TInt aResourceId) const;
	  HBufC8 *AllocReadLC(TInt aResourceId) const;
	  void ConfirmSignatureL(TInt aSignature);
	  void ConfirmSignatureL();
	  TInt SignatureL() const;  
	  TBool OwnsResourceId(TInt aResourceId) const;
	  TBool OwnsResourceIdL(TInt aResourceId) const;
	  void OpenL(RFs& aFs, const TDesC& aName, TUint aFileOffset, TInt aFileSize);
	inline TInt Offset() const;
private:
	void DoOpenL(RFs& aFs, const TDesC& aName, TUint aFileOffset, TInt aFileSize);
	  TInt Offset2() const;
	RResourceFileImpl* Impl();
	const RResourceFileImpl* Impl() const;
private:
	enum
		{
		KRscFileSize = 24
		};
	TUint8 iImpl[KRscFileSize];
	};

 







inline TInt RResourceFile::Offset() const 
	{ 
	return Offset2(); 
	}


# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h" 1
 
 
 
 

 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bamdesca.h" 1
 
 
 
 

 
 
 










class MDesC8Array
 







    {
public:
	 
    virtual ~MDesC8Array() {}
	 




    virtual TInt MdcaCount() const =0;

	 








    virtual TPtrC8 MdcaPoint(TInt aIndex) const =0;
    };


class MDesC16Array
 







    {
public:
	 
    virtual ~MDesC16Array() {}

	 




    virtual TInt MdcaCount() const =0;
	 








    virtual TPtrC16 MdcaPoint(TInt aIndex) const =0;
    };


 
 
 


 














 
# 123 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bamdesca.h"





# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h" 2








class CDesC8Array : public CArrayFixBase, public MDesC8Array
 






	{
protected:
	  CDesC8Array(TBufRep aRep,TInt aGranularity);
public:
      ~CDesC8Array();
	  void AppendL(const TDesC8& aPtr);
	  void InsertL(TInt aPos,const TDesC8& aPtr);
	  TInt InsertIsqL(const TDesC8& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt InsertIsqAllowDuplicatesL(const TDesC8& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  void Sort(TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt Find(const TDesC8& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  TInt FindIsq(const TDesC8& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  void Delete(TInt aPos);
	  void Delete(TInt aIndex,TInt aCount);
	  void Reset();
	inline TPtrC8 operator[](TInt aIndex) const;
 
      TInt MdcaCount() const;
	  TPtrC8 MdcaPoint(TInt aIndex) const;
	};

inline TPtrC8 CDesC8Array::operator[](TInt aIndex) const
	{ return(MdcaPoint(aIndex)); }


class CDesC8ArrayFlat : public CDesC8Array
 





	{
public:
	  CDesC8ArrayFlat(TInt aGranularity);
      ~CDesC8ArrayFlat();
	};


class CDesC8ArraySeg : public CDesC8Array
 





	{
public:
	  CDesC8ArraySeg(TInt aGranularity);
      ~CDesC8ArraySeg();
	};


class CDesC16Array : public CArrayFixBase, public MDesC16Array
 








	{
protected:
	  CDesC16Array(TBufRep aRep,TInt aGranularity);
public:
      ~CDesC16Array();
	  void AppendL(const TDesC16& aPtr);
	  void InsertL(TInt aPos,const TDesC16& aPtr);
	  TInt InsertIsqL(const TDesC16& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt InsertIsqAllowDuplicatesL(const TDesC16& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  void Sort(TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt Find(const TDesC16& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  TInt FindIsq(const TDesC16& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  void Delete(TInt aPos);
	  void Delete(TInt aIndex,TInt aCount);
	  void Reset();
	inline TPtrC16 operator[](TInt aIndex) const;
 
      TInt MdcaCount() const;
		  TPtrC16 MdcaPoint(TInt aIndex) const;
	};



inline TPtrC16 CDesC16Array::operator[](TInt aIndex) const
 








 { return(MdcaPoint(aIndex)); }


class CDesC16ArrayFlat : public CDesC16Array
 





	{
public:
	  CDesC16ArrayFlat(TInt aGranularity);
      ~CDesC16ArrayFlat();
	};


class CDesC16ArraySeg : public CDesC16Array
 





	{
public:
	  CDesC16ArraySeg(TInt aGranularity);
      ~CDesC16ArraySeg();
	};


class CPtrC8Array : public CArrayFixFlat<TPtrC8>, public MDesC8Array
 






	{
public:
	  CPtrC8Array(TInt aGranularity);
	  ~CPtrC8Array();
 
	  void CopyL(const MDesC8Array& aArray);
    inline void operator=(const MDesC8Array& aArray);
 
      TInt MdcaCount() const;
      TPtrC8 MdcaPoint(TInt aIndex) const;
	};


class CPtrC16Array : public CArrayFixFlat<TPtrC16>, public MDesC16Array
 






	{
public:
	  CPtrC16Array(TInt aGranularity);
	  ~CPtrC16Array();
 
	  void CopyL(const MDesC16Array& aArray);
    inline void operator=(const MDesC16Array& aArray);
 
      TInt MdcaCount() const;
      TPtrC16 MdcaPoint(TInt aIndex) const;
	};


inline void CPtrC8Array::operator=(const MDesC8Array& aArray)
 








	{CopyL(aArray);}


inline void CPtrC16Array::operator=(const MDesC16Array& aArray)
 








	{CopyL(aArray);}

 


 






typedef CDesC16Array     CDesCArray;

 






typedef CDesC16ArrayFlat CDesCArrayFlat;

 






typedef CDesC16ArraySeg  CDesCArraySeg;

 












typedef CPtrC16Array CPtrCArray;
# 307 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h"








# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/basched.h" 1
 
 
 
 

 
 
 












 



const TInt KErrExtended=(-1000);
const TInt KErrExtendedWithText=(-1001);
const TInt KLeaveWithoutAlert=(-1002);
const TInt KLeaveExit=(-1003);

 


struct SExtendedError
	{
	TUid iComponent;
	TInt iErrorNumber;
	TBool iInformation;
	};

class CBaErrorHandler;

class CBaActiveScheduler : public CActiveScheduler
 



	{
public:
	  static void LeaveNoAlert();
public:  
	  static void Exit();
	  static void LeaveForAlert(TUid aComponent,TInt aErrorNumber);
	  static void LeaveForInfoPrint(TUid aComponent,TInt aErrorNumber);
	  static void LeaveForErrorHandler(const CBaErrorHandler *aHandler);
	  static const SExtendedError& ExtendedError();
	  static void DisplayExtendedError(TUid aComponent,TInt aErrorNumber);
	  virtual void DisplayError(TInt aError) const;
public: 
	  void Error(TInt aError) const;
private:
 
	  virtual void Reserved_1();
	  virtual void Reserved_2();
 
	static void ExtendedLeave(TUid aComponent,TInt aErrorNumber,TBool aLeaveForInfoPrint);
protected:
	SExtendedError iExtendedError;
	};


# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2



class CVwsSessionWrapper;
class MVwsSessionWrapperObserver;

class CCoeAppUiBase;
class CCoeEnv;
class TResourceReader;
class RGenericPointerArray;

 




enum TActivePriority
	{
	 
	EActivePriorityClockTimer=300,
	 
	EActivePriorityIpcEventsHigh=200,
	 
	EActivePriorityFepLoader=150,
	 
	EActivePriorityWsEvents=100,
	 
	EActivePriorityRedrawEvents=50,
	 
	EActivePriorityDefault=0,
	 
	EActivePriorityLogonA=-10
	};

class CCoeEnvExtra;
class CCoeStatic;


class MCoeObserverOfLoadedFep
 











	{
public:
	 


	virtual void HandleChangeInLoadedFep()=0;
private:
	  virtual void MCoeObserverOfLoadedFep_Reserved_1();
	  virtual void MCoeObserverOfLoadedFep_Reserved_2();
	};

class TCoeInputCapabilities;  


class MCoeFocusObserver
 














	{
public:
	 

	virtual void HandleChangeInFocus()=0;
	 

	virtual void HandleDestructionOfFocusedItem()=0;
private:
	  virtual void MCoeFocusObserver_Reserved_1();
	  virtual void MCoeFocusObserver_Reserved_2();
	};

class MCoeResourceChangeObserver
 






	{
public:
	 
	virtual void HandleResourceChange()=0;
private:
	  virtual void MCoeResourceChangeObserver_Reserved_1();
	  virtual void MCoeResourceChangeObserver_Reserved_2();
	};

class MCoeForegroundObserver
 














	{
public:
	 
	virtual void HandleGainingForeground()=0;
	 
	virtual void HandleLosingForeground()=0;
private:
	  virtual void MCoeForegroundObserver_Reserved_1();
	  virtual void MCoeForegroundObserver_Reserved_2();
	};


class MCoeMessageObserver
 













	{
public:
	 
	enum TMessageResponse
		{
		 
		EMessageNotHandled,
		 
		EMessageHandled
		};
public:
	 










	virtual TMessageResponse HandleMessageL(TUint32 aClientHandleOfTargetWindowGroup, TUid aMessageUid, const TDesC8& aMessageParameters)=0;
private:
	  virtual void MCoeMessageObserver_Reserved_1();
	  virtual void MCoeMessageObserver_Reserved_2();
	};

 
class MCoeFepObserver;

 



typedef void (*TCoeFepObserverFunction)(MCoeFepObserver& aFepObserver);
class CCoeFepParameters;  
class CCoeFep;  

class CCoeScheduler : public CBaActiveScheduler
 




	{
public:
	  CCoeScheduler(CCoeEnv* aCoeEnv);
	  virtual void WaitForAnyRequest();
	  virtual void DisplayError(TInt aError) const;
	 


	inline CCoeEnv* CoeEnv() {return iCoeEnv;}
	TBool Flush() const;  
	void SetFlush(TBool aFlush);  
private:
	 
	  virtual void Reserved_1();
	  virtual void Reserved_2();
private:
	CCoeEnv* iCoeEnv;
	TBool iFlush;
	};


class CCoeEnv : public CActive
 














	{
public:
	  ~CCoeEnv();
	  CCoeEnv();
	  virtual void DestroyEnvironment();
	  CCoeAppUiBase* SetAppUi(CCoeAppUiBase* aAppUi);
	  void ExecuteD();
	  void RunL();
	  void DoCancel();
	  virtual void HandleError(TInt aError);
	  void ConstructL();
	  void ConstructL(TBool aInitialFocusState);
	inline const TWsEvent& LastEvent() const;
	inline CCoeAppUiBase* AppUi() const;
	inline RFs& FsSession() const;
	inline RWsSession& WsSession() const;
	inline RWindowGroup& RootWin() const;
	inline CWindowGc& SystemGc() const;
	inline const CFont* NormalFont() const;
	inline CWsScreenDevice* ScreenDevice() const;
	inline TBool IsSchedulerRunning() const;

	  CWindowGc* CreateGcL();
	  void Flush(TTimeIntervalMicroSeconds32 aDelay=0);
	  CFbsFont* CreateDeviceFontL(CGraphicsDevice* aDevice,const TFontSpec& aFontSpec);
	  CFbsFont* CreateScreenFontL(const TFontSpec& aFontSpec);
	  void ReleaseScreenFont(CFont* aFont) const;
	  void CreateResourceReaderLC(TResourceReader& aReader,TInt aResourceId) const;
	inline void ReadResource(TDes& aDes,TInt aResourceId) const; 
	inline void ReadResourceL(TDes& aDes,TInt aResourceId) const; 
	inline  HBufC* AllocReadResourceL(TInt aResourceId) const;
	inline HBufC* AllocReadResourceLC(TInt aResourceId) const;
	  TInt AddResourceFileL(const TDesC& aFileName);
	  void DeleteResourceFile(TInt aOffset);
	inline CDesCArrayFlat* ReadDesCArrayResourceL(TInt aResourceId);
	  void LeaveWithErrorText(const TDesC& aMsg,const TDesC* aContextText= 0L );
	  void Format128(TDes& aDes,TInt aResourceId,...);
	  void Format256(TDes& aDes,TInt aResourceId,...);
	  static TVersion Version();
	  static CCoeEnv* Static();
	  void SimulateKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  TBool IsWservEventPending() const;
	  TBool IsRedrawEventPending() const;
	  void PrepareToExit();
	  void BringOwnerToFront();
	  void ReadResourceAsDes8(TDes8& aDes,TInt aResourceId) const;  
	  void ReadResourceAsDes8L(TDes8& aDes,TInt aResourceId) const;
	  HBufC8* AllocReadResourceAsDes8L(TInt aResourceId) const;
	  HBufC8* AllocReadResourceAsDes8LC(TInt aResourceId) const;
	  CDesC8ArrayFlat* ReadDesC8ArrayResourceL(TInt aResourceId);
	  void SuppressNextFlush();
	  void ReadResourceAsDes16(TDes16& aDes,TInt aResourceId) const;  
	  void ReadResourceAsDes16L(TDes16& aDes,TInt aResourceId) const; 
	  HBufC16* AllocReadResourceAsDes16L(TInt aResourceId) const;  
	  HBufC16* AllocReadResourceAsDes16LC(TInt aResourceId) const;  
	  CDesC16ArrayFlat* ReadDesC16ArrayResourceL(TInt aResourceId);  
	  void AddObserverOfLoadedFepL(MCoeObserverOfLoadedFep& aObserverOfLoadedFep);  
	  void RemoveObserverOfLoadedFep(MCoeObserverOfLoadedFep& aObserverOfLoadedFep);  
	  void AddFocusObserverL(MCoeFocusObserver& aFocusObserver);  
	  void RemoveFocusObserver(MCoeFocusObserver& aFocusObserver);  
	  void SyncNotifyFocusObserversOfChangeInFocus();
	void NotifyFocusObserversOfDestructionOfFocusedItem();  
	  void AddForegroundObserverL(MCoeForegroundObserver& aForegroundObserver);  
	  void RemoveForegroundObserver(MCoeForegroundObserver& aForegroundObserver);  
	void NotifyForegroundObserversOfGainingForeground();  
	void NotifyForegroundObserversOfLosingForeground();  
	  void AddResourceChangeObserverL(MCoeResourceChangeObserver& aResourceChangeObserver); 
	  void RemoveResourceChangeObserver(MCoeResourceChangeObserver& aResourceChangeObserver); 
	void NotifyResourceObserversOfChangeInResource(); 
	  void AddMessageObserverL(MCoeMessageObserver& aMessageObserver);  
	  void RemoveMessageObserver(MCoeMessageObserver& aMessageObserver);  
	  void AddFepObserverL(MCoeFepObserver& aFepObserver);  
	  void RemoveFepObserver(MCoeFepObserver& aFepObserver);  
	  void ForEachFepObserverCall(TCoeFepObserverFunction aFepObserverFunction);  
	void LoadFepL();  
	void LoadFepL(const TDesC& aFileNameOfFepDll);  
	  void InstallFepL(const TDesC& aFileNameOfFepDll);  
	  void InstallFepL(const TDesC& aFileNameOfFepDll, const TBool aLeave);
	  HBufC* NameOfInstalledFepL();  
	  MDesC16Array * FileNamesOfAvailableFepsL();  
	  void ExecuteFepSettingsDialogL(const TDesC& aFileNameOfFepDll);  
	  CCoeFep* Fep() const;  
	  TUid FepUid() const;  
	  CWindowGc* SwapSystemGc(CWindowGc* aGc);  
	  static CCoeStatic* Static(TUid aUid);
	  CCoeStatic* FindStatic(TUid aUid);
	  void DisableExitChecks(TBool aDisable);
	  void InputCapabilitiesChanged();  
public:  
	  CCoeFepParameters* FepParameters();
public:  
	  void GetMessageNotifyingObserversLC(TUint32 aClientHandleOfTargetWindowGroup, TUid& aMessageUid, TPtr8& aMessageParameters, const TWsEvent& aMessageEvent);
protected:  
	  void SetUpFepL(CCoeFepParameters* aFepParameters, const TDesC& aFileNameOfDefaultFepDll);
private:  
	  virtual void Reserved_1();
	  virtual void Reserved_2();
public:  
	void ReadEvent();
	CVwsSessionWrapper* InitViewServerSessionL(MVwsSessionWrapperObserver& aObserver);
	void AddStatic(CCoeStatic* aStatic);
	void QueueNotificationToFocusObserversOfChangeInFocus();
	TInt FocusObserverNotificationIdentifier() const;
	TBool FocusObserverNotificationIsStillPending(TInt aFocusObserverNotificationIdentifier) const;
protected:
	  virtual void DestroyScreen();
	inline TDes& ErrorText();
	inline TDes& ErrorContextText();
private:
	  virtual void InitSystemFontsL();
	  virtual TInt ResourceFileVersionNumber() const;
	void CreateActiveSchedulerL();
	void ConnectToFileServerL();
	void ConnectToWindowServerL();
	void InitScreenL();
	void InitRootWindowL(TBool aInitialFocusState);
	void InitSystemGcL();
	RResourceFile& ResourceFileForId(TInt aResourceId) const;
	void DestroyAllResourceFiles();
	void AddObserverL(TAny* aObserver, RGenericPointerArray& aArray);
	void RemoveObserver(TAny* aObserver, RGenericPointerArray& aArray);
	inline TBool DisableShutdownChecks() const;
	void UpdateStatic(CCoeAppUiBase* aNewAppUi);
	void SetInitialHandleCount();
	inline TUint InitialHandleCount() const;
protected:
	CCoeAppUiBase* iAppUi;
	RFs iFsSession;
	RWsSession iWsSession;
	RWindowGroup iRootWin;
	CWindowGc* iSystemGc;
	const CFont* iNormalFont;
	CWsScreenDevice* iScreen;
	TWsEvent iLastEvent;
	CArrayFix<RResourceFile>* iResourceFileArray;

private:
	enum TFlags  
		{
		ENoShutdownChecks			=0x0001,
		EExtraPointerIsErrorCode	=0x0002,
		ESchedulerIsRunning			=0x0004
		};
private:
	TDes* iErrorText;
	TDes* iErrorContextText;
	CCoeEnvExtra* iExtra;
	CTrapCleanup* iCleanup;
	TUint iEnvFlags;
	};

class CCoeStatic : public CBase
 











	{
public:
	 
	enum TScope
		{
		 
		EThread,
		 
		EApp,
		};
	 
	enum {EDefaultDestructionPriority=100};
public:
	  ~CCoeStatic();
protected:
	  CCoeStatic(TUid aUid,TScope=EThread);
	  CCoeStatic(TUid aUid,TInt aDestructionPriority,TScope aScope=EThread);
private:
	void DoConstruction(TUid aUid,TInt aDestructionPriority,TScope aScope);
	void SetCsAppUi(CCoeAppUiBase* aAppUi);
	CCoeAppUiBase* CsAppUi() const;
	TScope CsScope() const;
	inline TInt DestructionPriority() const {return iCsLink.iPriority;}
private:
	TPriQueLink iCsLink;
	TUid iCsUid;
	TUint iCsAppUiAndScope;
private:
	friend class CCoeEnv;
	friend class CCoeEnvExtra;
	};

inline const TWsEvent& CCoeEnv::LastEvent() const
 




	{ return(iLastEvent); }

inline CCoeAppUiBase* CCoeEnv::AppUi() const
 


	{ return(iAppUi); }

inline RFs& CCoeEnv::FsSession() const
 





	{ return((RFs&)iFsSession); }

inline RWsSession& CCoeEnv::WsSession() const
 





	{ return((RWsSession&)iWsSession); }

inline RWindowGroup& CCoeEnv::RootWin() const
 






	{ return((RWindowGroup&)iRootWin); }

inline CWindowGc& CCoeEnv::SystemGc() const
 





	{ return((CWindowGc&)*iSystemGc); }

inline const CFont* CCoeEnv::NormalFont() const
 





	{ return(iNormalFont); }

inline CWsScreenDevice* CCoeEnv::ScreenDevice() const
 




	{ return(iScreen); }

inline TDes& CCoeEnv::ErrorText() 
 


	{ return *iErrorText; }

inline TDes& CCoeEnv::ErrorContextText() 
 


	{ return *iErrorContextText; }


inline void CCoeEnv::ReadResource(TDes& aDes,TInt aResourceId) const
 













	{ ReadResourceAsDes16(aDes,aResourceId); }

inline void CCoeEnv::ReadResourceL(TDes& aDes,TInt aResourceId) const
 







	{ ReadResourceAsDes16L(aDes,aResourceId); }

inline  HBufC* CCoeEnv::AllocReadResourceL(TInt aResourceId) const
 







	{ return AllocReadResourceAsDes16L(aResourceId); }

inline HBufC* CCoeEnv::AllocReadResourceLC(TInt aResourceId) const
 








	{ return AllocReadResourceAsDes16LC(aResourceId); }

inline CDesCArrayFlat* CCoeEnv::ReadDesCArrayResourceL(TInt aResourceId)
 




	{ return ReadDesC16ArrayResourceL(aResourceId); }
# 613 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h"


 
 
 
 
 
 
 
 
 
inline TBool CCoeEnv::IsSchedulerRunning() const
	{return iEnvFlags&ESchedulerIsRunning;}


# 72 "../../libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 1
 
 
 
 




 


 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 1
 
 
 
 

 




 





 

 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.hrh" 1
 
 
 
 




 












 






































 




# 20 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 2













 







 


 





const TInt KUidMediaServerLibraryValue = 268450111 ;
# 60 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h"


 





const TUid KUidMediaServerLibrary = {KUidMediaServerLibraryValue};

const TUint  KUidMdaTimerFactoryValue =  268441660 ; const TUid  KUidMdaTimerFactory  = { KUidMdaTimerFactoryValue}; 

 





const TInt KMdaServerDefaultMessageSlots=-1;	 

 





const TInt KMdaUnknown = -1;

 

 







class TMdaRawPackage
	{
public:
	inline TPtr8& Package();
	inline const TPtr8& Package() const;
protected:
	TMdaRawPackage(TInt aDerivedSize);
	inline void SetSize(TInt aDerivedSize);
protected:
	TPtr8 iThis;
	friend class RDummyMdaObject;
	};


class TMdaOpenPackage : public TMdaRawPackage
 






	{
public:
	inline void SetHandleAddress(TPckgBuf<TInt>* aHandle);
	inline TPckgBuf<TInt>* GetHandleAddress() const;
	inline TMdaOpenPackage(TInt aDerivedSize);
private:
	TPckgBuf<TInt>* iHandle;
	};

 












class TMdaPackage : public TMdaRawPackage
	{
public:
	inline TUid Type() const;
	inline TUid Uid() const;
	inline void SetUid(TUid aUid);
	inline TBool operator==(const TMdaPackage& aPackage);  
protected:
	inline TMdaPackage(TUid aType, TUid aUid, TInt aDerivedSize);
private:
	TUid iType;
	TUid iUid;
	};


 






class TMdaReturnPackage : public TMdaPackage
	{
public:
	inline TInt ReturnSize() const;
protected:
	inline TMdaReturnPackage(TUid aType, TUid aUid, TInt aDerivedSize);
	inline void SetReturnSize(TInt aReturnSize);
private:
	TInt iRetSize;
	friend class RDummyMdaObject;
	};


 






class TMdaEvent
	{
public:
	TInt32 iId;
	TInt32 iArg[3];
	};


 






class TMdaObjectEvent
	{
public:
	TInt iHandle;
	TMdaEvent iEvent;
	};

 






class TMdaEventPackage : public TMdaRawPackage
	{
public:
	inline TMdaEventPackage();  
	 
	inline TInt EventCount() const;
	inline TInt MaxEvents() const;
	inline const TMdaEvent& Event();  
	inline const TMdaEvent& Event(TInt aIndex);
	inline TInt EventFrom();  
	inline TInt EventFrom(TInt aIndex);
protected:
	inline TMdaEventPackage(TInt aMaxEvents);
protected:
	TInt iMaxEvents;
	TInt iValidEvents;
	TMdaObjectEvent iFirstEvent;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.inl" 1
 
 
 
 

 

inline TPtr8& TMdaRawPackage::Package()
	{ 
	((TMdaRawPackage*)this)->iThis.Set((TUint8*)this,iThis.Length(),iThis.MaxLength()); 
	return iThis; 
	}

inline const TPtr8& TMdaRawPackage::Package() const
	{ 
	((TMdaRawPackage*)this)->iThis.Set((TUint8*)this,iThis.Length(),iThis.MaxLength()); 
	return iThis; 
	}

inline void TMdaRawPackage::SetSize(TInt aDerivedSize)
	{ 
	iThis.Set((TUint8*)this,aDerivedSize,aDerivedSize);
	}

inline void TMdaOpenPackage::SetHandleAddress(TPckgBuf<TInt>* aHandle)
	{
	iHandle = aHandle;
	}

inline TPckgBuf<TInt>* TMdaOpenPackage::GetHandleAddress() const
	{
	return iHandle;
	}

 




inline TUid TMdaPackage::Type() const
	{
	return iType; 
	}

 




inline TUid TMdaPackage::Uid() const
	{ 
	return iUid;
	}

 







inline TBool TMdaPackage::operator==(const TMdaPackage& aPackage)
	{
	return ((aPackage.Type()==Type())&&(aPackage.Uid()==Uid()));
	}

inline void TMdaPackage::SetUid(TUid aUid)
	{
	iUid = aUid;
	}

inline TInt TMdaReturnPackage::ReturnSize() const
	{ 
	return iRetSize;
	}

inline void TMdaReturnPackage::SetReturnSize(TInt aReturnSize)
	{
	iRetSize = aReturnSize;
	}

inline TMdaRawPackage::TMdaRawPackage(TInt aDerivedSize)
#pragma warning( disable : 4355 )	
: iThis((TUint8*)this,aDerivedSize,aDerivedSize) 
#pragma warning( default : 4355 )
	{ 
	}

 









inline TMdaPackage::TMdaPackage(TUid aType, TUid aUid, TInt aDerivedSize)
: TMdaRawPackage(aDerivedSize),iType(aType),iUid(aUid)
	{
	}

inline TMdaOpenPackage::TMdaOpenPackage(TInt aDerivedSize) :
TMdaRawPackage(aDerivedSize)
	{
	}

inline TMdaReturnPackage::TMdaReturnPackage(TUid aType, TUid aUid, TInt aDerivedSize)
: TMdaPackage(aType,aUid,aDerivedSize)
	{  
	iRetSize = 0;
	}	

# 232 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfbase.h" 1
 
 
 
 




 



 













enum TMdaPriority
	{
  	 



    EMdaPriorityMin = -100,
	 


    EMdaPriorityNormal = 0,
	 


    EMdaPriorityMax = 100
	};

 






enum TMdaPriorityPreference
	{
	 


    EMdaPriorityPreferenceNone =	0x00000000,
	 



    EMdaPriorityPreferenceTime =	0x00000001,
	 



    EMdaPriorityPreferenceQuality = 0x00000002,
	 



    EMdaPriorityPreferenceTimeAndQuality = EMdaPriorityPreferenceTime|EMdaPriorityPreferenceQuality
	};

 





enum TMMFState
{
	 

	EMMFStateIdle,
	 

	EMMFStatePlaying,
	 

	EMMFStateTonePlaying,
	 

	EMMFStateRecording,
	 

	EMMFStatePlayingRecording,
	 

	EMMFStateConverting
};

 






class TMMFPrioritySettings
	{
public:
	 






	TInt iPriority;

	 














	TMdaPriorityPreference iPref;

	 


	TMMFState iState;
	};

 





typedef TPckgBuf<TMMFPrioritySettings> TMMFPrioritySettingsPckg;



# 234 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 2



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 1
 
 
 
 




 


 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/port.h" 1
 
 
 
 




 


 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/port.hrh" 1
 
 
 
 








# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/port.h" 2



const TUint  KUidMdaSourcePortValue =  268450134 ; const TUid  KUidMdaSourcePort  = { KUidMdaSourcePortValue};  
const TUint  KUidMdaDestinationPortValue =  268450135 ; const TUid  KUidMdaDestinationPort  = { KUidMdaDestinationPortValue};  

 

 





enum
	{
	EMLbIoFactoryNewIO=0
	};

 





enum
	{
	EMLbPortNewBuffer=EMLbIoFactoryNewIO+1,
	EMLbPortConfig,
	EMLbPortNegotiate
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/controller.h" 1
 
 
 
 

 


# 15 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.hrh" 1
 
 
 
 






enum TMdaResourceStringType
	{
	EMdaResStringText=0x01,
	EMdaResStringData=0x02
	};

enum TMdaResourceUsage
	{
	EMdaResUsageSrc=0x01,
	EMdaResUsageDst=0x02,
	EMdaResUsageSrcAndDst=0x03  
	};

enum TMdaResourceConfigDefType
	{
	EMdaResConfigDefChoiceList=0x01,
	EMdaResConfigDefInteger=0x02,
	EMdaResConfigDefText=0x03,
	 
	EMdaResConfigDefChoiceListReadOnly=0x81,
	EMdaResConfigDefIntegerReadOnly=0x82,
	EMdaResConfigDefTextReadOnly=0x83
	};

enum TMdaResourceSigType
	{
	EMdaResSigTypeData=0,
	EMdaResSigTypeNamePattern=1,
	EMdaResSigTypeMime=2
	};






















# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 2


 
const TUint  KUidMdaResourceManagerValue =  268450122 ; const TUid  KUidMdaResourceManager  = { KUidMdaResourceManagerValue};   
const TUint  KUidMdaSourceClipValue =  268450126 ; const TUid  KUidMdaSourceClip  = { KUidMdaSourceClipValue};   
const TUint  KUidMdaDestinationClipValue =  268450127 ; const TUid  KUidMdaDestinationClip  = { KUidMdaDestinationClipValue};  
const TUint  KUidMdaClipLocationValue =  268450128 ; const TUid  KUidMdaClipLocation  = { KUidMdaClipLocationValue};   
const TUint  KUidMdaClipFormatValue =  268450129 ; const TUid  KUidMdaClipFormat  = { KUidMdaClipFormatValue};  
const TUint  KUidMdaSourceStreamValue =  268450130 ; const TUid  KUidMdaSourceStream  = { KUidMdaSourceStreamValue};   
const TUint  KUidMdaDestinationStreamValue =  268450131 ; const TUid  KUidMdaDestinationStream  = { KUidMdaDestinationStreamValue};  
const TUint  KUidMdaStreamDeviceValue =  268450132 ; const TUid  KUidMdaStreamDevice  = { KUidMdaStreamDeviceValue};   
const TUint  KUidMdaFileResLocValue =  268450124 ; const TUid  KUidMdaFileResLoc  = { KUidMdaFileResLocValue};   
const TUint  KUidMdaDesResLocValue =  268450125 ; const TUid  KUidMdaDesResLoc  = { KUidMdaDesResLocValue};  
const TUint  KUidMdaUrlResLocValue =  268450134 ; const TUid  KUidMdaUrlResLoc  = { KUidMdaUrlResLocValue};  
const TUint  KUidMdaClipDurationValue =  268450133 ; const TUid  KUidMdaClipDuration  = { KUidMdaClipDurationValue};   
const TUint  KUidMdaClipPrimeWindowValue =  268450166 ; const TUid  KUidMdaClipPrimeWindow  = { KUidMdaClipPrimeWindowValue};  
const TUint  KUidMdaClipCropValue =  268450197 ; const TUid  KUidMdaClipCrop  = { KUidMdaClipCropValue};  


 





const TInt KMdaResourceSizeUnknown = KMdaUnknown;

 



const TInt KMdaRepeatForever = -2;

 

 





enum
	{
	EMLbResourceHandleConfig=EMLbPortNegotiate+1
	};

 





enum
	{
	EMLbResourceObjectConfig=0,
	EMLbResourceObjectCreatePort=1
	};

 





enum
	{
	EMLbClipFunctionBase=EMLbResourceObjectCreatePort,
	EMLbClipLocRead,
	EMLbClipLocWrite
	};

 





enum
	{
	EMdaResourceEventIdConfigComplete,
	EMdaResourceEventIdConfigFailed,
	EMdaResourceEventIdSizeChanged,
	EMdaResourceEventIdDataChanged
	};

 

 





class TMdaResourceQuery : public TMdaPackage
	{
public:
	TMdaResourceQuery(TUid aType);
	};

 













class TMdaClipLocation : public TMdaPackage
	{
protected:
	inline TMdaClipLocation(TUid aUid, TInt aDerivedSize);
public:

	 


	TInt iSize;  

	 



	TInt iVisible;  
	};

 










class TMdaClipFormat : public TMdaPackage
	{
public:
	inline TMdaClipFormat();
protected:
	inline TMdaClipFormat(TUid aUid, TInt aDerivedSize);
	};

 





class TMdaClipFormatQuery : public TMdaClipFormat
	{
public:
	inline TMdaClipFormatQuery(TUid aUid, TInt aAdditionalSize);
	};

 





class TMdaStreamDevice : public TMdaPackage
	{
protected:
	inline TMdaStreamDevice(TUid aUid, TInt aDerivedSize);
	};

 

 







class TMdaFileClipLocation : public TMdaClipLocation
	{
public:
	inline TMdaFileClipLocation();
	inline TMdaFileClipLocation(const TDesC& aName);
public:
	 


	TBuf<256> iName;
	};

 







class TMdaDesClipLocation : public TMdaClipLocation
	{
public:
	inline TMdaDesClipLocation();
	inline TMdaDesClipLocation(TDes8& aWriteableDes);
	inline TMdaDesClipLocation(const TDesC8& aReadOnlyDes);
public:
	 


	TThreadId iThreadId;
	 


	TDesC8* iDes;
	};

 





class TMdaUrlClipLocation : public TMdaClipLocation
	{
public:
	inline TMdaUrlClipLocation();
	inline TMdaUrlClipLocation(const TDesC& aUrl, TInt aIapId, const TDesC8& aMimeType = KNullDesC8);
public:
	TBuf<256> iUrl;
	TBuf8<256> iMimeType;
	TInt iIapId;
	};


 

inline TMdaResourceQuery::TMdaResourceQuery(TUid aType) :
TMdaPackage(aType,TUid::Null() ,sizeof(TMdaResourceQuery)) {}
	
 








inline TMdaClipLocation::TMdaClipLocation(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaClipLocation,aUid,aDerivedSize) {}

 


inline TMdaClipFormat::TMdaClipFormat(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaClipFormat,aUid,aDerivedSize) {}

inline TMdaClipFormatQuery::TMdaClipFormatQuery(TUid aUid, TInt aAdditionalSize) :
TMdaClipFormat(aUid,sizeof(TMdaClipFormat)+aAdditionalSize) {}
	
inline TMdaClipFormat::TMdaClipFormat() : 
TMdaPackage(KUidMdaClipFormat,TUid::Null() ,sizeof(TMdaClipFormat)) {}

inline TMdaStreamDevice::TMdaStreamDevice(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaStreamDevice,aUid,aDerivedSize) {}

 


inline TMdaFileClipLocation::TMdaFileClipLocation() :
TMdaClipLocation(KUidMdaFileResLoc,sizeof(TMdaFileClipLocation)) {}

 





inline TMdaFileClipLocation::TMdaFileClipLocation(const TDesC& aName) :
TMdaClipLocation(KUidMdaFileResLoc,sizeof(TMdaFileClipLocation)),
iName(aName) {}

inline TMdaUrlClipLocation::TMdaUrlClipLocation() :
TMdaClipLocation(KUidMdaUrlResLoc,sizeof(TMdaUrlClipLocation)) {}

inline TMdaUrlClipLocation::TMdaUrlClipLocation(const TDesC& aUrl, TInt aIapId, const TDesC8& aMimeType) :
TMdaClipLocation(KUidMdaUrlResLoc,sizeof(TMdaUrlClipLocation)),
iUrl(aUrl),iMimeType(aMimeType), iIapId(aIapId) {}


 



inline TMdaDesClipLocation::TMdaDesClipLocation() :
TMdaClipLocation(KUidMdaDesResLoc,sizeof(TMdaDesClipLocation)),
iThreadId(RThread().Id()) {}

 





inline TMdaDesClipLocation::TMdaDesClipLocation(const TDesC8& aReadOnlyDes) :
TMdaClipLocation(KUidMdaDesResLoc,sizeof(TMdaDesClipLocation)),
iThreadId(RThread().Id()),
iDes(&(TDesC8&)aReadOnlyDes) {}

 





inline TMdaDesClipLocation::TMdaDesClipLocation(TDes8& aWriteableDes) :
TMdaClipLocation(KUidMdaDesResLoc,sizeof(TMdaDesClipLocation)),
iThreadId(RThread().Id()),
iDes(&aWriteableDes) {}


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2

 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.hrh" 1
 
 
 






 
 








































































# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audiostream.hrh" 1
 
 
 
 




 
 
 






# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2


const TUint  KUidMdaPrioritySettingsValue =  268457514 ; const TUid  KUidMdaPrioritySettings  = { KUidMdaPrioritySettingsValue}; 
const TUint  KUidMdaMediaTypeAudioValue =  268450136 ; const TUid  KUidMdaMediaTypeAudio  = { KUidMdaMediaTypeAudioValue};   
const TUint  KUidMdaLocalSoundDeviceValue =  268450137 ; const TUid  KUidMdaLocalSoundDevice  = { KUidMdaLocalSoundDeviceValue};   
const TUint  KUidMdaClipLocationMaxWriteLengthValue =  268457517 ; const TUid  KUidMdaClipLocationMaxWriteLength  = { KUidMdaClipLocationMaxWriteLengthValue}; 
const TUint  KUidMdaTelephonySoundDeviceValue =  268450187 ; const TUid  KUidMdaTelephonySoundDevice  = { KUidMdaTelephonySoundDeviceValue};   
const TUint  KUidMdaClientPCMSoundDeviceValue =  268450188 ; const TUid  KUidMdaClientPCMSoundDevice  = { KUidMdaClientPCMSoundDeviceValue};   
const TUint  KUidMdaToneGeneratorDeviceValue =  268457494 ; const TUid  KUidMdaToneGeneratorDevice  = { KUidMdaToneGeneratorDeviceValue};   
const TUint  KUidMdaClipFormatWavValue =  268450138 ; const TUid  KUidMdaClipFormatWav  = { KUidMdaClipFormatWavValue};   

const TUint  KUidMdaAudioOutputStreamDeviceValue =  268457516 ; const TUid  KUidMdaAudioOutputStreamDevice  = { KUidMdaAudioOutputStreamDeviceValue};   

const TUint  KUidMdaWavCodecValue =  268450146 ; const TUid  KUidMdaWavCodec  = { KUidMdaWavCodecValue};   
const TUint  KUidMdaWavPcmCodecValue =  268450147 ; const TUid  KUidMdaWavPcmCodec  = { KUidMdaWavPcmCodecValue};   
const TUint  KUidMdaWavAlawCodecValue =  268450148 ; const TUid  KUidMdaWavAlawCodec  = { KUidMdaWavAlawCodecValue};  
const TUint  KUidMdaWavMulawCodecValue =  268450149 ; const TUid  KUidMdaWavMulawCodec  = { KUidMdaWavMulawCodecValue};  
const TUint  KUidMdaWavImaAdpcmCodecValue =  268450150 ; const TUid  KUidMdaWavImaAdpcmCodec  = { KUidMdaWavImaAdpcmCodecValue};  


const TUint  KUidMdaClipFormatAuValue =  268450141 ; const TUid  KUidMdaClipFormatAu  = { KUidMdaClipFormatAuValue};   
const TUint  KUidMdaAuCodecValue =  268450151 ; const TUid  KUidMdaAuCodec  = { KUidMdaAuCodecValue};   
const TUint  KUidMdaAuMulawCodecValue =  268450152 ; const TUid  KUidMdaAuMulawCodec  = { KUidMdaAuMulawCodecValue};   
const TUint  KUidMdaAu8PcmCodecValue =  268450153 ; const TUid  KUidMdaAu8PcmCodec  = { KUidMdaAu8PcmCodecValue};   
const TUint  KUidMdaAu16PcmCodecValue =  268450154 ; const TUid  KUidMdaAu16PcmCodec  = { KUidMdaAu16PcmCodecValue};  
const TUint  KUidMdaAuAlawCodecValue =  268450155 ; const TUid  KUidMdaAuAlawCodec  = { KUidMdaAuAlawCodecValue}; 

const TUint  KUidMdaClipFormatRawAudioValue =  268450142 ; const TUid  KUidMdaClipFormatRawAudio  = { KUidMdaClipFormatRawAudioValue};   
const TUint  KUidMdaRawAudioCodecValue =  268450156 ; const TUid  KUidMdaRawAudioCodec  = { KUidMdaRawAudioCodecValue};   
const TUint  KUidMdaRawAudioMulawCodecValue =  268450157 ; const TUid  KUidMdaRawAudioMulawCodec  = { KUidMdaRawAudioMulawCodecValue}; 
const TUint  KUidMdaRawAudioAlawCodecValue =  268450158 ; const TUid  KUidMdaRawAudioAlawCodec  = { KUidMdaRawAudioAlawCodecValue};  
const TUint  KUidMdaRawAudioS8PcmCodecValue =  268450159 ; const TUid  KUidMdaRawAudioS8PcmCodec  = { KUidMdaRawAudioS8PcmCodecValue};   
const TUint  KUidMdaRawAudioU8PcmCodecValue =  268450160 ; const TUid  KUidMdaRawAudioU8PcmCodec  = { KUidMdaRawAudioU8PcmCodecValue};   
const TUint  KUidMdaRawAudioSL16PcmCodecValue =  268450161 ; const TUid  KUidMdaRawAudioSL16PcmCodec  = { KUidMdaRawAudioSL16PcmCodecValue};   
const TUint  KUidMdaRawAudioSB16PcmCodecValue =  268450162 ; const TUid  KUidMdaRawAudioSB16PcmCodec  = { KUidMdaRawAudioSB16PcmCodecValue};   
const TUint  KUidMdaRawAudioUL16PcmCodecValue =  268450163 ; const TUid  KUidMdaRawAudioUL16PcmCodec  = { KUidMdaRawAudioUL16PcmCodecValue};   
const TUint  KUidMdaRawAudioUB16PcmCodecValue =  268450164 ; const TUid  KUidMdaRawAudioUB16PcmCodec  = { KUidMdaRawAudioUB16PcmCodecValue};   

const TUint  KUidMdaTelephonyStateQueryValue =  268450205 ; const TUid  KUidMdaTelephonyStateQuery  = { KUidMdaTelephonyStateQueryValue};   
const TUint  KUidMdaAudioStreamVolumeRampValue =  268457498 ; const TUid  KUidMdaAudioStreamVolumeRamp  = { KUidMdaAudioStreamVolumeRampValue};   

const TUint  KUidMdaDataTypeSettingsValue =  268450121 ; const TUid  KUidMdaDataTypeSettings  = { KUidMdaDataTypeSettingsValue}; 

const TUint  KUidMdaClipFormatRawAmrValue =  268437992 ; const TUid  KUidMdaClipFormatRawAmr  = { KUidMdaClipFormatRawAmrValue};   
const TUint  KUidMdaRawAmrCodecValue =  268437991 ; const TUid  KUidMdaRawAmrCodec  = { KUidMdaRawAmrCodecValue};   

 


const TInt KMdaClipLocationMaxWriteLengthNone = -1;

 




enum TMdaAudioBufferSettings
	{
	 
	 

	EMdaAudioBufferAtPlay =		0x0000000,
	 

	EMdaAudioBufferAtPrime =	0x0000001,
	 

	EMdaAudioBufferDouble =		0x0000002,
	 

	EMdaAudioBufferSupply =		0x0000004
	};

 

 





class TMdaPrioritySettings : public TMdaPackage
	{
public:
	inline TMdaPrioritySettings();
public:
	 






	TInt iPriority;
	 














	TMdaPriorityPreference iPref;
	};

 





class TMdaClipLocationMaxWriteLength : public TMdaPackage
 	{
public:
 	inline TMdaClipLocationMaxWriteLength ();
public:
 	TInt iLength;
	};


 







class TMdaDatatypeSettings : public TMdaPackage
	{
protected:
	inline TMdaDatatypeSettings(TUid aUid,TInt aDerivedSize);
	};

inline TMdaDatatypeSettings::TMdaDatatypeSettings(TUid aUid,TInt aDerivedSize) :
TMdaPackage(KUidMdaDataTypeSettings,aUid,aDerivedSize) {}

 















class TMdaAudioDataSettings : public TMdaDatatypeSettings
	{
public:
	 



	enum TAudioCaps
		{

		 

		 


		ESampleRateFixed =		0x00000001,

		 

		ESampleRateAnyInRange = 0x00000002,

		 

		ESampleRate8000Hz =		0x00000010,

		 

		ESampleRate11025Hz =	0x00000040,

		 

		ESampleRate12000Hz =	0x00000080,

		 

		ESampleRate16000Hz =	0x00000100,

		 

		ESampleRate22050Hz =	0x00000400,

		 

		ESampleRate24000Hz =	0x00000800,

		 

		ESampleRate32000Hz =	0x00001000,

		 

		ESampleRate44100Hz =	0x00004000,

		 

		ESampleRate48000Hz =	0x00010000,

		 

		ESampleRate96000Hz =	0x00020000,

		 

		ESampleRate64000Hz =	0x00040000,

		 

		 

		EChannelsMono =			0x02000000,

		 

		EChannelsStereo =		0x04000000,

		 

		ERoutingControl =		0x08000000,

		 

		ERealTime =				0x10000000
		};

	 


	enum TAudioFlags
		{

		 

		ENoLocalRouting =		0x00000001,

		 

		ENoNetworkRouting =		0x00000002
		};
public:
	inline TMdaAudioDataSettings();
	inline void Query();  
public:
	 

	 



	TInt iCaps;

	 


	TInt iMaxVolume;  

	 
	 


	TInt iSampleRate;

	 


	TInt iChannels;

	 


	TInt iVolume;

	 


	TInt iFlags;
	};

 

 







class TMdaWavClipFormat : public TMdaClipFormat
	{
public:
	inline TMdaWavClipFormat();
	};

 









class TMdaWavCodec : public TMdaPackage
	{
public:
	inline TMdaWavCodec();  
protected:
	inline TMdaWavCodec(TUid aUid,TInt aDerivedSize);
	};

 





class TMdaCodecQuery : public TMdaPackage
	{
public:
	inline TMdaCodecQuery(TUid aType, TUid aUid,TInt aAdditionalSize);
	};

 







class TMdaPcmWavCodec : public TMdaWavCodec
	{
public:

	 


	enum TBits
		{
   		 

		E8BitPcm=0,

   		 

		E16BitPcm=1
		};
public:
	inline TMdaPcmWavCodec(TBits aBits=E16BitPcm);
public:
	 


	TBits iBits;
	};

 





class TMdaAlawWavCodec : public TMdaWavCodec
	{
public:
	inline TMdaAlawWavCodec();
	};

 





class TMdaMulawWavCodec : public TMdaWavCodec
	{
public:
	inline TMdaMulawWavCodec();
	};

 





class TMdaImaAdpcmWavCodec : public TMdaWavCodec
	{
public:
	inline TMdaImaAdpcmWavCodec();
	};


 
 







class TMdaAuClipFormat : public TMdaClipFormat
	{
public:
	inline TMdaAuClipFormat();
	};

 









class TMdaAuCodec : public TMdaPackage
	{
public:
	inline TMdaAuCodec();  
protected:
	inline TMdaAuCodec(TUid aUid,TInt aDerivedSize);
	};

 





class TMdaPcm8BitAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaPcm8BitAuCodec();
	};

 





class TMdaPcm16BitAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaPcm16BitAuCodec();
	};

 





class TMdaAlawAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaAlawAuCodec();
	};

 





class TMdaMulawAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaMulawAuCodec();
	};

 
 







class TMdaRawAudioClipFormat : public TMdaClipFormat
	{
public:
	inline TMdaRawAudioClipFormat();
	};

 















class TMdaRawAudioCodec : public TMdaPackage
	{
public:
	inline TMdaRawAudioCodec();  
protected:
	inline TMdaRawAudioCodec(TUid aUid,TInt aDerivedSize);
	};

 





class TMdaMulawRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaMulawRawAudioCodec();
	};

 





class TMdaAlawRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaAlawRawAudioCodec();
	};

 





class TMdaS8PcmRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaS8PcmRawAudioCodec();
	};

 





class TMdaU8PcmRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaU8PcmRawAudioCodec();
	};

 





class TMdaSL16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaSL16RawAudioCodec();
	};

 





class TMdaSB16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaSB16RawAudioCodec();
	};

 





class TMdaUL16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaUL16RawAudioCodec();
	};

 





class TMdaUB16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaUB16RawAudioCodec();
	};

 







class TMdaLocalAudioDevice : public TMdaStreamDevice
	{
public:
	inline TMdaLocalAudioDevice();
	};

 







class TMdaTelephonyAudioDevice : public TMdaStreamDevice
	{
public:
	inline TMdaTelephonyAudioDevice();
	};

 






class TMdaTelephonyStateQuery : public TMdaPackage
	{
public:
	inline TMdaTelephonyStateQuery();
public:
	TBool iIsTelephonyActive;
	};

 






class TMdaClientPCMAudioDevice : public TMdaStreamDevice
	{
public:
	inline TMdaClientPCMAudioDevice();
	};


 





class TMdaAudioStreamVolumeRamp : public TMdaPackage
	{
public:
	inline TMdaAudioStreamVolumeRamp();
public:
	TTimeIntervalMicroSeconds iDuration;
	};

 





enum TMdaToneGeneratorFunction
	{
	EMdaToneGeneratorConfig=0,
	EMdaToneGeneratorGetFixedNames=1,
	EMdaToneGeneratorPlay=2
	};

 





enum TMdaToneType  
	{
	EMdaToneTypeSimple,
	EMdaToneTypeDTMF,
	EMdaToneTypeDesSeq,
	EMdaToneTypeFileSeq,
	EMdaToneTypeFixedSeq
	};

 





class TMdaToneGeneratorConfig : public TMdaReturnPackage
	{
public:
	inline TMdaToneGeneratorConfig();
	inline void SetReturnSize(TInt aReturnSize);
public:
	enum TMask
		{
		EPrepare		= 0x1,
		EVolumeChange	= 0x2,
		EPriorityChange = 0x4,
		EDTMFLengths    = 0x8,
		ESetRepeat		= 0x10,
		EVolumeRamp		= 0x20
		};
public:
	TUint32 iMask;
	TInt iVolume;
	TInt iMaxVolume;
	TInt iPriority;
	TMdaPriorityPreference iPref;
	TTimeIntervalMicroSeconds32 iDtmfToneOnLength;
	TTimeIntervalMicroSeconds32 iDtmfToneOffLength;
	TTimeIntervalMicroSeconds32 iDtmfPauseLength;
	TMdaToneType iType;
	TInt iFrequency;
	TTimeIntervalMicroSeconds iDuration;
	const TDesC8* iDes;
	TInt iDesLength;
	TInt iFixedSequenceNumber;
	TTimeIntervalMicroSeconds iRepeatTrailingSilence;
	TInt iRepeatCount;
	TTimeIntervalMicroSeconds iRampDuration;
	};

enum TMdaAudioOutputFunction
	{
	EMdaAudioOutputPrepare=0,
	EMdaAudioOutputConfig=1,
	EMdaAudioOutputWrite=2,
	EMdaAudioOutputStop=3,
	EMdaAudioOutputPlay=4
	};

 





class TMdaAudioOutputConfig : public TMdaReturnPackage
	{
public:
	inline TMdaAudioOutputConfig();
	inline void SetReturnSize(TInt aReturnSize);
public:
	enum TMask
		{
		ENull = 0x0,
		EQuery	= 0x1,
		EVolumeChange		= 0x2,
		EPriorityChange		= 0x4,
		EChannelsChange		= 0x8,
		ESampleRateChange	= 0x10
		};
public:
	TUint32 iMask;
	TInt						iPriority;
	TTimeIntervalMicroSeconds	iPosition;
	TInt						iMaxVolume;
	TInt						iVolume;
	TInt						iNumChannels;
	TInt						iSampleRate;
	TMdaPriorityPreference		iPref;
	};

 





class TMdaToneFixedSequenceNames : public TMdaRawPackage
	{
public:
	inline TMdaToneFixedSequenceNames();
public:
	TInt iCount;
	};

 

 


inline TMdaAudioDataSettings::TMdaAudioDataSettings() :
TMdaDatatypeSettings(KUidMdaMediaTypeAudio,sizeof(TMdaAudioDataSettings)) 
	{
	Mem::FillZ(&iSampleRate,sizeof(TInt)*4);
	}

 



inline void TMdaAudioDataSettings::Query()
	{
	iChannels = KMdaUnknown;
	iSampleRate = KMdaUnknown;
	iVolume = KMdaUnknown;
	} 

 


inline TMdaWavClipFormat::TMdaWavClipFormat() :
TMdaClipFormat(KUidMdaClipFormatWav,sizeof(TMdaWavClipFormat)) {}

 


inline TMdaWavCodec::TMdaWavCodec() :
TMdaPackage(KUidMdaWavCodec,TUid::Null() ,sizeof(TMdaWavCodec)) {}

inline TMdaCodecQuery::TMdaCodecQuery(TUid aType, TUid aUid,TInt aAdditionalSize) :
TMdaPackage(aType,aUid,sizeof(TMdaCodecQuery)+aAdditionalSize) {}

inline TMdaWavCodec::TMdaWavCodec(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaWavCodec,aUid,aDerivedSize) {}

 





inline TMdaPcmWavCodec::TMdaPcmWavCodec(TBits aBits) :
TMdaWavCodec(KUidMdaWavPcmCodec,sizeof(TMdaPcmWavCodec)), iBits(aBits) {}

 


inline TMdaAlawWavCodec::TMdaAlawWavCodec() :
TMdaWavCodec(KUidMdaWavAlawCodec,sizeof(TMdaAlawWavCodec)) {}

 


inline TMdaMulawWavCodec::TMdaMulawWavCodec() :
TMdaWavCodec(KUidMdaWavMulawCodec,sizeof(TMdaMulawWavCodec)) {}

 


inline TMdaImaAdpcmWavCodec::TMdaImaAdpcmWavCodec() :
TMdaWavCodec(KUidMdaWavImaAdpcmCodec,sizeof(TMdaImaAdpcmWavCodec)) {}

 


inline TMdaAuClipFormat::TMdaAuClipFormat() :
TMdaClipFormat(KUidMdaClipFormatAu,sizeof(TMdaAuClipFormat)) {}

 


inline TMdaAuCodec::TMdaAuCodec() :
TMdaPackage(KUidMdaAuCodec,TUid::Null() ,sizeof(TMdaAuCodec)) {}

inline TMdaAuCodec::TMdaAuCodec(TUid aUid,TInt aDerivedSize) :
TMdaPackage(KUidMdaAuCodec,aUid,aDerivedSize) {}

 


inline TMdaPcm16BitAuCodec::TMdaPcm16BitAuCodec() :
TMdaAuCodec(KUidMdaAu16PcmCodec,sizeof(TMdaPcm16BitAuCodec)) {}

 


inline TMdaPcm8BitAuCodec::TMdaPcm8BitAuCodec() :
TMdaAuCodec(KUidMdaAu8PcmCodec,sizeof(TMdaPcm8BitAuCodec)) {}

 


inline TMdaAlawAuCodec::TMdaAlawAuCodec() :
TMdaAuCodec(KUidMdaAuAlawCodec,sizeof(TMdaAlawAuCodec)) {}

 


inline TMdaMulawAuCodec::TMdaMulawAuCodec() :
TMdaAuCodec(KUidMdaAuMulawCodec,sizeof(TMdaMulawAuCodec)) {}

 


inline TMdaRawAudioClipFormat::TMdaRawAudioClipFormat() :
TMdaClipFormat(KUidMdaClipFormatRawAudio,sizeof(TMdaRawAudioClipFormat)) {}

 


inline TMdaRawAudioCodec::TMdaRawAudioCodec() :
TMdaPackage(KUidMdaRawAudioCodec,TUid::Null() ,sizeof(TMdaRawAudioCodec)) {}

inline TMdaRawAudioCodec::TMdaRawAudioCodec(TUid aUid,TInt aDerivedSize) :
TMdaPackage(KUidMdaRawAudioCodec,aUid,aDerivedSize) {}

 


inline TMdaMulawRawAudioCodec::TMdaMulawRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioMulawCodec,sizeof(TMdaMulawRawAudioCodec)) {}

 


inline TMdaAlawRawAudioCodec::TMdaAlawRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioAlawCodec,sizeof(TMdaAlawRawAudioCodec)) {}

 


inline TMdaS8PcmRawAudioCodec::TMdaS8PcmRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioS8PcmCodec,sizeof(TMdaS8PcmRawAudioCodec)) {}

 


inline TMdaU8PcmRawAudioCodec::TMdaU8PcmRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioU8PcmCodec,sizeof(TMdaU8PcmRawAudioCodec)) {}

 


inline TMdaSL16RawAudioCodec::TMdaSL16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioSL16PcmCodec,sizeof(TMdaSL16RawAudioCodec)) {}

 


inline TMdaSB16RawAudioCodec::TMdaSB16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioSB16PcmCodec,sizeof(TMdaSB16RawAudioCodec)) {}

 


inline TMdaUL16RawAudioCodec::TMdaUL16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioUL16PcmCodec,sizeof(TMdaUL16RawAudioCodec)) {}

 


inline TMdaUB16RawAudioCodec::TMdaUB16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioUB16PcmCodec,sizeof(TMdaUB16RawAudioCodec)) {}

inline TMdaLocalAudioDevice::TMdaLocalAudioDevice() : 
TMdaStreamDevice(KUidMdaLocalSoundDevice,sizeof(TMdaLocalAudioDevice)) {}

inline TMdaTelephonyAudioDevice::TMdaTelephonyAudioDevice() : 
TMdaStreamDevice(KUidMdaTelephonySoundDevice,sizeof(TMdaTelephonyAudioDevice)) {}

inline TMdaClientPCMAudioDevice::TMdaClientPCMAudioDevice() : 
TMdaStreamDevice(KUidMdaClientPCMSoundDevice,sizeof(TMdaClientPCMAudioDevice)) {}

inline TMdaAudioStreamVolumeRamp::TMdaAudioStreamVolumeRamp() :
TMdaPackage(KUidMdaAudioStreamVolumeRamp,KUidMdaAudioStreamVolumeRamp,sizeof(TMdaAudioStreamVolumeRamp)) {}

inline TMdaTelephonyStateQuery::TMdaTelephonyStateQuery() :
TMdaPackage(KUidMdaTelephonySoundDevice,KUidMdaTelephonyStateQuery,sizeof(TMdaTelephonyStateQuery)) {}
 
inline TMdaToneGeneratorConfig::TMdaToneGeneratorConfig() :
TMdaReturnPackage(KUidMdaToneGeneratorDevice,KUidMdaToneGeneratorDevice,sizeof(TMdaToneGeneratorConfig)) {}

inline void TMdaToneGeneratorConfig::SetReturnSize(TInt aReturnSize)
	{ TMdaReturnPackage::SetReturnSize(aReturnSize); }

inline TMdaAudioOutputConfig::TMdaAudioOutputConfig() : 
TMdaReturnPackage(KUidMdaAudioOutputStreamDevice,KUidMdaAudioOutputStreamDevice,sizeof(TMdaAudioOutputConfig)) {}

inline void TMdaAudioOutputConfig::SetReturnSize(TInt aReturnSize)
	{ TMdaReturnPackage::SetReturnSize(aReturnSize); }


inline TMdaToneFixedSequenceNames::TMdaToneFixedSequenceNames() :
TMdaRawPackage(sizeof(TMdaToneFixedSequenceNames)) {}


inline TMdaPrioritySettings::TMdaPrioritySettings() :
TMdaPackage(KUidMdaPrioritySettings,KUidMdaPrioritySettings,sizeof(TMdaPrioritySettings)) {}

inline TMdaClipLocationMaxWriteLength::TMdaClipLocationMaxWriteLength() :
 TMdaPackage(KUidMdaClipLocationMaxWriteLength,KUidMdaClipLocationMaxWriteLength,sizeof(TMdaClipLocationMaxWriteLength)) {}


# 73 "../../libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mdaaudiooutputstream.h" 1
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 1
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasourcesink.hrh" 1
 
 
 





 
 

const TUid KUidMmfDataPath		= {0x101F5D06}; 
const TUid KUidMmfFormatDecode	= {0x101F5D04}; 
const TUid KUidMmfFormatEncode	= {0x101F5D05};
const TUid KUidMmfAudioOutput	= {0x101F53B9};  
const TUid KUidMmfAudioInput	= {0x101F53BB}; 

 
const TUint KMmfUidFileSource		= 0x101F53B1;
const TUint KMmfUidFileSink			= 0x101F53B3;
const TUint KMmfUidDescriptorSource = 0x101F53B2;
const TUint KMmfUidDescriptorSink	= 0x101F53B4; 
const TUint KMmfUidUrlSource		= 0x101F6068;
const TUint KMmfUidUrlSink		= 0x101F6069;

const TUid KUidMmfFileSource		= {KMmfUidFileSource}; 
const TUid KUidMmfFileSink			= {KMmfUidFileSink}; 
const TUid KUidMmfDescriptorSource	= {KMmfUidDescriptorSource};
const TUid KUidMmfDescriptorSink	= {KMmfUidDescriptorSink}; 
const TUid KUidMmfUrlSource		= {KMmfUidUrlSource};
const TUid KUidMmfUrlSink		= {KMmfUidUrlSink};

 
static const TUid KUidMediaTypeAudio	= {0x101F5D07};
static const TUid KUidMediaTypeVideo	= {0x101F5D08};
static const TUid KUidMediaTypeMidi	= {0x101F7D02};




# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatabuffer.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32transbuf.h" 1
 
 
 
 
 











enum TTransferBufferType
	{
	ETransferBufferFixedContiguous,
	ETransferBufferContiguous,
	ETransferBufferNonContiguous
	};

class RTransferWindow;

 





class RTransferBuffer : public RHandleBase
	{
	public:
		  TInt Create(TInt aBufferSize);
		  TInt GetBufferSize() const;
	};

 





class RTransferWindow : public RHandleBase
	{
	public:
		  TInt Create(TInt aMaxBufferSize);
		  TInt Open(RTransferBuffer& aBuffer);
		  TInt MapInBuffer(const RTransferBuffer& aBuffer) const;
		  void WaitForBuffer() const;
		  void WaitForBuffer(TRequestStatus& aStatus) const;
		  void CancelWaitForBuffer() const;
		  void MapOutBuffer() const;
		  void WaitForBufferFree() const;
		  void WaitForBufferFree(TRequestStatus& aStatus) const;
		  void CancelWaitForBufferFree() const;
		  TUint8* GetBufferAddress() const;
		  TInt GetBufferSize() const;
	};



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatabuffer.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfbuffer.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfbuffer.hrh" 1
 
 
 




static const TUid KUidMmfDataBuffer			= {0x101F5D09}; 
static const TUid KUidMmfDescriptorBuffer 		= {0x101F5D09};
static const TUid KUidMmfTransferBuffer			= {0x101F5E66};
static const TUid KUidMmfAudioBuffer			= {0x101F72A9};
static const TUid KUidMmfYUVBuffer			= {0x101F5D0A};
static const TUid KUidMmfBitmapFrameBuffer		= {0x101F5D0B};
static const TUid KUidMmfPtrBuffer			= {0x101FD90B};




# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfbuffer.h" 2



 





enum TBufferStatus
	{
	 
	EAvailable,

	 
	EBeingFilled,

	 
	EFull,

	 
	EBeingEmptied,

	 
	EUnAvailable
	};


 





class CMMFBuffer : public CBase
	{
public:
	  static TBool IsSupportedDataBuffer(TUid aUid);
	  static TBool IsFileServerSafe(TUid aUid);
	 




	TUid Type() const {return iType;};
	 





	virtual void SetStatus(TBufferStatus aStatus) 
			{iStatus = aStatus; if (iStatus == EAvailable) iPosition = 0;}
	 




	TBufferStatus Status() {return iStatus;};

	 






	virtual TUint BufferSize() const = 0;

	 


	virtual ~CMMFBuffer() {};
	inline TTimeIntervalMicroSeconds TimeToPlay() const;
	inline void SetTimeToPlay (TTimeIntervalMicroSeconds aTime);
	inline TUint FrameNumber() const;
	inline void SetFrameNumber(TUint aFrame);
	inline void NextFrame();
	inline virtual void SetPosition (TUint aPosition);
	inline virtual TUint Position() const;
	inline virtual TInt RequestSize() const;
	inline void SetLastBuffer(TBool aLastBuffer);
	inline TBool LastBuffer() const;
protected:
	CMMFBuffer(TUid aType): iType(aType), iStatus(EAvailable) {};	

protected:
	 


	TUid iType;

	 




	TBufferStatus iStatus;

	 


	TTimeIntervalMicroSeconds iTimeToPlay;

	 



	TUint iPosition;

	 


	TUint iFrameNumber;

	 


	TInt iRequestSize;

	 


	TBool iLastBuffer; 
	};

 




inline TTimeIntervalMicroSeconds CMMFBuffer::TimeToPlay() const
	{
	return iTimeToPlay;
	}

 





inline void CMMFBuffer::SetTimeToPlay (TTimeIntervalMicroSeconds aTime)
	{
	iTimeToPlay = aTime;
	}

 




inline TUint CMMFBuffer::FrameNumber() const
	{
	return iFrameNumber;
	}

 





inline void CMMFBuffer::SetFrameNumber (TUint aFrameNumber)
	{
	iFrameNumber = aFrameNumber;
	}

 


inline void CMMFBuffer::NextFrame()
	{
	iFrameNumber++;
	}


 







inline void CMMFBuffer::SetPosition (TUint aPosition)
	{
	iPosition = aPosition;
	}

 






inline TUint CMMFBuffer::Position() const
	{
	return iPosition;
	}

 





inline TBool CMMFBuffer::LastBuffer() const
	{
	return iLastBuffer;
	}

 






inline void CMMFBuffer::SetLastBuffer(TBool aLastBuffer)
	{
	iLastBuffer = aLastBuffer;
	}

 




inline TInt CMMFBuffer::RequestSize() const
	{
	return iRequestSize;
	}


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatabuffer.h" 2


 





static const TInt KMMFDataBufferDefaultBufferSize = 32;

 








class CMMFDataBuffer : public CMMFBuffer
	{
public:
	  static CMMFDataBuffer* NewL();
	  static CMMFDataBuffer* NewL(TInt aMaxBufferSize);
	 


	virtual ~CMMFDataBuffer() {};

	 






	virtual TDes8& Data() = 0;

	 






	virtual const TDesC8& Data() const = 0;

	 






	virtual TUint BufferSize() const = 0;

	 











	virtual void SetRequestSizeL(TInt aSize) = 0;
protected:
	 


	CMMFDataBuffer(TUid aType): CMMFBuffer(aType) {};
	};


 









class CMMFDescriptorBuffer : public CMMFDataBuffer
	{
public:
	  static CMMFDescriptorBuffer* NewL();
	  static CMMFDescriptorBuffer* NewL(TInt aMaxBufferSize);
	  ~CMMFDescriptorBuffer();
	  void ReAllocBufferL(TInt aMaxBufferSize);
	virtual TDes8& Data();
	virtual const TDesC8& Data() const;
	virtual void SetStatus(TBufferStatus aStatus);
	virtual void SetRequestSizeL(TInt aSize);
	virtual TUint BufferSize() const;
	virtual void SetPosition (TUint aPosition);
private:
	CMMFDescriptorBuffer() : CMMFDataBuffer(KUidMmfDescriptorBuffer), iPtr(0,0,0) {};
	void ConstructL(TInt aMaxBufferSize);
private:
	TUint8* iData;
	TPtr8 iPtr;
	};


 













class CMMFTransferBuffer : public CMMFDataBuffer
	{
public:
	  static CMMFTransferBuffer* NewL(RTransferWindow& aTransferWindow, TUint aDataLength = 0);
	  ~CMMFTransferBuffer();
	virtual TDes8& Data();
	virtual const TDesC8& Data() const;
	virtual TUint BufferSize() const;
	virtual void SetRequestSizeL(TInt aSize);
	virtual void SetPosition (TUint aPosition);
	  RTransferWindow& TransferWindow();
	  void MapOutBuffer();
	  TInt UpdateTransferWindow(RTransferWindow& aTransferWindow, TUint aDataLength = 0);
private:
	 


	CMMFTransferBuffer() : CMMFDataBuffer(KUidMmfTransferBuffer), iPtr(0,0,0){};
	void ConstructL(RTransferWindow& aTransferWindow, TUint aDataLength);
private:
	RTransferWindow iTransferWindow;
	TBool iTransferWindowMappedInOK;
	TPtr8 iPtr;
	};

 











class CMMFPtrBuffer : public CMMFDataBuffer
	{
public:
	  static CMMFPtrBuffer* NewL();		 
	  static CMMFPtrBuffer* NewL(const TPtr8& aPtr);
	  ~CMMFPtrBuffer();
	  void SetPtr(const TPtr8& aPtr);
	virtual TDes8& Data();
	virtual const TDesC8& Data() const;
	virtual void SetStatus(TBufferStatus aStatus);	
	virtual void SetRequestSizeL(TInt aSize);
	virtual TUint BufferSize() const;
	virtual void SetPosition (TUint aPosition);
private:
	CMMFPtrBuffer() : CMMFDataBuffer(KUidMmfPtrBuffer), iPtr(0,0,0) {};
	void ConstructL(const TPtr8& aPtr);
private:
	TPtr8 iPtr;
	};


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmffourcc.h" 1
 





 
 
 
 




 

 

const TUint32 KMMFFourCCCodePCM8 = 0x38502020;		 

 

const TUint32 KMMFFourCCCodePCMU8 = 0x38555020;		 

 

const TUint32 KMMFFourCCCodePCM16 = 0x36315020;		 

 

const TUint32 KMMFFourCCCodePCMU16 = 0x36315550;	 

 

const TUint32 KMMFFourCCCodePCM16B = 0x42363150;	 

 

const TUint32 KMMFFourCCCodePCMU16B = 0x42365550;	 

 

const TUint32 KMMFFourCCCodeIMAD = 0x44414d49;		 

 

const TUint32 KMMFFourCCCodeIMAS = 0x53414d49;		 

 

const TUint32 KMMFFourCCCodeALAW = 0x57414c41;		 

 

const TUint32 KMMFFourCCCodeMuLAW = 0x57414c75;		 

 

const TUint32 KMMFFourCCCodeGSM610 = 0x364d5347;	 

 

const TUint32 KMMFFourCCCodeNULL = 0x4c4c554e;		 

 

const TUint32 KMMFFourCCCodeAMR = 0x524d4120;		 

 

const TUint32 KMMFFourCCCodeAAC = 0x43414120;		 

 

const TUint32 KMMFFourCCCodeAWB = 0x42574120;		 

 

const TUint32 KMMFFourCCCodeMP3 = 0x33504d20;		 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 1
 
 
 
 
# 369 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h"


# 81 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmffourcc.h" 2




# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 2



 





class TMediaId
	{
public:

	 











	TMediaId(TUid aMediaType, TUint aStreamId) : iMediaType(aMediaType), iStreamId(aStreamId) {};

	 








	TMediaId(TUid aMediaType) : iMediaType(aMediaType), iStreamId(0) {};

	 


	TMediaId() : iMediaType(TUid::Null() ), iStreamId(0) {};
public:
	 


	TUid iMediaType;

	 



	TUint iStreamId;
	};

 





const TInt KFourCCNULL = KMMFFourCCCodeNULL;

 









class TFourCC
{
public:

	 


	TFourCC() {iFourCC = KMMFFourCCCodeNULL;}  

	 















	TFourCC(TUint8 aChar1, TUint8 aChar2, TUint8 aChar3, TUint8 aChar4) {iFourCC =(aChar4<<24)+(aChar3<<16)+(aChar2<<8)+aChar1;}

	 






	TFourCC(const TDesC8& aDes) {iFourCC =(aDes[3]<<24)+(aDes[2]<<16)+(aDes[1]<<8)+aDes[0];}

	 





	TFourCC(TInt32 aFourCC) {iFourCC = aFourCC;}

	 




	TUint32 FourCC() {return iFourCC;}
	inline void FourCC( TPtr8* aDes ) const ;

	 





	void Set(TFourCC aFourCC) {iFourCC = aFourCC.iFourCC;}

	 





	void Set(TUint32 aFourCC) {iFourCC = aFourCC;}

	 








	TBool operator==(const TFourCC& aA) const {return (iFourCC == aA.iFourCC);}

	 








	TBool operator==(const TUint32& aUint) const {return (iFourCC == aUint);}

	 








	TBool operator!=(const TFourCC& aA) const {return (iFourCC != aA.iFourCC);}

	 





	TBool operator!=(const TUint32& aUint) const {return (iFourCC != aUint);}

private:
	TUint32 iFourCC;
};

 







inline void TFourCC::FourCC( TPtr8* aDes ) const
	{
	TUint8 char1 = TUint8( iFourCC ) ;
	TUint8 char2 = TUint8( iFourCC >> 8 ) ;
	TUint8 char3 = TUint8( iFourCC >> 16 ) ;
	TUint8 char4 = TUint8( iFourCC >> 24 ) ;

	aDes->Format( (TPtrC8((const TText8 *)( "%1c%1c%1c%1c" ))) , char1, char2, char3, char4 ) ;
	}

 




class CMMFChannelAndSampleRateConverter : public CBase
	{
public:
	 











	virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer) =0;
	virtual void Reset() {};

	 


	virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize) {return aSrcBufferSize;}

	void SetRates(TInt aSrcRate,TInt aSrcChannels,TInt aDstRate,TInt aDstChannels);
public:
	 


	TInt iFromRate;
	 


	TInt iToRate;
	 


	TInt iFromChannels;
	 


	TInt iToChannels;
protected:
	TReal iRatio;
	TInt iFraction;
	TInt iIndex;
	};

 


class CMMFStereoToMonoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);

	};

 


class CMMFStereoToMonoConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);
	};

 


class CMMFStereoToStereoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
	};

 


class CMMFMonoToMonoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
	};

 


class CMMFMonoToStereoConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);
	};

 


class CMMFMonoToStereoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);
	};

 





class CMMFChannelAndSampleRateConverterFactory : public CBase
	{





public:
	  CMMFChannelAndSampleRateConverter* CreateConverterL(TInt aFromRate,TInt aFromChannels,
												 TInt aToRate,TInt aToChannels);
	  CMMFChannelAndSampleRateConverter* CreateConverterL();
	CMMFChannelAndSampleRateConverter* Converter() {return iConverter;}
	  ~CMMFChannelAndSampleRateConverterFactory();
	TInt Rate() {return iToRate;}
	TInt Channels() {return iToChannels;}
public:
	 


	TInt iFromRate;
	 


	TInt iToRate;
	 


	TInt iFromChannels;
	 


	TInt iToChannels;
private:
	CMMFChannelAndSampleRateConverter* iConverter;
	};





# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 1
 
 
 
 

 






 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 19 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 20 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomerrorcodes.h" 1
 
 
 
 

 




 




 
 
const TInt KEComErrBase								= -17000;

 
 
const TInt KEComErrLast								= -17030;

 
 
 
 




const TInt KEComErrNoInterfaceIdentified			= -17004;

 




const TInt KEComErrNoResolver						= -17014;

 




const TInt KEComErrTooManyNotificationsOutstanding	= -17026;

 





const TInt KEComErrMissingParameter					= -17028;

 



const TInt KEComErrListInvalidAwaitNotification		= -17029;

 




const TInt KEComErrListCurrentlyUnavailable			= -17030;


 
 
 
 



const TInt KEComErrInvalidUnloadPolicy				= -17003;

 




const TInt KEComErrInvalidIIC						= -17008;

 




const TInt KEComErrDriveNotFound					= -17019;


 
 
 
 



const TInt KEComErrUnknownService					= -17002;

 



const TInt KEComErrReferenceCountInvalid			= -17013;

 



const TInt KEComErrDestructionFailed				= -17017;

 




const TInt KEComErrInvalidRegistryData				= -17022;

 





const TInt KEComErrDestroyingWithNullDtorKey		= -17027;


 
 
 
 


const TInt KEComErrAlreadyReceiving					= -17001;

 



const TInt KEComErrEnableFailed						= -17005;

 



const TInt KEComErrDisableFailed					= -17006;

 




const TInt KEComErrNoRegistrationsFound				= -17007;

 



const TInt KEComErrUninstallFailed					= -17009;

 



const TInt KEComErrReinstallFailed					= -17010;

 



const TInt KEComErrRegistrationFailed				= -17011;

 



const TInt KEComErrNotConnected						= -17012;

 



const TInt KEComErrSuspendFailed					= -17015;

 



const TInt KEComErrResumeFailed						= -17016;

 




const TInt KEComErrDriveAlreadyInstalled			= -17018;

 


const TInt KEComErrIndexEntryNotFound				= -17020;

 




const TInt KEComErrNoRegistrationData				= -17021;

 


const TInt KEComErrMismatchedTags					= -17023;

 


const TInt KEComErrInstantiationPointerNotFound		= -17024;

 


const TInt KEComErrInstantiationPointerNotAvailable = -17025;


# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomresolverparams.h" 1
 
 
 
 

 





 






 
 















 
class TEComResolverParams
	{
public:
	 
	inline TEComResolverParams();
	
	 
	inline const TDesC8& DataType() const;
	 
	inline void SetDataType(const TDesC8& aDataType);
	
	inline TBool IsGenericMatch() const;
	inline void SetGenericMatch(TBool aGenericMatch);

	 
	 
	inline TBool IsWildcardMatch() const;
	 
	inline void SetWildcardMatch(TBool aWildcardMatch);

private:
	 
	 
	TPtrC8 iDataType;
	 
	TBool iGenericMatch;
	};


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomresolverparams.inl" 1
 
 
 
 

 





 


 
 
 
 
 

 




TEComResolverParams::TEComResolverParams()
:	iDataType(0L ,0),
	iGenericMatch(EFalse)
	{
	 
	}


 






 
const TDesC8& TEComResolverParams::DataType() const
	{
	return iDataType;
	}


 







 
void TEComResolverParams::SetDataType(const TDesC8& aDataType)
	{
	iDataType.Set(aDataType);
	}

 






TBool TEComResolverParams::IsGenericMatch() const
	{
	return iGenericMatch;
	}

 


























void TEComResolverParams::SetGenericMatch(TBool aGenericMatch)
	{
	iGenericMatch=aGenericMatch;
	}
	

 






 
TBool TEComResolverParams::IsWildcardMatch() const
	{
	return iGenericMatch;
	}


 







 
void TEComResolverParams::SetWildcardMatch(TBool aWildcardMatch)
	{
	iGenericMatch=aWildcardMatch;
	}




# 66 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomresolverparams.h" 2



# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 1
 
 
 
 

 



 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 15 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 2


 
 
 

































 
class CImplementationInformation : public CBase
	{
public:
	 
	static CImplementationInformation* NewLC(RReadStream& aStream);
	 
	static CImplementationInformation* NewL(TUid	aUid, 
											TInt	aVersion, 
											HBufC*  aName,
											HBufC8* aDataType,
											HBufC8* aOpaqueData,
											TDriveUnit aDrive,
											TBool aRomOnly,
											TBool aRomBased);
	 
	static CImplementationInformation* NewL(const CImplementationInformation& aImplInfo);
	 
	~CImplementationInformation();
	 
	inline const TDesC& DisplayName() const;
	 
	inline const TDesC8& DataType() const;
	 
	inline const TDesC8& OpaqueData() const;
	 
	inline TUid ImplementationUid() const;
	 
	inline TInt Version() const;
	 
	inline TBool Disabled() const;
	 
	inline void SetDisabled(TBool aDisabled);
	 
	void ExternalizeL(RWriteStream& aStream) const;
	 
	void InternalizeL(RReadStream& aStream);
	inline TDriveUnit Drive() const;
	inline TBool RomOnly() const;
	inline TBool RomBased() const;
	void SetRomBased(TBool aRomBased);

private:
	 
	CImplementationInformation();
	 
	CImplementationInformation(TUid aUid, 
							   TInt aVersion, 
							   HBufC*  aName, 
							   HBufC8* aDataType,
							   HBufC8* aOpaqueData,
							   TDriveUnit aDrive,
							   TBool aRomOnly,
							   TBool aRomBased);

private:
	 
	 
	TUid		iImplementationUid;
	 
	 
	TInt		iVersion;
	 
	 
	HBufC*		iDisplayName;
	 




	 
	HBufC8*		iData;
	 



	 
	HBufC8*		iOpaqueData;
	  
	 
	TBool		iDisabled;
	  
	TDriveUnit		iDrive;
	 
	TBool iRomOnly;
	 
	TBool iRomBased;
	};	 

 



typedef RArray<CImplementationInformation*> RImplInfoArray;

 



typedef RPointerArray<CImplementationInformation> RImplInfoPtrArray;


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.inl" 1
 
 
 
 

 



 

 
 
 
 

 





const TDesC& CImplementationInformation::DisplayName() const
	{
	if(iDisplayName == 0L )
		return KNullDesC();
	else
		return *iDisplayName;
	}


 





const TDesC8& CImplementationInformation::DataType() const
	{
	if(iData == 0L )
		return KNullDesC8();
	else
		return *iData;
	}


 





const TDesC8& CImplementationInformation::OpaqueData() const
	{
	if(iOpaqueData == 0L )
		return KNullDesC8();
	else
		return *iOpaqueData;
	}


 





TUid CImplementationInformation::ImplementationUid() const
	{
	return iImplementationUid;
	}


 





TInt CImplementationInformation::Version() const
	{
	return iVersion;
	}


 






TBool CImplementationInformation::Disabled() const
	{
	return iDisabled;
	}


 






void CImplementationInformation::SetDisabled(TBool aDisabled)
	{
	iDisabled = aDisabled;
	}

 






TDriveUnit CImplementationInformation::Drive() const
	{
	return iDrive;
	}


 





TBool CImplementationInformation::RomOnly() const
	{
	return iRomOnly;
	}

 





TBool CImplementationInformation::RomBased() const
	{
	return iRomBased;
	}
# 156 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 2



# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2


 
 
 


const TInt KMaxServiceArgs = 4;

 





const TUid KRomOnlyResolverUid = {0x10009D92};

 













 
class REComSession  : public RSessionBase
	{
public:
	 
	  REComSession();
	 
	  static REComSession& OpenL();
	 
	  void Close();
	 
	  void NotifyOnChange(TRequestStatus& aStatus);
	 
	  void CancelNotifyOnChange(TRequestStatus& aStatus);
	 
	  static void ListImplementationsL(TUid aInterfaceUid, 
											  const TEComResolverParams& aResolutionParameters,
											  RImplInfoPtrArray& aImplInfoArray);
	 
	  static void ListImplementationsL(TUid aInterfaceUid,
											  RImplInfoPtrArray& aImplInfoArray);
	 
	  static void ListImplementationsL(TUid aInterfaceUid, 
											  const TEComResolverParams& aResolutionParameters, 
											  TUid aResolverUid,
											  RImplInfoPtrArray& aImplInfoArray);

	 
	 
	 
	 
	 
	 
	 

	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TUid& aDtorIDKey);
	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TInt32 aKeyOffset);
	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TUid& aDtorIDKey, 
												TAny* aConstructionParameters);
	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TInt32 aKeyOffset,
												TAny* aConstructionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey,
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset, 
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey, 
												TAny* aConstructionParameters, 
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset, 
												TAny* aConstructionParameters, 
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey, 
												const TEComResolverParams& aResolutionParameters,
												TUid aResolverUid);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset,
												const TEComResolverParams& aResolutionParameters, 
												TUid aResolverUid);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey, 
												TAny* aConstructionParameters,
												const TEComResolverParams& aResolutionParameters, 
												TUid aResolverUid);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset, 
												TAny* aConstructionParameters,
												const TEComResolverParams& aResolutionParameters,
												TUid aResolverUid);
	 
	  static void DestroyedImplementation(TUid aDtorIDKey);
	  static void FinalClose();

private:
	 
	void ConstructL();
	 
	void ReallyClose();
	 
	static void ListImplementationsL(TInt aServiceId, 
									 TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid aResolverUid,
									 RImplInfoPtrArray& aImplInfoArray);
	 
	TAny* GetResolvedCreationMethodL(TUid aImplementationUid, 
									 TUid& aDtorIDKey);
	 
	TAny* GetResolvedCreationMethodL(TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid& aDtorIDKey);
	 
	TAny* GetResolvedCreationMethodL(TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid aResolverUid, 
									 TUid& aDtorIDKey);
	 
	TAny* GetResolvedCreationMethodL(TInt aServiceId,
									 TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid aResolverUid, 
									 TUid& aDtorIDKey);
	 
	TAny* CreateL(TAny* aCreationMethodPtr);
	 
	TAny* CreateL(TAny* aCreationMethodPtr, TAny* aCreationParameters);

private:
	 
	TInt iReserved2;


 

	 
	TBool iDoNotCloseThis;

	 
	TAny* iReserved;

	};



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframework.h" 1
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframeworkbase.h" 1
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32mem.h" 1
 
 
 
 









 












class TMemBuf : public TStreamBuf
	{
public:
	  TMemBuf();
	  void Set(TUint8* aPtr,TUint8* anEnd,TInt aMode=ERead|EWrite);
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline TUint8* Base() const;
	inline TUint8* End() const;
private:
	TUint8* iBase;
	};

 


















class TDesBuf : public TStreamBuf
	{
public:
	  TDesBuf();
	  void Set(TDes8& aDes,TInt aMode=ERead|EWrite);
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  void DoSynchL();
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline TDes8& Des() const;
	inline TUint8* Base() const;
 	void Consolidate();
private:
	TDes8* iDes;
	};

 































class TBufBuf : public TStreamBuf
	{
public:
	enum {ETruncate=0x10,EInsert=0x20};
public:
	  TBufBuf();
	  void Set(CBufBase& aBuf,TInt aPos,TInt aMode=ERead|EWrite);
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  void DoSynchL();
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline CBufBase& Buf() const;
 	void Consolidate();
 
	void SetPos(TMark aMark,TInt aPos);
	inline void SetPos(TRead,TInt aPos);
	inline void SetPos(TWrite,TInt aPos);
	TInt Pos(TMark aMark) const;
	inline TInt Pos(TRead) const;
	inline TInt Pos(TWrite) const;
	inline TInt MovePos(TRead,TInt anOffset);
	inline TInt MovePos(TWrite,TInt anOffset);
	inline TInt Mark(TRead) const;
	inline TInt Mark(TWrite) const;
private:
	CBufBase* iBuf;
	TInt iRPos;
	TInt iWPos;
	TInt iMode;
	};

 



class RMemReadStream : public RReadStream
	{
public:
	RMemReadStream() {}
	  RMemReadStream(const TAny* aPtr,TInt aLength);
	  void Open(const TAny* aPtr,TInt aLength);
private:
	TMemBuf iSource;
	};

 



class RMemWriteStream : public RWriteStream
	{
public:
	RMemWriteStream() {}
	inline RMemWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RMemWriteStream(TAny* aPtr,TInt aMaxLength);
	  void Open(TAny* aPtr,TInt aMaxLength);
private:
	TMemBuf iSink;
	};

 



class RDesReadStream : public RReadStream
	{
public:
	RDesReadStream() {}
	  RDesReadStream(const TDesC8& aDes);
	  void Open(const TDesC8& aDes);
private:
	TMemBuf iSource;
	};

 



class RDesWriteStream : public RWriteStream
	{
public:
	RDesWriteStream() {}
	inline RDesWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RDesWriteStream(TDes8& aDes);
	  void Open(TDes8& aDes);
private:
	TDesBuf iSink;
	};

 



class RBufReadStream : public RReadStream
	{
public:
	RBufReadStream() {}
	  RBufReadStream(const CBufBase& aBuf,TInt aPos=0);
	  void Open(const CBufBase& aBuf,TInt aPos=0);
private:
	TBufBuf iSource;
	};

 



class RBufWriteStream : public RWriteStream
	{
public:
	RBufWriteStream() {}
	inline RBufWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RBufWriteStream(CBufBase& aBuf,TInt aPos=0);
	  void Open(CBufBase& aBuf,TInt aPos=0);
	  void Truncate(CBufBase& aBuf,TInt aPos=0);
	  void Insert(CBufBase& aBuf,TInt aPos);
	inline void Append(CBufBase& aBuf);
private:
	TBufBuf iSink;
	};

 
















class CBufStore : public CStreamStore
	{
public:
	  static CBufStore* NewL(TInt anExpandSize);
	  static CBufStore* NewLC(TInt anExpandSize);
	  CBufStore(TInt anExpandSize);
	  ~CBufStore();
protected:
	  TStreamId DoExtendL();
	  void DoDeleteL(TStreamId anId);
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
	  MStreamBuf* DoWriteL(TStreamId anId);
	  MStreamBuf* DoReplaceL(TStreamId anId);
private:
	CBufSeg& BufL(TStreamId anId) const;
private:
	CArrayFixFlat<CBufSeg*> iBufArray;
	TInt iExpandSize;
	};		

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32mem.inl" 1
 
 
 
 

 
inline RMemWriteStream::RMemWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

 
inline RDesWriteStream::RDesWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

 
inline RBufWriteStream::RBufWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}
inline void RBufWriteStream::Append(CBufBase& aBuf)
	{Insert(aBuf,aBuf.Size());}

# 274 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32mem.h" 2


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframeworkbase.h" 2


 






const TInt KUseDefaultIap = -1;


 













class TMMFEvent
	{
public:

	 









	  TMMFEvent(TUid aEventType, TInt aErrorCode);

	 





	  TMMFEvent();

	 


	TUid iEventType;

	 


	TInt iErrorCode;

	};

 





typedef TPckgBuf<TMMFEvent> TMMFEventPckg;

 





typedef TPckgBuf<TUid> TMMFUidPckg;

 





typedef TPckgBuf<TTimeIntervalMicroSeconds> TMMFTimeIntervalMicroSecondsPckg;


 












class CMMFMetaDataEntry : public CBase
	{
public:

	 























	  static CMMFMetaDataEntry* NewL(const TDesC& aName, const TDesC& aValue);

	 











	  static CMMFMetaDataEntry* NewL(const CMMFMetaDataEntry& aOther);

	 









	  static CMMFMetaDataEntry* NewL();

	 




	  ~CMMFMetaDataEntry();

	 






	  const TDesC& Name() const;

	 






	  const TDesC& Value() const;

	 









	  void SetNameL(const TDesC& aName);

	 









	  void SetValueL(const TDesC& aValue);

	 










	  void ExternalizeL(RWriteStream& aStream) const;

	 










	  void InternalizeL(RReadStream& aStream);
private:

	 




	CMMFMetaDataEntry();

	 





















	void ConstructL(const TDesC& aName, const TDesC& aValue);
private:
	 


	HBufC* iName;

	 


	HBufC* iValue;
	};




 










class CMMFUrlParams : public CBase
	{
public:

	 















	  static CMMFUrlParams* NewL(const TDesC& aUrl, TInt aIAPId=KUseDefaultIap);

	 














	  static CMMFUrlParams* NewLC(const TDesC& aUrl, TInt aIAPId=KUseDefaultIap);

	 











	  static CMMFUrlParams* NewLC(RReadStream& aStream);

	 









	  void ExternalizeL(RWriteStream& aStream) const;

	 









	  CBufFlat* ExternalizeToCBufFlatLC() const;

	 


	~CMMFUrlParams();


	 





	  const TDesC& Url() const;

	 






	  TInt IAPId() const;

	 








	  TBool UseIAPId() const;
private:
	CMMFUrlParams();
	void ConstructL(const TDesC& aUrl, TInt aIAPId);
	void ConstructL(RReadStream& aStream);
private:
	HBufC* iUrl;
	TInt iIAPId;
	};



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframework.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.h" 1
 
 
 
 

 







 




 
 
 
 
 



typedef RMessage2 RMmfIpcMessage;

class CMmfIpcServer;  

 




 
class CMmfIpcSession : public CSession2
	{
protected:
	virtual void CreateL(const CMmfIpcServer& aServer);
	CMmfIpcSession() {}
	 
	void CreateL();
	};

 




 
class CMmfIpcServer : public CServer2
	{
protected:
	virtual CMmfIpcSession* NewSessionL(const TVersion& aVersion) const=0;
	CMmfIpcServer(TInt aPriority,TServerType aType=EUnsharableSessions);
private:
	 
	CSession2* NewSessionL(const TVersion& aVersion,const RMessage2& aMessage) const;
	};















 






class RMmfSessionBase : public RSessionBase
	{
protected:
	 
	TInt SendReceive(TInt aFunction) const;
	void SendReceive(TInt aFunction, TRequestStatus& aStatus) const;
	 
	TInt SendReceive(TInt aFunction, TInt aParam0) const;
	TInt SendReceive(TInt aFunction, TInt aParam0, TInt aParam1) const;
	void SendReceive(TInt aFunction, TInt aParam0, TRequestStatus& aStatus) const;
	void SendReceive(TInt aFunction, TInt aParam0, TInt aParam1, TRequestStatus& aStatus) const;
	TInt SendReceive(TInt aFunction, const TDesC8& aParam0) const;
	TInt SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1) const;
	TInt SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2) const;
	void SendReceive(TInt aFunction, const TDesC8& aParam0, TRequestStatus& aStatus) const;
	void SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TRequestStatus& aStatus) const;
	void SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TRequestStatus& aStatus) const;
	 
	TInt SendReceiveResult(TInt aFunction, TDes8& aResult) const;
	TInt SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult) const;
	TInt SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult) const;
	void SendReceiveResult(TInt aFunction, TDes8& aResult, TRequestStatus& aStatus) const;
	void SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult, TRequestStatus& aStatus) const;
	void SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult, TRequestStatus& aStatus) const;
	};


 





class MmfMessageUtil 
	{
public:
	static TInt Read(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult);
	static TInt Write(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue);
	static void ReadL(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult);
	static void WriteL(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue);
	};
	
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.inl" 1
 
 
 
 



 
 
 

inline void CMmfIpcSession::CreateL(const CMmfIpcServer&  )
	{
	 
	} 
	
inline void CMmfIpcSession::CreateL() 
	{ 
	const CMmfIpcServer* server = static_cast<const CMmfIpcServer*>(Server());
	CreateL(*server);  
	}

 
 
 

inline CMmfIpcServer::CMmfIpcServer(TInt aPriority,TServerType aType):
	CServer2(aPriority,aType)
	{
	}

inline CSession2* CMmfIpcServer::NewSessionL(const TVersion& aVersion, const RMessage2&  ) const
	{
	return NewSessionL(aVersion);
	}



 
 
 

inline TInt RMmfSessionBase::SendReceive(TInt aFunction) const
	{
	return RSessionBase::SendReceive(aFunction);
	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, TRequestStatus& aStatus) const
	{
	RSessionBase::SendReceive(aFunction,aStatus);
	}

 

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0));








	}

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0, TInt aParam1) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0,aParam1));








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0), aStatus);








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0, TInt aParam1, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0,aParam1), aStatus);








	}

 

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0));








	}

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1));








	}

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2));








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0), aStatus);








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1), aStatus);








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2), aStatus);








	}

 

inline TInt RMmfSessionBase::SendReceiveResult(TInt aFunction, TDes8& aResult) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aResult));








	}

inline TInt RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aResult));








	}

inline TInt RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2,&aResult));








	}

inline void RMmfSessionBase::SendReceiveResult(TInt aFunction, TDes8& aResult, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aResult), aStatus);








	}

inline void RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aResult), aStatus);








	}

inline void RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2,&aResult), aStatus);








	}
	
 
 
 

inline void MmfMessageUtil::ReadL(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult)
	{

	User::LeaveIfError(aMessage.Read(aParam, aResult));
# 303 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.inl"

	}

inline void MmfMessageUtil::WriteL(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue)
	{

	User::LeaveIfError(aMessage.Write(aParam, aValue));
# 322 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.inl"

	}

inline TInt MmfMessageUtil::Read(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult)
	{

	return aMessage.Read(aParam, aResult);




	}

inline TInt MmfMessageUtil::Write(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue)
	{

	return aMessage.Write(aParam, aValue);




	}
# 125 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.h" 2



# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframework.h" 2


 
class CMMFControllerImplementationInformation;

static const TLitC<sizeof(L"MMFControllerProxyServer" )/2>  KMMFControllerProxyServerName ={sizeof(L"MMFControllerProxyServer" )/2-1,L"MMFControllerProxyServer" } ;

 




 


const TInt KMMFControllerProxyMaxHeapSize = 0x1000000; 

 


const TInt KMMFControllerProxyMaxCachedMessages = 10;

 




const TInt KMMFObjectHandleControllerProxy = -1;

 





const TInt KMMFObjectHandleController = -2;

 





const TInt KMMFObjectHandleNull = 0;
 





const TInt KMMFObjectHandleFirstValid = 1;

 


const TInt KMmfControllerThreadShutdownTimeout = 20000000;	 

 




const TUid KUidInterfaceMMFControllerProxy = {0x101F77E7};

 


enum TMMFControllerProxyMessages
	{
	EMMFControllerProxyLoadControllerPluginByUid,
	EMMFControllerProxyReceiveEvents,
	EMMFControllerProxyCancelReceiveEvents
	};


 















class TMMFMessageDestination
	{
public:

	 






	  TMMFMessageDestination();

	 









	  TMMFMessageDestination(TUid aInterfaceId);

	 









	  TMMFMessageDestination(TUid aInterfaceId, TInt aDestinationHandle);

	 







	  TMMFMessageDestination(const TMMFMessageDestination& aOther);

	 






	  TUid InterfaceId() const;

	 






	  TInt DestinationHandle() const;

	 










	  TBool operator==(const TMMFMessageDestination& aOther) const;

private:
	TUid iInterfaceId;
	TInt iDestinationHandle;
	};

 





typedef TPckgBuf<TMMFMessageDestination> TMMFMessageDestinationPckg;


 


















class TMMFMessage
	{
friend class CMMFControllerProxySession;
public:

	 










	  TMMFMessage(const TMMFMessage& aMessage);

	 







	  const TMMFMessageDestination& Destination();

	 









	  TInt Function();

	 







	  TInt SizeOfData1FromClient();

	 











	  TInt ReadData1FromClient(TDes8& aDes);

	 











	  void ReadData1FromClientL(TDes8& aDes);


	 








	  TInt SizeOfData2FromClient();

	 











	  TInt ReadData2FromClient(TDes8& aDes);

	 











	  void ReadData2FromClientL(TDes8& aDes);

	 












	  TInt WriteDataToClient(const TDesC8& aDes);

	 











	  void WriteDataToClientL(const TDesC8& aDes);

	 









	  void Complete(TInt aReason);

	 







	  TBool IsCompleted();
private:
	 






	TMMFMessage(const RMmfIpcMessage& aMessage);

	 






	void FetchDestinationL();
private:

	 


	RMessagePtr2 iMessage;
	 


	TInt iFunction;
	 


	TInt iDummyPadding[6];







	 


	TMMFMessageDestination iDestination;

	 


	TBool iAmCompleted;
	};


 











class RMMFControllerProxy : public RMmfSessionBase
	{
public:

	 




	  RMMFControllerProxy();

	 









	  TInt LoadController(TUid aControllerUid);

	 










	  TInt LoadController(const CMMFControllerImplementationInformation& aControllerInfo);

	 







	  void Close();

	 




























	  TInt SendSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom) const;

	 

























	  TInt SendSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2) const;

	 

































	  void SendAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction,  const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom, TRequestStatus& aStatus) const;

	 






























	  void SendAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction,  const TDesC8& aDataTo1, const TDesC8& aDataTo2, TRequestStatus& aStatus) const;

	 


















	  void ReceiveEvents(TMMFEventPckg& aEvent, TRequestStatus& aStatus);

	 











	  TInt CancelReceiveEvents();
private:
	 


	TInt DoCreateSubThread(const TDesC& aName, TUint aMaxHeapSize);

	 


	TUint ControllersMaxHeapSizeL(TUid aControllerUid);

	 




	TInt LoadController(TUid aControllerUid, const CMMFControllerImplementationInformation* aControllerInfo);

private:
	 


	RThread iSubThread;
	 



	TMMFMessageDestinationPckg iDestinationPckg;
	};

 








class TMMFControllerProxyStartParams
	{
public:

	 







	TMMFControllerProxyStartParams(TRequestStatus& aStatus) : iStatus(&aStatus), iThreadId(RThread().Id())
		{aStatus=KRequestPending;};

	 






	void SignalL()
		{
		RThread starter;
		User::LeaveIfError(starter.Open(iThreadId));
		starter.RequestComplete(iStatus,KErrNone);
		starter.Close();
		};
public:
	TRequestStatus* iStatus;
	TThreadId iThreadId;
	};

 





class CMMFControllerProxyShutdown : public CTimer
	{
	enum {EMMFControllerProxyShutdownDelay=1000000};	 
public:

	 






	static CMMFControllerProxyShutdown* NewL();

	 





	void Start();

	 






	void ShutdownNow();
private:
	CMMFControllerProxyShutdown();
	void ConstructL();

	 




	void RunL();
	};


 





class MAsyncEventHandler
	{
public:

	 







	virtual TInt SendEventToClient(const TMMFEvent& aEvent) = 0;
	};

 








class CMMFEventReceiver : public CBase
	{
public:

	 











	static CMMFEventReceiver* NewL(const TMMFMessage& aMessage);

	 






	~CMMFEventReceiver();

	 







	void SendEvent(const TMMFEvent& aEvent);
private:

	 







	CMMFEventReceiver(const TMMFMessage& aMessage);
private:
	 


	TMMFMessage iMessage;
	};



 











class CMMFControllerProxyServer : public CMmfIpcServer
	{
public:
	 








	static CMMFControllerProxyServer* NewL();

	 




	~CMMFControllerProxyServer();

	 













	static TInt StartThread(TAny* aAny);

	 









	TInt RunError(TInt aError);

	 






	void SessionCreated();

	 





	void SessionDestroyed();
private:

	 












	static void DoStartThreadL(TMMFControllerProxyStartParams* aParams);

	 











	CMmfIpcSession* NewSessionL(const TVersion& aVersion) const;

	 




	CMMFControllerProxyServer();

	 




	void ConstructL();
private:
	 


	CMMFControllerProxyShutdown* iShutdownTimer;
	 


	TBool iHaveSession;
	};

class CMMFController;

 








class CMMFControllerProxySession : public CMmfIpcSession, public MAsyncEventHandler
	{
public:

	 








	static CMMFControllerProxySession* NewL();

	 









	void CreateL(const CMmfIpcServer& aServer);

	 


	~CMMFControllerProxySession();

	 













	void ServiceL(const RMmfIpcMessage& aMessage);

	 






	TInt SendEventToClient(const TMMFEvent& aEvent);
private:
	 


	CMMFControllerProxySession();

	 










	TBool ReceiveEventsL(TMMFMessage& aMessage);

	 









	TBool CancelReceiveEvents(TMMFMessage& aMessage);

	 









	TBool LoadControllerL(TMMFMessage& aMessage);
private:
	 


	CMMFController* iController;
	 


	CMMFControllerProxyServer* iServer;
	 


	CMMFEventReceiver* iEventReceiver;
	 


	RArray<TMMFEvent> iEvents;
	};



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2


 
 
 

class CMMFBuffer;
class MDataSink;
class MAsyncEventHandler;

 





class MDataSource
	{
public:
	static inline MDataSource* NewSourceL( TUid aImplementationUid,  const TDesC8& aInitData ) ;

	 


	virtual ~MDataSource() {REComSession::DestroyedImplementation(iDtor_ID_Key);};

	 




	virtual TUid DataSourceType() const {return iDataSourceType;};

	 











	virtual TFourCC SourceDataTypeCode(TMediaId aMediaId) = 0;

	inline virtual TInt SetSourceDataTypeCode(TFourCC aSourceFourCC, TMediaId aMediaId);

	 







































	virtual void FillBufferL(CMMFBuffer* aBuffer, MDataSink* aConsumer,TMediaId aMediaId)=0;

	 











	virtual void BufferEmptiedL(CMMFBuffer* aBuffer)=0;

	 









	virtual TBool CanCreateSourceBuffer()=0;

	 


















	virtual CMMFBuffer* CreateSourceBufferL(TMediaId aMediaId, TBool &aReference) = 0;

	inline virtual CMMFBuffer* CreateSourceBufferL(TMediaId aMediaId, CMMFBuffer& aSinkBuffer, TBool &aReference);

	inline virtual TInt SourceThreadLogon(MAsyncEventHandler& aEventHandler);

	 










	virtual void SourceThreadLogoff() {};

	inline virtual void NegotiateSourceL(MDataSink& aDataSink);  

	 







	virtual TBool SourceSampleConvert() {return EFalse;};
	
	 





	virtual void SourcePrimeL() {};
	
	 





	virtual void SourcePlayL() {};

	 





	virtual void SourcePauseL() {};

	 





	virtual void SourceStopL() {};

	inline virtual void SetSourcePrioritySettings(const TMMFPrioritySettings& aPrioritySettings);

	 








	virtual void SourceCustomCommand(TMMFMessage& aMessage) {aMessage.Complete(KErrNotSupported);};
protected:

	 








	virtual void ConstructSourceL(  const TDesC8& aInitData ) = 0 ;

	 


	MDataSource(TUid aType): iDataSourceType(aType) {}
private:
	TUid iDataSourceType;
	TUid iDtor_ID_Key;

	};

 









inline MDataSource* MDataSource::NewSourceL( TUid aImplementationUid, const TDesC8& aInitData )
	{
	MDataSource* retPtr = (reinterpret_cast<  MDataSource* >(  REComSession::CreateImplementationL( aImplementationUid,
																			((TInt)(&(( MDataSource  *)0)->  iDtor_ID_Key ))  )  ))  ;
	CleanupDeletePushL(retPtr);
	retPtr->ConstructSourceL( aInitData ) ;

	CleanupStack::Pop(retPtr);
	return retPtr ;
	}

 















inline TInt MDataSource::SetSourceDataTypeCode(TFourCC  , TMediaId  )
{
	return KErrNotSupported;
}

 






















inline CMMFBuffer* MDataSource::CreateSourceBufferL(TMediaId aMediaId, CMMFBuffer&  , TBool &aReference)
{
	return CreateSourceBufferL(aMediaId, aReference);
}

 


















inline TInt MDataSource::SourceThreadLogon(MAsyncEventHandler&  )
{
	return KErrNone;
}

 








inline void MDataSource::NegotiateSourceL(MDataSink&  )
{
}

 













inline void MDataSource::SetSourcePrioritySettings(const TMMFPrioritySettings&  )
{
}

 






inline static void DoDataSourceStop(TAny* aSource)
	{
	MDataSource* source = (static_cast< MDataSource* >(  aSource )) ;
	 
	 
	 
	TInt  error ;{TTrap __t;if (__t.Trap( error )==0){  source->SourceStopL() ;TTrap::UnTrap();}} ;
	}

 





inline static void DoDataSourceThreadLogoff(TAny* aSource)
	{
	MDataSource* source = (static_cast< MDataSource* >(  aSource )) ;
	source->SourceThreadLogoff();
	}


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasink.h" 1
 
 
 











 
 
 

class TFourCC;
class TMediaId;
class CMMFBuffer;
class MDataSource;
class MAsyncEventHandler;

 





class MDataSink
	{
public:

	static inline MDataSink* NewSinkL( TUid aImplementationUid,  const TDesC8& aInitData ) ;

	 


	virtual ~MDataSink() {REComSession::DestroyedImplementation(iDtor_ID_Key);};

	 




	virtual TUid DataSinkType() const {return iDataSinkType;};

	 











	virtual TFourCC SinkDataTypeCode(TMediaId aMediaId) = 0;

	inline virtual TInt SetSinkDataTypeCode(TFourCC aSinkFourCC, TMediaId aMediaId);

	 



















	virtual void EmptyBufferL(CMMFBuffer* aBuffer, MDataSource* aSupplier, TMediaId aMediaId)=0;

	 










	virtual void BufferFilledL(CMMFBuffer* aBuffer)=0;
	
	 









	virtual TBool CanCreateSinkBuffer()=0;
	
	 

















	virtual CMMFBuffer* CreateSinkBufferL(TMediaId aMediaId, TBool &aReference)=0;

	inline virtual TInt SinkThreadLogon(MAsyncEventHandler& aEventHandler);

	 










	virtual void SinkThreadLogoff() {};

	inline virtual void NegotiateL(MDataSource& aDataSource);

	 





	virtual void SinkPrimeL() {};

	 





	virtual void SinkPlayL() {};

	 





	virtual void SinkPauseL() {};

	 





	virtual void SinkStopL() {};

	inline virtual void SetSinkPrioritySettings(const TMMFPrioritySettings& aPrioritySettings);

	 








	virtual void SinkCustomCommand(TMMFMessage& aMessage) {aMessage.Complete(KErrNotSupported);};

protected:
	 








	virtual void ConstructSinkL( const TDesC8& aInitData ) = 0;

	 





	MDataSink(TUid aType): iDataSinkType(aType) {}
private:
	TUid iDataSinkType;
	TUid iDtor_ID_Key;
	};

 









inline MDataSink* MDataSink::NewSinkL( TUid aImplementationUid,  const TDesC8& aInitData )
	{
	MDataSink* retPtr = (reinterpret_cast<  MDataSink* >(  REComSession::CreateImplementationL( aImplementationUid,
																			((TInt)(&(( MDataSink  *)0)->  iDtor_ID_Key ))  )  ))  ;
	CleanupDeletePushL(retPtr);
	retPtr->ConstructSinkL( aInitData ) ;

	CleanupStack::Pop(retPtr);
	return retPtr ;
	}

 















inline TInt MDataSink::SetSinkDataTypeCode(TFourCC  , TMediaId  )
{
	return KErrNotSupported;
}

 



















inline TInt MDataSink::SinkThreadLogon(MAsyncEventHandler&  )
{
	return KErrNone;
}

 










inline void MDataSink::NegotiateL(MDataSource&  )
{
}

 













inline void MDataSink::SetSinkPrioritySettings(const TMMFPrioritySettings&  )
{
}

 






inline static void DoDataSinkStop(TAny* aSink)
	{
	MDataSink* sink = (static_cast< MDataSink* >(  aSink )) ;
	 
	 
	 
	TInt  error ;{TTrap __t;if (__t.Trap( error )==0){  sink->SinkStopL() ;TTrap::UnTrap();}} ;
	}

 





inline static void DoDataSinkThreadLogoff(TAny* aSink)
	{
	MDataSink* sink = (static_cast< MDataSink* >(  aSink )) ;
	sink->SinkThreadLogoff();
	}



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerpluginresolver.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apmstd.h" 1
 
 
 
 








 



const TInt KMaxDataTypeLength=256;

 
class RReadStream;
class RWriteStream;

 







typedef TInt16 TDataTypePriority;

 



const TInt16 KDataTypePriorityUserSpecified=KMaxTInt16;

 






const TInt16 KDataTypePriorityHigh=10000;

 






const TInt16 KDataTypePriorityNormal=0;

 






const TInt16 KDataTypePriorityLow=-10000;

 






const TInt16 KDataTypePriorityLastResort=-20000;

 



const TInt16 KDataTypePriorityNotSupported=KMinTInt16;


class TDataType
 








	{
public:
	  TDataType();
	  TDataType(const TDataType& aDataType);
	  TDataType(const TDesC8& aDataType);
	  TDataType(TUid aUid);
	 
	  TInt operator==(const TDataType& aDataType) const;
	  TInt operator!=(const TDataType& aDataType) const;
	  TBool IsNative() const;
	 
	  TBuf<KMaxDataTypeLength> Des() const;
	  TPtrC8 Des8() const;
	  TUid Uid() const;
	 
	  void InternalizeL(RReadStream& aReadStream);
	  void ExternalizeL(RWriteStream& aWriteStream) const;
private:
	void ParseDes();
private:
	TBuf8<KMaxDataTypeLength> iDataType;
	TUid iUid;
	};

 




 


static const TLitC8<sizeof(  "X-Epoc-Url/" )>  KEpocUrlDataTypeHeader ={sizeof(  "X-Epoc-Url/" )-1,  "X-Epoc-Url/" } ;



class TDataTypeWithPriority
 











	{
public:
	  TDataTypeWithPriority(const TDataType& aDataType, TDataTypePriority aPriority);
public:
	 
	TDataType iDataType;
	 
	TDataTypePriority iPriority;
	};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerpluginresolver.h" 2



 





const TUint KMMFDefaultControllerThreadHeapSize = 0x100000;  


class CMMFFormatImplementationInformation;

 





typedef RPointerArray<CMMFFormatImplementationInformation> RMMFFormatImplInfoArray;

class CMMFControllerImplementationInformation;

 





typedef RPointerArray<CMMFControllerImplementationInformation> RMMFControllerImplInfoArray;

 




class MTaggedDataParserClient
	{
public:
	virtual void ProcessTaggedDataL(const TDesC8& aTag, const TDesC8& aData) = 0;
	};

 




class TaggedDataParser
	{
public:

	 


	static void ParseTaggedDataL(const TDesC8& aData, MTaggedDataParserClient& aClient);

	 


	static void ConvertTextToUidL(const TDesC8& aData, TUid& aUid);

	 



	static void ConvertTextToTUintL(const TDesC8& aData, TUint& aUid);

	};

class CDesC8Array;

 







class CMMFPluginImplementationInformation : public CBase
	{
public:

	 







	  TUid Uid() const;

	 






	  const TDesC& DisplayName() const;

	 






	  const TDesC& Supplier() const;

	 






	  TInt Version() const;

	 









	  const RArray<TUid>& SupportedMediaIds() const;

	 










	  TBool SupportsSupplier(const TDesC& aSupplier) const;

	 









	  TBool SupportsMediaId(TUid aMediaId) const;

	 


	virtual ~CMMFPluginImplementationInformation();

protected:

	 


	CMMFPluginImplementationInformation();

	 


	void SetSupplierL(const TDesC8& aData);

	 


	void AddMediaIdL(const TDesC8& aData);
protected:

	 


	TUid iUid;

	 


	HBufC* iDisplayName;

	 


	HBufC* iSupplier;

	 


	TInt iVersion;

	 


	RArray<TUid> iMediaIds;
	};

 
































class CMMFFormatImplementationInformation : public CMMFPluginImplementationInformation, MTaggedDataParserClient
	{
public:

	 









	static CMMFFormatImplementationInformation* NewL(const CImplementationInformation& aImplInfo);

	 









	static CMMFFormatImplementationInformation* NewLC(const CImplementationInformation& aImplInfo);

	 


	virtual ~CMMFFormatImplementationInformation();

	 





	  const CDesC8Array& SupportedFileExtensions() const;

	 






	  const CDesC8Array& SupportedMimeTypes() const;

	 





	  const CDesC8Array& SupportedHeaderData() const;

	 










	  TBool SupportsFileExtension(const TDesC8& aFileExtension) const;

	 









	  TBool SupportsMimeType(const TDesC8& aMimeType) const;

	 










	  TBool SupportsHeaderDataL(const TDesC8& aHeaderData) const;
protected:

	 


	CMMFFormatImplementationInformation();

	 


	void ConstructL(const CImplementationInformation& aImplInfo);

	 


	void AddFileExtensionL(const TDesC8& aData);

	 


	void AddMimeTypeL(const TDesC8& aData);

	 


	void AddHeaderDataL(const TDesC8& aData);

	 


	void ProcessTaggedDataL(const TDesC8& aTag, const TDesC8& aData);

private:
	 


	CDesC8Array* iFileExtensions;

	 


	CDesC8Array* iMimeTypes;

	 


	CDesC8Array* iHeaderData;
	};


 






































class CMMFControllerImplementationInformation : public CMMFPluginImplementationInformation, MTaggedDataParserClient
	{
public:

	 









	static CMMFControllerImplementationInformation* NewL(const CImplementationInformation& aImplInfo);

	 












	static CMMFControllerImplementationInformation* NewLC(const CImplementationInformation& aImplInfo);

	 









	  static CMMFControllerImplementationInformation* NewL(TUid aUid);

	 


	~CMMFControllerImplementationInformation();

	 






	  const RMMFFormatImplInfoArray& PlayFormats() const;

	 






	  const RMMFFormatImplInfoArray& RecordFormats() const;

	 






	  TUint HeapSpaceRequired() const;

	 


	void GetPlayFormatsL();

	 


	void GetRecordFormatsL();
protected:

	 


	CMMFControllerImplementationInformation();

	 


	void ConstructL(const CImplementationInformation& aImplInfo);

	 


	void SetPlayFormatCollectionUidL(const TDesC8& aData);

	 


	void SetRecordFormatCollectionUidL(const TDesC8& aData);

	 


	void SetHeapSizeL(const TDesC8& aData);

	 


	void ProcessTaggedDataL(const TDesC8& aTag, const TDesC8& aData);

	 


















	void GetFormatsL(TUid aFormatCollectionUid, TUid aFormatPluginCollectionUid, RMMFFormatImplInfoArray& aFormatArray);

	 










	void AddFormatsSwallowCorruptL(RImplInfoPtrArray& aEcomArray, RMMFFormatImplInfoArray& aFormatArray);

private:

	 


	RMMFFormatImplInfoArray iPlayFormats;

	 


	RMMFFormatImplInfoArray iRecordFormats;

	 


	TUid iPlayFormatCollectionUid;

	 


	TUid iRecordFormatCollectionUid;
	
	 


	TUint iHeapSpaceRequired;
	};


 







class CMMFPluginSelectionParameters : public CBase
	{
public:

 



enum TPreferredSupplierMatchType
	{

	 

	ENoPreferredSupplierMatch,

	 

	EPreferredSupplierPluginsFirstInList,

	 

	EOnlyPreferredSupplierPluginsReturned
	};
 



enum TMediaIdMatchType
	{

	 

	ENoMediaIdMatch,

	 



	EAllowOtherMediaIds,

	 



	EAllowOnlySuppliedMediaIds
	};

public:

	 




	virtual ~CMMFPluginSelectionParameters();


	 









	  void SetPreferredSupplierL(const TDesC& aPreferredSupplier, TPreferredSupplierMatchType aMatchType);

	 









	  void SetMediaIdsL(const RArray<TUid>& aMediaIds, TMediaIdMatchType aMatchType);

	 






	  const TDesC& PreferredSupplier() const;

	 





	  TPreferredSupplierMatchType PreferredSupplierMatchType() const;

	 






	  const RArray<TUid>& MediaIds() const;

	 






	  TMediaIdMatchType MediaIdMatchType() const;

	 






	  TUid InterfaceUid() const;

protected:

	 








	CMMFPluginSelectionParameters(TUid aPluginInterfaceUid);

	 








	TBool CheckMediaIdSupportL(const CMMFPluginImplementationInformation& aPlugin) const;
private:
	TUid iPluginInterfaceUid;
	HBufC* iPreferredSupplier;
	TPreferredSupplierMatchType iPreferredSupplierMatchType;
	RArray<TUid> iMediaIds;
	TMediaIdMatchType iMediaIdMatchType;
	};







 









class CMMFFormatSelectionParameters : public CBase
	{
public:
 



enum TMatchDataType
	{

	 

	EMatchAny,

	 

	EMatchFileExtension,

	 

	EMatchMimeType,

	 

	EMatchHeaderData
	};

public:
	
	 






	  static CMMFFormatSelectionParameters* NewL();

	 





	  static CMMFFormatSelectionParameters* NewLC();

	 






	static CMMFFormatSelectionParameters* NewL(const CMMFFormatSelectionParameters& aParams);

	 















	  void SetMatchToFileNameL(const TDesC& aFileName);

	 










	  void SetMatchToUriL(const TDesC& aUri);

	 







	  void SetMatchToMimeTypeL(const TDesC8& aMimeType);

	 








	  void SetMatchToHeaderDataL(const TDesC8& aHeaderData);

	 






	  const TDesC8& MatchData() const;

	 






	  TMatchDataType MatchDataType() const;

	 


	virtual ~CMMFFormatSelectionParameters();
protected:

	 


	CMMFFormatSelectionParameters();
	void ConstructL(const CMMFFormatSelectionParameters& aParams);
private:
	HBufC8* iMatchData;
	TMatchDataType iMatchDataType;
	};



 







class CMMFControllerPluginSelectionParameters : public CMMFPluginSelectionParameters
	{
public:

	 






	  static CMMFControllerPluginSelectionParameters* NewL();

	 






	  static CMMFControllerPluginSelectionParameters* NewLC();

	 












	  void SetRequiredPlayFormatSupportL(const CMMFFormatSelectionParameters& aRequiredSupport);

	 














	  void SetRequiredRecordFormatSupportL(const CMMFFormatSelectionParameters& aRequiredSupport);

	 









	  virtual void ListImplementationsL(RMMFControllerImplInfoArray& aImplementations) const;

	 


	virtual ~CMMFControllerPluginSelectionParameters();
protected:
	CMMFControllerPluginSelectionParameters();
	void MatchImplementationToSelectParamsL(RMMFControllerImplInfoArray& aImplementations, const CMMFControllerImplementationInformation& aPlugin, TInt& aArrayPos) const;
	TInt CheckPreferredSupplierL(RMMFControllerImplInfoArray& aImplementations, const CMMFControllerImplementationInformation& aPlugin) const;
	TBool CheckFormatSupportL(CMMFFormatSelectionParameters* aSelectParams, const RMMFFormatImplInfoArray& aFormats) const;
protected:
	 


	CMMFFormatSelectionParameters* iRequiredPlayFormatSupport;
	
	 


	CMMFFormatSelectionParameters* iRequiredRecordFormatSupport;
	};

 








class CMmfRecognizerUtil : public CBase
	{
public:
	enum TMatchLevel
		{
		EMatchNone,  
		EMatchData,  
		EMatchName   
		};
public:
	  static void GetMimeTypesL(CDesC8Array* aMimeTypes);

	  static CMmfRecognizerUtil* CMmfRecognizerUtil::NewL();
	~CMmfRecognizerUtil();
	  TMatchLevel GetMimeTypeL(const TDesC& aFileName, const TDesC8& aImageData, TDes8& aMimeType);

private:
	CMmfRecognizerUtil();
	void ConstructL();

private:
	class CBody;
	CBody* iBody;
	};





 











class CMMFFormatPluginSelectionParameters : public CMMFPluginSelectionParameters
	{
public:

	 









	  void ListImplementationsL(RMMFFormatImplInfoArray& aImplementations) const;

	 







	  void SetRequiredFormatSupportL(const CMMFFormatSelectionParameters& aRequiredSupport);

	 


	virtual ~CMMFFormatPluginSelectionParameters();
protected:
	 


	CMMFFormatPluginSelectionParameters(TUid aInterfaceUid);

	void MatchImplementationToSelectParamsL(RMMFFormatImplInfoArray& aImplementations, const CMMFFormatImplementationInformation& aPlugin, TInt& aArrayPos) const;
	TInt CheckPreferredSupplierL(RMMFFormatImplInfoArray& aImplementations, const CMMFFormatImplementationInformation& aPlugin) const;
	TBool CheckFormatSupportL(const CMMFFormatImplementationInformation& aPlugin) const;
protected:
	 


	CMMFFormatSelectionParameters* iRequiredFormatSupport;
	};

 







class CMMFFormatEncodePluginSelectionParameters : public CMMFFormatPluginSelectionParameters
	{
public:

	 






	  static CMMFFormatEncodePluginSelectionParameters* NewL();

	 






	  static CMMFFormatEncodePluginSelectionParameters* NewLC();
protected:
	 


	CMMFFormatEncodePluginSelectionParameters();
	};


 







class CMMFFormatDecodePluginSelectionParameters : public CMMFFormatPluginSelectionParameters
	{
public:

	 






	  static CMMFFormatDecodePluginSelectionParameters* NewL();

	 






	  static CMMFFormatDecodePluginSelectionParameters* NewLC();
protected:
	 


	CMMFFormatDecodePluginSelectionParameters();
	};



 







template <class T>
class CleanupResetAndDestroy
	{
public:
	 





	inline static void PushL(T& aRef);
private:
	static void ResetAndDestroy(TAny *aPtr);
	};
template <class T>
inline void CleanupResetAndDestroyPushL(T& aRef);
template <class T>
inline void CleanupResetAndDestroy<T>::PushL(T& aRef)
	{CleanupStack::PushL(TCleanupItem(&ResetAndDestroy,&aRef));}
template <class T>
void CleanupResetAndDestroy<T>::ResetAndDestroy(TAny *aPtr)
	{((static_cast< T* >( aPtr )) )->ResetAndDestroy();}
template <class T>
inline void CleanupResetAndDestroyPushL(T& aRef)
	{CleanupResetAndDestroy<T>::PushL(aRef);}



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmfplugininterfaceuids.hrh" 1
 
 
 
 





 











# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2



 








const TUid KMMFErrorCategoryControllerGeneralError = {0x101F76D3};

 








const TUid KMMFEventCategoryPlaybackComplete = {0x101f7ea0};

 


const TUid KUidInterfaceMMFDataSinkHolder = {0x101F76D4};
 


const TUid KUidInterfaceMMFDataSourceHolder = {0x101F76D5};

 





const TUid KUidInterfaceMMFController = {0x101F4F47 };

 




enum TMMFControllerMessages
	{
	EMMFControllerAddDataSource,
	EMMFControllerAddDataSink,
	EMMFControllerRemoveDataSource,
	EMMFControllerRemoveDataSink,
	EMMFControllerReset,
	EMMFControllerPrime,
	EMMFControllerPlay,
	EMMFControllerPause,
	EMMFControllerStop,
	EMMFControllerGetPosition,
	EMMFControllerSetPosition,
	EMMFControllerGetDuration,
	EMMFControllerGetNumberOfMetaDataEntries,
	EMMFControllerGetSizeOfMetaDataEntry, 
	EMMFControllerGetMetaDataEntry,
	EMMFControllerSetPrioritySettings,
	EMMFControllerCancelAddDataSource,
	EMMFControllerCancelAddDataSink
	};



 










class RMMFController
	{
public:

	  RMMFController();

	  TInt Open(TUid aControllerUid, const TMMFPrioritySettings& aPrioritySettings);

	  TInt Open(const CMMFControllerImplementationInformation& aControllerInfo, const TMMFPrioritySettings& aPrioritySettings);

	  void Close();

	  TInt SetPrioritySettings(const TMMFPrioritySettings& aPrioritySettings) const;

	  TInt AddDataSource(TUid aSourceUid, const TDesC8& aSourceInitData);

	  TInt AddDataSink(TUid aSinkUid, const TDesC8& aSinkInitData);

	  TInt AddDataSource(TUid aSourceUid, const TDesC8& aSourceInitData, TMMFMessageDestination& aHandleInfo);

	  TInt AddDataSink(TUid aSinkUid, const TDesC8& aSinkInitData, TMMFMessageDestination& aHandleInfo);

	  void AddDataSource(const TMMFUidPckg& aSourceUid, const TDesC8& aSourceInitData, TMMFMessageDestinationPckg& aHandleInfoPckg, TRequestStatus& aStatus);

	  void CancelAddDataSource();
	
	  void AddDataSink(const TMMFUidPckg& aSinkUid, const TDesC8& aSinkInitData, TMMFMessageDestinationPckg& aHandleInfoPckg, TRequestStatus& aStatus);
	
	  void CancelAddDataSink();

	  TInt RemoveDataSource(const TMMFMessageDestination& aSourceHandleInfo);

	  TInt RemoveDataSink(const TMMFMessageDestination& aSinkHandleInfo);

	  TInt Reset();

	  TInt Prime();

	  TInt Play();

	  TInt Pause();

	  TInt Stop();

	  TInt GetPosition(TTimeIntervalMicroSeconds& aPosition) const;

	  TInt SetPosition(const TTimeIntervalMicroSeconds& aPosition) const;

	  TInt GetDuration(TTimeIntervalMicroSeconds& aDuration) const;

	  TInt GetNumberOfMetaDataEntries(TInt& aNumberOfEntries) const;

	  CMMFMetaDataEntry* GetMetaDataEntryL(TInt aIndex) const;

	  TInt CustomCommandSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom);

	  TInt CustomCommandSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2);

	  void CustomCommandAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom, TRequestStatus& aStatus);

	  void CustomCommandAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TRequestStatus& aStatus);

	  void ReceiveEvents(TMMFEventPckg& aEventPckg, TRequestStatus& aStatus);

	  TInt CancelReceiveEvents();

private:
	 


	RMMFControllerProxy iControllerProxy;

	 


	TMMFMessageDestinationPckg iDestinationPckg;
	};


 










class CMMFObject : public CBase
	{
friend class CMMFObjectContainer; 
public:
	  ~CMMFObject();

	  CMMFObject(TUid aInterfaceId);

	  const TMMFMessageDestination& Handle();

	  TBool operator==(const CMMFObject& aOther);

	 












	virtual void HandleRequest(TMMFMessage& aMessage) = 0;
private:
	void SetHandle(const TMMFMessageDestination& aNewHandle);
private:
	TMMFMessageDestination iHandle;
	};


 







class CMMFObjectContainer : public CBase
	{
public:

	  CMMFObjectContainer();

	  ~CMMFObjectContainer();

	  TInt AddMMFObject(CMMFObject& aObject);

	  void RemoveAndDestroyMMFObject(CMMFObject& aObject);

	  TInt FindMMFObject(const TMMFMessageDestination& aObjectHandle, CMMFObject*& aObjectFound);

	  void DeleteAllObjects();
private:
	 


	TInt FindMMFObject(const CMMFObject& aObject, TInt& aPositionInArray);

	 


	TInt GenerateObjectHandle();
private:
	 


	RPointerArray<CMMFObject> iObjects;

	 


	TInt iNextObjectHandle;
	};


 










class CMMFDataSourceHolder : public CMMFObject
	{
public:

	  CMMFDataSourceHolder(MDataSource& aDataSource);

	  ~CMMFDataSourceHolder();

	  MDataSource& DataSource();

	 
	  void HandleRequest(TMMFMessage& aMessage);
private:
	 


	MDataSource* iDataSource;
	};

 










class CMMFDataSinkHolder : public CMMFObject
	{
public:
	  CMMFDataSinkHolder(MDataSink& aDataSink);

	  ~CMMFDataSinkHolder();

	  MDataSink& DataSink();

	 
	  void HandleRequest(TMMFMessage& aMessage);

private:
	 


	MDataSink* iDataSink;
	};


 











class RMMFCustomCommandsBase
	{
public:

	  RMMFCustomCommandsBase(RMMFController& aController, TUid aInterfaceId);
protected:
	 






	RMMFController& iController;

	 





	TMMFMessageDestinationPckg iDestinationPckg;
	};

 















class CMMFCustomCommandParserBase : public CBase
	{
public:

	 









	virtual void HandleRequest(TMMFMessage& aMessage) = 0;

	 






	  TUid InterfaceId();

	 




	  ~CMMFCustomCommandParserBase();
protected:

	 









	  CMMFCustomCommandParserBase(TUid aInterfaceId);

private:

	 


	TUid iInterfaceId;
	};

 










class CMMFCustomCommandParserManager : public CBase
	{
public:
	 






	static CMMFCustomCommandParserManager* NewL();

	 






	~CMMFCustomCommandParserManager();

	 










	TBool HandleRequest(TMMFMessage& aMessage);

	 











	void AddCustomCommandParserL(CMMFCustomCommandParserBase& aParser);
private:
	CMMFCustomCommandParserManager();
private:
	 


	RPointerArray<CMMFCustomCommandParserBase> iParsers;
	};



 
















class CMMFController : public CBase
	{
public:

	 














	static CMMFController* NewL(TUid aControllerUid, MAsyncEventHandler& aEventHandler);

	 









	  virtual void HandleRequestL(TMMFMessage& aMessage);

	 


	  virtual ~CMMFController();
protected:

	 


	CMMFController(){};

	 

	 















	virtual void AddDataSourceL(MDataSource& aDataSource) = 0;

	 















	virtual void AddDataSinkL(MDataSink& aDataSink) = 0;

	 


















	virtual void RemoveDataSourceL(MDataSource& aDataSource) = 0;

	 


















	virtual void RemoveDataSinkL(MDataSink& aDataSink) = 0;

	 











	virtual void ResetL() = 0;

	 







	virtual void PrimeL() = 0;

	 







	  virtual void PrimeL(TMMFMessage& aMessage);

	 










	virtual void PlayL()= 0;

	 







	  virtual void PlayL(TMMFMessage& aMessage);


	 











	virtual void PauseL()= 0;

	 







	  virtual void PauseL(TMMFMessage& aMessage);

	 







	virtual void StopL()= 0;

	 







	  virtual void StopL(TMMFMessage& aMessage);

	 








	virtual TTimeIntervalMicroSeconds PositionL() const = 0;

	 









	virtual void SetPositionL(const TTimeIntervalMicroSeconds& aPosition) = 0;

	 








	virtual TTimeIntervalMicroSeconds DurationL() const = 0;

	 














	virtual void SetPrioritySettings(const TMMFPrioritySettings& aPrioritySettings) = 0;

	 




















	virtual void CustomCommand(TMMFMessage& aMessage)
		{aMessage.Complete(KErrNotSupported);}; 

	 








	virtual void GetNumberOfMetaDataEntriesL(TInt& aNumberOfEntries) = 0;

	 










	virtual CMMFMetaDataEntry* GetMetaDataEntryL(TInt aIndex) = 0;

	 

	 










	  TInt DoSendEventToClient(const TMMFEvent& aEvent);

	 









	  CMMFObjectContainer& MMFObjectContainerL();

	 















	  void AddCustomCommandParserL(CMMFCustomCommandParserBase& aParser);

private:
	 


	void ConstructL(MAsyncEventHandler& aEventHandler);
	 
	TBool DoAddDataSourceL(TMMFMessage& aMessage);
	TBool DoAddDataSinkL(TMMFMessage& aMessage);
	TBool DoRemoveDataSourceL(TMMFMessage& aMessage);
	TBool DoRemoveDataSinkL(TMMFMessage& aMessage);
	TBool DoResetL(TMMFMessage& aMessage);
	TBool DoPrimeL(TMMFMessage& aMessage);
	TBool DoPlayL(TMMFMessage& aMessage);
	TBool DoPauseL(TMMFMessage& aMessage);
	TBool DoStopL(TMMFMessage& aMessage);
	TBool DoGetPositionL(TMMFMessage& aMessage);
	TBool DoSetPositionL(TMMFMessage& aMessage);
	TBool DoGetDurationL(TMMFMessage& aMessage);
	TBool DoSetPrioritySettingsL(TMMFMessage& aMessage);
	void DoCustomCommand(TMMFMessage& aMessage);
	TBool DoGetNumberOfMetaDataEntriesL(TMMFMessage& aMessage);
	TBool DoGetSizeOfMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoGetMetaDataEntryL(TMMFMessage& aMessage);
private:
	 


	CBufFlat* iMetaDataBuffer;

	 


	TUid iDtor_ID_Key;

	 


	MAsyncEventHandler* iAsyncEventHandler;

	 


	CMMFObjectContainer* iMMFObjectContainer;

	 


	CMMFCustomCommandParserManager* iCustomCommandParserManager;
	};



 







class MMMFControllerEventMonitorObserver
	{
public:

	 







	virtual void HandleEvent(const TMMFEvent& aEvent) = 0;
	};

 








class CMMFControllerEventMonitor : public CActive
	{
public:

	 












	  static CMMFControllerEventMonitor* NewL(MMMFControllerEventMonitorObserver& aObserver,
		RMMFController& aMMFController);
	 


	~CMMFControllerEventMonitor();

	 






	  void Start();

private:
	 






	void RunL();

	 




	void DoCancel();

	 










	CMMFControllerEventMonitor(MMMFControllerEventMonitorObserver& aObserver,
		RMMFController& aMMFController);
private:
	MMMFControllerEventMonitorObserver& iObserver;
	RMMFController& iMMFController;
	TMMFEventPckg iEventPckg;
	};

 





class MMMFAddDataSourceSinkAsyncObserver
	{
public:
 








	virtual void MadssaoAddDataSourceSinkAsyncComplete(TInt aError, const TMMFMessageDestination& aHandle) = 0;
	};


 








class CMMFAddDataSourceSinkAsync : public CActive
	{
public:
 








	  static CMMFAddDataSourceSinkAsync* NewL(MMMFAddDataSourceSinkAsyncObserver& aObs);

 














	  void AddDataSource(RMMFController& aController, TUid aSourceUid, const TDesC8& aSourceInitData);

 














	  void AddDataSink(RMMFController& aController, TUid aSinkUid, const TDesC8& aSinkInitData);

 


	~CMMFAddDataSourceSinkAsync();

private:
	void RunL();
	void DoCancel();
	CMMFAddDataSourceSinkAsync(MMMFAddDataSourceSinkAsyncObserver& aObserver);
private:
	enum TCurrentAction {EIdle, EAddingDataSource, EAddingDataSink};
private:
	MMMFAddDataSourceSinkAsyncObserver& iObserver;
	TMMFMessageDestinationPckg iHandleInfoPckg;
	TCurrentAction iCurrentAction;
	RMMFController* iMMFController;
	HBufC8* iSourceSinkInitData;
	TMMFUidPckg iSourceSinkUidPckg;
	};


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfvideo.h" 1
 
 
 
 






class CFbsBitmap;

 








const TInt KMMFVariableVideoBitRate = -1;

 







const TInt KMMFNoMaxClipSize = -1;

 






const TUid KMMFEventCategoryVideoOpenComplete = {0x101F7F85};

 





const TUid KMMFEventCategoryVideoPrepareComplete = {0x101F7F86};

 



const TUid KMMFEventCategoryVideoLoadingStarted = {0x101F7F87};

 



const TUid KMMFEventCategoryVideoLoadingComplete = {0x101F7F88};

 



const TUid KMMFEventCategoryVideoPlayerGeneralError = {0x101F8000};

 



const TUid KMMFEventCategoryVideoRecorderGeneralError = {0x101F8001};


 







enum TVideoRotation
	{
	EVideoRotationNone,
	EVideoRotationClockwise90,
	EVideoRotationClockwise180,
	EVideoRotationClockwise270
	};

 






class TMMFVideoConfig
	{
public:
	inline TMMFVideoConfig();

public:
	 



	TBool						iAudioEnabled;
	 


	TPoint						iTopLeftPt;
	 


	TRect						iClipRect;
	 


	TInt						iBitmapHandle;
	 


	TInt						iFrameNumber;
	 


	TReal32						iFramesPerSecond;
	 


	TSize						iVideoFrameSize;
	 




	TInt						iVolume;
	 





	TInt						iMaxVolume;
	 


	TInt						iBalance;
	 



	TInt						iGain;
	 


	TInt						iMaxGain;
	 





	TInt						iMetaData;
	 


	TInt						iMaxFileSize;
	 


	TUint						iChannels;
	 


	TInt						iVideoBitRate;
	 


	TInt						iAudioBitRate;
	 


	TUid						iFormatUid;
	 


	TFourCC						iVideoCodec;
	 


	TFourCC						iAudioCodec;
	 


	TTimeIntervalMicroSeconds	iRampDuration;
	 


	TTimeIntervalMicroSeconds	iStartPosition;
	 


	TTimeIntervalMicroSeconds	iEndPosition;
	 


	TTimeIntervalMicroSeconds	iRecordTimeAvailable;
	 





	TInt						iFrameBitmapServerHandle;
	 


	TRect						iWindowRect;
	 


	TInt						iCameraHandle;
	 


	TInt						iDSAEvent;
	 


	TInt						iLoadingCompletePercentage;
	 


	TVideoRotation				iVideoRotation;
	 


	TReal32						iWidthScalePercentage;
	 


	TReal32						iHeightScalePercentage;
	 


	TBool						iAntiAliasFiltering;
	 


	TRect						iCropRectangle;
	};

 


inline TMMFVideoConfig::TMMFVideoConfig() {};

 











class MMMFVideoFrameMessage 
	{
public:
	 





	virtual void FrameReady(TInt aError) = 0;
	 




	virtual CFbsBitmap& GetBitmap() = 0;
	};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/caf/caf.h" 1
 








 






 
const TInt KErrCANotSupported  =(-17450);

 




const TInt KErrCANoPermission  =(-17451); 

 




const TInt KErrCANoRights      =(-17452); 

 




const TInt KErrCANoAgent       =(-17453);

 
const TInt KErrCAOutOfRange    =(-17454);

 



const TInt KErrCAPendingRights =(-17455);

 




const TInt KErrCASizeNotDetermined = (-17456);

 
const TInt KErrCAF32AgentAlreadyFound  =(-17457);


namespace ContentAccess
	{
	 
	enum TQosAttribute
		{
		 
		EQosBufferSize   = 0,
		 
		EQosAttrTop  
		};

	 


	enum TContentShareMode
		{
		EContentShareReadOnly      = 0,   
		EContentShareReadWrite     = 1,   
		EContentShareExclusive     = 2    
		};
		
		 



	enum TIntent
		{
		EPeek		= 0,	 
		EPlay		= 1,	 
		EView		= 2,	 
		EExecute	= 3,	 
		EPrint		= 4		 
		};

	 



	enum TAttribute
		{
		EIsProtected   = 0,  
		EIsForwardable = 1,
		EIsModifyable  = 2,
		EIsCopyable    = 3,
		ECanPlay       = 4,  
		ECanPrint      = 5,  
		ECanExecute    = 6,  
		ECanView       = 7,  
		ERightsNone    = 8,  
		ERightsPending = 9,  
		
		EAttrTop			 
		}; 

	 



	enum TOutputType
		{
		EContent					= 0,	 
		EReceipt					= 1      
		}; 

	 



	enum TMimeFields
		{
		EContentType				= 0,	 
		EContentLength				= 1,	 
		EContentId					= 2,     
		EContentTransferEncoding	= 3,     
		EBoundary					= 4,     
		EMimeMax				    		 
		}; 
	}


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 2


class CMMFVideoFrameMessage;
class CFbsBitmap;
class CDesC8Array;

 



const TInt KPlaybackRateNormal = 1;

 





const TInt KMMFBalanceCenter = 0;

 





const TInt KMMFBalanceMaxLeft = -100;

 





const TInt KMMFBalanceMaxRight = 100;

 



const TInt KMMFVideoCurrentFrame = -1;

 



enum TMMFDSAEvent
	{
	EAbortDSA,
	EResumeDSA
	};

 





const TUid KUidInterfaceMMFAudioPlayDevice = {0x101F76D6};

 


enum TMMFAudioPlayDeviceMessages
	{
	EMMFAudioPlayDeviceSetVolume,
	EMMFAudioPlayDeviceGetMaxVolume,
	EMMFAudioPlayDeviceGetVolume,
	EMMFAudioPlayDeviceSetVolumeRamp,
	EMMFAudioPlayDeviceSetBalance,
	EMMFAudioPlayDeviceGetBalance
	};

 





const TUid KUidInterfaceMMFAudioRecordDevice = {0x101F76D7};

 


enum TMMFAudioRecordDeviceMessage
	{
	EMMFAudioRecordDeviceSetGain,
	EMMFAudioRecordDeviceGetMaxGain,
	EMMFAudioRecordDeviceGetGain,
	EMMFAudioRecordDeviceSetBalance,
	EMMFAudioRecordDeviceGetBalance
	};

 





const TUid KUidInterfaceMMFAudioPlayController = {0x101F76D8};

 


enum TMMFAudioPlayControllerMessages
	{
	EMMFAudioPlayControllerSetPlaybackWindow,
	EMMFAudioPlayControllerDeletePlaybackWindow,
	EMMFAudioPlayControllerGetLoadingProgress
	};

 





const TUid KUidInterfaceMMFAudioRecordController = {0x101F76D9};

 


enum TMMFAudioRecordControllerMessages
	{
	EMMFAudioRecordControllerGetRecordTimeAvailable,
	EMMFAudioRecordControllerSetMaxDuration,
	EMMFAudioRecordControllerSetMaxFileSize,
	EMMFAudioRecordControllerCrop,
	EMMFAudioRecordControllerAddMetaDataEntry,
	EMMFAudioRecordControllerRemoveMetaDataEntry,
	EMMFAudioRecordControllerReplaceMetaDataEntry
	};

 





const TUid KUidInterfaceMMFAudioController = {0x101F76DA};

 


enum TMMFAudioControllerMessages
	{
	EMMFAudioControllerSetSourceSampleRate,
	EMMFAudioControllerSetSourceNumChannels,
	EMMFAudioControllerSetSourceFormat,
	EMMFAudioControllerSetSourceBitRate,
	EMMFAudioControllerSetSourceDataType,
	EMMFAudioControllerSetSinkSampleRate,
	EMMFAudioControllerSetSinkNumChannels,
	EMMFAudioControllerSetSinkFormat,
	EMMFAudioControllerSetSinkBitRate,
	EMMFAudioControllerSetSinkDataType,
	EMMFAudioControllerGetSourceSampleRate,
	EMMFAudioControllerGetSourceBitRate,
	EMMFAudioControllerGetSourceNumChannels,
	EMMFAudioControllerGetSourceFormat,
	EMMFAudioControllerGetSourceDataType,
	EMMFAudioControllerGetSinkSampleRate,
	EMMFAudioControllerGetSinkBitRate,
	EMMFAudioControllerGetSinkNumChannels,
	EMMFAudioControllerGetSinkFormat,
	EMMFAudioControllerGetSinkDataType,
	EMMFAudioControllerGetSupportedSourceSampleRates,
	EMMFAudioControllerGetSupportedSourceBitRates,
	EMMFAudioControllerGetSupportedSourceNumChannels,
	EMMFAudioControllerGetSupportedSourceDataTypes,
	EMMFAudioControllerGetSupportedSinkSampleRates,
	EMMFAudioControllerGetSupportedSinkBitRates,
	EMMFAudioControllerGetSupportedSinkNumChannels,
	EMMFAudioControllerGetSupportedSinkDataTypes,
	EMMFAudioControllerCopyArrayData,
	EMMFAudioControllerSetCodec
	};


 



const TUid KUidInterfaceMMFVideoController = {0x101F76DB};

 


enum TMMFVideoControllerMessages
	{
	EMMFVideoControllerGetAudioCodec,
	EMMFVideoControllerGetVideoBitRate,
	EMMFVideoControllerGetAudioBitRate,
	EMMFVideoControllerGetVideoFrameSize,
	EMMFVideoControllerSetFrameRate,
	EMMFVideoControllerGetFrameRate,
	EMMFVideoControllerGetVideoMimeType
	};

 



const TUid KUidInterfaceMMFVideoPlayController = {0x101F7B73};

 


enum TMMFVideoPlayControllerMessages
	{
	EMMFVideoPlayControllerPrepare,
	EMMFVideoPlayControllerGetFrame,
	EMMFVideoPlayControllerSetDisplayWindow,
	EMMFVideoPlayControllerGetAudioEnabled,
	EMMFVideoPlayControllerUpdateDisplayRegion,
	EMMFVideoPlayControllerDSAEvent,
	EMMFVideoPlayControllerPlay,
	EMMFVideoPlayControllerRefreshFrame,
	EMMFVideoPlayControllerGetLoadingProgress,
	EMMFVideoPlayControllerSetRotation,
	EMMFVideoPlayControllerGetRotation,
	EMMFVideoPlayControllerSetScaleFactor,
	EMMFVideoPlayControllerGetScaleFactor,
	EMMFVideoPlayControllerSetCropRegion,
	EMMFVideoPlayControllerGetCropRegion
	};

 



const TUid KUidInterfaceMMFVideoRecordController = {0x101F7B74};

 


enum TMMFVideoRecordControllerMessages
	{
	EMMFVideoRecordControllerSetVideoFormat,
	EMMFVideoRecordControllerSetVideoCodec,
	EMMFVideoRecordControllerSetAudioCodec,
	EMMFVideoRecordControllerSetVideoBitRate,
	EMMFVideoRecordControllerSetAudioBitRate,
	EMMFVideoRecordControllerSetVideoFrameSize,
	EMMFVideoRecordControllerSetMaxFileSize,
	EMMFVideoRecordControllerAddMetaDataEntry,
	EMMFVideoRecordControllerRemoveMetaDataEntry,
	EMMFVideoRecordControllerReplaceMetaDataEntry,
	EMMFVideoRecordControllerSetAudioEnabled,
	EMMFVideoRecordControllerPrepare,
	EMMFVideoRecordControllerSetCameraHandle,
	EMMFVideoRecordControllerGetRecordTimeAvailable,
	EMMFVideoRecordControllerGetSupportedSinkAudioTypes,
	EMMFVideoRecordControllerGetSupportedSinkVideoTypes,
	EMMFVideoRecordControllerCopyDescriptorArrayData,
	EMMFVideoRecordControllerCopyFourCCArrayData,
	EMMFVideoRecordControllerGetAudioEnabled  
	};


 



const TUid KUidInterfaceMMFVideoDRMExt = {0x101F7C23};

 


enum TMMFDRMIntentMessages
	{
	EMMFVideoDRMExtGetFrame
	};



 









class RMMFAudioPlayDeviceCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFAudioPlayDeviceCustomCommands(RMMFController& aController);

	 









	  TInt SetVolume(TInt aVolume) const;

	 









	  TInt GetMaxVolume(TInt& aMaxVolume) const;

	 









	  TInt GetVolume(TInt& aVolume) const;

	 














	  TInt SetVolumeRamp(const TTimeIntervalMicroSeconds& aRampDuration) const;

	 










	  TInt SetBalance(TInt aBalance) const;

	 









	  TInt GetBalance(TInt& aBalance) const;
	};

 






class MMMFAudioPlayDeviceCustomCommandImplementor
	{
public:

	 










	virtual void MapdSetVolumeL(TInt aVolume) = 0;

	 










	virtual void MapdGetMaxVolumeL(TInt& aMaxVolume) = 0;

	 










	virtual void MapdGetVolumeL(TInt& aVolume) = 0;

	 















	virtual void MapdSetVolumeRampL(const TTimeIntervalMicroSeconds& aRampDuration) = 0;

	 











	virtual void MapdSetBalanceL(TInt aBalance) = 0;

	 










	virtual void MapdGetBalanceL(TInt& aBalance) = 0;
	};

 
































class CMMFAudioPlayDeviceCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 











	  static CMMFAudioPlayDeviceCustomCommandParser* NewL(MMMFAudioPlayDeviceCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioPlayDeviceCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioPlayDeviceCustomCommandParser(MMMFAudioPlayDeviceCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetVolumeL(TMMFMessage& aMessage);
	TBool DoGetMaxVolumeL(TMMFMessage& aMessage);
	TBool DoGetVolumeL(TMMFMessage& aMessage);
	TBool DoSetVolumeRampL(TMMFMessage& aMessage);
	TBool DoSetBalanceL(TMMFMessage& aMessage);
	TBool DoGetBalanceL(TMMFMessage& aMessage);
private:
	 
	MMMFAudioPlayDeviceCustomCommandImplementor& iImplementor;
	};

 










class RMMFAudioRecordDeviceCustomCommands : public RMMFCustomCommandsBase
	{
public:
	
	 







	  RMMFAudioRecordDeviceCustomCommands(RMMFController& aController);

	 









	  TInt SetGain(TInt aGain) const;

	 









	  TInt GetMaxGain(TInt& aMaxGain) const;

	 









	  TInt GetGain(TInt& aGain) const;

	 










	  TInt SetBalance(TInt aBalance) const;

	 









	  TInt GetBalance(TInt& aBalance) const;
	};

 






class MMMFAudioRecordDeviceCustomCommandImplementor
	{
public:

	 










	virtual void MardSetGainL(TInt aGain) = 0;

	 










	virtual void MardGetMaxGainL(TInt& aMaxGain) = 0;

	 










	virtual void MardGetGainL(TInt& aGain) = 0;

	 











	virtual void MardSetBalanceL(TInt aBalance) = 0;

	 










	virtual void MardGetBalanceL(TInt& aBalance) = 0;
	};

 
































class CMMFAudioRecordDeviceCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 











	  static CMMFAudioRecordDeviceCustomCommandParser* NewL(MMMFAudioRecordDeviceCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioRecordDeviceCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioRecordDeviceCustomCommandParser(MMMFAudioRecordDeviceCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetGainL(TMMFMessage& aMessage);
	TBool DoGetMaxGainL(TMMFMessage& aMessage);
	TBool DoGetGainL(TMMFMessage& aMessage);
	TBool DoSetBalanceL(TMMFMessage& aMessage);
	TBool DoGetBalanceL(TMMFMessage& aMessage);
private:
	 
	MMMFAudioRecordDeviceCustomCommandImplementor& iImplementor;
	};


 










class RMMFAudioPlayControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:
	
	 







	  RMMFAudioPlayControllerCustomCommands(RMMFController& aController);

	 












	  TInt SetPlaybackWindow(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) const;

	 





	  TInt DeletePlaybackWindow();

	 









	  TInt GetLoadingProgress(TInt& aPercentageProgress) const;
	};


 






class MMMFAudioPlayControllerCustomCommandImplementor
	{
public:

	 













	virtual void MapcSetPlaybackWindowL(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) = 0;

	 







	virtual void MapcDeletePlaybackWindowL() = 0;

	 










	virtual void MapcGetLoadingProgressL(TInt& aPercentageComplete) = 0;
	};

 
































class CMMFAudioPlayControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFAudioPlayControllerCustomCommandParser* NewL(MMMFAudioPlayControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioPlayControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioPlayControllerCustomCommandParser(MMMFAudioPlayControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetPlaybackWindowL(TMMFMessage& aMessage);
	TBool DoDeletePlaybackWindowL(TMMFMessage& aMessage);
	TBool DoGetLoadingProgressL(TMMFMessage& aMessage);
private:
	 


	MMMFAudioPlayControllerCustomCommandImplementor& iImplementor;
	};




 










class RMMFAudioRecordControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFAudioRecordControllerCustomCommands(RMMFController& aController);

	 









	  TInt GetRecordTimeAvailable(TTimeIntervalMicroSeconds& aTime) const;

	 









	  TInt SetMaxDuration(const TTimeIntervalMicroSeconds& aMaxDuration) const;

	 









	  TInt SetMaxFileSize(TInt aMaxSize) const;

	 











	  TInt Crop(TBool aToEnd);

	 







	  void AddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry);

	 









	  TInt RemoveMetaDataEntry(TInt aIndex);

	 









	  void ReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry);
	};

 






class MMMFAudioRecordControllerCustomCommandImplementor
	{
public:

	 










	virtual void MarcGetRecordTimeAvailableL(TTimeIntervalMicroSeconds& aTime) = 0;

	 










	virtual void MarcSetMaxDurationL(const TTimeIntervalMicroSeconds& aMaxDuration) = 0;

	 










	virtual void MarcSetMaxFileSizeL(TInt aMaxSize) = 0;

	 












	virtual void MarcCropL(TBool aToEnd) = 0;

	 







	virtual void MarcAddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry) = 0;

	 







	virtual void MarcRemoveMetaDataEntryL(TInt aIndex) = 0;

	 









	virtual void MarcReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry) = 0;
	};

 
































class CMMFAudioRecordControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFAudioRecordControllerCustomCommandParser* NewL(MMMFAudioRecordControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioRecordControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioRecordControllerCustomCommandParser(MMMFAudioRecordControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoGetRecordTimeAvailableL(TMMFMessage& aMessage);
	TBool DoSetMaxDurationL(TMMFMessage& aMessage);
	TBool DoSetMaxFileSizeL(TMMFMessage& aMessage);
	TBool DoCropL(TMMFMessage& aMessage);
	TBool DoAddMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoRemoveMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoReplaceMetaDataEntryL(TMMFMessage& aMessage);
private:
	 


	MMMFAudioRecordControllerCustomCommandImplementor& iImplementor;
	};


 










class RMMFAudioControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 








	  RMMFAudioControllerCustomCommands(RMMFController& aController);

	 









	  TInt SetSourceSampleRate(TUint aSampleRate) const;

	 









	  TInt SetSourceBitRate(TUint aRate) const;

	 










	  TInt SetSourceNumChannels(TUint aNumChannels) const;

	 











	  TInt SetSourceFormat(TUid aFormatUid) const;

	 









	  TInt SetSourceDataType(TFourCC aDataType) const;

	 









	  TInt SetSinkSampleRate(TUint aSampleRate) const;

	 









	  TInt SetSinkBitRate(TUint aRate) const;

	 










	  TInt SetSinkNumChannels(TUint aNumChannels) const;

	 











	  TInt SetSinkFormat(TUid aFormatUid) const;

	 









	  TInt SetSinkDataType(TFourCC aDataType) const;

	 











	  TInt SetCodec(TFourCC aSourceDataType, TFourCC aSinkDataType) const;

	 









	  TInt GetSourceSampleRate(TUint& aRate) const;

	 









	  TInt GetSourceBitRate(TUint& aRate) const;

	 










	  TInt GetSourceNumChannels(TUint& aNumChannels) const;

	 











	  TInt GetSourceFormat(TUid& aFormat) const;

	 









	  TInt GetSourceDataType(TFourCC& aDataType) const;

	 









	  TInt GetSinkSampleRate(TUint& aRate) const;

	 









	  TInt GetSinkBitRate(TUint& aRate) const;

	 










	  TInt GetSinkNumChannels(TUint& aNumChannels) const;

	 











	  TInt GetSinkFormat(TUid& aFormat) const;

	 









	  TInt GetSinkDataType(TFourCC& aDataType) const;

	 











	  void GetSupportedSourceSampleRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSourceBitRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSourceNumChannelsL(RArray<TUint>& aSupportedChannels) const;

	 











	  void GetSupportedSourceDataTypesL(RArray<TFourCC>& aSupportedDataTypes) const;

	 











	  void GetSupportedSinkSampleRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSinkBitRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSinkNumChannelsL(RArray<TUint>& aSupportedChannels) const;

	 











	  void GetSupportedSinkDataTypesL(RArray<TFourCC>& aSupportedDataTypes) const;

private:
	void DoGetUintArrayL(RArray<TUint>& aArray, TMMFAudioControllerMessages aIpc) const;
	void DoGetFourCCArrayL(RArray<TFourCC>& aArray, TMMFAudioControllerMessages aIpc) const;
	};


 






class MMMFAudioControllerCustomCommandImplementor
	{
public:

	 







	virtual void MacSetSourceSampleRateL(TUint aSampleRate) = 0;

	 







	virtual void MacSetSourceBitRateL(TUint aBitRate) = 0;

	 








	virtual void MacSetSourceNumChannelsL(TUint aNumChannels) = 0;

	 








	virtual void MacSetSourceFormatL(TUid aFormatUid) = 0;

	 







	virtual void MacSetSourceDataTypeL(TFourCC aDataType) = 0;

	 







	virtual void MacSetSinkSampleRateL(TUint aSampleRate) = 0;

	 







	virtual void MacSetSinkBitRateL(TUint aRate) = 0;

	 








	virtual void MacSetSinkNumChannelsL(TUint aNumChannels) = 0;

	 








	virtual void MacSetSinkFormatL(TUid aFormatUid) = 0;

	 







	virtual void MacSetSinkDataTypeL(TFourCC aDataType) = 0;

	 









	virtual void MacSetCodecL(TFourCC aSourceDataType, TFourCC aSinkDataType) = 0;


	 







	virtual void MacGetSourceSampleRateL(TUint& aRate) = 0;

	 







	virtual void MacGetSourceBitRateL(TUint& aRate) = 0;

	 








	virtual void MacGetSourceNumChannelsL(TUint& aNumChannels) = 0;

	 








	virtual void MacGetSourceFormatL(TUid& aFormat) = 0;

	 







	virtual void MacGetSourceDataTypeL(TFourCC& aDataType) = 0;

	 







	virtual void MacGetSinkSampleRateL(TUint& aRate) = 0;

	 







	virtual void MacGetSinkBitRateL(TUint& aRate) = 0;

	 








	virtual void MacGetSinkNumChannelsL(TUint& aNumChannels) = 0;

	 








	virtual void MacGetSinkFormatL(TUid& aFormat) = 0;

	 







	virtual void MacGetSinkDataTypeL(TFourCC& aDataType) = 0;

	 







	virtual void MacGetSupportedSourceSampleRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSourceBitRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSourceNumChannelsL(RArray<TUint>& aSupportedChannels) = 0;

	 









	virtual void MacGetSupportedSourceDataTypesL(RArray<TFourCC>& aSupportedDataTypes) = 0;

	 









	virtual void MacGetSupportedSinkSampleRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSinkBitRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSinkNumChannelsL(RArray<TUint>& aSupportedChannels) = 0;

	 









	virtual void MacGetSupportedSinkDataTypesL(RArray<TFourCC>& aSupportedDataTypes) = 0;
	};

 
































class CMMFAudioControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFAudioControllerCustomCommandParser* NewL(MMMFAudioControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:
	 







	CMMFAudioControllerCustomCommandParser(MMMFAudioControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);

	TBool DoSetSourceSampleRateL(TMMFMessage& aMessage);
	TBool DoSetSourceNumChannelsL(TMMFMessage& aMessage);
	TBool DoSetSourceFormatL(TMMFMessage& aMessage);
	TBool DoSetSinkSampleRateL(TMMFMessage& aMessage);
	TBool DoSetSinkNumChannelsL(TMMFMessage& aMessage);
	TBool DoSetSinkFormatL(TMMFMessage& aMessage);
	TBool DoSetCodecL(TMMFMessage& aMessage);
	TBool DoSetSourceBitRateL(TMMFMessage& aMessage);
	TBool DoSetSourceDataTypeL(TMMFMessage& aMessage);
	TBool DoSetSinkBitRateL(TMMFMessage& aMessage);
	TBool DoSetSinkDataTypeL(TMMFMessage& aMessage);
	TBool DoGetSourceSampleRateL(TMMFMessage& aMessage);
	TBool DoGetSourceBitRateL(TMMFMessage& aMessage);
	TBool DoGetSourceNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSourceFormatL(TMMFMessage& aMessage);
	TBool DoGetSourceDataTypeL(TMMFMessage& aMessage);
	TBool DoGetSinkSampleRateL(TMMFMessage& aMessage);
	TBool DoGetSinkBitRateL(TMMFMessage& aMessage);
	TBool DoGetSinkNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSinkFormatL(TMMFMessage& aMessage);
	TBool DoGetSinkDataTypeL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceSampleRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceBitRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceDataTypesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkSampleRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkBitRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkDataTypesL(TMMFMessage& aMessage);
	TBool DoCopyArrayDataL(TMMFMessage& aMessage);

	void DoCreateBufFromUintArrayL(RArray<TUint>& aArray);
	void DoCreateBufFromFourCCArrayL(RArray<TFourCC>& aArray);
private:
	 


	MMMFAudioControllerCustomCommandImplementor& iImplementor;

	CBufFlat* iDataCopyBuffer;
	};


class RWindow;

 










class RMMFVideoControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoControllerCustomCommands(RMMFController& aController);

	 









	  TInt GetVideoFrameSize(TSize& aVideoFrameSize) const;

	 









	  TInt GetAudioCodec(TFourCC& aCodec) const;

	 










	  TInt GetVideoBitRate(TInt& aBitRate) const;

	 









	  TInt GetAudioBitRate(TInt& aBitRate) const;

	 









	  TInt SetFrameRate(TReal32 aFramesPerSecond) const;

	 









	  TInt GetFrameRate(TReal32& aFramesPerSecond) const;

	 







	  TInt GetVideoMimeType(TDes8& aMimeType) const;
	};

 










class RMMFVideoPlayControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoPlayControllerCustomCommands(RMMFController& aController);

	 










	  TInt Prepare();

	 













	  void GetFrame(CFbsBitmap& aBitmap, TRequestStatus& aStatus);

	 











	  TInt SetDisplayWindow(const TRect& aWindowRect, const TRect& aClipRect) const;

	 









	  TInt UpdateDisplayRegion(const TRegion& aRegion) const;

	 









	  TInt GetAudioEnabled(TBool& aEnabled) const;

	 









	  TInt DirectScreenAccessEvent(const TMMFDSAEvent aDSAEvent) const;

	 











	  TInt Play(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) const;

	 






	  TInt RefreshFrame() const;

	 









	  TInt GetLoadingProgress(TInt& aPercentageProgress) const;

	 









	  TInt SetRotation(TVideoRotation aRotation) const;

	 









	  TInt GetRotation(TVideoRotation& aRotation) const;

	 















	  TInt SetScaleFactor(TReal32 aWidthPercentage, TReal32 aHeightPercentage, TBool aAntiAliasFiltering) const;

	 















	  TInt GetScaleFactor(TReal32& aWidthPercentage, TReal32& aHeightPercentage, TBool& aAntiAliasFiltering) const;

	 









	  TInt SetCropRegion(const TRect& aCropRegion) const;

	 










	  TInt GetCropRegion(TRect& aCropRegion) const;


private:
	TPckgBuf<TMMFVideoConfig> iConfigPackage;
	};

 










class RMMFVideoRecordControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoRecordControllerCustomCommands(RMMFController& aController);

	 









	  TInt SetVideoFormat(TUid aVideoFormatUid) const;

	 









	  TInt SetVideoCodec(const TDesC8& aVideoCodec) const;

	 









	  TInt SetVideoBitRate(TInt aBitRate) const;

	 









	  TInt SetAudioBitRate(TInt aBitRate) const;

	 









	  TInt SetAudioCodec(TFourCC aAudioCodec) const;

	 









	  TInt SetVideoFrameSize(TSize aVideoFrameSize) const;

	 










	  TInt SetMaxFileSize(TInt aMaxSize) const;

	 









	  void AddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry)const;

	 









	  TInt RemoveMetaDataEntry(TInt aIndex)const;

	 









	  void ReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry)const;

	 









	  TInt SetAudioEnabled(TBool aEnable) const;

	 







	  TInt Prepare() const;

	 









	  TInt SetCameraHandle(TInt aCameraHandle) const;

	 









	  TInt GetRecordTimeAvailable(TTimeIntervalMicroSeconds& aTime) const;

	 







	  TInt GetSupportedSinkAudioTypes(RArray<TFourCC>& aSupportedDataTypes) const;

	 







	  TInt GetSupportedSinkVideoTypes(CDesC8Array& aDataTypes) const;

	 
	 









	  TInt GetAudioEnabled(TBool& aEnabled) const;

private:
	void DoGetCDesC8ArrayL(CDesC8Array& aArray, TMMFVideoRecordControllerMessages aIpc) const;
	void DoGetFourCCArrayL(RArray<TFourCC>& aArray) const;
	};



 






class MMMFVideoRecordControllerCustomCommandImplementor
	{
public:

	 









	virtual void MvrcSetVideoFormatL(TUid aVideoFormatUid)=0;

	 









	virtual void MvrcSetVideoCodecL(const TDesC8& aVideoCodec)=0;

	 









	virtual void MvrcSetAudioCodecL(TFourCC aAudioCodec)=0;

	 










	virtual void MvrcSetVideoBitRateL(TInt& aBitRate)=0;

	 









	virtual void MvrcSetAudioBitRateL(TInt& aBitRate)=0;

	 







	virtual void MvrcAddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry)=0;

	 







	virtual void MvrcRemoveMetaDataEntryL(TInt aIndex)=0;

	 









	virtual void MvrcReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry)=0;

	 








	virtual void MvrcSetMaxFileSizeL(TInt aMaxFileSize)=0;

	 







	virtual void MvrcSetAudioEnabledL(TBool aEnable)=0;

	 







	virtual void MvrcSetVideoFrameSizeL(TSize aFrameSize)=0;

	 





	virtual void MvrcPrepareL()=0;

	 




	virtual void MvrcSetCameraHandleL(TInt aCameraHandle)=0;

	 







	virtual void MvrcGetRecordTimeAvailableL(TTimeIntervalMicroSeconds& aTime) = 0;

	 









	virtual void MvrcGetSupportedSinkAudioTypesL(RArray<TFourCC>& aDataTypes)=0;

	 









	virtual void MvrcGetSupportedSinkVideoTypesL(CDesC8Array& aDataTypes)=0;

	 
	 







	virtual void MvrcGetAudioEnabledL(TBool& aEnabled)=0;
	};


 










class MMMFVideoPlayControllerCustomCommandImplementor
	{
public:

	 










	virtual void MvpcPrepare()=0;

	 







	virtual void MvpcGetFrameL(MMMFVideoFrameMessage& aVideoFrame)=0;

	 







	virtual void MvpcGetAudioEnabledL(TBool& aEnabled)=0;

	 







	virtual void MvpcSetDisplayWindowL(const TRect& aWindowRect, const TRect& aClipRect) = 0;

	 








	virtual void MvpcUpdateDisplayRegionL(const TRegion& aRegion) = 0;

	 









	virtual void MvpcDirectScreenAccessEventL(const TMMFDSAEvent aDSAEvent) = 0;

	 









	virtual void MvpcPlayL(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) = 0;
	
	 




	virtual void MvpcRefreshFrameL() = 0;

	 







	virtual void MvpcGetLoadingProgressL(TInt& aPercentageComplete) = 0;

	 







	virtual void MvpcSetRotationL(TVideoRotation aRotation) = 0;

	 







	virtual void MvpcGetRotationL(TVideoRotation& aRotation) = 0;

	 














	virtual void MvpcSetScaleFactorL(TReal32 aWidthPercentage, TReal32 aHeightPercentage, TBool aAntiAliasFiltering) = 0;

	 














	virtual void MvpcGetScaleFactorL(TReal32& aWidthPercentage, TReal32& aHeightPercentage, TBool& aAntiAliasFiltering) = 0;

	 







	virtual void MvpcSetCropRegionL(const TRect& aCropRegion) = 0;

	 








	virtual void MvpcGetCropRegionL(TRect& aCropRegion) = 0;
	};



 






class MMMFVideoControllerCustomCommandImplementor
	{
public:

	 







	virtual void MvcGetVideoFrameSizeL(TSize& aVideoFrameSize)=0;

	 







	virtual void MvcGetAudioCodecL(TFourCC& aCodec)=0;

	 








	virtual void MvcGetVideoBitRateL(TInt& aBitRate)=0;

	 







	virtual void MvcGetAudioBitRateL(TInt& aBitRate)=0;

	 







	virtual void MvcSetFrameRateL(TReal32 aFramesPerSecond)=0;

	 







	virtual void MvcGetFrameRateL(TReal32& aFramesPerSecond)=0;

	 







	virtual void MvcGetVideoMimeTypeL(TDes8& aMimeType)=0;
	};


 

































class CMMFVideoControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoControllerCustomCommandParser* NewL(MMMFVideoControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFVideoControllerCustomCommandParser(MMMFVideoControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoGetAudioCodecL(TMMFMessage& aMessage);

	TBool DoGetAudioBitRateL(TMMFMessage& aMessage);
	TBool DoGetVideoBitRateL(TMMFMessage& aMessage);
	TBool DoGetVideoFrameSizeL(TMMFMessage& aMessage);
	TBool DoSetFrameRateL(TMMFMessage& aMessage);
	TBool DoGetFrameRateL(TMMFMessage& aMessage);
	TBool DoGetVideoMimeTypeL(TMMFMessage& aMessage);
private:
	 


	MMMFVideoControllerCustomCommandImplementor& iImplementor;
	};

 










class CMMFVideoPlayControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoPlayControllerCustomCommandParser* NewL(MMMFVideoPlayControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoPlayControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:
	 







	CMMFVideoPlayControllerCustomCommandParser(MMMFVideoPlayControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoRequestFrameL(TMMFMessage& aMessage);
	TBool DoGetFrameL(TMMFMessage& aMessage);
	TBool DoSetDisplayWindowL(TMMFMessage& aMessage);
	TBool DoUpdateDisplayRegionL(TMMFMessage& aMessage);
	TBool DoGetAudioEnabledL(TMMFMessage& aMessage);
	TBool DoDirectScreenAccessEventL(TMMFMessage& aMessage);
	TBool DoPlayL(TMMFMessage& aMessage);
	TBool DoRefreshFrameL(TMMFMessage& aMessage);
	TBool DoGetLoadingProgressL(TMMFMessage& aMessage);
	TBool DoPrepareL(TMMFMessage& aMessage);
	TBool DoSetRotationL(TMMFMessage& aMessage);
	TBool DoGetRotationL(TMMFMessage& aMessage);
	TBool DoSetScaleFactorL(TMMFMessage& aMessage);
	TBool DoGetScaleFactorL(TMMFMessage& aMessage);
	TBool DoSetCropRegionL(TMMFMessage& aMessage);
	TBool DoGetCropRegionL(TMMFMessage& aMessage);


private:
	 


	MMMFVideoPlayControllerCustomCommandImplementor& iImplementor;
	CMMFVideoFrameMessage* iVideoFrameMessage;
	};

 










class CMMFVideoRecordControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoRecordControllerCustomCommandParser* NewL(MMMFVideoRecordControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoRecordControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:
	 







	CMMFVideoRecordControllerCustomCommandParser(MMMFVideoRecordControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetVideoFormatL(TMMFMessage& aMessage);
	TBool DoSetAudioBitRateL(TMMFMessage& aMessage);
	TBool DoSetVideoBitRateL(TMMFMessage& aMessage);
	TBool DoSetVideoCodecL(TMMFMessage& aMessage);
	TBool DoSetAudioCodecL(TMMFMessage& aMessage);
	TBool DoAddMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoRemoveMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoReplaceMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoSetMaxFileSizeL(TMMFMessage& aMessage);
	TBool DoSetAudioEnabledL(TMMFMessage& aMessage);
	TBool DoSetVideoFrameSizeL(TMMFMessage& aMessage);
	TBool DoPrepareL(TMMFMessage& aMessage);
	TBool DoSetCameraHandleL(TMMFMessage& aMessage);
	TBool DoGetRecordTimeAvailableL(TMMFMessage& aMessage);

	TBool DoGetSupportedSinkAudioTypesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkVideoTypesL(TMMFMessage& aMessage);

	TInt32 DoCreateBufFromCDesC8ArrayL(CDesC8Array& aArray);
	TBool DoCopyCDesC8ArrayDataL(TMMFMessage& aMessage);

	TBool DoCopyFourCCArrayDataL(TMMFMessage& aMessage);
	void DoCreateBufFromFourCCArrayL(RArray<TFourCC>& aArray);
	TBool DoGetAudioEnabledL(TMMFMessage& aMessage);  

private:
	 


	MMMFVideoRecordControllerCustomCommandImplementor& iImplementor;
	CBufFlat* iDataCopyBuffer;
	};



 










class RMMFVideoDRMExtCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoDRMExtCustomCommands(RMMFController& aController);

	 









	  void GetFrame(CFbsBitmap& aBitmap, ContentAccess::TIntent aIntent, TRequestStatus& aStatus);

private:
	TPckgBuf<TMMFVideoConfig> iConfigPackage;
	TPckgBuf<ContentAccess::TIntent> iIntentPackage;
	};



 






class MMMFVideoDRMExtCustomCommandImplementor
	{
public:

	 







	virtual void MvdeGetFrameL(MMMFVideoFrameMessage& aVideoFrame, ContentAccess::TIntent aIntent)=0;
	};


 








class CMMFVideoDRMExtCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoDRMExtCustomCommandParser* NewL(MMMFVideoDRMExtCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoDRMExtCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);

private:
	 






	CMMFVideoDRMExtCustomCommandParser(MMMFVideoDRMExtCustomCommandImplementor& aImplementor);
	 

	void DoGetFrameL(TMMFMessage& aMessage);

private:
	MMMFVideoDRMExtCustomCommandImplementor& iImplementor;
	CMMFVideoFrameMessage* iVideoFrameMessage;
	};




# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mdaaudiooutputstream.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/utility.h" 1
 
 
 
 
 





 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/port.h" 1
 
 
 
 




 


 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/base.h" 1
 
 
 
 




 


 


 



enum { KDummyMdaSessionNotImplemented = 0 };

 



enum { KMediaServerNotImplemented = 0 };

 



enum { KDummyMdaObjectNotImplemented = 0 };

 





  TInt StartMediaServer();
  void StartMediaServerL();
  void StartMediaServer(TRequestStatus& aStatus);

class RDummyMdaObject;

 






class RDummyMdaSession : public RSessionBase
	{
public:
	  TInt Connect(TInt aSlots=KMdaServerDefaultMessageSlots);
	  void ConnectL(TInt aSlots=KMdaServerDefaultMessageSlots);
	  void ConnectLC(TInt aSlots=KMdaServerDefaultMessageSlots);
	 
	  void Close();
	 
	  TInt ListenTo(const RDummyMdaObject& aObject);
	  void ListenToL(const RDummyMdaObject& aObject);
	  void StopListeningTo(const RDummyMdaObject& aObject);
	 
	  TInt SetListenerParameters(TMdaEventPackage& aPackage,TInt aMaxPackages);
	  void SetListenerParametersL(TMdaEventPackage& aPackage,TInt aMaxPackages);
	 
	  void GetListenerEvents(TMdaEventPackage& aEvents, TRequestStatus& aStatus);
	  void CancelGetListenerEvents();
private:
	friend class RDummyMdaObject;
	};

class RMdaRegistry;

 






class RDummyMdaObject
	{
public:
      void Close();
protected:
	 
	  TInt SynchCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TAny* aArg= 0L );
	  void SynchCreateMessageL(const RDummyMdaObject& aParent,TInt16 aFunction,TAny* aArg= 0L );
	  void SynchCreateMessageLC(const RDummyMdaObject& aParent,TInt16 aFunction,TAny* aArg= 0L );
	  void AsynchCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TRequestStatus &aStatus,TAny* aArg= 0L );
	  TInt SynchPackageCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TMdaOpenPackage& aPackage);
	  void SynchPackageCreateMessageL(const RDummyMdaObject& aParent,TInt16 aFunction,TMdaOpenPackage& aPackage);
	  void SynchPackageCreateMessageLC(const RDummyMdaObject& aParent,TInt16 aFunction,TMdaOpenPackage& aPackage);
	  void AsynchPackageCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TRequestStatus &aStatus,TMdaOpenPackage& aPackage);
	  void CancelCreateMessage( TRequestStatus &aStatus);
	 
	  TInt BlindMessage(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  void BlindMessageL(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  TInt SynchMessage(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  void SynchMessageL(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  void AsynchMessage(TInt16 aFunction,TRequestStatus &aStatus,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ) const;
	  void CancelMessage( TRequestStatus &aStatus) const;
	 
	  TInt SynchPackage(TInt16 aFunction,const TMdaRawPackage& aPackage) const;
	  void SynchPackageL(TInt16 aFunction,const TMdaRawPackage& aPackage) const;
	  void AsynchPackage(TInt16 aFunction,TRequestStatus &aStatus,const TMdaRawPackage& aPackage) const;
	  TInt SynchPackageReturn(TInt16 aFunction,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
	  void SynchPackageReturnL(TInt16 aFunction,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
	  void SynchPackageReturnLC(TInt16 aFunction,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
	  void AsynchPackageReturn(TInt16 aFunction,TRequestStatus &aStatus,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
private:
	RDummyMdaSession iSession;
	TPckgBuf<TInt> iObjectHandle;
	friend class RMdaRegistry;
	friend class RMdaTimer;
	friend class RMdaTimerFactory;
	};


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/port.h" 2



 





class RMdaPort : public RDummyMdaObject
	{
	};

 





class RMdaSrcPort : public RMdaPort
	{  
	};

 





class RMdaDstPort : public RMdaPort
	{  
	};


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/utility.h" 2


 



enum {
	KDummyMdaControllerNotImplemented = 0,
	KDummyMdaServerNotImplemented,
	KDummyMdaResourceNotImplemented
	};

 
 

 





class MMdaObjectEventListener
	{
public:

	 




	virtual const RDummyMdaObject& MoelObject() const =0;

	 







	virtual void MoelEvent(const TMdaEvent& aEvent) =0;

	 



	virtual void MoelEventMissed() =0;
	friend class CMdaServer;
	};

 





class CMdaServer : public CBase
	{
public:
	  static CMdaServer* NewL();
	  ~CMdaServer();
	  void AddListenerL(MMdaObjectEventListener& aListener);
	  void RemoveListener(MMdaObjectEventListener& aListener);
	};

 













class MMdaObjectStateChangeObserver
	{
public:
	virtual void MoscoStateChangeEvent(CBase* aObject, TInt aPreviousState, TInt aCurrentState, TInt aErrorCode)=0;
	};

 




class MDummyMdaSrcPort
	{
public:
	virtual const RMdaSrcPort& MspSrcPort()=0;
	};

 




class MDummyMdaDstPort
	{
public:
	virtual const RMdaDstPort& MdpDstPort()=0;
	};

 




class CDummyMdaResource : public CActive, public MDummyMdaSrcPort, public MDummyMdaDstPort
	{
protected:
	  CDummyMdaResource(TInt aPriority);
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mdaaudiooutputstream.h" 2



 









class MMdaAudioOutputStreamCallback 
	{
public:

	 






	virtual void MaoscOpenComplete(TInt aError) = 0;

	 














	virtual void MaoscBufferCopied(TInt aError, const TDesC8& aBuffer) = 0;

	 









	virtual void MaoscPlayComplete(TInt aError) = 0;
	};


class CMMFMdaAudioOutputStream;

 
































class CMdaAudioOutputStream : public CBase
	{
public:

	 












	  static CMdaAudioOutputStream* NewL(MMdaAudioOutputStreamCallback& aCallBack,
												CMdaServer* aServer = 0L );

	 




















	  static CMdaAudioOutputStream* NewL(MMdaAudioOutputStreamCallback& aCallBack,
												TInt aPriority,
												TMdaPriorityPreference aPref = EMdaPriorityPreferenceTimeAndQuality);


	 




	~CMdaAudioOutputStream();

	 







	virtual void SetAudioPropertiesL(TInt aSampleRate, TInt aChannels);

	 










	virtual void Open(TMdaPackage* aSettings);

	 




	virtual TInt MaxVolume();

	 




	virtual TInt Volume();

	 







	virtual void SetVolume(const TInt aNewVolume);

	 

















	virtual void SetPriority(TInt aPriority, TMdaPriorityPreference aPref);
	
	 











	virtual void WriteL(const TDesC8& aData);

	 


	virtual void Stop();

	 




	virtual const TTimeIntervalMicroSeconds& Position();

	 





	  void SetBalanceL(TInt aBalance = KMMFBalanceCenter);
	
	 




	  TInt GetBalanceL() const;

	 




	  TInt GetBytes();

	 









      void SetDataTypeL(TFourCC aAudioType);

	 




	  TFourCC DataType() const;


private:
	CMdaAudioOutputStream();
private:
	 


	CMMFMdaAudioOutputStream* iProperties;
	};


# 74 "../../libayfly/ayfly.h" 2




# 1 "../../libayfly/z80ex/include/z80ex.h" 1
 











# 1 "../../libayfly/z80ex/include/z80ex_common.h" 1
 











 
 









# 44 "../../libayfly/z80ex/include/z80ex_common.h"

typedef unsigned char Z80EX_BYTE;
typedef signed char Z80EX_SIGNED_BYTE;
typedef unsigned short Z80EX_WORD;
typedef unsigned int Z80EX_DWORD;



# 13 "../../libayfly/z80ex/include/z80ex.h" 2


typedef
enum {regAF,regBC,regDE,regHL,regAF_,regBC_,regDE_,regHL_,regIX,regIY,regPC,regSP,regI,regR,regR7,regIM ,regIFF1,regIFF2}
Z80_REG_T;



struct _z80_cpu_context;
typedef struct _z80_cpu_context Z80EX_CONTEXT;



 

 
typedef void (*z80ex_tstate_cb)(Z80EX_CONTEXT *cpu, void *user_data);

 

typedef Z80EX_BYTE (*z80ex_mread_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD addr, int m1_state, void *user_data);

 
typedef void (*z80ex_mwrite_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD addr, Z80EX_BYTE value, void *user_data);

 
typedef Z80EX_BYTE (*z80ex_pread_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD port, void *user_data);

 
typedef void (*z80ex_pwrite_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD port, Z80EX_BYTE value, void *user_data);

 
typedef Z80EX_BYTE (*z80ex_intread_cb)(Z80EX_CONTEXT *cpu, void *user_data);




 
extern Z80EX_CONTEXT *z80ex_create(z80ex_mread_cb mrcb_fn, void *mrcb_data,
	z80ex_mwrite_cb mwcb_fn, void *mwcb_data,
	z80ex_pread_cb prcb_fn, void *prcb_data,
	z80ex_pwrite_cb pwcb_fn, void *pwcb_data,
	z80ex_intread_cb ircb_fn, void *ircb_data);

 
extern void z80ex_destroy(Z80EX_CONTEXT *cpu);

 
extern int z80ex_step(Z80EX_CONTEXT *cpu);

 

extern Z80EX_BYTE z80ex_last_op_type(Z80EX_CONTEXT *cpu);

 
extern void z80ex_set_tstate_callback(Z80EX_CONTEXT *cpu, z80ex_tstate_cb cb_fn, void *user_data);

 
 
extern int z80ex_int(Z80EX_CONTEXT *cpu);

 
 

extern int z80ex_nmi(Z80EX_CONTEXT *cpu);

 
extern void z80ex_reset(Z80EX_CONTEXT *cpu);

 
extern Z80EX_WORD z80ex_get_reg(Z80EX_CONTEXT *cpu, Z80_REG_T reg);

 
extern void z80ex_set_reg(Z80EX_CONTEXT *cpu, Z80_REG_T reg, Z80EX_WORD value);

 
extern int z80ex_doing_halt(Z80EX_CONTEXT *cpu);

 

extern int z80ex_op_tstate(Z80EX_CONTEXT *cpu);

 

extern void z80ex_w_states(Z80EX_CONTEXT *cpu, unsigned w_states);

 


extern void z80ex_next_t_state(Z80EX_CONTEXT *cpu);





# 78 "../../libayfly/ayfly.h" 2

# 90 "../../libayfly/ayfly.h"

















struct AYSongInfo;

typedef void (*ELAPSED_CALLBACK)(void *arg);
typedef void (*PLAYER_INIT_PROC)(AYSongInfo &info);
typedef void (*PLAYER_PLAY_PROC)(AYSongInfo &info);
typedef void (*PLAYER_CLEANUP_PROC)(AYSongInfo &info);

# 1 "../../libayfly/ay.h" 1
 






















enum
{
    AY_CHNL_A_FINE = 0,
    AY_CHNL_A_COARSE,
    AY_CHNL_B_FINE,
    AY_CHNL_B_COARSE,
    AY_CHNL_C_FINE,
    AY_CHNL_C_COARSE,
    AY_NOISE_PERIOD,
    AY_MIXER,
    AY_CHNL_A_VOL,
    AY_CHNL_B_VOL,
    AY_CHNL_C_VOL,
    AY_ENV_FINE,
    AY_ENV_COARSE,
    AY_ENV_SHAPE,
    AY_GPIO_A,
    AY_GPIO_B
};

class ay
{
public:
    ay(AYSongInfo *info);
    ~ay();
    void ayReset();
    void ayWrite(unsigned char reg, unsigned char val);
    unsigned char ayRead(unsigned char reg);
    void ayProcess(unsigned char *stream, unsigned long len);
    void ayProcessMono(unsigned char *stream, unsigned long len);
    inline void chnlMute(unsigned long chnl, bool mute)
    {
        chnl_mute[chnl] = !mute;
    }
    ;
    inline bool chnlMuted(unsigned long chnl)
    {
        return chnl_mute[chnl];
    }
    ;
    inline float GetVolume(unsigned long chnl)
    {
        return volume[chnl];
    }
    ;
    inline void SetVolume(unsigned long chnl, float new_volume)
    {
        volume[chnl] = new_volume;
    }
    ;
    inline const unsigned char *GetRegs()
    {
        return regs;
    };

    void SetParameters();
private:
    static const float init_levels[16];
    float levels[16];
    unsigned char regs[16];
    long noise_period;
    long chnl_period[3];
    float chnl_vol[3];
    bool chnl_enable[3];
    long tone_period_init[3];
    long noise_period_init;
    long chnl_trigger[3];
    bool noise_enable[3];
    unsigned long noise_trigger;
    unsigned long noise_reg;
    long env_period_init;
    long env_period;
    unsigned long env_type;
    unsigned long env_tick;
    unsigned long env_vol;
    long env_trigger;
    bool chnl_mute[3];
    unsigned long ay_tacts;
    void setEnvelope();
    void updateEnvelope();
    float volume[3];
    unsigned long int_counter;
    unsigned long int_limit;
    AYSongInfo *songinfo;
};



# 114 "../../libayfly/ayfly.h" 2

# 1 "../../libayfly/AbstractAudio.h" 1
 






















class AbstractAudio
{
public:
    AbstractAudio(unsigned long _sr, AYSongInfo *info);
    virtual ~AbstractAudio();
    virtual bool Start(void) = 0;
    virtual void Stop() = 0;
    virtual void WriteAy(unsigned char reg, unsigned char val)
    {
        ay8910->ayWrite(reg, val);
    }
    ;
    unsigned char ReadAy(unsigned char reg)
    {
        return ay8910->ayRead(reg);
    }
    ;
    void ResetAy()
    {
        ay8910->ayReset();
    }
    ;
    inline virtual void ChnlMute(unsigned long chnl, bool mute)
    {
        if(ay8910)
            ay8910->chnlMute(chnl, mute);
    }
    ;
    inline virtual bool ChnlMuted(unsigned long chnl)
    {
        return ay8910 ? ay8910->chnlMuted(chnl) : true;
    }
    ;
    bool Started()
    {
        return started;
    }
    ;
    inline float GetVolume(unsigned long chnl)
    {
        return ay8910 ? ay8910->GetVolume(chnl) : 0;
    }
    ;
    inline void SetVolume(unsigned long chnl, float new_volume)
    {
        if(ay8910)
        {
            ay8910->SetVolume(chnl, new_volume);
        }
    }
    ;
    inline const unsigned char *GetAYRegs(unsigned long chip_num = 0)
    {
        return ay8910 ? ay8910->GetRegs() : 0;
    }
    ;
    inline void GetAYBuffer(unsigned char *buffer, unsigned long buffer_length, unsigned long chip_num = 0)
    {
        ay8910->ayProcess(buffer, buffer_length);
    }
    ;
    inline void GetAYBufferMono(unsigned char *buffer, unsigned long buffer_length, unsigned long chip_num = 0)
    {
        ay8910->ayProcessMono(buffer, buffer_length);
    }
    ;
    inline void SetAYParameters()
    {
        ay8910->SetParameters();
    }
    ;
protected:
    unsigned long sr;
    bool started;
    AYSongInfo *songinfo;
    ay *ay8910;
};


# 115 "../../libayfly/ayfly.h" 2


struct AYSongInfo
{





    TFileName Author;
    TFileName Name;
    TFileName FilePath;

    unsigned long Length;  
    unsigned long Loop;  
    bool bEmul;  
    PLAYER_INIT_PROC init_proc;  
    PLAYER_PLAY_PROC play_proc;  
    PLAYER_CLEANUP_PROC cleanup_proc;  
    void *data;  
    unsigned char *module;  
    unsigned char *file_data;  
    unsigned char z80IO [65536];  
    unsigned long file_len;  
    AbstractAudio *player;  
    Z80EX_CONTEXT *z80ctx;  
    unsigned long timeElapsed;  
    ELAPSED_CALLBACK callback;  
    void *callback_arg;  
    unsigned short ay_reg;  
    unsigned long z80_freq;  
    unsigned long ay_freq;  
    unsigned long int_freq;  
    unsigned long sr;  
    ~AYSongInfo();
};









# 1 "../../libayfly/s60/ayfly_s60Audio.h" 1
















class Cayfly_s60Sound;

class CCommandHandler: public CActive
{
public:
      static CCommandHandler* NewL();
      ~CCommandHandler();
    void Start(Cayfly_s60Sound *aSound);
    void DoCancel();
      CCommandHandler();
      void RunL();
private:
    Cayfly_s60Sound *iSound;
};

class Cayfly_s60Sound: public CBase, MMdaAudioOutputStreamCallback
{
public:
    enum
    {
        EStopped = 0, EStarting, EPlaying, EStopping
    };
public:
    static Cayfly_s60Sound* NewL(AYSongInfo *info);
    virtual ~Cayfly_s60Sound();

    void StartPlay();
    void StopPlay();
    void SetDeviceVolume(TInt aVolume);
    TInt GetDeviceVolume();

    virtual void MaoscOpenComplete(TInt aError);
    virtual void MaoscBufferCopied(TInt aError, const TDesC8 &aBuffer);
    virtual void MaoscPlayComplete(TInt aError);

    bool StartL();
    void StopL();

    void PrivateWaitRequestOK();
    void PrivateStart();
    void PrivateStop();
    void PrivateSetVolume();
    TInt State();
    void Exit();
    unsigned char *iBuffer1;
    unsigned char *iBuffer2;
    TPtr8 iDesc1;
    TPtr8 iDesc2;
    RThread iPlayerThread;
    TRequestStatus *iRequestPtr;
    TBool iKilling;
    TInt iBufferToMix;
    TInt iMixStep;
    CIdle *iIdle;
    TBool iIdleActive;
    TBool iStartOnNext;
    CMdaAudioOutputStream *iStream;
    TMdaAudioDataSettings iSettings;
    TInt iState;
    TInt iVolume;
    CCommandHandler *iHandler;
    bool stereo;
private:
    void ConstructL();
    Cayfly_s60Sound(AYSongInfo *info);
    AYSongInfo *songinfo;
    static TInt MixLoop(TAny *t);
};

 
class Cayfly_s60Audio : public AbstractAudio
{
public:
    Cayfly_s60Audio(AYSongInfo *info);
    virtual ~Cayfly_s60Audio();
    virtual bool Start();
    virtual void Stop();
    void SetDeviceVolume(TInt aVolume);
    TInt GetDeviceVolume();
private:
    Cayfly_s60Sound *sound;
};


# 160 "../../libayfly/ayfly.h" 2




 
bool ay_sys_readfromfile(AYSongInfo &info);
bool ay_sys_getsonginfo(AYSongInfo &info);
bool ay_sys_getsonginfoindirect(AYSongInfo &info);
void ay_sys_rewindsong(AYSongInfo &info, long new_position);
bool ay_sys_initz80(AYSongInfo &info);
void ay_sys_z80exec(AYSongInfo &info);
void ay_sys_resetz80(AYSongInfo &info);
void ay_sys_shutdownz80(AYSongInfo &info);
bool ay_sys_initsong(AYSongInfo &info);


extern "C" {

 



  void *ay_initsong(TFileName FilePath, unsigned long sr);




  void *ay_initsongindirect(unsigned char *module, unsigned long sr, TFileName type, unsigned long size);




  void *ay_getsonginfo(TFileName FilePath);




  void *ay_getsonginfoindirect(unsigned char *module, TFileName type, unsigned long size);




  TFileName ay_getsongname(void *info);




  TFileName ay_getsongauthor(void *info);




  TFileName ay_getsongpath(void *info);

  void ay_z80xec(void *info);
  void ay_seeksong(void *info, long new_position);
  void ay_resetsong(void *info);
  void ay_closesong(void **info);
  bool ay_songstarted(void *info);
  void ay_startsong(void *info);
  void ay_stopsong(void *info);
  void ay_setvolume(void *info, unsigned long chnl, float volume);
  float ay_getvolume(void *info, unsigned long chnl);
  void ay_chnlmute(void *info, unsigned long chnl, bool mute);
  bool ay_chnlmuted(void *info, unsigned long chnl);
  void ay_setcallback(void *info, ELAPSED_CALLBACK callback, void *callback_arg);
  unsigned long ay_getsonglength(void *info);
  unsigned long ay_getelapsedtime(void *info);
  unsigned long ay_getsongloop(void *info);
  const unsigned char *ay_getregs(void *info, unsigned long chip_num);
  void ay_rendersongbuffer(void *info, unsigned char *buffer, unsigned long buffer_length, unsigned long chip_num);
  unsigned long ay_getz80freq(void *info);
  void ay_setz80freq(void *info, unsigned long z80_freq);
  unsigned long ay_getayfreq(void *info);
  void ay_setayfreq(void *info, unsigned long ay_freq);
  unsigned long ay_getintfreq(void *info);
  void ay_setintfreq(void *info, unsigned long int_freq);
  void ay_setsongplayer(void *info, void *   player);
  void *ay_getsongplayer(void *info);





}














# 25 "../../libayfly/s60/ayfly_s60Audio.cpp" 2


static const TLitC<sizeof(L"ayflyplaybackthread" )/2>  KThreadName ={sizeof(L"ayflyplaybackthread" )/2-1,L"ayflyplaybackthread" } ;

 
static const TInt sampleRateConversionTable[] =
{ 44100, TMdaAudioDataSettings::ESampleRate44100Hz, 32000, TMdaAudioDataSettings::ESampleRate32000Hz, 22050, TMdaAudioDataSettings::ESampleRate22050Hz, 16000, TMdaAudioDataSettings::ESampleRate16000Hz, 11025, TMdaAudioDataSettings::ESampleRate11025Hz, 48000, TMdaAudioDataSettings::ESampleRate48000Hz, 8000, TMdaAudioDataSettings::ESampleRate8000Hz };

Cayfly_s60Sound* Cayfly_s60Sound::NewL(AYSongInfo *info)
{
    Cayfly_s60Sound* a = new (ELeave) Cayfly_s60Sound(info);
    a->ConstructL();
    return a;
}

Cayfly_s60Sound::Cayfly_s60Sound(AYSongInfo *info) :
    iDesc1(0, 0, 0), iDesc2(0, 0, 0)
{
    songinfo = info;
    iVolume = 7;

}

Cayfly_s60Sound::~Cayfly_s60Sound()
{

    delete[] iBuffer1;
    delete[] iBuffer2;
}

void Cayfly_s60Sound::MaoscOpenComplete(TInt aError)
{
    if(aError != KErrNone)
    {
        User::Panic((TPtrC((const TText *)L"STREAMOPEN FAILED" )) , aError);
        iState = EStopped;
        return;
    }

    TInt mix_freq = 0;

     
    for(TUint i = 0; i < sizeof(sampleRateConversionTable) / sizeof(TInt); i += 2)
    {
        TInt  err ;{TTrap __t;if (__t.Trap( err )==0){  iStream->SetAudioPropertiesL(sampleRateConversionTable[i + 1], TMdaAudioDataSettings::EChannelsStereo) ;TTrap::UnTrap();}} ;
        if(err == KErrNone)
        {
            mix_freq = sampleRateConversionTable[i];
            stereo = true;
            break;
        }
    }

     
    if(mix_freq == 0)
    {
        for(TUint i = 0; i < sizeof(sampleRateConversionTable) / sizeof(TInt); i += 2)
        {
            TInt  err ;{TTrap __t;if (__t.Trap( err )==0){  iStream->SetAudioPropertiesL(sampleRateConversionTable[i + 1], TMdaAudioDataSettings::EChannelsMono) ;TTrap::UnTrap();}} ;
            if(err == KErrNone)
            {
                mix_freq = sampleRateConversionTable[i];
                stereo = false;
                break;
            }
        }
    }

    songinfo->sr = mix_freq;
    songinfo->player->SetAYParameters();

    iState = EPlaying;

     
    if(stereo)
    {
        songinfo->player->GetAYBuffer(iBuffer1, 2048 * 8 *4 );
        songinfo->player->GetAYBuffer(iBuffer2, 2048 * 8 *4 );
    }
    else
    {
        songinfo->player->GetAYBufferMono(iBuffer1, 2048 * 8 *4 );
        songinfo->player->GetAYBufferMono(iBuffer2, 2048 * 8 *4 );
    }

    iStream->SetVolume(iVolume);
    iStream->SetBalanceL();

     
    iStream->WriteL(iDesc1);
    iStream->WriteL(iDesc2);

    iMixStep = 8 ;
    iIdleActive = EFalse;
}

TInt Cayfly_s60Sound::MixLoop(TAny *t)
{
    Cayfly_s60Sound *s = (Cayfly_s60Sound*)t;
    TInt samplesLeft = ((8  - s->iMixStep) * (2048 * 8 *4  / 8 ));

     
    if(s->State() != Cayfly_s60Sound::EPlaying)
        return EFalse;

    if(s->iStartOnNext)
    {
         
        if(s->iBufferToMix == 0)
        {
            if(s->stereo)
                s->songinfo->player->GetAYBuffer((unsigned char*)(s->iBuffer1 + ((2048 * 8 *4  / 8 ) * s->iMixStep)), samplesLeft);
            else
                s->songinfo->player->GetAYBufferMono((unsigned char*)(s->iBuffer1 + ((2048 * 8 *4  / 8 ) * s->iMixStep)), samplesLeft);
        }
        else
        {
            if(s->stereo)
                s->songinfo->player->GetAYBuffer((unsigned char*)(s->iBuffer2 + ((2048 * 8 *4  / 8 ) * s->iMixStep)), samplesLeft);
            else
                s->songinfo->player->GetAYBufferMono((unsigned char*)(s->iBuffer2 + ((2048 * 8 *4  / 8 ) * s->iMixStep)), samplesLeft);
        }

         
        s->iMixStep = 0;
        s->iBufferToMix = 1 - s->iBufferToMix;
        s->iStartOnNext = EFalse;

        return ETrue;
    }
    else
    {
         
        char *mix_buffer = (char*)s->iBuffer1;

         
        if(s->iBufferToMix == 1)
        {
            mix_buffer = (char*)s->iBuffer2;
        }

        if(s->stereo)
            s->songinfo->player->GetAYBuffer((unsigned char*)(mix_buffer + ((2048 * 8 *4  / 8 ) * s->iMixStep)), 2048 * 8 *4  / 8 );
        else
            s->songinfo->player->GetAYBufferMono((unsigned char*)(mix_buffer + ((2048 * 8 *4  / 8 ) * s->iMixStep)), 2048 * 8 *4  / 8 );

        s->iMixStep++;

        if(s->iMixStep == 8 )
        {
             
            if(s->iBufferToMix == 0)
                s->iStream->WriteL(s->iDesc1);
            else
                s->iStream->WriteL(s->iDesc2);

            s->iIdleActive = EFalse;
            return EFalse;
        }
    }

     
    return ETrue;
}

void Cayfly_s60Sound::MaoscBufferCopied(TInt aError, const TDesC8 &aBuffer)
{
    if(aError != KErrNone)
    {
        iState = EStopped;
        return;
    }

    if(iState == EPlaying)
    {
        if(!iIdleActive)
        {
             
            iBufferToMix = 0;
            if(aBuffer.Ptr() == iBuffer2)
            {
                iBufferToMix = 1;
            }

            iMixStep = 0;

             
            iStartOnNext = EFalse;
            iIdle = CIdle::NewL(CActive::EPriorityIdle);
            iIdle->Start(TCallBack(MixLoop, this));
            iIdleActive = ETrue;
        }
        else
        {
             
            iStartOnNext = ETrue;
        }
    }
}

void Cayfly_s60Sound::MaoscPlayComplete(TInt aError)
{
    if(aError != KErrNone)
    {
        iState = EStopped;
    }
}

void Cayfly_s60Sound::SetDeviceVolume(TInt aVolume)
{
    iVolume = aVolume;
    PrivateWaitRequestOK();
    iPlayerThread.RequestComplete(iRequestPtr, 3 );
}

TInt Cayfly_s60Sound::GetDeviceVolume()
{
    User::After(50000);
    return iVolume;
}

bool Cayfly_s60Sound::StartL()
{
    PrivateWaitRequestOK();
    iPlayerThread.RequestComplete(iRequestPtr, 1 );
    return true;
}

void Cayfly_s60Sound::StopL()
{
    PrivateWaitRequestOK();
    iPlayerThread.RequestComplete(iRequestPtr, 2 );
    User::After(100000);
}

void Cayfly_s60Sound::PrivateStart()
{
     
    if(iState != EStopped)
        return;

    delete iStream;

    iState = EStarting;
    iStream = CMdaAudioOutputStream::NewL(*this);
    iStream->Open(&iSettings);
}

void Cayfly_s60Sound::PrivateStop()
{
    if(iState == EPlaying)
    {
        iState = EStopping;
        iStream->Stop();
    }
}

TInt Cayfly_s60Sound::State()
{
    return iState;
}

void Cayfly_s60Sound::Exit()
{
    TRequestStatus req = KRequestPending;

    iPlayerThread.Logon(req);
    iPlayerThread.RequestComplete(iRequestPtr, 4 );

    User::WaitForRequest(req);
    iPlayerThread.Close();

     
}

void Cayfly_s60Sound::PrivateSetVolume()
{
    if(iState == EPlaying)
    {
        if(iVolume < 0)
            iVolume = 0;
        if(iVolume > iStream->MaxVolume())
            iVolume = iStream->MaxVolume();
        iStream->SetVolume(iVolume);
    }
}

void Cayfly_s60Sound::PrivateWaitRequestOK()
{
     
    while((iRequestPtr == 0L ) || (*iRequestPtr != KRequestPending))
    {
        User::After(10000);
    }
}

CCommandHandler::~CCommandHandler()
{
}

void CCommandHandler::DoCancel()
{
}

CCommandHandler::CCommandHandler() :
    CActive(CActive::EPriorityIdle)
{
}

CCommandHandler* CCommandHandler::NewL()
{
    CCommandHandler *a = new (ELeave) CCommandHandler;
    return a;
}

void CCommandHandler::Start(Cayfly_s60Sound *aSound)
{
    iSound = aSound;
    iSound->iRequestPtr = &iStatus;

    iStatus = KRequestPending;
    SetActive();

    iSound->iKilling = EFalse;
}

void CCommandHandler::RunL(void)
{
     
    switch(iStatus.Int())
    {
        case 1 :
            iSound->PrivateStart();
            break;
        case 2 :
            iSound->PrivateStop();
            break;
        case 3 :
            iSound->PrivateSetVolume();
            break;
        case 4 :
            iSound->PrivateStop();
            iSound->iKilling = ETrue;
            break;
        case 5 :
            if(iSound->State() == Cayfly_s60Sound::EStopped)
            {
                Deque();
                CActiveScheduler::Stop();

                delete iSound->iStream;
                iSound->iStream = 0L ;

                return;
            }
        default:
            break;
    }

    iSound->iRequestPtr = &iStatus;
    iStatus = KRequestPending;
    SetActive();

    if(iSound->iKilling)
    {
         
        User::After(10000);
        User::RequestComplete(iSound->iRequestPtr, 5 );
    }
}

TInt serverthreadfunction(TAny *aThis)
{
    Cayfly_s60Sound *a = (Cayfly_s60Sound*)aThis;

    CTrapCleanup *ctrap = CTrapCleanup::New();

    CActiveScheduler *scheduler = new CActiveScheduler();
    CActiveScheduler::Install(scheduler);

    a->iHandler = CCommandHandler::NewL();
    CActiveScheduler::Add(a->iHandler);

    a->iHandler->Start(a);
    CActiveScheduler::Start();

     
    delete a->iHandler;
    delete scheduler;
    delete ctrap;

    return 0;
}

void Cayfly_s60Sound::ConstructL()
{
    iVolume = 7;

    iBuffer1 = new (ELeave) unsigned char[2048 * 8 *4 ];
    iDesc1.Set(iBuffer1, 2048 * 8 *4 , 2048 * 8 *4 );
    iBuffer2 = new (ELeave) unsigned char[2048 * 8 *4 ];
    iDesc2.Set(iBuffer2, 2048 * 8 *4 , 2048 * 8 *4 );

    iStream = 0L ;
    iState = EStopped;
    stereo = true;

     







    RThread curthread;

     
    TInt err = KErrAlreadyExists;
    while(err == KErrAlreadyExists)
    {
        User::After(100000);
        err = iPlayerThread.Create(KThreadName, serverthreadfunction, 65536 , 0L , (TAny*)this);
    }
    iPlayerThread.SetProcessPriority(EPriorityHigh);
    iPlayerThread.SetPriority(EPriorityRealTime);
    curthread.SetPriority(EPriorityLess);

    iPlayerThread.Resume();  
}

Cayfly_s60Audio::Cayfly_s60Audio(AYSongInfo *info) :
    AbstractAudio(32000 , info)
{
    songinfo = info;
    sound = Cayfly_s60Sound::NewL(songinfo);
}

Cayfly_s60Audio::~Cayfly_s60Audio()
{
    if(sound)
    {
        sound->Exit();
        delete sound;
        sound = 0;
    }

}

bool Cayfly_s60Audio::Start()
{
    started = sound->StartL();
    return started;
}

void Cayfly_s60Audio::Stop()
{
    started = false;
    sound->StopL();
}

void Cayfly_s60Audio::SetDeviceVolume(TInt aVolume)
{
    if(sound)
    {
        sound->SetDeviceVolume(aVolume);
    }
}

TInt Cayfly_s60Audio::GetDeviceVolume()
{
    if(sound)
    {
        return sound->GetDeviceVolume();
    }
    return 0;
}

