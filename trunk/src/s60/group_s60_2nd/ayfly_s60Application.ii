# 1 "../src/ayfly_s60Application.cpp"
 



















 
# 1 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 1
 


































# 1 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 1
 










































# 52 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h"


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 1
 




 




 


















 









extern "C" {


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/_ansi.h" 1
 




 




 







 











 










 




















# 43 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stddef.h" 1
 




 







 





typedef unsigned short int wchar_t;



typedef long		ptrdiff_t;
typedef unsigned int	size_t;

 





# 48 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdarg_e.h" 1
 




 




 










 


typedef char* __e32_va_list;






# 50 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/sys/stdio_t.h" 1
 







extern "C" {




 




struct __sbuf {
	unsigned char *	_base;
	int				_size;
};

 






typedef long _fpos_t;		 
							 

 

























struct __sFILE {
  unsigned char *_p;			 
  int			 _r;			 
  int			 _w;			 
  short			 _flags;		 
  short			 _file;			 
  struct __sbuf	 _bf;			 
  int			 _lbfsize;		 

   
  void *		 _cookie;		 

  int		(*_read) (void * _cookie, char *_buf, int _n);
  int		(*_write)(void * _cookie, const char *_buf, int _n);
  _fpos_t	(*_seek) (void * _cookie, _fpos_t _offset, int _whence);
  int		(*_close)(void * _cookie);

   
  struct __sbuf		_ub;		 
  unsigned char *	_up;		 
  int				_ur;		 

   
  unsigned char		_ubuf[3];	 
  unsigned char		_nbuf[1];	 

   
  struct __sbuf		_lb;		 

   
  int				_blksize;	 
  int				_offset;	 

  struct _reent *	_data;		 
};



}


# 52 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h" 2


typedef _fpos_t fpos_t;
typedef struct __sFILE FILE;





	 











 





































 













  FILE *__stdin  (void);
  FILE *__stdout (void);
  FILE *__stderr (void);





 


  FILE *	tmpfile		(void);
  char *	tmpnam		(char *);
  wchar_t *	wtmpnam		(wchar_t *);
  int	fclose		(FILE *);
  int	fflush		(FILE *);
  FILE *	freopen		(const char *, const char *, FILE *);
  FILE *	wfreopen		(const wchar_t *, const wchar_t *, FILE *);
  void	setbuf		(FILE *, char *);
  int	setvbuf		(FILE *, char *, int, size_t);
  int	fprintf		(FILE *, const char *, ...);
  int	fscanf		(FILE *, const char *, ...);
  int	printf		(const char *, ...);
  int	scanf		(const char *, ...);
  int	sscanf		(const char *, const char *, ...);
  int	vfprintf	(FILE *, const char *, __e32_va_list);
  int	vprintf		(const char *, __e32_va_list);
  int	vsprintf	(char *, const char *, __e32_va_list);
  int	fgetc		(FILE *);
  char *  fgets		(char *, int, FILE *);
  int	fputc		(int, FILE *);
  int	fputs		(const char *, FILE *);
  int	getc		(FILE *);
  int	getchar		(void);
  char *  gets		(char *);
  int	putc		(int, FILE *);
  int	putchar		(int);
  int	puts		(const char *);
  int	ungetc		(int, FILE *);
  size_t	fread		(void*, size_t _size, size_t _n, FILE *);
  size_t	fwrite		(const void* , size_t _size, size_t _n, FILE *);
  int	fgetpos		(FILE *, fpos_t *);
  int	fseek		(FILE *, long, int);
  int	fsetpos		(FILE *, const fpos_t *);
  long	ftell		(FILE *);
  void	rewind		(FILE *);
  void	clearerr	(FILE *);
  int	feof		(FILE *);
  int	ferror		(FILE *);
  void    perror		(const char *);

  FILE *	fopen		(const char *_name, const char *_type);
  FILE *	wfopen		(const wchar_t *_name, const wchar_t *_type);
  int	sprintf		(char *, const char *, ...);


 


  int	fileno		(FILE *);


  FILE *	fdopen		(int, const char *);
  FILE *	wfdopen		(int, const wchar_t *);


 


  void	_cleanup	(void);

 


  int	popen3	(const char *cmd, const char *mode, char** envp, int fids[3]);
  int	wpopen3	(const wchar_t *cmd, const wchar_t *mode, wchar_t** envp, int fids[3]);

# 223 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdio.h"



}


# 54 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdlib.h" 1
 




 




 






extern "C" {









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/sys/reent.h" 1
 




 




 






extern "C" {






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/time.h" 1
 




 




 







extern "C" {








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/machine/types.h" 1
 




 
















# 28 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/time.h" 2






typedef signed int  clock_t;




typedef signed int  time_t;



struct tm
{
  int	tm_sec;		 
  int	tm_min;		 
  int	tm_hour;	 
  int	tm_mday;	 
  int	tm_mon;		 
  int	tm_year;	 
  int	tm_wday;	 
  int	tm_yday;	 
  int	tm_isdst;	 
};

  clock_t	clock		(void);
  double		difftime	(time_t _time2, time_t _time1);
  time_t		mktime		(struct tm *_timeptr);
  time_t		time		(time_t *_timer);
  size_t		strftime	(char *_s, size_t _maxsize, const char *_fmt, const struct tm *_t);

  char*		asctime		(const struct tm *_tblock);
  char*		ctime		(const time_t *_time);
  struct tm*	gmtime		(const time_t *_timer);
  struct tm*	localtime	(const time_t *_timer);


 




  char*		asctime_r	(const struct tm *, char *);
  char*		ctime_r		(const time_t *, char *);
  struct tm*	gmtime_r	(const time_t *, struct tm *);
  struct tm*	localtime_r	(const time_t *, struct tm *);


}


# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/sys/reent.h" 2


struct _glue 
{
  struct _glue *_next;
  int _niobs;
  struct __sFILE *_iobs;
};

 




struct _atexit {
	struct	_atexit *_next;			 
	int	_ind;				 
	void	(*_fns[32 ])(void);	 
};


 










struct _reent
{
   
  int _errno;
  struct __sFILE _sf[3];		 

  char *_scanpoint;		 
  char _asctime[(26+8) ];	 
  struct tm _struct_tm;		 
  long _next[2];		 
  int  _inc;			 
  char _tmpnam[37];		 
  wchar_t _wtmpnam[37];		 
  void *_netdb;			 
 
  int _current_category;	 
  const char *_current_locale;

  int __sdidinit;		 

  void (*__cleanup)(struct _reent *);

   
  struct _atexit *_atexit;	 
  struct _atexit _atexit0;	 

   
  void (**(_sig_func))();

  struct _glue __sglue;		 

  char **environ;
  int environ_slots;

  char* _pNarrowEnvBuffer;
  int _NEBSize;

  void *_system;		 
};

 



  void		_reclaim_reent	(struct _reent*);
  void		_REENT_INIT	(struct _reent*);
  struct _reent*	ImpurePtr	(void);
  void		_init_reent	(struct _reent*,void*);

 


  void CloseSTDLIB();





}



# 28 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdlib.h" 2


typedef struct 
{
  int quot;  
  int rem;  
} div_t;














 



  int	_epoc32_atexit	(void (*_func)(void));




  void	abort	(void);


  int	abs		(int);
  double	atof	(const char *_nptr);
  int	atoi	(const char *_nptr);


  void*	bsearch	(const void * _key,
		       const void * _base,
		       size_t _nmemb,
		       size_t _size,
		       int (*_compar)(const void *, const void *));
  void*	calloc	(size_t _nmemb, size_t _size);
  div_t	div	(int _numer, int _denom);
  void	exit	(int _status)  ;
  void	free	(void *);
  char*  getenv	(const char *_string);
  wchar_t*  wgetenv	(const wchar_t *_string);
  void*	malloc	(size_t _size);

  int	mbtowc	 (wchar_t *pwc, const char *s, size_t n);
  int	wctomb	 (char *s, wchar_t wc);
  int	mbstowcs (wchar_t *pwc, const char *s, size_t n);
  int	wcstombs (char *s, const wchar_t *pwc, size_t n);
  int    mblen    (const char * string, size_t size);

  void	qsort	(void * _base, size_t _nmemb, size_t _size, int(*_compar)(const void *, const void *));
  int	rand	(void);
  void*	realloc	(void * _r, size_t _size);
  void	srand	(unsigned _seed);
  double	strtod	(const char *_n, char **_end_PTR);
  long	strtol	(const char *_n, char **_end_PTR, int _base);
  unsigned long strtoul		(const char *_n_PTR, char **_end_PTR, int _base);
  int	system	(const char *_string);
  int	wsystem	(const wchar_t *_string);

 


  int	setenv	(const char *_string, const char *_value, int _overwrite);
  void	unsetenv (const char *_name);
  int	wsetenv	(const wchar_t *_string, const wchar_t *_value, int _overwrite);
  void	wunsetenv (const wchar_t *_name);

# 119 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/stdlib.h"


 


}


# 55 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/string.h" 1
 




 




 







extern "C" {















  void*	memchr		(const void*, int, size_t);
  int 	memcmp		(const void*, const void*, size_t);
  void*	memcpy		(void* dst, const void* src, size_t);
  void*	memmove		(void*, const void*, size_t);
  void*	memset		(void*, int, size_t);
  char*	strcat		(char *, const char *);
  wchar_t* wcscat	(wchar_t *, const wchar_t *);
  char*	strchr		(const char *, int);
  int	strcmp		(const char *, const char *);
  int	wcscmp		(const wchar_t *, const wchar_t *);
  int	strcoll		(const char *, const char *);
  char*	strcpy		(char *, const char *);
  wchar_t* wcscpy	(wchar_t *, const wchar_t *);
  size_t	strcspn		(const char *, const char *);
  char*	strerror	(int);
  size_t	strlen		(const char *);
  size_t	wcslen		(const wchar_t *);
  char*	strncat		(char *, const char *, size_t);
  int	strncmp		(const char *, const char *, size_t);
  char*	strncpy		(char *, const char *, size_t);
  char*	strpbrk		(const char *, const char *);
  char*	strrchr		(const char *, int);
  size_t	strspn		(const char *, const char *);
  char*	strstr		(const char *, const char *);
  size_t	strxfrm		(char *, const char *, size_t);


  char*	strtok		(char *, const char *);


  char*	strtok_r	(char *, const char *, char **);

 


  int	strcasecmp	(const char *, const char *);
  char*	strdup		(const char *);
  wchar_t*	wcsdup		(const wchar_t *);
  int	strncasecmp	(const char *, const char *, size_t);
  char 	*rindex		(const char *, int);
  char 	*index		(const char *, int);

# 85 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/libc/string.h"



}


# 56 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2













# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.h" 1
 
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 1
 
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h" 1
 
 
 
 
 








# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"






 
# 47 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"


# 63 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"
























































typedef void TAny;
typedef signed char TInt8;
typedef unsigned char TUint8;
typedef short int TInt16;
typedef unsigned short int TUint16;
typedef long int TInt32;
typedef unsigned long int TUint32;
typedef signed int TInt;
typedef unsigned int TUint;
typedef float TReal32;
typedef double TReal64;
typedef double TReal;
typedef unsigned char TText8;
typedef unsigned short int TText16;
typedef int TBool;
















typedef TText16 TText;










typedef TInt8 *VA_LIST[1];
















# 224 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32def.h"

















 








 








 































 
















# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2




const TInt KDefaultJustifyWidth=(-1);
const TInt KMaxCheckedUid=3;
const TInt KMaxUidName=10;
const TInt KMaxName=0x80;
const TInt KMaxOsName=(KMaxName-KMaxUidName-2-4);
const TInt KMaxInfoName=0x10;
const TInt KMaxFullName=(KMaxName<<1);
const TInt KMaxPassword=0x10;
const TInt KMaxExitCategoryName=0x10;
const TInt KMaxDayName=0x20;
const TInt KMaxDayNameAbb=0x08;
const TInt KMaxDays=7;
const TInt KMaxMonthName=0x20;
const TInt KMaxMonthNameAbb=0x08;
const TInt KMaxMonths=12;
const TInt KMaxSuffix=0x04;
const TInt KMaxSuffixes=31;
const TInt KMaxAmPmName=0x04;
const TInt KMaxAmPms=2;
const TInt KMaxTranslateTable=0x100;
const TInt KMaxCurrencySymbol=0x08;
const TInt KMaxShortDateFormatSpec=40;
const TInt KMaxLongDateFormatSpec=80;
const TInt KMaxTimeFormatSpec=60;
const TInt KMaxFileName=0x100;
const TInt KMaxVersionName=0x10;
const TInt KMaxPath=0x100;
const TInt KMaxDeviceInfo=0x80;
const TInt KMinHeapSize=0x100;
const TInt KDstHome=0x01;
const TInt KDstEuropean=0x02;
const TInt KDstNorthern=0x04;
const TInt KDstSouthern=0x08;
const TInt KDefaultStackSize=0x2000;
const TUint KNoChar=0xffffffffu;
const TInt KIndexPtr=(-1);
const TInt KCurrentProcessHandle=0xffff0000;
const TInt KHandleNoClose=0x00008000;
const TInt KCurrentThreadHandle=0xffff0001|KHandleNoClose;
const TInt KNullHandle=0;
const TInt KDefaultUnit=0x00;
const TInt KNullUnit=0xffffffff;
const TInt KMaxUnits=0x20;
const TInt KMaxMessageArguments=0x04;
const TInt KDefaultRealWidth=20;
const TInt KMinHeapGrowBy=0x1000;
const TInt KMaxExponentConversion=99;
const TInt KNullUidValue=0;
const TInt KDeltaTimerDefaultGranularity=100000;
const TInt KMaxTInt8=0x7f;
const TInt KMinTInt8=(-128);
const TUint KMaxTUint8=0xffu;
const TInt KMaxTInt16=0x7fff;
const TInt KMinTInt16=(-32768);
const TUint KMaxTUint16=0xffffu;
const TInt KMaxTInt32=0x7fffffff;
const TInt KMinTInt32=(TInt)0x80000000;
const TUint KMaxTUint32=0xffffffffu;
const TInt KMaxTInt=0x7fffffff;
const TInt KMinTInt=(TInt)0x80000000;
const TUint KMaxTUint=0xffffffffu;
const TUint KMatchAny='*';
const TUint KMatchOne='?';
const TInt KMaxLocalDrives=9;
const TInt KMaxPBusSockets=4;

const TInt KErrNone=0;
const TInt KErrNotFound=(-1);  
const TInt KErrGeneral=(-2);
const TInt KErrCancel=(-3);
const TInt KErrNoMemory=(-4);
const TInt KErrNotSupported=(-5);
const TInt KErrArgument=(-6);
const TInt KErrTotalLossOfPrecision=(-7);
const TInt KErrBadHandle=(-8);
const TInt KErrOverflow=(-9);
const TInt KErrUnderflow=(-10);
const TInt KErrAlreadyExists=(-11);
const TInt KErrPathNotFound=(-12);
const TInt KErrDied=(-13);
const TInt KErrInUse=(-14);
const TInt KErrServerTerminated=(-15);
const TInt KErrServerBusy=(-16);
const TInt KErrCompletion=(-17);
const TInt KErrNotReady=(-18);
const TInt KErrUnknown=(-19);
const TInt KErrCorrupt=(-20);
const TInt KErrAccessDenied=(-21);
const TInt KErrLocked=(-22);
const TInt KErrWrite=(-23);
const TInt KErrDisMounted=(-24);
const TInt KErrEof=(-25);
const TInt KErrDiskFull=(-26);
const TInt KErrBadDriver=(-27);
const TInt KErrBadName=(-28);
const TInt KErrCommsLineFail=(-29);
const TInt KErrCommsFrame=(-30);
const TInt KErrCommsOverrun=(-31);
const TInt KErrCommsParity=(-32);
const TInt KErrTimedOut=(-33);
const TInt KErrCouldNotConnect=(-34);
const TInt KErrCouldNotDisconnect=(-35);
const TInt KErrDisconnected=(-36);
const TInt KErrBadLibraryEntryPoint=(-37);
const TInt KErrBadDescriptor=(-38);
const TInt KErrAbort=(-39);
const TInt KErrTooBig=(-40);
const TInt KErrDivideByZero=(-41);
const TInt KErrBadPower=(-42);
const TInt KErrDirFull=(-43);
const TInt KErrHardwareNotAvailable=(-44);
const TInt KErrSessionClosed=(-45);
const TInt KErrPermissionDenied=(-46);

 
 
 
 
 

const TInt KRequestPending=(-KMaxTInt);

enum TKernelPanic
	{
	EBadHandle=0,
	EAccessDenied=1,
	EBadName=2,
	ECausedException=3,
	ECompletion=4,
	ELeaveWithoutTrap=5,
	ESegmentReadOutOfRange=6,
	ESegmentWriteOutOfRange=7,
	EChunkSizeTooBig=8,
	ERequestAlreadyPending=9,
	ERequestNoInvalid=10,
	EBadUnitNumber=11,
	EEventAlreadyCaptured=12,
	EEventNotCaptured=13,
	EBadPriority=14,
	ETimerAlreadyPending=15,
	EAlreadyLoggedOn=16,
	EFailedKernelHeapCheck=17,
	ERequestFromWrongThread=18,
	EMesAlreadyPending=19,
	EEventRequestPending=20,
	EIllegalWsProcess=21,
	EHardwareNotAvailable=22,
	EUnsharableSession=23,
	EDesOverflow=24,
	ETransferBufferTooBigForWindow=25,
	ETransferBufferNotMappedIntoWindow=26,
	ETransferWindowAlreadyInUse=27,
	EMsgQueueRequestPending=28,
	EMsgQueueIllegalCancel=29,
	EMsgQueueInvalidSlots=30,
	EMsgQueueInvalidLength=31,
	};

 

enum TMediaType
	{
	EMediaNotPresent,
	EMediaUnknown,EMediaFloppy,EMediaHardDisk,EMediaCdRom,
	EMediaRam,EMediaFlash,EMediaRom,EMediaRemote
	};

 
const TUint KMediaSubTypeATACard=1;
const TUint KMediaSubTypeMMCCard=2;
const TUint KMediaSubTypeMMCCardSecure=3;
const TUint KMediaSubTypeSDCard=4;
const TUint KMediaSubTypeSDCardProtected=5;

enum TBatteryState {EBatNotSupported,EBatGood,EBatLow};

const TUint KDriveAttLocal=0x01;
const TUint KDriveAttRom=0x02;
const TUint KDriveAttRedirected=0x04;
const TUint KDriveAttSubsted=0x08;
const TUint KDriveAttInternal=0x10;
const TUint KDriveAttRemovable=0x20;
const TUint KDriveAttRemote=0x40;
const TUint KDriveAttTransaction=0x80;

const TUint KMediaAttVariableSize=0x01;
const TUint KMediaAttDualDensity=0x02;
const TUint KMediaAttFormattable=0x04;
const TUint KMediaAttWriteProtected=0x08;
const TUint KMediaAttLockable=0x10;
const TUint KMediaAttLocked=0x20;
const TUint KMediaAttHasPassword=0x40;

const TUint KMediaAttReadWhileWrite=0x80;


const TUint KDriveFileSysFAT=0x01;
const TUint KDriveFileSysROM=0x02;
const TUint KDriveFileSysLFFS=0x03;

enum TFalse {EFalse= 0 };
enum TTrue {ETrue= 1 };
enum TAllowDuplicates {ENoDuplicates,EAllowDuplicates};
enum TRadix {EBinary=2,EOctal=8,EDecimal=10,EHex=16};

 














 








enum TLanguage
	{
	 


	ELangTest = 0,
	 
	ELangEnglish = 1,
	 
	ELangFrench = 2,
	 
	ELangGerman = 3,
	 
	ELangSpanish = 4,
	 
	ELangItalian = 5,
	 
	ELangSwedish = 6,
	 
	ELangDanish = 7,
	 
	ELangNorwegian = 8,
	 
	ELangFinnish = 9,
	 
	ELangAmerican = 10,
	 
	ELangSwissFrench = 11,
	 
	ELangSwissGerman = 12,
	 
	ELangPortuguese = 13,
	 
	ELangTurkish = 14,
	 
	ELangIcelandic = 15,
	 
	ELangRussian = 16,
	 
	ELangHungarian = 17,
	 
	ELangDutch = 18,
	 
	ELangBelgianFlemish = 19,
	 
	ELangAustralian = 20,
	 
	ELangBelgianFrench = 21,
	 
	ELangAustrian = 22,
	 
	ELangNewZealand = 23,
	 
	ELangInternationalFrench = 24,
	 
	ELangCzech = 25,
	 
	ELangSlovak = 26,
	 
	ELangPolish = 27,
	 
	ELangSlovenian = 28,
	 
	ELangTaiwanChinese = 29,
	 
	ELangHongKongChinese = 30,
	 
	ELangPrcChinese = 31,
	 
	ELangJapanese = 32,
	 
	ELangThai = 33,
	 
	ELangAfrikaans = 34,
	 
	ELangAlbanian = 35,
	 
	ELangAmharic = 36,
	 
	ELangArabic = 37,
	 
	ELangArmenian = 38,
	 
	ELangTagalog = 39,
	 
	ELangBelarussian = 40,
	  
	ELangBengali = 41,
	 
	ELangBulgarian = 42,
	  
	ELangBurmese = 43,
	 
	ELangCatalan = 44,
	 
	ELangCroatian = 45,
	 
	ELangCanadianEnglish = 46,
	 
	ELangInternationalEnglish = 47,
	 
	ELangSouthAfricanEnglish = 48,
	 
	ELangEstonian = 49,
	 
	ELangFarsi = 50,
	 
	ELangCanadianFrench = 51,
	 
	ELangScotsGaelic = 52,
	 
	ELangGeorgian = 53,
	  
	ELangGreek = 54,
	 
	ELangCyprusGreek = 55,
	 
	ELangGujarati = 56,
	 
	ELangHebrew = 57,
	  
	ELangHindi = 58,
	 
	ELangIndonesian = 59,
	 
	ELangIrish = 60,
	 
	ELangSwissItalian = 61,
	 
	ELangKannada = 62,
	 
	ELangKazakh = 63,
	 
	ELangKhmer = 64,
	 
	ELangKorean = 65,
	 
	ELangLao = 66,
	 
	ELangLatvian = 67,
	 
	ELangLithuanian = 68,
	 
	ELangMacedonian = 69,
	 
	ELangMalay = 70,
	 
	ELangMalayalam = 71,
	  
	ELangMarathi = 72,
	 
	ELangMoldavian = 73,
	 
	ELangMongolian = 74,
	 
	ELangNorwegianNynorsk = 75,
	 
	ELangBrazilianPortuguese = 76,
	 
	ELangPunjabi = 77,
	 
	ELangRomanian = 78,
	 
	ELangSerbian = 79,
	 
	ELangSinhalese = 80,
	 
	ELangSomali = 81,
	 
	ELangInternationalSpanish = 82,
	 
	ELangLatinAmericanSpanish = 83,
	 
	ELangSwahili = 84,
	 
	ELangFinlandSwedish = 85,
	ELangReserved1 = 86,		 
	  
	ELangTamil = 87,
	 
	ELangTelugu = 88,
	 
	ELangTibetan = 89,
	 
	ELangTigrinya = 90,
	 
	ELangCyprusTurkish = 91,
	 
	ELangTurkmen = 92,
	 
	ELangUkrainian = 93,
	  
	ELangUrdu = 94,
	ELangReserved2 = 95,	 
	 
	ELangVietnamese = 96,
	 
	ELangWelsh = 97,
	 
	ELangZulu = 98,
	 
	ELangOther = 99,
	ELangNone = 0xFFFF,  
	ELangMaximum = ELangNone  
	};

 
const TUint KDialectMask=0x03FF;


 



enum TDateFormat 
	{
	 
	EDateAmerican,
	 
	EDateEuropean,
	 
	EDateJapanese
	};


 




enum TTimeFormat 
	{
	 
	ETime12,
	 
	ETime24
	};

 




enum TClockFormat 
	{
	 
	EClockAnalog,
	 
	EClockDigital
	};

 





enum TUnitsFormat 
	{
	 
	EUnitsImperial,
	 
	EUnitsMetric
	};

 




enum TAmPm 
	{
	 
	EAm,
	 
	EPm
	};

 



enum TDay
	{
	 
	EMonday,
	 
	ETuesday,
	 
	EWednesday,
	 
	EThursday,
	 
	EFriday,
	 
	ESaturday,
	 
	ESunday
	};

 











enum TMonth
	{
	 
	EJanuary,
	 
	EFebruary,
	 
	EMarch,
	 
	EApril,
	 
	EMay,
	  
	EJune,
	 
	EJuly,
	 
	EAugust,
	 
	ESeptember,
	 
	EOctober,
	 
	ENovember,
	 
	EDecember
	};

enum TOwnerType {EOwnerProcess,EOwnerThread};
enum TDllReason {EDllProcessAttach,EDllThreadAttach,EDllThreadDetach,EDllProcessDetach};

enum TProcessPriority
	{
	EPriorityLow=150,
	EPriorityBackground=250,
	EPriorityForeground=350,
	EPriorityHigh=450,
	EPriorityWindowServer=650,
	EPriorityFileServer=750,
	EPriorityRealTimeServer=850,
	EPrioritySupervisor=950
	};

enum TThreadPriority
	{
	EPriorityNull=(-30),
	EPriorityMuchLess=(-20),
	EPriorityLess=(-10),
	EPriorityNormal=0,
	EPriorityMore=10,
	EPriorityMuchMore=20,
	EPriorityRealTime=30,
	EPriorityAbsoluteVeryLow=100,
	EPriorityAbsoluteLow=200,
	EPriorityAbsoluteBackground=300,
	EPriorityAbsoluteForeground=400,
	EPriorityAbsoluteHigh=500
	};

enum TExcType
	{
	EExcGeneral=0,
	EExcIntegerDivideByZero=1,
	EExcSingleStep=2,
	EExcBreakPoint=3,
	EExcIntegerOverflow=4,
	EExcBoundsCheck=5,
	EExcInvalidOpCode=6,
	EExcDoubleFault=7,
	EExcStackFault=8,
	EExcAccessViolation=9,
	EExcPrivInstruction=10,
	EExcAlignment=11,
	EExcPageFault=12,
	EExcFloatDenormal=13,
	EExcFloatDivideByZero=14,
	EExcFloatInexactResult=15,
	EExcFloatInvalidOperation=16,
	EExcFloatOverflow=17,
	EExcFloatStackCheck=18,
	EExcFloatUnderflow=19,
	EExcAbort=20,
	EExcKill=21,
	EExcUserInterrupt=22,
	EExcDataAbort=23,
	EExcCodeAbort=24,
	EExcMaxNumber=25,
	EExcInvalidVector=26,
	};

enum TExitType {EExitKill,EExitTerminate,EExitPanic,EExitPending};
enum TAlign {ELeft,ECenter,ERight};

const TInt KRealFormatTypesMask=0x00000007;
const TInt KRealFormatFixed=1;
const TInt KRealFormatExponent=2;
const TInt KRealFormatGeneral=3;
const TInt KRealFormatNoExponent=4;
const TInt KRealFormatCalculator=5;

 

const TInt KRealFormatTypeFlagsMask=0x7C000000;
const TInt KExtraSpaceForSign=0x40000000;
const TInt KAllowThreeDigitExp=0x20000000;
const TInt KUseSigFigs=0x10000000;
const TInt KDoNotUseTriads=0x08000000;
const TInt KGeneralLimit=0x04000000;

enum TLeave {ELeave};

 





enum TFirstWeekRule 
	{
	 


	EFirstWeek,
	 




	EFirstFourDayWeek,
	 


	EFirstFullWeek
	};

enum TTimerLockSpec
	{
	EOneOClock,
	ETwoOClock,
	EThreeOClock,
	EFourOClock,
	EFiveOClock,
	ESixOClock,
	ESevenOClock,
	EEightOClock,
	ENineOClock,
	ETenOClock,
	EElevenOClock,
	ETwelveOClock
	};

typedef TInt (*TThreadFunction)(TAny *aPtr);
typedef TInt (*TLibraryFunction)();
typedef TInt (*TLibraryEntry)(TDllReason aReason);

inline TInt Lim(TInt aVal,TUint aLimit)
	{return(((TUint)aVal)<=aLimit);}

inline TInt LimX(TInt aVal,TUint aLimit)
	{return(((TUint)aVal)<aLimit);}

template <class T>
inline T Min(T aLeft,T aRight)
	{return(aLeft<aRight ? aLeft : aRight);}

template <class T>
inline T Min(T aLeft,TUint aRight)
	{return(aLeft<(TInt)aRight ? aLeft : (T)aRight);}

template <class T>
inline T Max(T aLeft,T aRight)
	{return(aLeft<aRight ? aRight : aLeft);}

template <class T>
inline T Max(T aLeft,TUint aRight)
	{return(aLeft<(TInt)aRight ? (TInt)aRight : aLeft);}

template <class T>
inline T Abs(T aVal)
	{return(aVal<0 ? -aVal : aVal);}

template <class T>
inline TBool Rng(T aMin,T aVal,T aMax)
	{return(aVal>=aMin && aVal<=aMax);}

template <class T,class S>
inline T* PtrAdd(T* aPtr,S aVal)
	{return((T*)(((TUint8*)aPtr)+aVal));}

template <class T,class S>
inline T* PtrSub(T* aPtr,S aVal)
	{return((T*)(((TUint8*)aPtr)-aVal));}

template <class T>
inline T Align2(T aValue)
	{return((T)((((TUint)aValue)+sizeof(TUint16)-1)&~(sizeof(TUint16)-1)));}

template <class T>
inline T Align4(T aValue)
	{return((T)((((TUint)aValue)+sizeof(TUint32)-1)&~(sizeof(TUint32)-1)));}

class TInt64
	{
public:
	inline TInt64();
	  TInt64(TInt aVal);
	inline TInt64(TUint aVal);
	inline TInt64(TUint aHigh,TUint aLow);
	  TInt64(TReal aVal);
	inline void Set(TUint aHigh,TUint aLow);
	inline TUint Low() const;
	inline TUint High() const;
	  TInt GetTInt() const;
	  TReal GetTReal() const;
	  TInt64 &operator=(TInt aVal);
	inline TInt64& operator=(TUint aVal);
	  TInt64& operator=(TReal aVal);
	  TInt64& operator+=(const TInt64 &aVal);
	  TInt64& operator-=(const TInt64 &aVal);
	  TInt64& operator*=(const TInt64 &aVal);
	  TInt64& operator/=(const TInt64 &aVal);
	  TInt64& operator%=(const TInt64 &aVal);
	  TInt64& operator>>=(TInt aShift);
	  TInt64& operator<<=(TInt aShift);
	  TInt64 operator+() const;
	  TInt64 operator-() const;
	  TInt64& operator++();
	  TInt64 operator++(TInt);
	  TInt64& operator--();
	  TInt64 operator--(TInt);
	  TInt64 operator+(const TInt64 &aVal) const;
	  TInt64 operator-(const TInt64 &aVal) const;
	  TInt64 operator*(const TInt64 &aVal) const;
	  TInt64 operator/(const TInt64 &aVal) const;
	  TInt64 operator%(const TInt64 &aVal) const;
	  TInt64 operator>>(TInt aShift) const;
	  TInt64 operator<<(TInt aShift) const;
	  void Lsr(TInt aShift);
	  void Mul10();
	  TInt MulTop(const TInt64 &aVal);
	  void DivMod(const TInt64 &aVal,TInt64 &aRemainder);
	  TInt operator==(const TInt64 &aVal) const;
	  TInt operator!=(const TInt64 &aVal) const;
	  TInt operator>=(const TInt64 &aVal) const;
	  TInt operator<=(const TInt64 &aVal) const;
	  TInt operator>(const TInt64 &aVal) const;
	  TInt operator<(const TInt64 &aVal) const;
protected:
	TUint iLow;
	TUint iHigh;
	};

typedef void TExceptionHandler(TExcType);

 

const TUint KExceptionAbort=0x01;
const TUint KExceptionKill=0x02;
const TUint KExceptionUserInterrupt=0x04;
const TUint KExceptionFpe=0x08;
const TUint KExceptionFault=0x10;
const TUint KExceptionInteger=0x20;
const TUint KExceptionDebug=0x40;

template <class T>
class TRefByValue
	{
public:
	inline TRefByValue(T& aRef);
	inline operator T&();
private:
	TRefByValue& operator=(TRefByValue aRef);
private:
	T &iRef;
	};

class TFunctor
	{
public:
	  virtual void operator()() =0;
	};

class TCallBack
	{
public:
	inline TCallBack();
	inline TCallBack(TInt (*aFunction)(TAny* aPtr));
	inline TCallBack(TInt (*aFunction)(TAny* aPtr),TAny* aPtr);
	inline TInt CallBack() const;
public:
	TInt (*iFunction)(TAny* aPtr);
	TAny* iPtr;
	};

class TSglQueLink
	{




private:
	  void Enque(TSglQueLink* aLink);
public:
	TSglQueLink* iNext;
	friend class TSglQueBase;
	};

class TDblQueLinkBase
	{
public:
	inline TDblQueLinkBase() : iNext(0L ) {}
	  void Enque(TDblQueLinkBase* aLink);
	  void AddBefore(TDblQueLinkBase* aLink);
public:
	TDblQueLinkBase* iNext;
	TDblQueLinkBase* iPrev;
	};

class TDblQueLink : public TDblQueLinkBase
	{
public:
	  void Deque();
	};

class TPriQueLink : public TDblQueLink
	{
public:
	TInt iPriority;
	};

class TDeltaQueLink : public TDblQueLinkBase
	{
public:
	TInt iDelta;
	};

class TSglQueBase
	{
public:
	  TBool IsEmpty() const;
	  void SetOffset(TInt anOffset);
	  void Reset();
protected:
	  TSglQueBase();
	  TSglQueBase(TInt anOffset);
	  void DoAddFirst(TAny* aPtr);
	  void DoAddLast(TAny* aPtr);
	  void DoRemove(TAny* aPtr);
protected:
	TSglQueLink* iHead;
	TSglQueLink* iLast;
	TInt iOffset;
private:
	TSglQueBase(const TSglQueBase& aQue);
	TSglQueBase &operator=(const TSglQueBase& aQue);
	friend class TSglQueIterBase;
	};

class TDblQueBase
	{
public:
	  TBool IsEmpty() const;
	  void SetOffset(TInt anOffset);
	  void Reset();
protected:
	  TDblQueBase();
	  TDblQueBase(TInt anOffset);
	  void DoAddFirst(TAny* aPtr);
	  void DoAddLast(TAny* aPtr);
	  void DoAddPriority(TAny* aPtr);
	  void __DbgTestEmpty() const;
protected:
	TDblQueLink iHead;
	TInt iOffset;
private:
	TDblQueBase(const TDblQueBase& aQue);
	TDblQueBase& operator=(const TDblQueBase& aQue);
	friend class TDblQueIterBase;
	};

class TDeltaQueBase : public TDblQueBase
	{
public:
	  TBool CountDown();
	  TBool CountDown(TInt aValue);
	  TBool FirstDelta(TInt& aValue);
	  void Reset();
protected:
	  TDeltaQueBase();
	  TDeltaQueBase(TInt anOffset);
	  void DoAddDelta(TAny* aPtr,TInt aDelta);
	  void DoRemove(TAny* aPtr);
	  TAny* DoRemoveFirst();
protected:
	TInt* iFirstDelta;
	};

template <class T>
class TSglQue : public TSglQueBase
	{
public:
	inline TSglQue();
	inline TSglQue(TInt anOffset);
	inline void AddFirst(T& aRef);
	inline void AddLast(T& aRef);
	inline TBool IsFirst(const T* aPtr) const;
	inline TBool IsLast(const T* aPtr) const;
	inline T* First() const;
	inline T* Last() const;
	inline void Remove(T& aRef);
	};

template <class T>
class TDblQue : public TDblQueBase
	{
public:
	inline TDblQue();
	inline TDblQue(TInt anOffset);
	inline void AddFirst(T& aRef);
	inline void AddLast(T& aRef);
	inline TBool IsHead(const T* aPtr) const;
	inline TBool IsFirst(const T* aPtr) const;
	inline TBool IsLast(const T* aPtr) const;
	inline T* First() const;
	inline T* Last() const;
	};

template <class T>
class TPriQue : public TDblQueBase
	{
public:
	inline TPriQue();
	inline TPriQue(TInt anOffset);
	inline void Add(T& aRef);
	inline TBool IsHead(const T* aPtr) const;
	inline TBool IsFirst(const T* aPtr) const;
	inline TBool IsLast(const T* aPtr) const;
	inline T* First() const;
	inline T* Last() const;
	};

template <class T>
class TDeltaQue : public TDeltaQueBase
	{
public:
	inline TDeltaQue();
	inline TDeltaQue(TInt anOffset);
	inline void Add(T& aRef,TInt aDelta);
	inline void Remove(T& aRef);
	inline T* RemoveFirst();
	};

class TSglQueIterBase
	{
public:
	  void SetToFirst();
protected:
	  TSglQueIterBase(TSglQueBase& aQue);
	  TAny* DoPostInc();
	  TAny* DoCurrent();
	  void DoSet(TAny* aLink);
protected:
	TInt iOffset;
	TSglQueLink* iHead;
	TSglQueLink* iNext;
	};

template <class T>
class TSglQueIter : public TSglQueIterBase
	{
public:
	inline TSglQueIter(TSglQueBase& aQue);
	inline void Set(T& aLink);
	inline operator T*();
	inline T* operator++(TInt);
	};

class TDblQueIterBase
	{
public:
	  void SetToFirst();
	  void SetToLast();
protected:
	  TDblQueIterBase(TDblQueBase& aQue);
	  TAny* DoPostInc();
	  TAny* DoPostDec();
	  TAny* DoCurrent();
	  void DoSet(TAny* aLink);
protected:
	TInt iOffset;
	TDblQueLinkBase* iHead;
	TDblQueLinkBase* iNext;
	};
 
template <class T>
class TDblQueIter : public TDblQueIterBase
	{
public:
	inline TDblQueIter(TDblQueBase& aQue);
	inline void Set(T& aLink);
	inline operator T*();
	inline T* operator++(TInt);
	inline T* operator--(TInt);
	};

enum TKeyCmpText
	{
	ECmpNormal,ECmpNormal8,ECmpNormal16,
	ECmpFolded,ECmpFolded8,ECmpFolded16,
	ECmpCollated,ECmpCollated8,ECmpCollated16
	};

enum TKeyCmpNumeric
	{
	ECmpTInt8=((ECmpCollated16+1)<<1),ECmpTInt16,ECmpTInt32,ECmpTInt,
	ECmpTUint8,ECmpTUint16,ECmpTUint32,ECmpTUint,
	ECmpTInt64
	};

class TKey
	{
public:
	inline void SetPtr(const TAny* aPtr);
	  virtual TInt Compare(TInt aLeft,TInt aRight) const;
	  virtual TAny* At(TInt anIndex) const;
protected:
	  TKey();
	  TKey(TInt anOffset,TKeyCmpText aType);
	  TKey(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKey(TInt anOffset,TKeyCmpNumeric aType);
protected:
	TInt iKeyOffset;
	TInt iKeyLength;
	TInt iCmpType;
	const TAny* iPtr;
	};

class TSwap
	{
public:
	  TSwap();
	  virtual void Swap(TInt aLeft,TInt aRight) const;
	};

class TDesC16;	 
class TPtrC16;	 

class TChar
	{
public:

	 



	enum TCategory
		{
		EAlphaGroup = 0x00,								 
		ELetterOtherGroup = 0x10,						 
		ELetterModifierGroup = 0x20,					 
		EMarkGroup = 0x30,
		ENumberGroup = 0x40,
		EPunctuationGroup = 0x50,
		ESymbolGroup = 0x60,
		ESeparatorGroup = 0x70,
		EControlGroup = 0x80,
		EMaxAssignedGroup = 0xE0,
		EUnassignedGroup = 0xF0,

		ELuCategory = EAlphaGroup | 0,					 
		ELlCategory = EAlphaGroup | 1,					 
		ELtCategory = EAlphaGroup | 2,					 
		ELoCategory = ELetterOtherGroup | 0,			 
		EMaxLetterCategory = ELetterOtherGroup | 0x0F,	 

		ELmCategory = ELetterModifierGroup | 0,			 
		EMaxLetterOrLetterModifierCategory = ELetterModifierGroup | 0x0F,  

		EMnCategory = EMarkGroup | 0,					 
		EMcCategory = EMarkGroup | 1,					 
		EMeCategory = EMarkGroup | 2,					 
		ENdCategory = ENumberGroup | 0,					 
		ENlCategory = ENumberGroup | 1,					 
		ENoCategory = ENumberGroup | 2,					 
		EPcCategory = EPunctuationGroup | 0,			 
		EPdCategory = EPunctuationGroup | 1,			 
		EPsCategory = EPunctuationGroup | 2,			 
		EPeCategory = EPunctuationGroup | 3,			 
		EPiCategory = EPunctuationGroup | 4,			 
		EPfCategory = EPunctuationGroup | 5,			 
		EPoCategory = EPunctuationGroup | 6,			 
		ESmCategory = ESymbolGroup | 0,					 
		EScCategory = ESymbolGroup | 1,					 
		ESkCategory = ESymbolGroup | 2,					 
		ESoCategory = ESymbolGroup | 3,					 
		EMaxGraphicCategory = ESymbolGroup | 0x0F,		 

		EZsCategory = ESeparatorGroup | 0,				 
		EMaxPrintableCategory = EZsCategory,			 

		EZlCategory = ESeparatorGroup | 1,				 
		EZpCategory = ESeparatorGroup | 2,				 
		ECcCategory = EControlGroup | 0,				 
		ECfCategory = EControlGroup | 1,				 
		EMaxAssignedCategory = EMaxAssignedGroup | 0x0F, 
														 
														 

		ECsCategory = EUnassignedGroup | 0,				 
		ECoCategory = EUnassignedGroup | 1,				 
		ECnCategory = EUnassignedGroup | 2				 
		};

	 
	enum TBdCategory
		{
		ELeftToRight,				 
		ELeftToRightEmbedding,		 
		ELeftToRightOverride,		 
		ERightToLeft,				 
		ERightToLeftArabic,			 
		ERightToLeftEmbedding,		 
		ERightToLeftOverride,		 
		EPopDirectionalFormat,		 
		EEuropeanNumber,			 
		EEuropeanNumberSeparator,	 
		EEuropeanNumberTerminator,	 
		EArabicNumber,				 
		ECommonNumberSeparator,		 
		ENonSpacingMark,			 
		EBoundaryNeutral,			 
		EParagraphSeparator,		 
		ESegmentSeparator,			 
		EWhitespace,				 
		EOtherNeutral				 
		};

	 
	enum TCjkWidth
		{
		ENeutralWidth,			 
		EHalfWidth,				 
		EFullWidth,
		ENarrow,
		EWide
		};

	 
  	enum TEncoding
  		{
  		EUnicode,				 
  		EShiftJIS				 
  		};
  
	 
	enum
		{

		EFoldCase = 1,			 
		EFoldAccents = 2,		 
		EFoldDigits = 4,		 
		EFoldSpaces = 8,		 
		EFoldKana = 16,			 
		EFoldWidth = 32,		 
		EFoldStandard = EFoldCase | EFoldAccents | EFoldDigits | EFoldSpaces,
								 

		EFoldAll = -1			 
		};

	 
	struct TCharInfo
		{
		TCategory iCategory;				 
		TBdCategory iBdCategory;			 
		TInt iCombiningClass;				 
		TUint iLowerCase;					 
		TUint iUpperCase;					 
		TUint iTitleCase;					 
		TBool iMirrored;					 
		TInt iNumericValue;					 
		};

	inline TChar();
	inline TChar(TUint aChar);
	inline TChar& operator-=(TUint aChar);
	inline TChar& operator+=(TUint aChar);
	inline TChar operator-(TUint aChar);
	inline TChar operator+(TUint aChar);
	inline operator TUint() const;
	inline void Fold();
	inline void LowerCase();
	inline void UpperCase();
	inline TBool Eos() const;
	  TUint GetUpperCase() const;
	  TUint GetLowerCase() const;
	  TBool IsLower() const;
	  TBool IsUpper() const;
	  TBool IsAlpha() const;
	  TBool IsDigit() const;
	  TBool IsAlphaDigit() const;
	  TBool IsHexDigit() const;
	  TBool IsSpace() const;
	  TBool IsPunctuation() const;
	  TBool IsGraph() const;
	  TBool IsPrint() const;
	  TBool IsControl() const;
	inline void Fold(TInt aFlags);
	inline void TitleCase();
	  TUint GetTitleCase() const;
	  TBool IsTitle() const;
	  TBool IsAssigned() const;
	  void GetInfo(TCharInfo& aInfo) const;
	  TCategory GetCategory() const;
	  TBdCategory GetBdCategory() const;
	  TInt GetCombiningClass() const;
	  TBool IsMirrored() const;
	  TInt GetNumericValue() const;
	  TCjkWidth GetCjkWidth() const;
	  static TBool Compose(TUint& aResult,const TDesC16& aSource);
	  TBool Decompose(TPtrC16& aResult) const;
	 
  	  TBool TranslateFromUnicode(TUint& aCode,TEncoding aEncoding) const;
	 
  	  static TBool TranslateToUnicode(TUint& aTo,TUint aFrom,TEncoding aEncoding);

protected:
	inline void SetChar(TUint aChar);
private:
	TUint iChar;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TCharF : public TChar
	{
public:
	inline TCharF(TUint aChar);
	inline TCharF(const TChar &aChar);
	inline TCharF& operator=(TUint aChar);
	inline TCharF& operator=(const TChar &aChar);
	};

class TCharLC : public TChar
	{
public:
	inline TCharLC(TUint aChar);
	inline TCharLC(const TChar& aChar);
	inline TCharLC& operator=(TUint aChar);
	inline TCharLC& operator=(const TChar& aChar);
	};

class TCharUC : public TChar
	{
public:
	inline TCharUC(TUint aChar);
	inline TCharUC(const TChar& aChar);
	inline TCharUC& operator=(TUint aChar);
	inline TCharUC& operator=(const TChar& aChar);
	};

class TRealFormat
	{
public:
	  TRealFormat();
	  TRealFormat(TInt aWidth);
	  TRealFormat(TInt aWidth,TInt aDecimalPlaces);
public:
	TInt iType;
	TInt iWidth;
	TInt iPlaces;
	TChar iPoint;
	TChar iTriad;
	TInt iTriLen;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32des8.h" 1
 
 
 
 
 








const TUint KMaskDesLength8=0xfffffff;
const TInt KShiftDesType8=28;

class TBufCBase8;
class HBufC8;
class TDes8;
class TPtrC8;
class TPtr8;
class TDesC8
    {
public:
	inline TInt operator<(const TDesC8 &aDes) const;
	inline TInt operator<=(const TDesC8 &aDes) const;
	inline TInt operator>(const TDesC8 &aDes) const;
	inline TInt operator>=(const TDesC8 &aDes) const;
	inline TInt operator==(const TDesC8 &aDes) const;
	inline TInt operator!=(const TDesC8 &aDes) const;
	inline const TUint8 &operator[](TInt anIndex) const;
	inline TInt Length() const;
	inline TInt Size() const;
	  const TUint8 *Ptr() const;
	  TInt Compare(const TDesC8 &aDes) const;
	  TInt CompareF(const TDesC8 &aDes) const;
	  TInt CompareC(const TDesC8 &aDes) const;
	  TInt Match(const TDesC8 &aDes) const;
	  TInt MatchF(const TDesC8 &aDes) const;
	  TInt MatchC(const TDesC8 &aDes) const;
	  TInt Locate(TChar aChar) const;
	  TInt LocateF(TChar aChar) const;
	  TInt LocateReverse(TChar aChar) const;
	  TInt LocateReverseF(TChar aChar) const;
	  TInt Find(const TDesC8 &aDes) const;
	  TInt Find(const TUint8 *pS,TInt aLenS) const;
	  TInt FindF(const TDesC8 &aDes) const;
	  TInt FindF(const TUint8 *pS,TInt aLenS) const;
	  TInt FindC(const TDesC8 &aDes) const;
	  TInt FindC(const TUint8 *pS,TInt aLenS) const;
	  TPtrC8 Left(TInt aLength) const;
	  TPtrC8 Right(TInt aLength) const;
	  TPtrC8 Mid(TInt aPos) const;
	  TPtrC8 Mid(TInt aPos,TInt aLength) const;
	  HBufC8 *Alloc() const;
	  HBufC8 *AllocL() const;
	  HBufC8 *AllocLC() const;
protected:
	inline TDesC8(TInt aType,TInt aLength);
	inline TDesC8() {}
 
	inline TInt Type() const;
	inline void DoSetLength(TInt aLength);
	  const TUint8 &AtC(TInt anIndex) const;
private:

	TUint iLength;




	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtrC8 : public TDesC8
	{
public:
	  TPtrC8();
	  TPtrC8(const TDesC8 &aDes);
	  TPtrC8(const TUint8 *aString);
	  TPtrC8(const TUint8 *aBuf,TInt aLength);
	inline void Set(const TUint8 *aBuf,TInt aLength);
	inline void Set(const TDesC8 &aDes);
	inline void Set(const TPtrC8& aPtr);
private:
	TPtrC8& operator=(const TPtrC8 &aDes);
protected:
	const TUint8 *iPtr;
private:
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TDes8Overflow
	{
public:
	virtual void Overflow(TDes8 &aDes)=0;
	};
 
class TDesC16;
class TDes8 : public TDesC8
	{
public:
	inline TDes8& operator=(const TUint8 *aString);
	inline TDes8& operator=(const TDesC8 &aDes);
	inline TDes8& operator=(const TDes8 &aDes);
	inline TInt MaxLength() const;
	inline TInt MaxSize() const;
	inline const TUint8 &operator[](TInt anIndex) const;
	inline TUint8 &operator[](TInt anIndex);
	inline TDes8 &operator+=(const TDesC8 &aDes);
	  void Zero();
	  const TUint8 *PtrZ();
 	  void SetLength(TInt aLength);
 	  void SetMax();
	  void Copy(const TDesC8 &aDes);
	  void Copy(const TUint8 *aBuf,TInt aLength);
	  void Copy(const TUint8 *aString);
	  void Copy(const TDesC16 &aDes);
	  void CopyF(const TDesC8 &aDes);
	  void CopyC(const TDesC8 &aDes);
	  void CopyLC(const TDesC8 &aDes);
	  void CopyUC(const TDesC8 &aDes);
	  void CopyCP(const TDesC8 &aDes);
	  void Append(TChar aChar);
	  void Append(const TDesC8 &aDes);
	  void Append(const TDesC16 &aDes);
	  void Append(const TUint8 *aBuf,TInt aLength);
	  void AppendFill(TChar aChar,TInt aLength);
	  void ZeroTerminate();
	  void Fill(TChar aChar);
	  void Fill(TChar aChar,TInt aLength);
	  void FillZ();
	  void FillZ(TInt aLength);
	  void Swap(TDes8 &aDes);
	  void Fold();
	  void Collate();
	  void LowerCase();
	  void UpperCase();
	  void Capitalize();
	  void Repeat(const TUint8 *aBuf,TInt aLength);
	  void Repeat(const TDesC8 &aDes);
	  void Trim();
	  void TrimAll();
	  void TrimLeft();
	  void TrimRight();
	  void Insert(TInt aPos,const TDesC8 &aDes);
	  void Delete(TInt aPos,TInt aLength);
	  void Replace(TInt aPos,TInt aLength,const TDesC8 &aDes);
	  void Justify(const TDesC8 &aDes,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void Num(TInt aVal);
	  void Num(TUint aVal,TRadix aRadix=EDecimal);
	  void NumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void NumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void NumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void Num(TInt64 aVal);
	  void Num(TInt64 aVal,TRadix aRadix);
	  void NumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt Num(TReal aVal,const TRealFormat &aFormat);
	  void Format(TRefByValue<const TDesC8> aFmt,...);
	  void FormatList(const TDesC8 &aFmt,VA_LIST aList);
	  void AppendJustify(const TDesC8 &Des,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TDesC8 &Des,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint8 *aString,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint8 *aString,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendNum(TInt aVal);
	  void AppendNum(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNum(TInt64 aVal);
	  void AppendNum(TInt64 aVal,TRadix aRadix);
	  void AppendNumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt AppendNum(TReal aVal,const TRealFormat &aFormat);
	  void AppendFormat(TRefByValue<const TDesC8> aFmt,TDes8Overflow *aOverflowHandler,...);
	  void AppendFormat(TRefByValue<const TDesC8> aFmt,...);
	  void AppendFormatList(const TDesC8 &aFmt,VA_LIST aList,TDes8Overflow *aOverflowHandler= 0L );
	  TPtr8 LeftTPtr(TInt aLength) const;
	  TPtr8 RightTPtr(TInt aLength) const;
	  TPtr8 MidTPtr(TInt aPos) const;
	  TPtr8 MidTPtr(TInt aPos,TInt aLength) const;
protected:
	inline TDes8(TInt aType,TInt aLength,TInt aMaxLength);
	inline TUint8 *WPtr() const;
	inline TDes8() {}
 
protected:
	TInt iMaxLength;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtr8 : public TDes8
	{
public:
	  TPtr8(TUint8 *aBuf,TInt aMaxLength);
	  TPtr8(TUint8 *aBuf,TInt aLength,TInt aMaxLength);
	inline TPtr8& operator=(const TUint8 *aString);
	inline TPtr8& operator=(const TDesC8& aDes);
	inline TPtr8& operator=(const TPtr8& aPtr);
	inline void Set(TUint8 *aBuf,TInt aLength,TInt aMaxLength);
	inline void Set(const TPtr8 &aPtr);
private:
	  TPtr8(TBufCBase8 &aLcb,TInt aMaxLength);
protected:
	TUint8 *iPtr;
private:
	friend class TBufCBase8;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TBufCBase8 : public TDesC8
	{
protected:
	  TBufCBase8();
	inline TBufCBase8(TInt aLength);
	  TBufCBase8(const TUint8 *aString,TInt aMaxLength);
	  TBufCBase8(const TDesC8 &aDes,TInt aMaxLength);
	  void Copy(const TUint8 *aString,TInt aMaxLength);
	  void Copy(const TDesC8 &aDes,TInt aMaxLength);
	inline TPtr8 DoDes(TInt aMaxLength);
	inline TUint8 *WPtr() const;
	};
 
class RReadStream;
class HBufC8 : public TBufCBase8
	{
public:
	  static HBufC8 *New(TInt aMaxLength);
	  static HBufC8 *NewL(TInt aMaxLength);
	  static HBufC8 *NewLC(TInt aMaxLength);
	  static HBufC8 *NewMax(TInt aMaxLength);
	  static HBufC8 *NewMaxL(TInt aMaxLength);
	  static HBufC8 *NewMaxLC(TInt aMaxLength);
	  static HBufC8 *NewL(RReadStream &aStream,TInt aMaxLength);
	  static HBufC8 *NewLC(RReadStream &aStream,TInt aMaxLength);
	  HBufC8& operator=(const TUint8 *aString);
	  HBufC8& operator=(const TDesC8 &aDes);
	inline HBufC8& operator=(const HBufC8 &aLcb);
	  HBufC8 *ReAlloc(TInt aMaxLength);
	  HBufC8 *ReAllocL(TInt aMaxLength);
	  TPtr8 Des();
private:
	inline HBufC8(TInt aLength);
private:
	TText8 iBuf[1];
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 


 
template <TInt S>
class TBufC8 : public TBufCBase8
	{
public:
	inline TBufC8();
    inline TBufC8(const TUint8 *aString);
	inline TBufC8(const TDesC8 &aDes);
	inline TBufC8<S> &operator=(const TUint8 *aString);
	inline TBufC8<S> &operator=(const TDesC8 &aDes);
	inline TPtr8 Des();
protected:
	TUint8 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt8)) -1)/ (sizeof(TInt)/sizeof(TInt8)) )* (sizeof(TInt)/sizeof(TInt8)) ) ];
	};
 
class TBufBase8 : public TDes8
	{
protected:
	  TBufBase8(TInt aMaxLength);
	  TBufBase8(TInt aLength,TInt aMaxLength);
	  TBufBase8(const TUint8* aString,TInt aMaxLength);
	  TBufBase8(const TDesC8& aDes,TInt aMaxLength);
	};
 
template <TInt S>
class TBuf8 : public TBufBase8
	{
public:
	inline TBuf8();
	inline TBuf8(TInt aLength);
    inline TBuf8(const TUint8* aString);
	inline TBuf8(const TDesC8& aDes);
	inline TBuf8<S>& operator=(const TUint8* aString);
	inline TBuf8<S>& operator=(const TDesC8& aDes);
	inline TBuf8<S>& operator=(const TBuf8<S>& aBuf);
protected:
	TUint8 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt8)) -1)/ (sizeof(TInt)/sizeof(TInt8)) )* (sizeof(TInt)/sizeof(TInt8)) ) ];
	};
 
typedef TRefByValue<const TDesC8> __TRefDesC8;
template <TInt S>
class TLitC8
	{
public:
	inline const TDesC8* operator&() const;
	inline operator const TDesC8&() const;
	inline const TDesC8& operator()() const;
	inline operator const __TRefDesC8() const;
public:
	TUint iTypeLength;
	TText8 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt8)) -1)/ (sizeof(TInt)/sizeof(TInt8)) )* (sizeof(TInt)/sizeof(TInt8)) ) ];
	};

class RBuf8 : public TDes8
 
















	{
public:
	  RBuf8();
	  explicit RBuf8(HBufC8* aHBuf);
	  void Assign(const RBuf8& aRBuf);
	  void Assign(TUint8 *aHeapCell,TInt aMaxLength);
	  void Assign(TUint8 *aHeapCell,TInt aLength,TInt aMaxLength);
	  void Assign(HBufC8* aHBuf);
	  void Swap(RBuf8& aRBuf);
	  TInt Create(TInt aMaxLength);
	  void CreateL(TInt aMaxLength);
	  TInt CreateMax(TInt aMaxLength);
	  void CreateMaxL(TInt aMaxLength);
	inline void CreateL(RReadStream &aStream,TInt aMaxLength);
	  TInt Create(const TDesC8& aDes);
	  void CreateL(const TDesC8& aDes);
	  TInt Create(const TDesC8& aDes,TInt aMaxLength);
	  void CreateL(const TDesC8& aDes,TInt aMaxLength);
	  TInt ReAlloc(TInt aMaxLength);
	  void ReAllocL(TInt aMaxLength);
	  void Close();
	  void CleanupClosePushL();

protected:
	  RBuf8(TInt aType,TInt aLength,TInt aMaxLength);
	RBuf8(const RBuf8&);  
	union
		{
		TUint8* iEPtrType;		 
		HBufC8* iEBufCPtrType;	 
		};
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


# 1334 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32des16.h" 1
 
 
 
 
 








const TUint KMaskDesLength16=0xfffffff;
const TInt KShiftDesType16=28;

class TBufCBase16;
class HBufC16;
class TDes16;
class TPtrC16;
class TPtr16;
struct TCollationMethod;

class TDesC16
    {
public:
	enum TPrefix { EIsPrefix = 0, EMightBePrefix = 1, EIsNotPrefix = 2 };

	inline TInt operator<(const TDesC16 &aDes) const;
	inline TInt operator<=(const TDesC16 &aDes) const;
	inline TInt operator>(const TDesC16 &aDes) const;
	inline TInt operator>=(const TDesC16 &aDes) const;
	inline TInt operator==(const TDesC16 &aDes) const;
	inline TInt operator!=(const TDesC16 &aDes) const;
	inline const TUint16 &operator[](TInt anIndex) const;
	inline TInt Length() const;
	inline TInt Size() const;
	  const TUint16 *Ptr() const;
	  TInt Compare(const TDesC16 &aDes) const;
	  TInt CompareF(const TDesC16 &aDes) const;
	  TInt CompareC(const TDesC16 &aDes) const;
	  TInt CompareC(const TDesC16& aDes,TInt aMaxLevel,const TCollationMethod* aCollationMethod) const;	
	  TInt Match(const TDesC16 &aDes) const;
	  TInt MatchF(const TDesC16 &aDes) const;
	  TInt MatchC(const TDesC16 &aDes) const;
	  TInt Locate(TChar aChar) const;
	  TInt LocateF(TChar aChar) const;
	  TInt LocateReverse(TChar aChar) const;
	  TInt LocateReverseF(TChar aChar) const;
	  TInt Find(const TDesC16 &aDes) const;
	  TInt Find(const TUint16 *aBuf,TInt aLen) const;
	  TInt FindF(const TDesC16 &aDes) const;
	  TInt FindF(const TUint16 *aBuf,TInt aLen) const;
	  TInt FindC(const TDesC16 &aDes) const;
	  TInt FindC(const TUint16 *aBuf,TInt aLen) const;
	  TInt FindC(const TUint16 *aBuf,TInt aLen, TInt aMaxLevel) const;
	  TPrefix HasPrefixC(const TDesC16& aPossiblePrefix,
		TInt aLevel, const TCollationMethod* aCollationMethod) const;
	  TPtrC16 Left(TInt aLength) const;
	  TPtrC16 Right(TInt aLength) const;
	  TPtrC16 Mid(TInt aPos) const;
	  TPtrC16 Mid(TInt aPos,TInt aLength) const;
	  HBufC16 *Alloc() const;
	  HBufC16 *AllocL() const;
	  HBufC16 *AllocLC() const;
protected:
	inline TDesC16() {}
	inline TDesC16(TInt aType,TInt aLength);
 
	inline TInt Type() const;
	inline void DoSetLength(TInt aLength);
	  const TUint16 &AtC(TInt anIndex) const;
private:

	TUint iLength;




	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtrC16 : public TDesC16
	{
public:
	  TPtrC16();
	  TPtrC16(const TDesC16 &aDes);
	  TPtrC16(const TUint16 *aString);
	  TPtrC16(const TUint16 *aBuf,TInt aLength);
	inline void Set(const TUint16 *aBuf,TInt aLength);
	inline void Set(const TDesC16 &aDes);
	inline void Set(const TPtrC16 &aPtr);
private:
	TPtrC16& operator=(const TPtrC16 &aDes);
protected:
	const TUint16 *iPtr;
private:
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TDes16Overflow
	{
public:
	virtual void Overflow(TDes16 &aDes)=0;
	};
 
class TDes16 : public TDesC16
	{
public:
	inline TDes16& operator=(const TUint16 *aString);
	inline TDes16& operator=(const TDesC16 &aDes);
	inline TDes16& operator=(const TDes16 &aDes);
	inline TInt MaxLength() const;
	inline TInt MaxSize() const;
	inline const TUint16 &operator[](TInt anIndex) const;
	inline TUint16 &operator[](TInt anIndex);
	inline TDes16 &operator+=(const TDesC16 &aDes);
	  void Zero();
	  const TUint16 *PtrZ();
 	  void SetLength(TInt aLength);
 	  void SetMax();
	  void Copy(const TDesC8 &aDes);
	  void Copy(const TDesC16 &aDes);
	  void Copy(const TUint16 *aBuf,TInt aLength);
	  void Copy(const TUint16 *aString);
	  void CopyF(const TDesC16 &aDes);
	  void CopyC(const TDesC16 &aDes);
	  void CopyLC(const TDesC16 &aDes);
	  void CopyUC(const TDesC16 &aDes);
	  void CopyCP(const TDesC16 &aDes);
	  void Append(TChar aChar);
	  void Append(const TDesC16 &aDes);
	  void Append(const TUint16 *aBuf,TInt aLength);
	  void AppendFill(TChar aChar,TInt aLength);
	  void ZeroTerminate();
	  void Fill(TChar aChar);
	  void Fill(TChar aChar,TInt aLength);
	  void FillZ();
	  void FillZ(TInt aLength);
	  void Swap(TDes16 &aDes);
	  void Fold();
	  void Collate();
	  void LowerCase();
	  void UpperCase();
	  void Capitalize();
	  void Repeat(const TDesC16 &aDes);
	  void Repeat(const TUint16 *aBuf,TInt aLength);
	  void Trim();
	  void TrimAll();
	  void TrimLeft();
	  void TrimRight();
	  void Insert(TInt aPos,const TDesC16 &aDes);
	  void Delete(TInt aPos,TInt aLength);
	  void Replace(TInt aPos,TInt aLength,const TDesC16 &aDes);
	  void Justify(const TDesC16 &aDes,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void Num(TInt aVal);
	  void Num(TUint aVal,TRadix aRadix=EDecimal);
	  void NumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void NumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void NumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void Num(TInt64 aVal);
	  void Num(TInt64 aVal,TRadix aRadix);
	  void NumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt Num(TReal aVal,const TRealFormat &aFormat);
	  void Format(TRefByValue<const TDesC16> aFmt,...);
	  void FormatList(const TDesC16 &aFmt,VA_LIST aList);
	  void AppendJustify(const TDesC16 &Des,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TDesC16 &Des,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint16 *aString,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendJustify(const TUint16 *aString,TInt aLength,TInt aWidth,TAlign anAlignment,TChar aFill);
	  void AppendNum(TInt aVal);
	  void AppendNum(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumUC(TUint aVal,TRadix aRadix=EDecimal);
	  void AppendNumFixedWidth(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNumFixedWidthUC(TUint aVal,TRadix aRadix,TInt aWidth);
	  void AppendNum(TInt64 aVal);
	  void AppendNum(TInt64 aVal,TRadix aRadix);
	  void AppendNumUC(TInt64 aVal,TRadix aRadix=EDecimal);
	  TInt AppendNum(TReal aVal,const TRealFormat &aFormat);
	  void AppendFormat(TRefByValue<const TDesC16> aFmt,TDes16Overflow *aOverflowHandler,...);
	  void AppendFormat(TRefByValue<const TDesC16> aFmt,...);
	  void AppendFormatList(const TDesC16 &aFmt,VA_LIST aList,TDes16Overflow *aOverflowHandler= 0L );
	  TPtr16 LeftTPtr(TInt aLength) const;
	  TPtr16 RightTPtr(TInt aLength) const;
	  TPtr16 MidTPtr(TInt aPos) const;
	  TPtr16 MidTPtr(TInt aPos,TInt aLength) const;
protected:
	inline TDes16() {}
	inline TDes16(TInt aType,TInt aLength,TInt aMaxLength);
	inline TUint16 *WPtr() const;
 
protected:
	TInt iMaxLength;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
    };
 
class TPtr16 : public TDes16
	{
public:
	  TPtr16(TUint16 *aBuf,TInt aMaxLength);
	  TPtr16(TUint16 *aBuf,TInt aLength,TInt aMaxLength);
	inline TPtr16& operator=(const TUint16 *aString);
	inline TPtr16& operator=(const TDesC16& aDes);
	inline TPtr16& operator=(const TPtr16& aDes);
	inline void Set(TUint16 *aBuf,TInt aLength,TInt aMaxLength);
	inline void Set(const TPtr16 &aPtr);
private:
	  TPtr16(TBufCBase16 &aLcb,TInt aMaxLength);
protected:
	TUint16 *iPtr;
private:
	friend class TBufCBase16;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
class TBufCBase16 : public TDesC16
	{
protected:
	  TBufCBase16();
	inline TBufCBase16(TInt aLength);
	  TBufCBase16(const TUint16 *aString,TInt aMaxLength);
	  TBufCBase16(const TDesC16 &aDes,TInt aMaxLength);
	  void Copy(const TUint16 *aString,TInt aMaxLength);
	  void Copy(const TDesC16 &aDes,TInt aMaxLength);
	inline TPtr16 DoDes(TInt aMaxLength);
	inline TUint16 *WPtr() const;
	};
 
class RReadStream;
class HBufC16 : public TBufCBase16
	{
public:
	  static HBufC16 *New(TInt aMaxLength);
	  static HBufC16 *NewL(TInt aMaxLength);
	  static HBufC16 *NewLC(TInt aMaxLength);
	  static HBufC16 *NewMax(TInt aMaxLength);
	  static HBufC16 *NewMaxL(TInt aMaxLength);
	  static HBufC16 *NewMaxLC(TInt aMaxLength);
	  static HBufC16 *NewL(RReadStream &aStream,TInt aMaxLength);
	  static HBufC16 *NewLC(RReadStream &aStream,TInt aMaxLength);
	  HBufC16& operator=(const TUint16 *aString);
	  HBufC16& operator=(const TDesC16 &aDes);
	inline HBufC16& operator=(const HBufC16 &aLcb);
	  HBufC16 *ReAlloc(TInt aMaxLength);
	  HBufC16 *ReAllocL(TInt aMaxLength);
	  TPtr16 Des();
private:
	inline HBufC16(TInt aLength);
private:
	TText16 iBuf[1];
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 


 
template <TInt S>
class TBufC16 : public TBufCBase16
	{
public:
	inline TBufC16();
    inline TBufC16(const TUint16 *aString);
	inline TBufC16(const TDesC16 &aDes);
	inline TBufC16<S> &operator=(const TUint16 *aString);
	inline TBufC16<S> &operator=(const TDesC16 &aDes);
	inline TPtr16 Des();
protected:
	TUint16 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt16)) -1)/ (sizeof(TInt)/sizeof(TInt16)) )* (sizeof(TInt)/sizeof(TInt16)) ) ];
	};
 
class TBufBase16 : public TDes16
	{
protected:
	  TBufBase16(TInt aMaxLength);
	  TBufBase16(TInt aLength,TInt aMaxLength);
	  TBufBase16(const TUint16* aString,TInt aMaxLength);
	  TBufBase16(const TDesC16& aDes,TInt aMaxLength);
	};
 
template <TInt S>
class TBuf16 : public TBufBase16
	{
public:
	inline TBuf16();
	inline TBuf16(TInt aLength);
    inline TBuf16(const TUint16* aString);
	inline TBuf16(const TDesC16& aDes);
	inline TBuf16<S>& operator=(const TUint16* aString);
	inline TBuf16<S>& operator=(const TDesC16& aDes);
	inline TBuf16<S>& operator=(const TBuf16<S>& aDes);
protected:
	TUint16 iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt16)) -1)/ (sizeof(TInt)/sizeof(TInt16)) )* (sizeof(TInt)/sizeof(TInt16)) ) ];
	};
 
typedef TRefByValue<const TDesC16> __TRefDesC16;
template <TInt S>
class TLitC16
	{
public:
	inline const TDesC16* operator&() const;
	inline operator const TDesC16&() const;
	inline const TDesC16& operator()() const;
	inline operator const __TRefDesC16() const;
public:

	typedef __wchar_t __TText;







public:
	TUint iTypeLength;
	__TText iBuf[(((( S )+ (sizeof(TInt)/sizeof(TInt16)) -1)/ (sizeof(TInt)/sizeof(TInt16)) )* (sizeof(TInt)/sizeof(TInt16)) ) ];
	};

class RBuf16 : public TDes16
 
















	{
public:
	  RBuf16();
	  explicit RBuf16(HBufC16* aHBuf);
	  void Assign(const RBuf16& aRBuf);
	  void Assign(TUint16 *aHeapCell,TInt aMaxLength);
	  void Assign(TUint16 *aHeapCell,TInt aLength,TInt aMaxLength);
	  void Assign(HBufC16* aHBuf);
	  void Swap(RBuf16& aRBuf);
	  TInt Create(TInt aMaxLength);
	  void CreateL(TInt aMaxLength);
	  TInt CreateMax(TInt aMaxLength);
	  void CreateMaxL(TInt aMaxLength);
	inline void CreateL(RReadStream &aStream,TInt aMaxLength);
	  TInt Create(const TDesC16& aDes);
	  void CreateL(const TDesC16& aDes);
	  TInt Create(const TDesC16& aDes,TInt aMaxLength);
	  void CreateL(const TDesC16& aDes,TInt aMaxLength);
	  TInt ReAlloc(TInt aMaxLength);
	  void ReAllocL(TInt aMaxLength);
	  void Close();
	  void CleanupClosePushL();

protected:
	  RBuf16(TInt aType,TInt aLength,TInt aMaxLength);
	RBuf16(const RBuf16&);  
	union
		{
		TUint16* iEPtrType;		 
		HBufC16* iEBufCPtrType;	 
		};
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};




# 1335 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2






typedef TDesC16 TDesC;
typedef TPtrC16 TPtrC;
typedef TDes16 TDes;
typedef TPtr16 TPtr;
typedef HBufC16 HBufC;
 













typedef RBuf16 RBuf;
typedef TDes16Overflow TDesOverflow;
# 1385 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"


template <TInt S>

class TBufC : public TBufCBase16



	{
public:
	inline TBufC();
	inline TBufC(const TText* aString);
	inline TBufC(const TDesC& aDes);
	inline TBufC<S>& operator=(const TText* aString);
	inline TBufC<S>& operator=(const TDesC& aDes);
	inline TPtr Des();
private:
	TText iBuf[(((( S )+ (sizeof(TUint)/sizeof(TUint16)) -1)/ (sizeof(TUint)/sizeof(TUint16)) )* (sizeof(TUint)/sizeof(TUint16)) ) ];
	};

template <TInt S>

class TBuf : public TBufBase16



	{
public:
	inline TBuf();
	inline TBuf(TInt aLength);
	inline TBuf(const TText* aString);
	inline TBuf(const TDesC& aDes);
	inline TBuf<S>& operator=(const TText* aString);
	inline TBuf<S>& operator=(const TDesC& aDes);
	inline TBuf<S>& operator=(const TBuf<S>& aBuf);
private:
	TText iBuf[(((( S )+ (sizeof(TUint)/sizeof(TUint16)) -1)/ (sizeof(TUint)/sizeof(TUint16)) )* (sizeof(TUint)/sizeof(TUint16)) ) ];
	};

typedef TRefByValue<const TDesC> __TRefDesC;
template <TInt S>
class TLitC
	{
public:
	enum {BufferSize=S-1};
	inline const TDesC* operator&() const;
	inline operator const TDesC&() const;
	inline const TDesC& operator()() const;
	inline operator const __TRefDesC() const;
public:



	typedef __wchar_t __TText;







public:
	TUint iTypeLength;
	__TText iBuf[(((( S )+ (sizeof(TUint)/sizeof(TUint16)) -1)/ (sizeof(TUint)/sizeof(TUint16)) )* (sizeof(TUint)/sizeof(TUint16)) ) ];
	};

static const TLitC<sizeof(L"" )/2>  KNullDesC ={sizeof(L"" )/2-1,L"" } ;
static const TLitC8<sizeof( "" )>  KNullDesC8 ={sizeof( "" )-1, "" } ;
static const TLitC16<sizeof(L"" )/2>  KNullDesC16 ={sizeof(L"" )/2-1,L"" } ;

template <class T>
class TPckgC : public TPtrC8
	{
public:
	inline TPckgC(const T& aRef);
	inline const T& operator()() const;
private:
	TPckgC<T>& operator=(const TPckgC<T>& aRef);
	};

template <class T>
class TPckg : public TPtr8
	{
public:
	inline TPckg(const T& aRef);
	inline T& operator()();
private:
	TPckg<T>& operator=(const TPckg<T>& aRef);
	};

template <class T>
class TPckgBuf : public TBuf8<sizeof(T)>
	{
public:
	inline TPckgBuf();
	inline TPckgBuf(const T& aRef);
	inline TPckgBuf& operator=(const TPckgBuf<T>& aRef);
	inline T& operator=(const T& aRef);
	inline T& operator()();
	inline const T& operator()() const;
	};

typedef TBuf<KMaxName> TName;
typedef TBuf<KMaxInfoName> TInfoName;
typedef TBuf<KMaxFullName> TFullName;
typedef TBuf<KMaxExitCategoryName> TExitCategoryName;
typedef TBuf<KMaxFileName> TFileName;
typedef TBuf<KMaxPath> TPath;
typedef TBuf<KMaxDeviceInfo> TDeviceInfo;
typedef TBuf<KMaxVersionName> TVersionName;
typedef TBuf<KMaxPassword> TPassword;

class TLexMark8
	{
public:
	inline TLexMark8();
private:
	inline TLexMark8(const TUint8* aString);
	const TUint8* iPtr;
	friend class TLex8;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TRealX;
class TLex8
	{
public:
	  TLex8();
	inline TLex8(const TUint8* aString);
	inline TLex8(const TDesC8& aDes);
	inline TLex8& operator=(const TUint8* aString);
	inline TLex8& operator=(const TDesC8& aDes);
	inline TBool Eos() const;
	inline void Mark(TLexMark8& aMark) const;
	inline void Mark();
	  void Inc();
	  void Inc(TInt aNumber);
	  TChar Get();
	  TChar Peek() const;
	  void UnGet();
	inline void UnGetToMark();
	  void UnGetToMark(const TLexMark8 aMark);
	  void SkipSpace();
	inline void SkipAndMark(TInt aNumber);
	  void SkipAndMark(TInt aNumber, TLexMark8& aMark);
	inline void SkipSpaceAndMark();
	  void SkipSpaceAndMark(TLexMark8& aMark);
	  void SkipCharacters();
	inline TInt TokenLength() const;
	  TInt TokenLength(const TLexMark8 aMark) const;
	  TPtrC8 MarkedToken() const;
	  TPtrC8 MarkedToken(const TLexMark8 aMark) const;
	  TPtrC8 NextToken();
	  TPtrC8 Remainder() const;
	  TPtrC8 RemainderFromMark() const;
	  TPtrC8 RemainderFromMark(const TLexMark8 aMark) const;
	  TInt Offset() const;
	inline TInt MarkedOffset() const;
	  TInt MarkedOffset(const TLexMark8 aMark) const;
	  TInt Val(TInt8& aVal);
	  TInt Val(TInt16& aVal);
	  TInt Val(TInt32& aVal);
	  TInt Val(TInt64& aVal);
	inline TInt Val(TInt& aVal);
	  TInt Val(TUint8& aVal,TRadix aRadix);
	  TInt Val(TUint16& aVal,TRadix aRadix);
	  TInt Val(TUint32& aVal,TRadix aRadix);
	  TInt Val(TInt64& aVal,TRadix aRadix);
	inline TInt Val(TUint& aVal,TRadix aRadix=EDecimal);
	  TInt Val(TInt32& aVal,TInt aLimit);
	  TInt Val(TInt64& aVal,const TInt64& aLimit);
	  TInt Val(TUint32& aVal,TRadix aRadix,TUint aLimit);
	  TInt Val(TInt64& aVal,TRadix aRadix,const TInt64 &aLimit);
	  TInt Val(TReal32& aVal);
	  TInt Val(TReal32& aVal,TChar aPoint);
	  TInt Val(TReal64& aVal);
	  TInt Val(TReal64& aVal,TChar aPoint);
	inline void Assign(const TLex8& aLex);
	  void Assign(const TUint8* aString);
	  void Assign(const TDesC8& aDes);
	TInt Val(TRealX& aVal);
	TInt Val(TRealX& aVal, TChar aPoint);
private:
	void Scndig(TInt& aSig,TInt& aExp,TInt64& aDl);
	void ScndigAfterPoint(TInt& aSig,TInt64& aDl);
	void ValidateMark(const TLexMark8 aMark) const;
private:
	const TUint8* iNext;
	const TUint8* iBuf;
	const TUint8* iEnd;
	TLexMark8 iMark;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TLexMark16
	{
public:
	inline TLexMark16();
private:
	inline TLexMark16(const TUint16* aString);
	const TUint16* iPtr;
	friend class TLex16;	
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TLex16
	{
public:
	  TLex16();
	inline TLex16(const TUint16* aString);
	inline TLex16(const TDesC16& aDes);
	inline TLex16& operator=(const TUint16* aString);
	inline TLex16& operator=(const TDesC16& aDes);
	inline TBool Eos() const;
	inline void Mark();
	inline void Mark(TLexMark16& aMark) const;
	  void Inc();
	  void Inc(TInt aNumber);
	  TChar Get();
	  TChar Peek() const;
	  void UnGet();
	inline void UnGetToMark();
	  void UnGetToMark(const TLexMark16 aMark);
	  void SkipSpace();
	inline void SkipAndMark(TInt aNumber);
	  void SkipAndMark(TInt aNumber, TLexMark16& aMark);
	  void SkipSpaceAndMark(TLexMark16& aMark);
	inline void SkipSpaceAndMark();
	  void SkipCharacters();
	inline TInt TokenLength() const;
	  TInt TokenLength(const TLexMark16 aMark) const;
	  TPtrC16 MarkedToken() const;
	  TPtrC16 MarkedToken(const TLexMark16 aMark) const;
	  TPtrC16 NextToken();
	  TPtrC16 Remainder() const;
	  TPtrC16 RemainderFromMark() const;
	  TPtrC16 RemainderFromMark(const TLexMark16 aMark) const;
	  TInt Offset() const;
	inline TInt MarkedOffset() const;
	  TInt MarkedOffset(const TLexMark16 aMark) const;
	  TInt Val(TInt8& aVal);
	  TInt Val(TInt16& aVal);
	  TInt Val(TInt32& aVal);
	  TInt Val(TInt64& aVal);
	inline TInt Val(TInt& aVal);
	  TInt Val(TUint8& aVal,TRadix aRadix);
	  TInt Val(TUint16& aVal,TRadix aRadix);
	  TInt Val(TUint32& aVal,TRadix aRadix);
	  TInt Val(TInt64& aVal,TRadix aRadix);
	inline TInt Val(TUint& aVal,TRadix aRadix=EDecimal);
	  TInt Val(TInt32& aVal,TInt aLimit);
	  TInt Val(TInt64& aVal,const TInt64& aLimit);
	  TInt Val(TUint32& aVal,TRadix aRadix,TUint aLimit);
	  TInt Val(TInt64& aVal,TRadix aRadix,const TInt64& aLimit);
	  TInt Val(TReal32& aVal);
	  TInt Val(TReal32& aVal,TChar aPoint);
	  TInt Val(TReal64& aVal);
	  TInt Val(TReal64& aVal,TChar aPoint);
	inline void Assign(const TLex16& aLex);
	  void Assign(const TUint16* aString);
	  void Assign(const TDesC16& aDes);		
	TInt Val(TRealX& aVal);
	TInt Val(TRealX& aVal, TChar aPoint);
private:
	void Scndig(TInt& aSig,TInt& aExp,TInt64& aDl);
	void ValidateMark(const TLexMark16 aMark) const;
private:
	const TUint16* iNext;
	const TUint16* iBuf;
	const TUint16* iEnd;
	TLexMark16 iMark;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


typedef TLex16 TLex;
typedef TLexMark16 TLexMark;





typedef TBuf<KMaxUidName> TUidName;
class TUid
	{
public:
	  TInt operator==(const TUid& aUid) const;
	  TInt operator!=(const TUid& aUid) const;
	  TUidName Name() const;
	static inline TUid Uid(TInt aUid);
	static inline TUid Null();
public:
	TInt32 iUid;
	};

class TUidType
	{
public:
	  TUidType();
	  TUidType(TUid aUid1);
	  TUidType(TUid aUid1,TUid aUid2);
	  TUidType(TUid aUid1,TUid aUid2,TUid aUid3);
	  TInt operator==(const TUidType& aUidType) const;
	  TInt operator!=(const TUidType& aUidType) const;
	  const TUid& operator[](TInt anIndex) const;
	  TUid MostDerived() const;
	  TBool IsPresent(TUid aUid) const;
	  TBool IsValid() const;
private:
	TUid iUid[KMaxCheckedUid];
	};

 




class TSecureId
	{
public:
	inline TSecureId();
	inline TSecureId(TUint32 aId);
	inline operator TUint32() const;
	inline TSecureId(TUid aId);
	inline operator TUid() const;
public:
	TUint32 iId;
	};




 




class TVendorId
	{
public:
	inline TVendorId();
	inline TVendorId(TUint32 aId);
	inline operator TUint32() const;
	inline TVendorId(TUid aId);
	inline operator TUid() const;
public:
	TUint32 iId;
	};



 




class SSecureId
	{
public:
	inline const TSecureId* operator&() const;
	inline operator const TSecureId&() const;
	inline operator TUint32() const;
	inline operator TUid() const;
public:
	TUint32 iId;
	};


	
	
 




class SVendorId
	{
public:
	inline const TVendorId* operator&() const;
	inline operator const TVendorId&() const;
	inline operator TUint32() const;
	inline operator TUid() const;
public:
	TUint32 iId;
	};




 











 











 



enum TCapability
	{
	ECapabilityTCB				= 0,
	ECapabilityCommDD			= 1,
	ECapabilityPowerMgmt		= 2,
	ECapabilityMultimediaDD		= 3,
	ECapabilityReadDeviceData	= 4,
	ECapabilityWriteDeviceData	= 5,
	ECapabilityDRM				= 6,
	ECapabilityTrustedUI		= 7,
	ECapabilityProtServ			= 8,
	ECapabilityDiskAdmin		= 9,
	ECapabilityNetworkControl	= 10,
	ECapabilityAllFiles			= 11,
	ECapabilitySwEvent			= 12,
	ECapabilityNetworkServices	= 13,
	ECapabilityLocalServices	= 14,
	ECapabilityReadUserData		= 15,
	ECapabilityWriteUserData	= 16,
	ECapabilityLocation			= 17,

	ECapability_Limit,					 

	ECapability_HardLimit		= 255,	 

	ECapability_None			= -1	
	};


class TCheckedUid
	{
public:
	  TCheckedUid();
	  TCheckedUid(const TUidType& aUidType);
	  TCheckedUid(const TDesC8& aPtr);
	  void Set(const TUidType& aUidType);
	  void Set(const TDesC8& aPtr);
	  TPtrC8 Des() const;
	inline const TUidType& UidType() const;
protected:
	  TUint Check() const;
private:
	TUidType iType;
	TUint iCheck;
	};

class TVersion
	{
public:
	  TVersion();
	  TVersion(TInt aMajor,TInt aMinor,TInt aBuild);
	  TVersionName Name() const;
public:
	TInt8 iMajor;
	TInt8 iMinor;
	TInt16 iBuild;
	};

 
















class TDateTime
	{
public:
	inline TDateTime();
	  TDateTime(TInt aYear,TMonth aMonth,TInt aDay,TInt aHour,TInt aMinute, TInt aSecond,TInt aMicroSecond);
	  TInt Set(TInt aYear,TMonth aMonth,TInt aDay,TInt aHour,TInt aMinute, TInt aSecond,TInt aMicroSecond);
	  TInt SetYear(TInt aYear);
	  TInt SetYearLeapCheck(TInt aYear);
	  TInt SetMonth(TMonth aMonth);
	  TInt SetDay(TInt aDay);
	  TInt SetHour(TInt aHour);
	  TInt SetMinute(TInt aMinute);
	  TInt SetSecond(TInt aSecond);
	  TInt SetMicroSecond(TInt aMicroSecond);
	inline TInt Year() const;
	inline TMonth Month() const;
	inline TInt Day() const;
	inline TInt Hour() const;
	inline TInt Minute() const;
	inline TInt Second() const;
	inline TInt MicroSecond() const;
private:
	TInt iYear;
	TMonth iMonth;
	TInt iDay;
	TInt iHour;
	TInt iMinute;
	TInt iSecond;
	TInt iMicroSecond;
	};

 












class TTimeIntervalMicroSeconds
	{
public:
	inline TTimeIntervalMicroSeconds();
	inline TTimeIntervalMicroSeconds(const TInt64& aInterval);
	inline TTimeIntervalMicroSeconds& operator=(const TInt64& aInterval);
	inline TBool operator==(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator!=(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator>=(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator<=(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator>(const TTimeIntervalMicroSeconds& aInterval) const;
	inline TBool operator<(const TTimeIntervalMicroSeconds& aInterval) const;
	inline const TInt64& Int64() const;
private:
	TInt64 iInterval;
	};

 
















class TTimeIntervalBase
	{
public:
	inline TBool operator==(TTimeIntervalBase aInterval) const;
	inline TBool operator!=(TTimeIntervalBase aInterval) const;
	inline TBool operator>=(TTimeIntervalBase aInterval) const;
	inline TBool operator<=(TTimeIntervalBase aInterval) const;
	inline TBool operator>(TTimeIntervalBase aInterval) const;
	inline TBool operator<(TTimeIntervalBase aInterval) const;
	inline TInt Int() const;
protected:
	inline TTimeIntervalBase();
	inline TTimeIntervalBase(TInt aInterval);
protected:
	TInt iInterval;
	};

 












class TTimeIntervalMicroSeconds32 : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalMicroSeconds32();
	inline TTimeIntervalMicroSeconds32(TInt aInterval);
	inline TTimeIntervalMicroSeconds32& operator=(TInt aInterval);
	};

 












class TTimeIntervalSeconds : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalSeconds();
	inline TTimeIntervalSeconds(TInt aInterval);
	inline TTimeIntervalSeconds& operator=(TInt aInterval);
	};

 










class TTimeIntervalMinutes : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalMinutes();
	inline TTimeIntervalMinutes(TInt aInterval);
	inline TTimeIntervalMinutes& operator=(TInt aInterval);
	};

 










class TTimeIntervalHours : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalHours();
	inline TTimeIntervalHours(TInt aInterval);
	inline TTimeIntervalHours& operator=(TInt aInterval);
	};

 










class TTimeIntervalDays : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalDays();
	inline TTimeIntervalDays(TInt aInterval);
	inline TTimeIntervalDays& operator=(TInt aInterval);
	};

 










class TTimeIntervalMonths : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalMonths();
	inline TTimeIntervalMonths(TInt aInterval);
	inline TTimeIntervalMonths& operator=(TInt aInterval);
	};

 












class TTimeIntervalYears : public TTimeIntervalBase
	{
public:
	inline TTimeIntervalYears();
	inline TTimeIntervalYears(TInt aInterval);
	inline TTimeIntervalYears& operator=(TInt aInterval);
	};

 





enum 
	{
	 
	EParseTimePresent=0x1,
	 
	EParseDatePresent=0x2
	};


 




























class TTime
	{
public:
	inline TTime();
	inline TTime(const TInt64& aTime);
	  TTime(const TDesC& aString);
	  TTime(const TDateTime& aDateTime);
	inline TTime& operator=(const TInt64& aTime);
	  TTime& operator=(const TDateTime& aDateTime);
	  void HomeTime();
	  void UniversalTime();
	  TInt Set(const TDesC& aString);

	  TDateTime DateTime() const;
	  TTimeIntervalMicroSeconds MicroSecondsFrom(TTime aTime) const;
	  TInt SecondsFrom(TTime aTime,TTimeIntervalSeconds& aInterval) const;
	  TInt MinutesFrom(TTime aTime,TTimeIntervalMinutes& aInterval) const;
	  TInt HoursFrom(TTime aTime,TTimeIntervalHours& aInterval) const;
	  TTimeIntervalDays DaysFrom(TTime aTime) const;
	  TTimeIntervalMonths MonthsFrom(TTime aTime) const;
	  TTimeIntervalYears YearsFrom(TTime aTime) const;

	  TInt DaysInMonth() const;
	  TDay DayNoInWeek() const;
	  TInt DayNoInMonth() const;
	  TInt DayNoInYear() const;
	  TInt DayNoInYear(TTime aStartDate) const;
	  TInt WeekNoInYear() const;
	  TInt WeekNoInYear(TTime aStartDate) const;
	  TInt WeekNoInYear(TFirstWeekRule aRule) const;
	  TInt WeekNoInYear(TTime aStartDate,TFirstWeekRule aRule) const;
	  void FormatL(TDes& aDes,const TDesC& aFormat) const;
	  void RoundUpToNextMinute();
	  TInt Parse(const TDesC& aDes,TInt aCenturyOffset=0);

	  TTime operator+(TTimeIntervalYears aYear) const;
	  TTime operator+(TTimeIntervalMonths aMonth) const;
	  TTime operator+(TTimeIntervalDays aDay) const;
	  TTime operator+(TTimeIntervalHours aHour) const;
	  TTime operator+(TTimeIntervalMinutes aMinute) const;
	  TTime operator+(TTimeIntervalSeconds aSecond) const;  	
	  TTime operator+(TTimeIntervalMicroSeconds aMicroSecond) const;
	  TTime operator+(TTimeIntervalMicroSeconds32 aMicroSecond) const;
	  TTime operator-(TTimeIntervalYears aYear) const;
	  TTime operator-(TTimeIntervalMonths aMonth) const;
	  TTime operator-(TTimeIntervalDays aDay) const;
	  TTime operator-(TTimeIntervalHours aHour) const;
	  TTime operator-(TTimeIntervalMinutes aMinute) const;
	  TTime operator-(TTimeIntervalSeconds aSecond) const;  	
	  TTime operator-(TTimeIntervalMicroSeconds aMicroSecond) const;
	  TTime operator-(TTimeIntervalMicroSeconds32 aMicroSecond) const;
	  TTime& operator+=(TTimeIntervalYears aYear);
	  TTime& operator+=(TTimeIntervalMonths aMonth);
	  TTime& operator+=(TTimeIntervalDays aDay);
	  TTime& operator+=(TTimeIntervalHours aHour);
	  TTime& operator+=(TTimeIntervalMinutes aMinute);
	  TTime& operator+=(TTimeIntervalSeconds aSecond);	
	  TTime& operator+=(TTimeIntervalMicroSeconds aMicroSecond);
	  TTime& operator+=(TTimeIntervalMicroSeconds32 aMicroSecond);
	  TTime& operator-=(TTimeIntervalYears aYear);
	  TTime& operator-=(TTimeIntervalMonths aMonth);
	  TTime& operator-=(TTimeIntervalDays aDay);
	  TTime& operator-=(TTimeIntervalHours aHour);
	  TTime& operator-=(TTimeIntervalMinutes aMinute);
	  TTime& operator-=(TTimeIntervalSeconds aSecond);	
	  TTime& operator-=(TTimeIntervalMicroSeconds aMicroSecond);
	  TTime& operator-=(TTimeIntervalMicroSeconds32 aMicroSecond);
	inline TBool operator==(TTime aTime) const;
	inline TBool operator!=(TTime aTime) const;
	inline TBool operator>=(TTime aTime) const;
	inline TBool operator<=(TTime aTime) const;
	inline TBool operator>(TTime aTime) const;
	inline TBool operator<(TTime aTime) const;
	inline const TInt64& Int64() const;
private:
	static TTime Convert(const TDateTime& aDateTime);
private:
	TInt64 iTime;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


 







class Time
	{
public:
	  static TTime NullTTime();
	  static TTime MaxTTime();
	  static TTime MinTTime();
	  static TInt DaysInMonth(TInt aYear, TMonth aMonth);
	  static TBool IsLeapYear(TInt aYear);
	  static TInt LeapYearsUpTo(TInt aYear);
	};

 








class TDayName : public TBuf<KMaxDayName>
	{
public:
	  TDayName();
	  TDayName(TDay aDay);
	  void Set(TDay aDay);
	};

 












class TDayNameAbb : public TBuf<KMaxDayNameAbb>
	{
public:
	  TDayNameAbb();
	  TDayNameAbb(TDay aDay);
	  void Set(TDay aDay);
	};

 









class TMonthName : public TBuf<KMaxMonthName>
	{
public:
	  TMonthName();
	  TMonthName(TMonth aMonth);
	  void Set(TMonth aMonth);
	};

 












class TMonthNameAbb : public TBuf<KMaxMonthNameAbb>
	{
public:
	  TMonthNameAbb();
	  TMonthNameAbb(TMonth aMonth);
	  void Set(TMonth aMonth);
	};

 














class TDateSuffix : public TBuf<KMaxSuffix>
	{
public:
	  TDateSuffix();
	  TDateSuffix(TInt aDateSuffix);
	  void Set(TInt aDateSuffix);
	};

 













class TAmPmName : public TBuf<KMaxAmPmName>
	{
public:
	  TAmPmName();
	  TAmPmName(TAmPm aSelector);
	  void Set(TAmPm aSelector);
	};


 












class TCurrencySymbol : public TBuf<KMaxCurrencySymbol>
	{
public:
	  TCurrencySymbol();
	  void Set();
	};

 















class TShortDateFormatSpec : public TBuf<KMaxShortDateFormatSpec>  
	{
public:
	  TShortDateFormatSpec();
	  void Set();
	};

 















class TLongDateFormatSpec : public TBuf<KMaxLongDateFormatSpec>  
	{
public:
	  TLongDateFormatSpec();
	  void Set();
	};

 














class TTimeFormatSpec : public TBuf<KMaxTimeFormatSpec>  
	{
public:
	  TTimeFormatSpec();
	  void Set();
	};

 



enum TDaylightSavingZone
	{
	 




	EDstHome=0x40000000,

	 
	EDstNone=0,

	 
	EDstEuropean=1,
	
	 
	EDstNorthern=2,

	 
	EDstSouthern=4
	};

const TInt KMaxDateSeparators=4;
const TInt KMaxTimeSeparators=4;

 






enum TLocalePos 
	{
	 


	ELocaleBefore,
	
	 


	ELocaleAfter
	};

 


enum TDigitType
	{
	EDigitTypeUnknown = 0x0000,
	EDigitTypeWestern = 0x0030,
	EDigitTypeArabicIndic = 0x0660,
	EDigitTypeEasternArabicIndic = 0x6F0,
	EDigitTypeDevanagari = 0x0966,
	EDigitTypeThai = 0x0E50,
	EDigitTypeAllTypes = 0xFFFF
	};


 











class TLocale
	{
public:
	
	 




	enum TNegativeCurrencyFormat
		{
		 
		ELeadingMinusSign,
		 


		EInBrackets,  
		 
		ETrailingMinusSign,
		 
		EInterveningMinusSign
		};
	 


	enum 
		{
		 




		EFlagNegativeLoseSpace = 0x00000001,
		
		 




		EFlagNegativeCurrencySymbolOpposite=0x00000002
		};

	 
	enum TDeviceTimeState
		{
		 

		EDeviceUserTime,

		 

		ENITZNetworkTimeSync
		};
public:
	  TLocale();
	  void Refresh();
	  void Set() const;
	  void FormatCurrency(TDes& aText, TInt aAmount);
	  void FormatCurrency(TDes& aText, TInt64 aAmount);
	  void FormatCurrency(TDes& aText, TDesOverflow& aOverflowHandler, TInt aAmount); 
	  void FormatCurrency(TDes& aText, TDesOverflow& aOverflowHandler, TInt64 aAmount); 
	
	inline TInt CountryCode() const;
	inline void SetCountryCode(TInt aCode);
	inline TTimeIntervalSeconds UniversalTimeOffset() const;
	inline void SetUniversalTimeOffset(const TTimeIntervalSeconds& anOffset);
	inline TDateFormat DateFormat() const;
	inline void SetDateFormat(TDateFormat aFormat);
	inline TTimeFormat TimeFormat() const;
	inline void SetTimeFormat(TTimeFormat aFormat);
	inline TLocalePos CurrencySymbolPosition() const;
	inline void SetCurrencySymbolPosition(TLocalePos aPos);
	inline TBool CurrencySpaceBetween() const;
	inline void SetCurrencySpaceBetween(TBool aSpace);
	inline TInt CurrencyDecimalPlaces() const;
	inline void SetCurrencyDecimalPlaces(TInt aPlaces);
	inline TBool CurrencyNegativeInBrackets() const;         
	inline void SetCurrencyNegativeInBrackets(TBool aBool);  
 	inline TBool CurrencyTriadsAllowed() const;  
	inline void SetCurrencyTriadsAllowed(TBool aBool);
	inline TChar ThousandsSeparator() const;
	inline void SetThousandsSeparator(const TChar& aChar);
	inline TChar DecimalSeparator() const;
	inline void SetDecimalSeparator(const TChar& aChar);
	inline TChar DateSeparator(TInt aIndex) const;
	inline void SetDateSeparator(const TChar& aChar,TInt aIndex);
	inline TChar TimeSeparator(TInt aIndex) const;
	inline void SetTimeSeparator(const TChar& aChar,TInt aIndex);
	inline TBool AmPmSpaceBetween() const;
	inline void SetAmPmSpaceBetween(TBool aSpace);
	inline TLocalePos AmPmSymbolPosition() const;
	inline void SetAmPmSymbolPosition(TLocalePos aPos);
	inline TUint DaylightSaving() const;
	inline void SetDaylightSaving(TUint aDaylightSaving);
	inline TBool QueryHomeHasDaylightSavingOn() const;
	inline TDaylightSavingZone HomeDaylightSavingZone() const;
	inline void SetHomeDaylightSavingZone(TDaylightSavingZone aZone);
	inline TUint WorkDays() const;
	inline void SetWorkDays(TUint aMask);
	inline TDay StartOfWeek() const;
	inline void SetStartOfWeek(TDay aDay);
	inline TClockFormat ClockFormat() const;
	inline void SetClockFormat(TClockFormat aFormat);
	inline TUnitsFormat UnitsGeneral() const;
	inline void SetUnitsGeneral(TUnitsFormat aFormat);
	inline TUnitsFormat UnitsDistanceShort() const;
	inline void SetUnitsDistanceShort(TUnitsFormat aFormat);
	inline TUnitsFormat UnitsDistanceLong() const;
	inline void SetUnitsDistanceLong(TUnitsFormat aFormat);
	inline TNegativeCurrencyFormat NegativeCurrencyFormat() const;
	inline void SetNegativeCurrencyFormat(TNegativeCurrencyFormat aNegativeCurrencyFormat);
	inline TBool NegativeLoseSpace() const;
	inline void SetNegativeLoseSpace(TBool aBool);
	inline TBool NegativeCurrencySymbolOpposite() const;
	inline void SetNegativeCurrencySymbolOpposite(TBool aBool);
	inline TLanguage LanguageDowngrade(TInt aIndex) const;	  
	inline void SetLanguageDowngrade(TInt aIndex, TLanguage aLanguage);
	inline TDigitType DigitType() const;
	inline void SetDigitType(TDigitType aDigitType);
	inline void SetDeviceTime(TDeviceTimeState aState);
	inline TDeviceTimeState DeviceTime() const;
private:
	TInt iCountryCode;
	TTimeIntervalSeconds iUniversalTimeOffset;
	TDateFormat iDateFormat;
	TTimeFormat iTimeFormat;
	TLocalePos iCurrencySymbolPosition;
	TBool iCurrencySpaceBetween;
	TInt iCurrencyDecimalPlaces;
	TNegativeCurrencyFormat iNegativeCurrencyFormat;  
	TBool iCurrencyTriadsAllowed;
	TChar iThousandsSeparator;
	TChar iDecimalSeparator;
	TChar iDateSeparator[KMaxDateSeparators];
	TChar iTimeSeparator[KMaxTimeSeparators];
	TLocalePos iAmPmSymbolPosition;
	TBool iAmPmSpaceBetween;
	TUint iDaylightSaving;
	TDaylightSavingZone iHomeDaylightSavingZone;
	TUint iWorkDays;
	TDay iStartOfWeek;
	TClockFormat iClockFormat;
	TUnitsFormat iUnitsGeneral;
	TUnitsFormat iUnitsDistanceShort;
	TUnitsFormat iUnitsDistanceLong;
	TUint iExtraNegativeCurrencyFormatFlags;
	TUint16 iLanguageDowngrade[3];
	TUint16 iSpare16;
	TDigitType iDigitType;
	TDeviceTimeState iDeviceTimeState;
	TInt iSpare[0x1E];
	};

class TSize;
class TPoint
	{
public:
	enum TUninitialized { EUninitialized };
	TPoint(TUninitialized) {}
	inline TPoint();
	inline TPoint(TInt aX,TInt aY);
	  TInt operator==(const TPoint& aPoint) const;
	  TInt operator!=(const TPoint& aPoint) const;
	  TPoint& operator-=(const TPoint& aPoint);
	  TPoint& operator+=(const TPoint& aPoint);
	  TPoint& operator-=(const TSize& aSize);
	  TPoint& operator+=(const TSize& aSize);
	  TPoint operator-(const TPoint& aPoint) const;
	  TPoint operator+(const TPoint& aPoint) const;
	  TPoint operator-(const TSize& aSize) const;
	  TPoint operator+(const TSize& aSize) const;
	  TPoint operator-() const;
	  void SetXY(TInt aX,TInt aY);
	  TSize AsSize() const;
public:
	TInt iX;
	TInt iY;
	};

class TSize
	{
public:
	enum TUninitialized { EUninitialized };
	TSize(TUninitialized) {}
	inline TSize();
	inline TSize(TInt aWidth,TInt aHeight);
	  TInt operator==(const TSize& aSize) const;
	  TInt operator!=(const TSize& aSize) const;
	  TSize& operator-=(const TSize& aSize);
	  TSize& operator-=(const TPoint& aPoint);
	  TSize& operator+=(const TSize& aSize);
	  TSize& operator+=(const TPoint& aPoint);
	  TSize operator-(const TSize& aSize) const;
	  TSize operator-(const TPoint& aPoint) const;
	  TSize operator+(const TSize& aSize) const;
	  TSize operator+(const TPoint& aPoint) const;
	  TSize operator-() const;
	  void SetSize(TInt aWidth,TInt aHeight);
	  TPoint AsPoint() const;
public:
	TInt iWidth;
	TInt iHeight;
	};

class TRect
	{
public:
	enum TUninitialized { EUninitialized };
	TRect(TUninitialized) {}
	  TRect();
	  TRect(TInt aAx,TInt aAy,TInt aBx,TInt aBy);
	  TRect(const TPoint& aPointA,const TPoint& aPointB);
	  TRect(const TPoint& aPoint,const TSize& aSize);
	  TRect(const TSize& aSize);
	  TInt operator==(const TRect& aRect) const;
	  TInt operator!=(const TRect& aRect) const;
	  void SetRect(TInt aAx,TInt aAy,TInt aBx,TInt aBy);
	  void SetRect(const TPoint& aPointTL,const TPoint& aPointBR);
	  void SetRect(const TPoint& aPoint,const TSize& aSize);
	  void Move(TInt aDx,TInt aDy);
	  void Move(const TPoint& aOffset);
	  void Resize(TInt aDx,TInt aDy);
	  void Resize(const TSize& aSize);
	  void Shrink(TInt aDx,TInt aDy);
	  void Shrink(const TSize& aSize);
	  void Grow(TInt aDx,TInt aDy);
	  void Grow(const TSize& aSize);
	  void BoundingRect(const TRect& aRect);
	  TBool IsEmpty() const;
	  TBool Intersects(const TRect& aRect) const;
	  void Intersection(const TRect& aRect);
	  void Normalize();
	  TBool Contains(const TPoint& aPoint) const;
	  TSize Size() const;
	  TInt Width() const;
	  TInt Height() const;
	  TBool IsNormalized() const;
	  TPoint Center() const;
	  void SetSize(const TSize& aSize);
	  void SetWidth(TInt aWidth);
	  void SetHeight(TInt aHeight);
private:
	void Adjust(TInt aDx,TInt aDy);
public:
	TPoint iTl;
	TPoint iBr;
	};

class TRegion
	{
public:
	inline TInt Count() const;
	inline const TRect* RectangleList() const;
	inline TBool CheckError() const;
	  TBool IsEmpty() const;
	  TRect BoundingRect() const;
	  const TRect& operator[](TInt aIndex) const;
	  void Copy(const TRegion& aRegion);
	  void AddRect(const TRect& aRect);
	  void SubRect(const TRect& aRect,TRegion* aSubtractedRegion= 0L );
	  void Offset(TInt aXoffset,TInt aYoffset);
	  void Offset(const TPoint& aOffset);
	  void Union(const TRegion& aRegion);
	  void Intersection(const TRegion& aRegion,const TRegion& aRegion2);
	  void Intersect(const TRegion& aRegion);
	  void SubRegion(const TRegion& aRegion,TRegion* aSubtractedRegion= 0L );
	  void ClipRect(const TRect& aRect);
	  void Clear();
	  void Tidy();
	  TInt Sort();
	  TInt Sort(const TPoint& aOffset);
	  void ForceError();
	  TBool IsContainedBy(const TRect& aRect) const;
	  TBool Contains(const TPoint& aPoint) const;
protected:
	  TRect* RectangleListW();
	  TRegion(TInt aAllocedRects);
	inline TRegion();
	TBool SetListSize(TInt aCount);
	void AppendRect(const TRect& aRect);
	void DeleteRect(TRect* aRect);
	void AppendRegion(TRegion& aRegion);
protected:
	TInt iCount;
	TBool iError;
	TInt iAllocedRects;
protected:
	enum {ERRegionBuf=0x40000000};
	};

class RRegion : public TRegion
	{
private:
	enum {EDefaultGranularity=5};
protected:
	  RRegion(TInt aBuf,TInt aGran);
public:
	  RRegion();
	  RRegion(TInt aGran);
	  RRegion(const RRegion& aRegion);
	  RRegion(const TRect& aRect,TInt aGran=EDefaultGranularity);
	  RRegion(TInt aCount,TRect* aRectangleList,TInt aGran=EDefaultGranularity);
	  void Close();
	  void Destroy();
	inline TInt CheckSpare() const;
private:
	TInt iGranularity;
	TRect* iRectangleList;
	friend class TRegion;
	};

template <TInt S>
class RRegionBuf : public RRegion
	{
public:
	inline RRegionBuf();
	inline RRegionBuf(const RRegion& aRegion);
	inline RRegionBuf(const RRegionBuf<S>& aRegion);
	inline RRegionBuf(const TRect& aRect);
private:
	TInt8 iRectangleBuf[S*sizeof(TRect)];
	};

template <TInt S>
class TRegionFix : public TRegion
	{
public:
	inline TRegionFix();
	inline TRegionFix(const TRect& aRect);
	inline TRegionFix(const TRegionFix<S>& aRegion);
private:
	TInt8 iRectangleBuf[S*sizeof(TRect)];
	};

class TRequestStatus
	{
public:
	inline TRequestStatus();
	inline TRequestStatus(TInt aVal);
	inline TInt operator=(TInt aVal);
	inline TInt operator==(TInt aVal) const;
	inline TInt operator!=(TInt aVal) const;
	inline TInt operator>=(TInt aVal) const;
	inline TInt operator<=(TInt aVal) const;
	inline TInt operator>(TInt aVal) const;
	inline TInt operator<(TInt aVal) const;
	inline TInt Int() const;
private:
	TInt iStatus;
	};

class TFindHandleBase
	{
public:
	  TFindHandleBase();
	  TFindHandleBase(const TDesC& aMatch);
	  void Find(const TDesC& aMatch);
	inline TInt Handle() const;
protected:
	TInt iFindHandle;
	TFullName iMatch;
	};

class TFindSemaphore : public TFindHandleBase
	{
public:
	inline TFindSemaphore();
	inline TFindSemaphore(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindMutex : public TFindHandleBase
	{
public:
	inline TFindMutex();
	inline TFindMutex(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindChunk : public TFindHandleBase
	{
public:
	inline TFindChunk();
	inline TFindChunk(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindThread : public TFindHandleBase
	{
public:
	inline TFindThread();
	inline TFindThread(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindProcess : public TFindHandleBase
	{
public:
	inline TFindProcess();
	inline TFindProcess(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindLogicalDevice : public TFindHandleBase
	{
public:
	inline TFindLogicalDevice();
	inline TFindLogicalDevice(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindPhysicalDevice : public TFindHandleBase
	{
public:
	inline TFindPhysicalDevice();
	inline TFindPhysicalDevice(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindLogicalChannel : public TFindHandleBase
	{
public:
	inline TFindLogicalChannel();
	inline TFindLogicalChannel(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindServer : public TFindHandleBase
	{
public:
	inline TFindServer();
	inline TFindServer(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class TFindLibrary : public TFindHandleBase
	{
public:
	inline TFindLibrary();
	inline TFindLibrary(const TDesC& aMatch);
	  TInt Next(TFullName& aResult);
	};

class THandleInfo
	{
public:
	TInt iNumOpenInProcess;
	TInt iNumOpenInThread;
	TInt iNumProcesses;
	TInt iNumThreads;
	};

class RThread;
class RHandleBase
	{
public:
	enum
		{
		EReadAccess=0x1,
		EWriteAccess=0x2,
		EDirectReadAccess=0x4,
		EDirectWriteAccess=0x8,
		};
public:
	inline RHandleBase();
	  void Close();
	  TName Name() const;
	  TFullName FullName() const;
	inline void SetHandle(TInt aHandle);
	  void SetHandleNC(TInt aHandle);
	  TInt Duplicate(const RThread& aSrc,TOwnerType aType=EOwnerProcess);
	  void HandleInfo(THandleInfo* anInfo);
	  TUint Attributes() const;
	inline TInt Handle() const;
protected:
	inline RHandleBase(TInt aHandle);
	  TInt Open(const TFindHandleBase& aHandle,TOwnerType aType);
protected:
	TInt iHandle;
	};

class RDevice : public RHandleBase
	{
public:
	inline TInt Open(const TFindLogicalDevice& aFind,TOwnerType aType=EOwnerProcess);
	  TInt Open(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  void GetCaps(TDes8& aDes) const;
	  TBool QueryVersionSupported(const TVersion& aVer) const;
	  TBool IsAvailable(TInt aUnit,const TDesC* aPhysicalDevice,const TDesC* anInfo) const;
	};

const TUint	KBusDevModeInvalid=0xFFFFFFFF;
const TUint	KBusDevSocketInfoMask=0x0000FFFF;
const TUint KBusDevPhase1Start=0x00010000;
const TUint KBusDevPhase2Start=0x00020000;

class MBusDev
	{
public:
      MBusDev();
    TInt CheckOpenMode(const TDesC& aDeviceName,TInt aUnit);
	TInt DoAsyncStart();
	TInt DoAsyncLateOpen(TInt aHandle,TInt anOpenInfo);
	inline TBool MayRequireRestart() {return(iStartInfo);}
	inline TInt DevSocketNumber() {return(iStartInfo&KBusDevSocketInfoMask);}
	inline TInt& Status() {return(iStatus);}
	inline void SetStatus(TInt aVal) {iStatus=aVal;}
private:
    TUint iStartInfo;
	TInt iStatus;
	};

class RBusLogicalChannel : public RHandleBase, public MBusDev
	{
protected:
	  TInt DoCreate(const TDesC& aDevice,const TVersion& aVer,const TDesC* aChan,TInt aUnit,const TDesC* aDriver,const TDesC8* anInfo,TOwnerType aType=EOwnerProcess);
	  void DoCancel(TUint aReqMask);
	  void DoRequest(TInt aReqNo,TRequestStatus& aStatus);
	  void DoRequest(TInt aReqNo,TRequestStatus& aStatus,TAny* a1);
	  void DoRequest(TInt aReqNo,TRequestStatus& aStatus,TAny* a1,TAny* a2);
	  TInt DoControl(TInt aFunction);
	  TInt DoControl(TInt aFunction,TAny* a1);
	  TInt DoControl(TInt aFunction,TAny* a1,TAny* a2);
	  TInt DoSvControl(TInt aFunction);
	  TInt DoSvControl(TInt aFunction,TAny* a1);
	  TInt DoSvControl(TInt aFunction,TAny* a1,TAny* a2);
private:
	TInt CheckBusStatus();
	TInt DoCheckBusStatus(TInt aSocket);
	};

class RTimer : public RHandleBase
	{
public:
	  TInt CreateLocal();
	  void Cancel();
	  void After(TRequestStatus& aStatus,TTimeIntervalMicroSeconds32 anInterval);
	  void At(TRequestStatus& aStatus,const TTime& aTime);
	  void Lock(TRequestStatus& aStatus,TTimerLockSpec aLock);
	  void Inactivity(TRequestStatus& aStatus, TTimeIntervalSeconds aSeconds);
	};

class RLibrary : public RHandleBase
	{
public:
	  void Close();
	  TInt Load(const TDesC& aFileName,const TUidType &aType);
	  TInt Load(const TDesC& aFileName,const TDesC& aPath=KNullDesC);
	  TInt Load(const TDesC& aFileName,const TDesC& aPath,const TUidType &aType);
	  TInt LoadRomLibrary(const TDesC& aFileName,const TDesC& aPath);
	  TLibraryFunction Lookup(TInt anOrdinal) const;
	  TUidType Type() const;
	  TLibraryEntry EntryPoint() const;
	  TUint* DllRefTable() const;
	TInt LibraryCallList(TInt& aNumEps, TUint*& aCallList);
	  TFileName FileName() const;
	  TInt GetRamSizes(TInt& aCodeSize, TInt& aConstDataSize);
	};

class RSemaphore : public RHandleBase
	{
public:
	inline TInt Open(const TFindSemaphore& aFind,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocal(TInt aCount,TOwnerType aType=EOwnerProcess);
	  TInt CreateGlobal(const TDesC& aName,TInt aCount,TOwnerType aType=EOwnerProcess);
	  TInt OpenGlobal(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt Count();
	  void Wait();
	  void Signal();
	  void Signal(TInt aCount);
	};

class RCriticalSection : private RSemaphore
	{
public:
	  RCriticalSection();
	  TInt CreateLocal(TOwnerType aType=EOwnerProcess);
	  void Close();
	  void Wait();
	  void Signal();
	inline TBool IsBlocked() const;
private:
	TInt iBlocked;
	};

class RMutex : public RHandleBase
	{
public:
	inline TInt Open(const TFindMutex& aFind,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocal(TOwnerType aType=EOwnerProcess);
	  TInt CreateGlobal(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt OpenGlobal(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt Count();
	  void Wait();
	  void Signal();
	};

class RChunk : public RHandleBase
	{
public:
	inline TInt Open(const TFindChunk& aFind,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocal(TInt aSize,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateLocalCode(TInt aSize,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateGlobal(const TDesC& aName,TInt aSize,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateDoubleEndedLocal(TInt aInitialBottom, TInt aInitialTop,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt CreateDoubleEndedGlobal(const TDesC& aName,TInt aInitialBottom,TInt aInitialTop,TInt aMaxSize,TOwnerType aType=EOwnerProcess);
	  TInt OpenGlobal(const TDesC& aName,TBool isReadOnly,TOwnerType aType=EOwnerProcess);
	  TInt Adjust(TInt aNewSize) const;
	  TInt AdjustDoubleEnded(TInt aBottom, TInt aTop) const;
	  TUint8* Base() const;
	  TInt Size() const;
	  TInt Bottom() const;
	  TInt Top() const;
	  TInt MaxSize() const;
	inline TBool IsReadable() const;
	inline TBool IsWritable() const;
private:
	friend class UserHeap;
	};

class RHeap;
class THeapWalk
	{
protected:
	enum TCellType
		{
		EGoodAllocatedCell,EGoodFreeCell,
		EBadAllocatedCellSize,EBadAllocatedCellAddress,
		EBadFreeCellAddress
		};
public:
	  THeapWalk(const RHeap &aHeap);
	  TInt Walk();
	virtual void Info(TCellType aType,TAny* aBase,TInt aLength)=0;
protected:
	inline TInt Value() const;
	inline void SetValue(TInt aValue);
private:
	RHeap* iHeap;
	TInt iValue;
	};

class UserHeap
	{
public:
	  static RHeap* FixedHeap(TAny* aBase, TInt aMaxLength);
	  static RHeap* ChunkHeap(const TDesC* aName, TInt aMinLength, TInt aMaxLength, TInt aGrowBy=KMinHeapGrowBy);
	  static RHeap* ChunkHeap(RChunk& aChunk, TInt aMinLength, TInt aGrowBy=KMinHeapGrowBy);
	};

  TInt CalcChunkHeapCompression(RHeap* aHeap,TInt aBaseOffset);

 
 
class RHeapBase
	{
public:
	enum THeapType {EFixedAddress,EChunkSupervisor,EChunkStack,EChunkNormal};
	struct SCell {TInt len;SCell* next;};
protected:
	TInt iMinLength;
	TInt iMaxLength;
	TInt iOffset;
	TInt iGrowBy;
	TInt iAccessCount;
	THeapType iType;
	RChunk iChunk;
	RCriticalSection iLock;
	TUint8* iBase;
	TUint8* iTop;
	SCell iFree;
	friend class THeapWalk;
	friend class S;
	friend TInt CalcChunkHeapCompression(RHeap* aHeap,TInt aBaseOffset);
	friend class UserHeap;
protected:
	RHeapBase(TInt aMaxLength);
	RHeapBase(const RChunk& aChunk,TInt anOffset,TInt aMinLength,TInt aMaxLength,TInt aGrowBy);
	virtual TInt ChunkAdjust(TInt aSize)=0;
	virtual TInt CompressAll()=0;
	};

class RHeap : public RHeapBase
	{
public:
	typedef TUint32 TAllocSize;
	enum TAllocFail {ERandom,ETrueRandom,EDeterministic,ENone,EFailNext};
	enum TDbgHeapType {EUser,EKernel};
public:
	  TInt Open();
	  void Close();
	  TInt AllocLen(const TAny* aCell) const;
	  TInt AllocSize(TInt& aTotalAllocSize) const;
	  TAny* Alloc(TInt aSize);
	  TAny* AllocL(TInt aSize);
	  TAny* AllocLC(TInt aSize);
	  TAny* Adjust(TAny* aCell,TInt anOffset,TInt aDelta);
	  TAny* AdjustL(TAny* aCell,TInt anOffset,TInt aDelta);
	  TInt Compress();
	  void Free(TAny* aCell);
	  void FreeZ(TAny* &aCell);
	  void FreeAll();
	  TAny* ReAlloc(TAny* aCell,TInt aSize);
	  TAny* ReAllocL(TAny* aCell,TInt aSize);
	  THeapType Type() const;
	  TUint8* Base() const;
	  TInt Size() const;
	  TInt Available(TInt& aBiggestBlock) const;
	  void Check() const;
	  TInt Count() const;
	  TInt Count(TInt& aFreeCount) const;
	  void __DbgMarkStart();
	  TUint32 __DbgMarkEnd(TInt aCount);
	  void __DbgMarkCheck(TBool aCountAll,TInt aCount,const TDesC8& aFileName,TInt aLineNum);
	  void __DbgSetAllocFail(TAllocFail aType,TInt aValue);
protected:
	  RHeap(TInt aMaxLength);
	  RHeap(const RChunk& aChunk,TInt anOffset,TInt aMinLength,TInt aMaxLength,TInt aGrowBy);
	  TAny* operator new(TUint aSize,TAny* aBase);
	  void Initialise();
	  SCell* GetAddress(TAny* aCell);
	  virtual TInt ChunkAdjust(TInt aSize);
	  virtual TInt CompressAll();
protected:
	friend class THeapWalk;
	friend class S;
	friend TInt CalcChunkHeapCompression(RHeap* aHeap,TInt aBaseOffset);
	friend class UserHeap;
private:
	void ChunkHeapCreated() const;	 
	TInt TryToGrowHeap(TInt aSize, SCell* pC, SCell* pP);
public:
	struct SDebugCell {TInt len;TInt nestingLevel;TInt allocCount;};
# 3285 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

public:
	TBool iTestCodeRunning;	
	TInt iTestNestingLevel;
	TInt iTestNumAllocCells;
	TUint iTestAddress;
	TInt iTestSize;
	TInt iTestAllocCount;
private:
	TInt iNestingLevel;
	TInt iAllocCount;
	TInt iLevelNumAllocCells;
	SDebugCell* iPtrDebugCell;
	TAllocFail iFailType;
	TInt iFailRate;
	TBool iFailed;
	TInt iFailAllocCount;
	TInt iRand;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TThreadId
	{
public:
	inline TThreadId();
	inline TThreadId(TUint anId);
	inline operator TUint() const;
	inline TInt operator==(TThreadId aId) const;
	inline TInt operator!=(TThreadId aId) const;
private:
	TUint iId;
	};

class RProcess;
class RThread : public RHandleBase
 



	{
public:
	inline RThread();
	  TInt Create(const TDesC& aName,TThreadFunction aFunction,TInt aStackSize,TAny* aPtr,RLibrary* aLibrary,RHeap* aHeap, TInt aHeapMinSize,TInt aHeapMaxSize,TOwnerType aType);
	  TInt Create(const TDesC& aName,TThreadFunction aFunction,TInt aStackSize,TInt aHeapMinSize,TInt aHeapMaxSize,TAny *aPtr,TOwnerType aType=EOwnerProcess);
	  TInt Create(const TDesC& aName,TThreadFunction aFunction,TInt aStackSize,RHeap* aHeap,TAny* aPtr,TOwnerType aType=EOwnerProcess);
	  TInt SetInitialParameter(TAny* aPtr);
	  TInt Open(const TDesC& aFullName,TOwnerType aType=EOwnerProcess);
	  TInt Open(TThreadId aID,TOwnerType aType=EOwnerProcess);
	  TThreadId Id() const;
	  void Resume() const;
	  void Suspend() const;
	  TInt Rename(const TDesC& aName) const;
	  void Kill(TInt aReason);
	  void Terminate(TInt aReason);
	  void Panic(const TDesC& aCategory,TInt aReason);
	  TInt Process(RProcess& aProcess) const;
	  TThreadPriority Priority() const;
	  void SetPriority(TThreadPriority aPriority) const;
	  TProcessPriority ProcessPriority() const;
	  void SetProcessPriority(TProcessPriority aPriority) const;
	  TBool System() const;
	  void SetSystem(TBool aState) const;
	  TBool Protected() const;
	  void SetProtected(TBool aState) const;
	  TInt RequestCount() const;
	  TExitType ExitType() const;
	  TInt ExitReason() const;
	  TExitCategoryName ExitCategory() const;
	  void RequestComplete(TRequestStatus*& aStatus,TInt aReason) const;

	  TInt GetDesLength(const TAny* aPtr) const;
	  TInt GetDesMaxLength(const TAny* aPtr) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes,TInt anOffset) const;
	  void ReadL(const TAny* aPtr,TDes16 &aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes,TInt anOffset) const;

	  void Logon(TRequestStatus& aStatus) const;
	  TInt LogonCancel(TRequestStatus& aStatus) const;
	  RHeap* Heap();	
	  void HandleCount(TInt& aProcessHandleCount, TInt& aThreadHandleCount) const;
	  TExceptionHandler* ExceptionHandler() const;
	  TInt SetExceptionHandler(TExceptionHandler* aHandler,TUint32 aMask);
	  void ModifyExceptionMask(TUint32 aClearMask, TUint32 aSetMask);
	  TInt RaiseException(TExcType aType);
	  TBool IsExceptionHandled(TExcType aType);
	  void Context(TDes8& aDes) const;
	  TInt GetRamSizes(TInt& aHeapSize,TInt& aStackSize);
	  TInt GetCpuTime(TTimeIntervalMicroSeconds& aCpuTime) const;
	inline TInt Open(const TFindThread& aFind,TOwnerType aType=EOwnerProcess);
	  void Rendezvous(TRequestStatus& aStatus) const;
	  TInt RendezvousCancel(TRequestStatus& aStatus) const;
	  static void Rendezvous(TInt aReason);

	 





	  TSecureId SecureId() const;

	 






	inline TVendorId VendorId() const
		{ return 0; }

	 








	inline TBool HasCapability(TCapability  ,const char*  =0) const
		{ return ETrue; }

	 









	inline TBool HasCapability(TCapability  ,TCapability  ,const char*  =0) const
		{ return ETrue; }

# 3432 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

	};

class TProcessId
	{
public:
	inline TProcessId();
	inline TProcessId(TUint anId);
	inline operator TUint() const;
	inline TInt operator==(TProcessId aId) const;
	inline TInt operator!=(TProcessId aId) const;
private:
	TUint iId;
	};


 



class TProcessMemoryInfo
	{
public:
	TUint32 iCodeBase;
	TUint32 iCodeSize;
	TUint32 iConstDataBase;
	TUint32 iConstDataSize;
	TUint32 iInitialisedDataBase;
	TUint32 iInitialisedDataSize;
	TUint32 iUninitialisedDataBase;
	TUint32 iUninitialisedDataSize;
	};

class RProcess : public RHandleBase
 



	{
public:
	inline RProcess();
	  TInt Create(const TDesC& aFileName,const TDesC& aCommand,TOwnerType aType=EOwnerProcess);
	  TInt Create(const TDesC& aFileName,const TDesC& aCommand,const TUidType &aUidType, TOwnerType aType=EOwnerProcess);
	  TInt Open(const TDesC& aName,TOwnerType aType=EOwnerProcess);
	  TInt Open(TProcessId aId,TOwnerType aType=EOwnerProcess);
	  TUidType Type() const;
	  void SetType(const TUidType& aType);
	  TProcessId Id() const;
	  TInt Rename(const TDesC& aName);
	  void Kill(TInt aReason);
	  void Terminate(TInt aReason);
	  void Panic(const TDesC& aCategory,TInt aReason);
	  void Resume();
	  TFileName FileName() const;
	  TInt CommandLineLength() const;
	  void CommandLine(TDes &aCommand) const;
	  TExitType ExitType() const;
	  TInt ExitReason() const;
	  TExitCategoryName ExitCategory() const;
	  TProcessPriority Priority() const;
	  void SetPriority(TProcessPriority aPriority) const;
	  TBool System() const;
	  void SetSystem(TBool aState) const;
	  TBool Protected() const;
	  void SetProtected(TBool aState) const;
	  TBool LoadedFromRam() const;
	  TInt Owner(RProcess &anOwner) const;
	  void SetOwner(const RProcess& aProcess) const;
	  void Logon(TRequestStatus& aStatus) const;
	  TInt LogonCancel(TRequestStatus& aStatus) const;
	  TInt GetRamSizes(TInt& aCodeSize, TInt& aConstDataSize, TInt& anInitialisedDataSize, TInt& anUninitialisedDataSize);
	  TInt GetMemoryInfo(TProcessMemoryInfo& aInfo) const;
	inline TInt Open(const TFindProcess& aFind,TOwnerType aType=EOwnerProcess);
	  void Rendezvous(TRequestStatus& aStatus) const;
	  TInt RendezvousCancel(TRequestStatus& aStatus) const;
	  static void Rendezvous(TInt aReason);

	 





	  TSecureId SecureId() const;

	 






	inline TVendorId VendorId() const
		{ return 0; }

	 








	inline TBool HasCapability(TCapability  ,const char*  =0) const
		{ return ETrue; }

	 









	inline TBool HasCapability(TCapability  ,TCapability  ,const char*  =0) const
		{ return ETrue; }
protected:
	inline RProcess(TInt aHandle);
	};



class RMessage;
class RMessagePtr
 



	{
	friend TBool operator==(RMessagePtr aLeft,RMessagePtr aRight);
public:
	inline RMessagePtr();
	inline RMessagePtr(const RMessage& aMessage);
	inline TBool IsNull() const;
	  void Complete(TInt aReason) const;
private:
	TInt iHandle;
	};
inline TBool operator==(RMessagePtr aLeft,RMessagePtr aRight);
inline TBool operator!=(RMessagePtr aLeft,RMessagePtr aRight);



class RMessagePtr2;

class RMessage
 



	{

	friend class CServer;
	friend class RMessagePtr;
public:
	enum TSessionMessages {EConnect=-1,EDisConnect=-2};
public:
	  RMessage();
	  void Complete(TInt aReason) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes,TInt anOffset) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes,TInt anOffset) const;
	  void Panic(const TDesC& aCategory,TInt aReason) const;
	  void Kill(TInt aReason) const;
	  void Terminate(TInt aReason) const;
	inline TInt Function() const;
	inline const RThread& Client() const;
	inline TInt Int0() const;
	inline TInt Int1() const;
	inline TInt Int2() const;
	inline TInt Int3() const;
	inline const TAny* Ptr0() const;
	inline const TAny* Ptr1() const;
	inline const TAny* Ptr2() const;
	inline const TAny* Ptr3() const;
	inline const RMessagePtr MessagePtr() const;




public:
	  explicit RMessage(const RMessagePtr2& aPtr);
protected:
	TInt iFunction;
	TInt iArgs[KMaxMessageArguments];
	RThread iClient;
	const TAny* iSessionPtr;
	TInt iHandle;
	};



class RServer : public RHandleBase
 



	{
public:
	  TInt CreateGlobal(const TDesC& aName);
	  void Receive(TRequestStatus& aStatus);
	  void Receive();
	  void Cancel();
	inline const RMessage& Message() const;
private:
	RMessage iMessage;
	};



class TIpcArgs
 



	{
public:
	 




	enum TArgType
		{
		 

		EUnspecified = 0,
		 

		EFlagDes = 4,
		 

		EFlagConst = 2,
		 

		EFlag16Bit = 1,
		 

		EDes8 = EFlagDes,
		 

		EDes16 = EFlagDes|EFlag16Bit,
		 

		EDesC8 = EFlagDes|EFlagConst,
		 

		EDesC16 = EFlagDes|EFlagConst|EFlag16Bit,
		};
	 



	enum
		{
		 

		KBitsPerType=3
		};
	 


	enum TNothing
		{
		 

		ENothing
		};
public:
	inline TIpcArgs()
		:iFlags(0)
	 




		{}
	template <class T0>
	inline explicit TIpcArgs(T0 a0)
	 


		{
		Assign(iArgs[0],a0);
		iFlags=(Type(a0)<<(0*KBitsPerType));
		}
	template <class T0,class T1>
	inline TIpcArgs(T0 a0,T1 a1)
	 


		{
		Assign(iArgs[0],a0);
		Assign(iArgs[1],a1);
		iFlags=(Type(a0)<<(0*KBitsPerType))|(Type(a1)<<(1*KBitsPerType));
		}
	template <class T0,class T1,class T2>
	inline TIpcArgs(T0 a0,T1 a1,T2 a2)
	 


		{
		Assign(iArgs[0],a0);
		Assign(iArgs[1],a1);
		Assign(iArgs[2],a2);
		iFlags=(Type(a0)<<(0*KBitsPerType))|(Type(a1)<<(1*KBitsPerType))|(Type(a2)<<(2*KBitsPerType));
		}
	template <class T0,class T1,class T2,class T3>
	inline TIpcArgs(T0 a0,T1 a1,T2 a2,T3 a3)
	 


		{
		Assign(iArgs[0],a0);
		Assign(iArgs[1],a1);
		Assign(iArgs[2],a2);
		Assign(iArgs[3],a3);
		iFlags=(Type(a0)<<(0*KBitsPerType))|(Type(a1)<<(1*KBitsPerType))|(Type(a2)<<(2*KBitsPerType))|(Type(a3)<<(3*KBitsPerType));
		}
	 
	inline void Set(TInt aIndex,TNothing);
	inline void Set(TInt aIndex,TInt aValue);
	inline void Set(TInt aIndex,const TAny* aValue);
	inline void Set(TInt aIndex,const TDesC8* aValue);
	inline void Set(TInt aIndex,const TDesC16* aValue);
	inline void Set(TInt aIndex,TDes8* aValue);
	inline void Set(TInt aIndex,TDes16* aValue);
private:
	inline static TArgType Type(TNothing);
	inline static TArgType Type(TInt);
	inline static TArgType Type(const TAny*);
	inline static TArgType Type(const TDesC8*);
	inline static TArgType Type(const TDesC16*);
	inline static TArgType Type(TDes8*);
	inline static TArgType Type(TDes16*);
	 
	inline static void Assign(TInt&,TNothing);
	inline static void Assign(TInt& aArg,TInt aValue);
	inline static void Assign(TInt& aArg,const TAny* aValue);
	inline static void Assign(TInt& aArg,const TDesC8* aValue);
	inline static void Assign(TInt& aArg,const TDesC16* aValue);
	inline static void Assign(TInt& aArg,TDes8* aValue);
	inline static void Assign(TInt& aArg,TDes16* aValue);
public:
	 



	TInt iArgs[KMaxMessageArguments];
	 



	TInt iFlags;
	};

class RMessagePtr2
 



	{
public:
	inline RMessagePtr2();
	inline TBool IsNull() const;
	inline TInt Handle() const;
	inline TBool ClientDataCaging() const;
	  void Complete(TInt aReason) const;
	  TInt GetDesLength(TInt aParam) const;
	  TInt GetDesLengthL(TInt aParam) const;
	  TInt GetDesMaxLength(TInt aParam) const;
	  TInt GetDesMaxLengthL(TInt aParam) const;
	  void ReadL(TInt aParam,TDes8& aDes,TInt aOffset=0) const;
	  void ReadL(TInt aParam,TDes16 &aDes,TInt aOffset=0) const;
	  void WriteL(TInt aParam,const TDesC8& aDes,TInt aOffset=0) const;
	  void WriteL(TInt aParam,const TDesC16& aDes,TInt aOffset=0) const;
	  TInt Read(TInt aParam,TDes8& aDes,TInt aOffset=0) const;
	  TInt Read(TInt aParam,TDes16 &aDes,TInt aOffset=0) const;
	  TInt Write(TInt aParam,const TDesC8& aDes,TInt aOffset=0) const;
	  TInt Write(TInt aParam,const TDesC16& aDes,TInt aOffset=0) const;
	  void Panic(const TDesC& aCategory,TInt aReason) const;
	  void Kill(TInt aReason) const;
	  void Terminate(TInt aReason) const;
	  TInt SetProcessPriority(TProcessPriority aPriority) const;
	inline   void SetProcessPriorityL(TProcessPriority aPriority) const;
	  TInt Client(RThread& aClient, TOwnerType aOwnerType=EOwnerProcess) const;
	inline   void ClientL(RThread& aClient, TOwnerType aOwnerType=EOwnerProcess) const;
	  TUint ClientProcessFlags() const;

	 





	  TSecureId SecureId() const;

	 






	inline TVendorId VendorId() const
		{ return 0; }

	 








	inline TBool HasCapability(TCapability  ,const char*  =0) const
		{ return ETrue; }

 	 







 	inline void HasCapabilityL(TCapability aCapability,const char* aDiagnosticMessage=0) const;

	 









	inline TBool HasCapability(TCapability  ,TCapability  ,const char*  =0) const
		{ return ETrue; }

	 








	inline void HasCapabilityL(TCapability aCapability1,TCapability aCapability2,const char* aDiagnosticMessage=0) const;

protected:
	TInt iHandle;
	};
inline TBool operator==(RMessagePtr2 aLeft,RMessagePtr2 aRight);
inline TBool operator!=(RMessagePtr2 aLeft,RMessagePtr2 aRight);

class CSession2;



class RMessage2 : public RMessagePtr2
 



	{
	friend class CServer2;
public:
	 

	enum TSessionMessages
		{
		 

		EConnect=-1,
		 

		EDisConnect=-2
		};
public:
	inline RMessage2();
	  explicit RMessage2(const RMessagePtr2& aPtr);
	inline TInt Function() const;
	inline TInt Int0() const;
	inline TInt Int1() const;
	inline TInt Int2() const;
	inline TInt Int3() const;
	inline const TAny* Ptr0() const;
	inline const TAny* Ptr1() const;
	inline const TAny* Ptr2() const;
	inline const TAny* Ptr3() const;
	inline CSession2* Session() const;
protected:
	TInt iFunction;
	TInt iArgs[KMaxMessageArguments];
private:
	TInt iSpare1;		 
protected:
	const TAny* iSessionPtr;
private:
	TInt iSpare2;		 
	TInt iSpare3;		 
	friend class RMessage;
	};

class RServer2 : public RHandleBase
 



	{
public:
	  TInt CreateGlobal(const TDesC& aName);
	  void Receive(RMessage2& aMessage,TRequestStatus& aStatus);
	  void Receive(RMessage2& aMessage);
	  void Cancel();
	};

class RSessionBase : public RHandleBase
 



	{
	friend class RSubSessionBase;
public:
	 

	enum TAttachMode
		{
		 

		EExplicitAttach,
		 

		EAutoAttach
		};
public:

	inline TInt Share(TAttachMode aAttachMode=EExplicitAttach);
	  TInt Attach() const;

	inline TInt ShareAuto();
protected:
	inline TInt CreateSession(const TDesC& aServer,const TVersion& aVersion);
	  TInt CreateSession(const TDesC& aServer,const TVersion& aVersion,TInt aAsyncMessageSlots);

	inline TInt Send(TInt aFunction,TAny* aPtr) const;
	inline void SendReceive(TInt aFunction,TAny* aPtr,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,TAny* aPtr) const;

	inline TInt Send(TInt aFunction,const TIpcArgs& aArgs) const;
	inline void SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,const TIpcArgs& aArgs) const;
	inline TInt Send(TInt aFunction) const;
	inline void SendReceive(TInt aFunction,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction) const;
private:
	  TInt DoShare(TInt aAttachMode);
	  TInt DoSend(TInt aFunction,TAny* aPtr) const;
	  void DoSendReceive(TInt aFunction,TAny* aPtr,TRequestStatus& aStatus) const;
	  TInt DoSendReceive(TInt aFunction,TAny* aPtr) const;
	TInt SendAsync(TInt aFunction,TAny* aPtr,TRequestStatus* aStatus) const;
	TInt SendSync(TInt aFunction,TAny *aPtr) const;
	};

class RSubSessionBase
 



	{
public:
	inline TInt SubSessionHandle() const;
protected:
	inline RSubSessionBase();
	inline RSessionBase& Session();

	inline TInt CreateSubSession(RSessionBase& aSession,TInt aFunction,const TAny* aPtr);

	inline TInt CreateSubSession(RSessionBase& aSession,TInt aFunction,const TIpcArgs& aArgs);
	inline TInt CreateSubSession(RSessionBase& aSession,TInt aFunction);
	  void CloseSubSession(TInt aFunction);

	inline TInt Send(TInt aFunction,const TAny* aPtr) const;
	inline void SendReceive(TInt aFunction,const TAny* aPtr,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,const TAny* aPtr) const;

	inline TInt Send(TInt aFunction,const TIpcArgs& aArgs) const;
	inline void SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction,const TIpcArgs& aArgs) const;
	inline TInt Send(TInt aFunction) const;
	inline void SendReceive(TInt aFunction,TRequestStatus& aStatus) const;
	inline TInt SendReceive(TInt aFunction) const;
private:
	  TInt DoCreateSubSession(RSessionBase& aSession,TInt aFunction,const TAny* aPtr);
	  TInt DoSend(TInt aFunction,const TAny* aPtr) const;
	  void DoSendReceive(TInt aFunction,const TAny* aPtr,TRequestStatus& aStatus) const;
	  TInt DoSendReceive(TInt aFunction,const TAny* aPtr) const;
private:
	RSessionBase iSession;
	TInt iSubSessionHandle;
	};

class RRefBase
	{
public:
	  void Free();
protected:
	inline RRefBase();
	inline RRefBase(const RRefBase& aRef);
	  void DoAlloc(const TAny* aPtr,TInt aSize);
	  void DoAllocL(const TAny* aPtr,TInt aSize);
	  void Copy(const RRefBase& aRef);
private:
	  void operator=(const RRefBase& aRef);
protected:
	TInt* iPtr;
	};

template <class T>
class RRef : public RRefBase
	{
public:
	inline RRef();
	inline RRef(const RRef<T>& anObject);
	inline void operator=(const RRef<T>& anObject);
	inline T* operator->();
	inline operator T*();
	inline void Alloc(const T& anObject);
	inline void Alloc(const T& anObject,TInt aSize);
	inline void AllocL(const T& anObject);
	inline void AllocL(const T& anObject,TInt aSize);
	};

class RChangeNotifier : public RHandleBase
	{
public:
	  TInt Create();
	  TInt Logon(TRequestStatus& aStatus) const;
	  TInt LogonCancel() const;
	};

enum TChanges
	{
	EChangesLocale=0x01,
	EChangesMidnightCrossover=0x02,
	EChangesThreadDeath=0x04,
	EChangesPowerStatus=0x08,
	EChangesSystemTime=0x10,
	EChangesFreeMemory=0x20,
	EChangesOutOfMemory=0x40,
	};

class RUndertaker : public RHandleBase
	{
public:
	  TInt Create();
	  TInt Logon(TRequestStatus& aStatus,TInt& aThreadHandle) const;
	  TInt LogonCancel() const;
	};

class TNotifyInfo
	{
public:
	const TDesC* iLine1;
	const TDesC* iLine2;
	const TDesC* iButton1;
	const TDesC* iButton2;
	TPtr* iButtonVal;
	};

 


class RNotifier : public RSessionBase
	{
public :
	  RNotifier();
	  TInt Connect();
	  TInt StartNotifier(TUid aNotifierUid,const TDesC8& aBuffer);
	  TInt StartNotifier(TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  TInt StartNotifier(TUid aNotifierDllUid,TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  TInt CancelNotifier(TUid aNotifierUid);
	  TInt UpdateNotifier(TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  void StartNotifierAndGetResponse(TRequestStatus& aRs,TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  void StartNotifierAndGetResponse(TRequestStatus& aRs,TUid aNotifierDllUid,TUid aNotifierUid,const TDesC8& aBuffer,TDes8& aResponse);
	  TInt UnloadNotifiers(TUid aNotifierUid);
	  TInt LoadNotifiers(TUid aNotifierUid);
	  void Notify(const TDesC& aLine1,const TDesC& aLine2,const TDesC& aBut1,const TDesC& aBut2,TInt& aButtonVal,TRequestStatus& aStatus);
	  TInt InfoPrint(const TDesC& aDes);
private:
	TPtr8 iButtonVal;
	TInt iSpare[7];  
	};

const TInt KMediaPasswordNotifyUid(0x10004c00);
const TInt KMaxMediaPassword(16);
typedef TBuf8<KMaxMediaPassword> TMediaPassword;	 

enum TMediaPswdNotifyExitMode {EMPEMUnlock, EMPEMCancel, EMPEMUnlockAndStore};

struct TMediaPswdNotifyBase
	{
	enum TCardType {ECTMmcPassword} iCT;
	TVersion iVersion;
	};

struct TMediaPswdSendNotifyInfoV1 : public TMediaPswdNotifyBase
	{
	 
	};

struct TMediaPswdSendNotifyInfoV1Debug : public TMediaPswdSendNotifyInfoV1
	{
	TInt iSleepPeriod;							 
	TMediaPswdNotifyExitMode iEM;
	TText8 iPW[KMaxMediaPassword];
	};

struct TMediaPswdReplyNotifyInfoV1 : public TMediaPswdNotifyBase
	{
	TText8 iPW[KMaxMediaPassword];
	TMediaPswdNotifyExitMode iEM;
	};

class TTrapHandler
	{
public:
	  TTrapHandler();
	  virtual void Trap()=0;
	  virtual void UnTrap()=0;
	  virtual void Leave(TInt aValue)=0;
	};

const TInt KNoCallEntryPoint = 0x01;

class TDllRefTable
	{
public:
	TUint16 iFlags;
	TUint16 iNumberOfEntries;
	};

class TDllRefTableEntry
	{
public:
	TUint iEntryPoint;
	TDllRefTable* iDllRefTable;
	};

struct TCollationMethod;  

class Mem
	{
public:
	  static TUint8* Copy(TAny* aTrg,const TAny* aSrc,TInt aLength);
	  static TUint8* Move(TAny* aTrg,const TAny* aSrc,TInt aLength);
	  static TInt Compare(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);
	  static TInt Compare(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);
	  static TInt CompareF(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);
	  static TInt CompareF(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);
	  static TInt CompareC(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);
	  static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);
	  static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL,
								  TInt aMaxLevel,const TCollationMethod* aCollationMethod);
	  static TInt CollationMethods();
	  static TUint CollationMethodId(TInt aIndex);
	  static const TCollationMethod* CollationMethodByIndex(TInt aIndex);
	  static const TCollationMethod* CollationMethodById(TUint aId);
	  static void Fill(TAny* aTrg,TInt aLength,TChar aChar);
	  static void FillZ(TAny* aTrg,TInt aLength);
	  static void Swap(TAny* aPtr1,TAny* aPtr2,TInt aLength);
	  static void Crc(TUint16& aCrc,const TAny* aPtr,TInt aLength);
	};

class Password
	{
public:
	  static TBool IsEnabled();
	  static TInt SetEnabled(const TPassword& aPassword,TBool aIsEnabled);
	  static TBool IsValid(const TPassword& aPassword);
	  static TInt Set(const TPassword& anOldPassword,const TPassword& aNewPassword);
	};

class User : public UserHeap
	{
public:
	 
	  static void Exit(TInt aReason);
	  static void Panic(const TDesC& aCategory,TInt aReason);
	  static TInt StartThread(TThreadFunction anEntryPt,TAny* aPtr);
	  static void HandleException(TExceptionHandler* aHandler, TExcType anException);
	 
	  static void Leave(TInt aReason);
	  static void LeaveNoMemory();
	  static TInt LeaveIfError(TInt aReason);
	  static TAny* LeaveIfNull(TAny* aPtr);
	  static TTrapHandler* SetTrapHandler(TTrapHandler* aHandler);
	  static TTrapHandler* TrapHandler();
	 
	  static TInt InfoPrint(const TDesC& aDes);
	 
	  static void RequestComplete(TRequestStatus*& aStatus,TInt aReason);
	  static void WaitForAnyRequest();
	  static void WaitForRequest(TRequestStatus& aStatus);
	  static void WaitForRequest(TRequestStatus& aStatus1,TRequestStatus& aStatus2);
	 
	  static TAny* Adjust(TAny* aCell,TInt anOffset,TInt aDelta);
	  static TAny* AdjustL(TAny* aCell,TInt anOffset,TInt aDelta);
	  static TInt AllocLen(const TAny* aCell);
	  static TAny* Alloc(TInt aSize);
	  static TAny* AllocL(TInt aSize);
	  static TAny* AllocLC(TInt aSize);
	  static TInt AllocSize(TInt& aTotalAllocSize);
	  static TInt Available(TInt& aBiggestBlock);
	  static TInt CountAllocCells();
	  static TInt CountAllocCells(TInt& aFreeCount);
	  static void Free(TAny* aCell);
	  static void FreeZ(TAny*& aCell);
	  static RHeap& Heap();
	  static TAny* ReAlloc(TAny* aCell,TInt aSize);
	  static TAny* ReAllocL(TAny* aCell,TInt aSize);
	  static RHeap* SwitchHeap(RHeap* aHeap);
	  static TInt CompressAllHeaps();
	 
	  static void After(TTimeIntervalMicroSeconds32 anInterval);
	  static TInt At(const TTime& aTime);
	 
	  static TInt SetHomeTime(const TTime& aTime);
	 
	  static void SetCurrencySymbol(const TDesC& aSymbol);
	 
	  static TUint TickCount();
	  static TTimerLockSpec LockPeriod();
	  static TInt LockedInc(TInt& aValue);
	  static TInt LockedDec(TInt& aValue);
	  static TTimeIntervalSeconds InactivityTime();
	  static void ResetInactivityTime();
	  static TUint32 FastCounter();
	 
	  static TInt Beep(TInt aFrequency,TTimeIntervalMicroSeconds32 aDuration);
	 
	  static TInt IsRomAddress(TBool& aBool,TAny* aPtr);
	 
	  static TInt BinarySearch(TInt aCount,const TKey& aKey,TInt& aPos);
	  static TInt QuickSort(TInt aCount,const TKey& aKey,const TSwap& aSwap);
	 
	  static TLanguage Language();
	 
	  static TUint Collate(TUint aChar);
	  static TUint Fold(TUint aChar);
	  static TUint LowerCase(TUint aChar);
	  static TUint UpperCase(TUint aChar);
	  static TUint Fold(TUint aChar,TInt aFlags);
	  static TUint TitleCase(TUint aChar);
	 
	  static TInt StringLength(const TUint8* aString);
	  static TInt StringLength(const TUint16* aString);
	 
	  static TInt FreeLogicalDevice(const TDesC& aDeviceName);
	  static TInt FreePhysicalDevice(const TDesC& aDriverName);
	  static TInt LoadLogicalDevice(const TDesC& aFileName);
	  static TInt LoadPhysicalDevice(const TDesC& aFileName);
	 
	  static TBool QueryVersionSupported(const TVersion& aCurrent,const TVersion& aRequested);
	  static TVersion Version();
	 
	  static TInt SetMachineConfiguration(const TDesC8& aConfig);
	  static TInt MachineConfiguration(TDes8& aConfig,TInt& aSize);
	 
	  static void SetDebugMask(TUint32 aVal);
	  static void SetJustInTime(const TBool aBoolean);
	  static void Check();
	  static void Invariant();
	  static TBool JustInTime();
	  static void __DbgMarkStart(RHeap::TDbgHeapType aHeapType);
	  static void __DbgMarkCheck(RHeap::TDbgHeapType aHeapType,TBool aCountAll,TInt aCount,const TDesC8& aFileName,TInt aLineNum);
	  static TUint32 __DbgMarkEnd(RHeap::TDbgHeapType aHeapType,TInt aCount);
	  static void __DbgSetAllocFail(RHeap::TDbgHeapType aHeapType,RHeap::TAllocFail aType,TInt aRate);
	 
	  static TInt ValidateName(const TDesC& aName);
	 
	  static void IMB_Range(TAny* aStart, TAny* aEnd);

	 





	  static TSecureId CreatorSecureId();

	 






	inline static TVendorId CreatorVendorId()
		{ return 0; }

	 








	inline static TBool CreatorHasCapability(TCapability  ,const char*  =0)
		{ return ETrue; }

	 









	inline static TBool CreatorHasCapability(TCapability  ,TCapability  ,const char*  =0)
		{ return ETrue; }
	};

class ExecHandler;
class TTrap
	{
public:
	inline TTrap();
	  TInt Trap(TInt& aResult);
	  static void UnTrap();
protected:
	enum {EMaxState=0x10};
protected:
	TInt iState[EMaxState];
	TTrap* iNext;
	TInt* iResult;
	TTrapHandler* iHandler;
	friend void User::Leave(TInt aNumber);
	friend class ExecHandler;
	};




class Dll
	{
public:
	static TInt GlobalAlloc(TInt aSize);
	static TBool GlobalAllocated();
	static TInt GlobalRead(TInt aPos, TInt aLength, TDes8& aDes);
	static TInt GlobalWrite(TInt aPos,const TDesC8& aDes);
	static TInt SetTls(TAny* aPtr);
	static TAny* Tls();
	static void FreeTls();
	static TInt InitialiseData();
	static void FreeData();
	static void FileName(TFileName &aFileName);
	};

class CBase;

template <class T>
class TArray
	{
public:
	inline TArray(TInt (*aCount)(const CBase* aPtr),const TAny*(*anAt)(const CBase* aPtr,TInt anIndex),const CBase* aPtr);
	inline TInt Count() const;
	inline const T& operator[](TInt anIndex) const;
private:
	const CBase* iPtr;
	TInt (*iCount)(const CBase* aPtr);
	const TAny*(*iAt)(const CBase* aPtr,TInt anIndex);
	};


template <class T,TInt S> 
class TFixedArray
 
 
	{
	typedef TFixedArray<T,S> ThisClass;
public:
	inline TFixedArray();
	inline TFixedArray(const T* aList, TInt aLength);
	 
	inline void Copy(const T* aList, TInt aLength);
	inline void Reset();		 
	inline void DeleteAll();
	 
	inline TInt Count() const;
	inline TInt Length() const;
	 
	inline T& operator[](TInt aIndex);
	inline const T& operator[] (TInt aIndex) const;
	 
	inline T& At(TInt aIndex);
	inline const T& At(TInt aIndex) const;
	 
	inline T* Begin();
	inline T* End();
	inline const T* Begin() const;
	inline const T* End() const;
	 
	inline TArray<T> Array() const;
protected:
	inline static TBool InRange(TInt aIndex);
	inline static TInt CountFunctionR(const CBase* aThis);
	inline static const TAny* AtFunctionR(const CBase* aThis,TInt aIndex);
protected:
	T iRep[S];
	};







typedef TBool (*TGeneralIdentityRelation)(const TAny*, const TAny*);
typedef TInt (*TGeneralLinearOrder)(const TAny*, const TAny*);

template <class T>
class TIdentityRelation
	{
public:
	inline TIdentityRelation( TBool(*anIdentity)(const T&, const T&) );
	inline operator TGeneralIdentityRelation() const;
private:
	TGeneralIdentityRelation iIdentity;
	};

template <class T>
class TLinearOrder
	{
public:
	inline TLinearOrder( TInt(*anOrder)(const T&, const T&) );
	inline operator TGeneralLinearOrder() const;
private:
	TGeneralLinearOrder iOrder;
	};

enum TArrayFindMode
 	{
 	EArrayFindMode_Any = 0,
 	EArrayFindMode_First = 1,
 	EArrayFindMode_Last = 2,
  
 	EArrayFindMode_Limit = 3
 	};

class RPointerArrayBase
	{
protected:
	  RPointerArrayBase();
	  RPointerArrayBase(TInt aGranularity);
	  RPointerArrayBase(TAny** aEntries, TInt aCount);
	  void Close();
	  TInt Count() const;
	inline void ZeroCount() {iCount=0;}
	inline TAny** Entries() {return iEntries;}
	  TAny*& At(TInt anIndex) const;
	  TInt Append(const TAny* anEntry);
	  TInt Insert(const TAny* anEntry, TInt aPos);
	  void Remove(TInt anIndex);
	  void Compress();
	  void GranularCompress();
	  void Reset();
	  TInt Find(const TAny* anEntry) const;
	  TInt Find(const TAny* anEntry, TGeneralIdentityRelation anIdentity) const;
	  TInt FindIsqSigned(TInt anEntry) const;
	  TInt FindIsqUnsigned(TUint anEntry) const;
	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder) const;
 	  TInt FindIsqSigned(TInt anEntry, TInt aMode) const;
 	  TInt FindIsqUnsigned(TUint anEntry, TInt aMode) const;
 	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TInt aMode) const;
	  TInt InsertIsqSigned(TInt anEntry, TBool aAllowRepeats);
	  TInt InsertIsqUnsigned(TUint anEntry, TBool aAllowRepeats);
	  TInt InsertIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TBool aAllowRepeats);
	  void HeapSortSigned();
	  void HeapSortUnsigned();
	  void HeapSort(TGeneralLinearOrder anOrder);
	  TInt BinarySearchSigned(TInt anEntry, TInt& anIndex) const;
	  TInt BinarySearchUnsigned(TUint anEntry, TInt& anIndex) const;
	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder) const;
 	  TInt BinarySearchSigned(TInt anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearchUnsigned(TUint anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder, TInt aMode) const;
	  static TInt GetCount(const CBase* aPtr);
	  static const TAny* GetElementPtr(const CBase* aPtr, TInt aIndex);
private:
	TInt Grow();
private:
	TInt iCount;
	TAny** iEntries;
	TInt iAllocated;
	TInt iGranularity;
	};

template <class T>
class RPointerArray : private RPointerArrayBase
	{
public:
	inline RPointerArray();
	inline RPointerArray(TInt aGranularity);
	inline RPointerArray(T** aEntries, TInt aCount);
	inline void Close();
	inline TInt Count() const;
	inline T* const& operator[](TInt anIndex) const;
	inline T*& operator[](TInt anIndex);
	inline TInt Append(const T* anEntry);
	inline TInt Insert(const T* anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void GranularCompress();
	inline void Reset();
	void ResetAndDestroy();
	inline TInt Find(const T* anEntry) const;
	inline TInt Find(const T* anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInAddressOrder(const T* anEntry) const;
	inline TInt FindInOrder(const T* anEntry, TLinearOrder<T> anOrder) const;
	inline TInt FindInAddressOrder(const T* anEntry, TInt& anIndex) const;
	inline TInt FindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
 	inline TInt SpecificFindInAddressOrder(const T* anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
 	inline TInt SpecificFindInAddressOrder(const T* anEntry, TInt& anIndex, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline TInt InsertInAddressOrder(const T* anEntry);
	inline TInt InsertInOrder(const T* anEntry, TLinearOrder<T> anOrder);
	inline TInt InsertInAddressOrderAllowRepeats(const T* anEntry);
	inline TInt InsertInOrderAllowRepeats(const T* anEntry, TLinearOrder<T> anOrder);

	 
	inline void AppendL(const T* anEntry);
	inline void InsertL(const T* anEntry, TInt aPos);
	inline TInt FindL(const T* anEntry) const;
	inline TInt FindL(const T* anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInAddressOrderL(const T* anEntry) const;
	inline TInt FindInOrderL(const T* anEntry, TLinearOrder<T> anOrder) const;
	inline void FindInAddressOrderL(const T* anEntry, TInt& anIndex) const;
	inline void FindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
	inline TInt SpecificFindInAddressOrderL(const T* anEntry, TInt aMode) const;
	inline TInt SpecificFindInOrderL(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void SpecificFindInAddressOrderL(const T* anEntry, TInt& anIndex, TInt aMode) const;
	inline void SpecificFindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void InsertInAddressOrderL(const T* anEntry);
	inline void InsertInOrderL(const T* anEntry, TLinearOrder<T> anOrder);
	inline void InsertInAddressOrderAllowRepeatsL(const T* anEntry);
	inline void InsertInOrderAllowRepeatsL(const T* anEntry, TLinearOrder<T> anOrder);

	inline void SortIntoAddressOrder();
	inline void Sort(TLinearOrder<T> anOrder);
	inline TArray<T*> Array() const;
	};

class RArrayBase
	{
protected:
	  RArrayBase(TInt anEntrySize);
	  RArrayBase(TInt aEntrySize,TAny* aEntries, TInt aCount);
	  RArrayBase(TInt anEntrySize, TInt aGranularity);
	  RArrayBase(TInt anEntrySize, TInt aGranularity, TInt aKeyOffset);
	  void Close();
	  TInt Count() const;
	  TAny* At(TInt anIndex) const;
	  TInt Append(const TAny* anEntry);
	  TInt Insert(const TAny* anEntry, TInt aPos);
	  void Remove(TInt anIndex);
	  void Compress();
	  void GranularCompress();
	  void Reset();
	  TInt Find(const TAny* anEntry) const;
	  TInt Find(const TAny* anEntry, TGeneralIdentityRelation anIdentity) const;
	  TInt FindIsqSigned(const TAny* anEntry) const;
	  TInt FindIsqUnsigned(const TAny* anEntry) const;
	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder) const;
 	  TInt FindIsqSigned(const TAny* anEntry, TInt aMode) const;
 	  TInt FindIsqUnsigned(const TAny* anEntry, TInt aMode) const;
 	  TInt FindIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TInt aMode) const;
	  TInt InsertIsqSigned(const TAny* anEntry, TBool aAllowRepeats);
	  TInt InsertIsqUnsigned(const TAny* anEntry, TBool aAllowRepeats);
	  TInt InsertIsq(const TAny* anEntry, TGeneralLinearOrder anOrder, TBool aAllowRepeats);
	  void HeapSortSigned();
	  void HeapSortUnsigned();
	  void HeapSort(TGeneralLinearOrder anOrder);
	  TInt BinarySearchSigned(const TAny* anEntry, TInt& anIndex) const;
	  TInt BinarySearchUnsigned(const TAny* anEntry, TInt& anIndex) const;
	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder) const;
 	  TInt BinarySearchSigned(const TAny* anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearchUnsigned(const TAny* anEntry, TInt& anIndex, TInt aMode) const;
 	  TInt BinarySearch(const TAny* anEntry, TInt& anIndex, TGeneralLinearOrder anOrder, TInt aMode) const;
	  static TInt GetCount(const CBase* aPtr);
	  static const TAny* GetElementPtr(const CBase* aPtr, TInt aIndex);
private:
	TInt Grow();
private:
	TInt iCount;
	TAny* iEntries;
	TInt iEntrySize;
	TInt iKeyOffset;
	TInt iAllocated;
	TInt iGranularity;
	};

template <class T>
class RArray : private RArrayBase
	{
public:
	inline RArray();
	inline RArray(TInt aGranularity);
	inline RArray(TInt aGranularity, TInt aKeyOffset);
	inline RArray(TInt aEntrySize,T* aEntries, TInt aCount);
	inline void Close();
	inline TInt Count() const;
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline TInt Append(const T& anEntry);
	inline TInt Insert(const T& anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void GranularCompress();
	inline void Reset();
	inline TInt Find(const T& anEntry) const;
	inline TInt Find(const T& anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInSignedKeyOrder(const T& anEntry) const;
	inline TInt FindInUnsignedKeyOrder(const T& anEntry) const;
	inline TInt FindInOrder(const T& anEntry, TLinearOrder<T> anOrder) const;
	inline TInt FindInSignedKeyOrder(const T& anEntry, TInt& anIndex) const;
	inline TInt FindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex) const;
	inline TInt FindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
 	inline TInt SpecificFindInSignedKeyOrder(const T& anEntry, TInt aMode) const;
 	inline TInt SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
 	inline TInt SpecificFindInSignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const;
 	inline TInt SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const;
 	inline TInt SpecificFindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline TInt InsertInSignedKeyOrder(const T& anEntry);
	inline TInt InsertInUnsignedKeyOrder(const T& anEntry);
	inline TInt InsertInOrder(const T& anEntry, TLinearOrder<T> anOrder);
	inline TInt InsertInSignedKeyOrderAllowRepeats(const T& anEntry);
	inline TInt InsertInUnsignedKeyOrderAllowRepeats(const T& anEntry);
	inline TInt InsertInOrderAllowRepeats(const T& anEntry, TLinearOrder<T> anOrder);

	 
	inline void AppendL(const T& anEntry);
	inline void InsertL(const T& anEntry, TInt aPos);
	inline TInt FindL(const T& anEntry) const;
	inline TInt FindL(const T& anEntry, TIdentityRelation<T> anIdentity) const;
	inline TInt FindInSignedKeyOrderL(const T& anEntry) const;
	inline TInt FindInUnsignedKeyOrderL(const T& anEntry) const;
	inline TInt FindInOrderL(const T& anEntry, TLinearOrder<T> anOrder) const;
	inline void FindInSignedKeyOrderL(const T& anEntry, TInt& anIndex) const;
	inline void FindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex) const;
	inline void FindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const;
	inline TInt SpecificFindInSignedKeyOrderL(const T& anEntry, TInt aMode) const;
	inline TInt SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt aMode) const;
	inline TInt SpecificFindInOrderL(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void SpecificFindInSignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const;
	inline void SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const;
	inline void SpecificFindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const;
	inline void InsertInSignedKeyOrderL(const T& anEntry);
	inline void InsertInUnsignedKeyOrderL(const T& anEntry);
	inline void InsertInOrderL(const T& anEntry, TLinearOrder<T> anOrder);
	inline void InsertInSignedKeyOrderAllowRepeatsL(const T& anEntry);
	inline void InsertInUnsignedKeyOrderAllowRepeatsL(const T& anEntry);
	inline void InsertInOrderAllowRepeatsL(const T& anEntry, TLinearOrder<T> anOrder);
	
	inline void SortSigned();
	inline void SortUnsigned();
	inline void Sort(TLinearOrder<T> anOrder);
	inline TArray<T> Array() const;
	};

  class RArray<TInt> : private RPointerArrayBase
	{
public:
	inline RArray();
	inline RArray(TInt aGranularity);
	inline void Close();
	inline TInt Count() const;
	inline const TInt& operator[](TInt anIndex) const;
	inline TInt& operator[](TInt anIndex);
	inline TInt Append(TInt anEntry);
	inline TInt Insert(TInt anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void GranularCompress();
	inline void Reset();
	inline TInt Find(TInt anEntry) const;
	inline TInt FindInOrder(TInt anEntry) const;
	inline TInt FindInOrder(TInt anEntry, TInt& anIndex) const;
 	inline TInt SpecificFindInOrder(TInt anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(TInt anEntry, TInt& anIndex, TInt aMode) const;
	inline TInt InsertInOrder(TInt anEntry);
	inline TInt InsertInOrderAllowRepeats(TInt anEntry);

	 
	inline void AppendL(TInt anEntry);
	inline void InsertL(TInt anEntry, TInt aPos);
	inline TInt FindL(TInt anEntry) const;
	inline TInt FindInOrderL(TInt anEntry) const;
	inline void FindInOrderL(TInt anEntry, TInt& anIndex) const;
	inline TInt SpecificFindInOrderL(TInt anEntry, TInt aMode) const;
	inline void SpecificFindInOrderL(TInt anEntry, TInt& anIndex, TInt aMode) const;
	inline void InsertInOrderL(TInt anEntry);
	inline void InsertInOrderAllowRepeatsL(TInt anEntry);

	inline void Sort();
	inline TArray<TInt> Array() const;
	};

  class RArray<TUint> : private RPointerArrayBase
	{
public:
	inline RArray();
	inline RArray(TInt aGranularity);
	inline void Close();
	inline TInt Count() const;
	inline const TUint& operator[](TInt anIndex) const;
	inline TUint& operator[](TInt anIndex);
	inline TInt Append(TUint anEntry);
	inline TInt Insert(TUint anEntry, TInt aPos);
	inline void Remove(TInt anIndex);
	inline void Compress();
	inline void Reset();
	inline TInt Find(TUint anEntry) const;
	inline TInt FindInOrder(TUint anEntry) const;
	inline TInt FindInOrder(TUint anEntry, TInt& anIndex) const;
 	inline TInt SpecificFindInOrder(TUint anEntry, TInt aMode) const;
 	inline TInt SpecificFindInOrder(TUint anEntry, TInt& anIndex, TInt aMode) const;
	inline TInt InsertInOrder(TUint anEntry);
	inline TInt InsertInOrderAllowRepeats(TUint anEntry);

	 
	inline void AppendL(TUint anEntry);
	inline void InsertL(TUint anEntry, TInt aPos);
	inline TInt FindL(TUint anEntry) const;
	inline TInt FindInOrderL(TUint anEntry) const;
	inline void FindInOrderL(TUint anEntry, TInt& anIndex) const;
	inline TInt SpecificFindInOrderL(TUint anEntry, TInt aMode) const;
	inline void SpecificFindInOrderL(TUint anEntry, TInt& anIndex, TInt aMode) const;
	inline void InsertInOrderL(TUint anEntry);
	inline void InsertInOrderAllowRepeatsL(TUint anEntry);

	inline void Sort();
	inline TArray<TUint> Array() const;
	};

inline TAny* operator new(TUint aSize, TAny* aBase);
inline TAny* operator new(TUint aSize, TLeave);

extern  TAny* operator new(TUint aSize);
extern  TAny* operator new(TUint aSize,TUint anExtraSize);
extern  void operator delete(TAny* aPtr);


inline TAny* operator new[](TUint aSize, TLeave);



TBool operator==(TTrue,volatile const TBool);
TBool operator==(volatile const TBool,TTrue);
TBool operator!=(TTrue,volatile const TBool);
TBool operator!=(volatile const TBool,TTrue);


 




const TInt KCapabilitySetMaxSize = (((TInt)ECapability_HardLimit + 7)>>3);

 




const TInt KMaxSecurityPolicySize = KCapabilitySetMaxSize + 3*sizeof(TUint32);


 
























































class TSecurityPolicy
	{
public:
	enum TSecPolicyType 
		{
		EAlwaysFail=0,
		EAlwaysPass=1,
		};
		
public:
	inline TSecurityPolicy();
	  TSecurityPolicy(TSecPolicyType aType);
	  TSecurityPolicy(TCapability aCap1, TCapability aCap2 = ECapability_None, TCapability aCap3 = ECapability_None);
	  TSecurityPolicy(TCapability aCap1, TCapability aCap2, TCapability aCap3, TCapability aCap4, TCapability aCap5 = ECapability_None, TCapability aCap6 = ECapability_None, TCapability aCap7 = ECapability_None);
	  TSecurityPolicy(TSecureId aSecureId, TCapability aCap1 = ECapability_None, TCapability aCap2 = ECapability_None, TCapability aCap3 = ECapability_None);
	  TSecurityPolicy(TVendorId aVendorId, TCapability aCap1 = ECapability_None, TCapability aCap2 = ECapability_None, TCapability aCap3 = ECapability_None);
	  TInt Set(const TDesC8& aDes);
	  TPtrC8 Package() const;
	inline TBool CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RThread aThread, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage=0) const;
	TBool Validate() const;
public:
	 



	enum TType
		{
		ETypeFail=0,	 
		ETypePass=1,	 
		ETypeC3=2,		 
		ETypeC7=3,		 
		ETypeS3=4,		 
		ETypeV3=5,		 

		ETypeLimit

		 
		};
private:
	void ConstructAndCheck3(TCapability aCap1, TCapability aCap2, TCapability aCap3);
private:
	TUint8 iType;
	TUint8 iCaps[3];				 
	union
		{
		TUint32 iSecureId;
		TUint32 iVendorId;
		TUint8 iExtraCaps[4];		 
		};
	friend class TCompiledSecurityPolicy;
	};

 




typedef TPckgBuf<TSecurityPolicy> TSecurityPolicyBuf;


 


struct SSecurityPolicyV1C7
	{
	inline const TSecurityPolicy* operator&() const;
	inline operator const TSecurityPolicy&() const;
	inline const TSecurityPolicy& operator()() const;
	inline TBool CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RThread aThread, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage=0) const;
	TUint8	iType;
	TUint8	iCaps[7];				 
	};



 


struct SSecurityPolicyV1SVC3
	{
	inline const TSecurityPolicy* operator&() const;
	inline operator const TSecurityPolicy&() const;
	inline const TSecurityPolicy& operator()() const;
	inline TBool CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RThread aThread, const char* aDiagnosticMessage=0) const;
	inline TBool CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage=0) const;
	TUint8	iType;
	TUint8	iCaps[3];				 
	TUint32	iId;
	};


	
 



enum __invalid_capability_value {};

 
















 









# 5028 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

 









# 5051 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"

 
























# 5089 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 



























 


























 

























 




















# 5206 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 























 





















 





















# 5286 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 
























 























 

















 





















# 5387 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h"



 
























 























 


















 



class PlatSec
	{
public:
	 









	inline static TBool IsCapabilityEnforced(TCapability aCapability);

	 





	enum TConfigSetting
		{
		EPlatSecEnforcement,  
		EPlatSecDiagnotics,   
		};

	 









	inline static TInt ConfigSetting(TConfigSetting aSetting);
	};

 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.inl" 1
 
 
 
 
 





 
inline TAny* operator new(TUint  , TAny* aBase)
	{return(aBase);}
inline TAny* operator new(TUint aSize, TLeave)
	{return User::AllocL(aSize);}


inline TAny* operator new[](TUint aSize, TLeave)
	{return User::AllocL(aSize);}


 
inline TInt64::TInt64()
	{}
inline TInt64::TInt64(TUint aVal)
	: iLow(aVal),iHigh(0)
	{}
inline TInt64::TInt64(TUint aHigh,TUint aLow)
	: iLow(aLow),iHigh(aHigh)
	{}
inline void TInt64::Set(TUint aHigh,TUint aLow)
	{iLow=aLow;iHigh=aHigh;}
inline TUint TInt64::Low() const
	{return(iLow);}
inline TUint TInt64::High() const
	{return(iHigh);}
inline TInt64 &TInt64::operator=(TUint aVal)
	{iLow=aVal;iHigh=0;return(*this);}

 
template <class T>
inline TRefByValue<T>::TRefByValue(T &aRef)
	: iRef(aRef)
	{}
template <class T>
inline TRefByValue<T>::operator T &()
	{return(iRef);}

 
inline TCallBack::TCallBack()
	{iFunction= 0L ;}
inline TCallBack::TCallBack(TInt (*aFunction)(TAny *aPtr))
	: iFunction(aFunction),iPtr(0L )
	{}
inline TCallBack::TCallBack(TInt (*aFunction)(TAny *aPtr),TAny *aPtr)
	: iFunction(aFunction),iPtr(aPtr)
	{}
inline TInt TCallBack::CallBack() const
	{ return (iFunction ? (*iFunction)(iPtr) : 0); }

 
template <class T>
inline TSglQue<T>::TSglQue()
	{}
template <class T>
inline TSglQue<T>::TSglQue(TInt anOffset)
	: TSglQueBase(anOffset)
	{}
template <class T>
inline void TSglQue<T>::AddFirst(T &aRef)
	{DoAddFirst(&aRef);}
template <class T>
inline void TSglQue<T>::AddLast(T &aRef)
	{DoAddLast(&aRef);}
template <class T>
inline TBool TSglQue<T>::IsFirst(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead);}
template <class T>
inline TBool TSglQue<T>::IsLast(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iLast);}
template <class T>
inline T *TSglQue<T>::First() const
	{return(PtrSub((T *)iHead,iOffset));}
template <class T>
inline T *TSglQue<T>::Last() const
	{return(PtrSub((T *)iLast,iOffset));}
template <class T>
inline void TSglQue<T>::Remove(T &aRef)
	{DoRemove(&aRef);}

 
template <class T>
inline TDblQue<T>::TDblQue()
	{}
template <class T>
inline TDblQue<T>::TDblQue(TInt anOffset)
	: TDblQueBase(anOffset)
	{}
template <class T>
inline void TDblQue<T>::AddFirst(T &aRef)
	{DoAddFirst(&aRef);}
template <class T>
inline void TDblQue<T>::AddLast(T &aRef)
	{DoAddLast(&aRef);}
template <class T>
inline TBool TDblQue<T>::IsHead(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)&iHead);}
template <class T>
inline TBool TDblQue<T>::IsFirst(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iNext);}
template <class T>
inline TBool TDblQue<T>::IsLast(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iPrev);}
template <class T>
inline T *TDblQue<T>::First() const
	{



    return(PtrSub((T *)iHead.iNext,iOffset));
    }
template <class T>
inline T *TDblQue<T>::Last() const
	{



	return(PtrSub((T *)iHead.iPrev,iOffset));
	}

 
template <class T>
inline TPriQue<T>::TPriQue()
	{}
template <class T>
inline TPriQue<T>::TPriQue(TInt anOffset)
	: TDblQueBase(anOffset)
	{}
template <class T>
inline void TPriQue<T>::Add(T &aRef)
	{DoAddPriority(&aRef);}
template <class T>
inline TBool TPriQue<T>::IsHead(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)&iHead);}
template <class T>
inline TBool TPriQue<T>::IsFirst(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iNext);}
template <class T>
inline TBool TPriQue<T>::IsLast(const T *aPtr) const
	{return(PtrAdd(aPtr,iOffset)==(T *)iHead.iPrev);}
template <class T>
inline T *TPriQue<T>::First() const
	{return(PtrSub((T *)iHead.iNext,iOffset));}
template <class T>
inline T *TPriQue<T>::Last() const
	{return(PtrSub((T *)iHead.iPrev,iOffset));}

 
template <class T>
inline TDeltaQue<T>::TDeltaQue()
	{}
template <class T>
inline TDeltaQue<T>::TDeltaQue(TInt anOffset)
	: TDeltaQueBase(anOffset)
	{}
template <class T>
inline void TDeltaQue<T>::Add(T &aRef,TInt aDelta)
	{DoAddDelta(&aRef,aDelta);}
template <class T>
inline void TDeltaQue<T>::Remove(T &aRef)
	{DoRemove(&aRef);}
template <class T>
inline T *TDeltaQue<T>::RemoveFirst()
	{return((T *) DoRemoveFirst());}

 
template <class T>
inline TSglQueIter<T>::TSglQueIter(TSglQueBase &aQue)
	: TSglQueIterBase(aQue)
	{}
template <class T>
inline void TSglQueIter<T>::Set(T &aLink)
	{DoSet(&aLink);}
template <class T>
inline TSglQueIter<T>::operator T *()
	{return((T *)DoCurrent());}
template <class T>
inline T *TSglQueIter<T>::operator++(TInt)
	{return((T *)DoPostInc());}

 
template <class T>
inline TDblQueIter<T>::TDblQueIter(TDblQueBase &aQue)
	: TDblQueIterBase(aQue)
	{}
template <class T>
inline void TDblQueIter<T>::Set(T &aLink)
	{DoSet(&aLink);}
template <class T>
inline TDblQueIter<T>::operator T *()
	{return((T *) DoCurrent());}
template <class T>
inline T *TDblQueIter<T>::operator++(TInt)
	{return((T *) DoPostInc());}
template <class T>
inline T *TDblQueIter<T>::operator--(TInt)
	{return((T *) DoPostDec());}

 
inline void TKey::SetPtr(const TAny *aPtr)
	{iPtr=aPtr;}

 
inline TInt THeapWalk::Value() const
	{return(iValue);}
inline void THeapWalk::SetValue(TInt aValue)
	{iValue=aValue;}

 
inline TChar::TChar()
	{}
inline TChar::TChar(TUint aChar)
	: iChar(aChar)
	{}
inline void TChar::SetChar(TUint aChar)
	{iChar=aChar;}
inline TChar& TChar::operator-=(TUint aChar)
	{iChar-=aChar;return(*this);}
inline TChar& TChar::operator+=(TUint aChar)
	{iChar+=aChar;return(*this);}
inline TChar TChar::operator-(TUint aChar)
	{return(iChar-aChar);}
inline TChar TChar::operator+(TUint aChar)
	{return(iChar+aChar);}
inline TChar::operator TUint() const
	{return(iChar);}
inline void TChar::Fold()
	{iChar=User::Fold(iChar);}
inline void TChar::LowerCase()
	{iChar=User::LowerCase(iChar);}
inline void TChar::UpperCase()
	{iChar=User::UpperCase(iChar);}

inline void TChar::Fold(TInt aFlags)
	{iChar=User::Fold(iChar,aFlags);}
inline void TChar::TitleCase()
	{iChar=User::TitleCase(iChar);}

inline TBool TChar::Eos() const
	{return(iChar==0);}

 
inline TCharF::TCharF(TUint aChar)
	: TChar(User::Fold(aChar))
	{}
inline TCharF::TCharF(const TChar& aChar)
	: TChar(User::Fold(aChar))
	{}
inline TCharF& TCharF::operator=(TUint aChar)
	{SetChar(User::Fold(aChar));return(*this);}
inline TCharF& TCharF::operator=(const TChar& aChar)
	{SetChar(User::Fold(aChar));return(*this);}

 
inline TCharLC::TCharLC(TUint aChar)
	: TChar(User::LowerCase(aChar))
	{}
inline TCharLC::TCharLC(const TChar& aChar)
	: TChar(User::LowerCase(aChar))
	{}
inline TCharLC& TCharLC::operator=(TUint aChar)
	{SetChar(User::LowerCase(aChar));return(*this);}
inline TCharLC& TCharLC::operator=(const TChar& aChar)
	{SetChar(User::LowerCase(aChar));return(*this);}

 
inline TCharUC::TCharUC(TUint aChar)
	: TChar(User::UpperCase(aChar))
	{}
inline TCharUC::TCharUC(const TChar& aChar)
	: TChar(User::UpperCase(aChar))
	{}
inline TCharUC& TCharUC::operator=(TUint aChar)
	{SetChar(User::UpperCase(aChar));return(*this);}
inline TCharUC& TCharUC::operator=(const TChar& aChar)
	{SetChar(User::UpperCase(aChar));return(*this);}

 
inline TInt TDesC8::operator<(const TDesC8 &aDes) const
	{return(Compare(aDes)<0);}
inline TInt TDesC8::operator<=(const TDesC8 &aDes) const
	{return(Compare(aDes)<=0);}
inline TInt TDesC8::operator>(const TDesC8 &aDes) const
	{return(Compare(aDes)>0);}
inline TInt TDesC8::operator>=(const TDesC8 &aDes) const
	{return(Compare(aDes)>=0);}
inline TInt TDesC8::operator==(const TDesC8 &aDes) const
	{return(Compare(aDes)==0);}
inline TInt TDesC8::operator!=(const TDesC8 &aDes) const
	{return(Compare(aDes)!=0);}
inline const TUint8 &TDesC8::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TInt TDesC8::Length() const
	{

	return(iLength&KMaskDesLength8);



	}
inline TInt TDesC8::Size() const
	{return(Length());}
inline void TDesC8::DoSetLength(TInt aLength)
	{

	iLength=(iLength&(~KMaskDesLength8))|aLength;



	}

 
inline void TPtrC8::Set(const TUint8 *aBuf,TInt aLength)
	{new(this) TPtrC8(aBuf,aLength);}
inline void TPtrC8::Set(const TDesC8 &aDes)
	{new(this) TPtrC8(aDes);}
inline void TPtrC8::Set(const TPtrC8& aPtr)
	{new(this) TPtrC8(aPtr);}

 
inline TPtr8 TBufCBase8::DoDes(TInt aMaxLength)
	{return TPtr8(*this,aMaxLength);}

 
template <TInt S>
inline TBufC8<S>::TBufC8()
	: TBufCBase8()
	{}
template <TInt S>
inline TBufC8<S>::TBufC8(const TUint8 *aString)
	: TBufCBase8(aString,S)
	{}
template <TInt S>
inline TBufC8<S>::TBufC8(const TDesC8 &aDes)
	: TBufCBase8(aDes,S)
	{}
template <TInt S>
inline TBufC8<S> &TBufC8<S>::operator=(const TUint8 *aString)
	{Copy(aString,S);return(*this);}
template <TInt S>
inline TBufC8<S> &TBufC8<S>::operator=(const TDesC8 &aDes)
	{Copy(aDes,S);return(*this);}
template <TInt S>
inline TPtr8 TBufC8<S>::Des()
	{return DoDes(S);}

 
inline HBufC8 &HBufC8::operator=(const HBufC8 &aLcb)
	{return *this=static_cast<const TDesC8&>(aLcb);}

 
inline TDes8 &TDes8::operator=(const TUint8 *aString)
    {Copy(aString);return(*this);}
inline TDes8 &TDes8::operator=(const TDesC8 &aDes)
    {Copy(aDes);return(*this);}
inline TDes8 &TDes8::operator=(const TDes8 &aDes)
    {Copy(aDes);return(*this);}
inline TDes8 &TDes8::operator+=(const TDesC8 &aDes)
	{Append(aDes);return(*this);}
inline const TUint8 &TDes8::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TUint8 &TDes8::operator[](TInt anIndex)
	{return((TUint8 &)AtC(anIndex));}
inline TInt TDes8::MaxLength() const
	{return(iMaxLength);}
inline TInt TDes8::MaxSize() const
	{return(iMaxLength);}
inline TUint8 * TDes8::WPtr() const
	{return((TUint8 *)Ptr());}

 
inline TPtr8 &TPtr8::operator=(const TUint8 *aString)
	{Copy(aString);return(*this);}
inline TPtr8 &TPtr8::operator=(const TDesC8 &aDes)
	{Copy(aDes);return(*this);}
inline TPtr8 &TPtr8::operator=(const TPtr8 &aDes)
	{Copy(aDes);return(*this);}
inline void TPtr8::Set(TUint8 *aBuf,TInt aLength,TInt aMaxLength)
	{new(this) TPtr8(aBuf,aLength,aMaxLength);}
inline void TPtr8::Set(const TPtr8 &aPtr)
	{new(this) TPtr8(aPtr);}

 
template <TInt S>
inline TBuf8<S>::TBuf8()
	: TBufBase8(S)
	{}
template <TInt S>
inline TBuf8<S>::TBuf8(TInt aLength)
	: TBufBase8(aLength,S)
	{}
template <TInt S>
inline TBuf8<S>::TBuf8(const TUint8 *aString)
	: TBufBase8(aString,S)
	{}
template <TInt S>
inline TBuf8<S>::TBuf8(const TDesC8 &aDes)
	: TBufBase8(aDes,S)
	{}
template <TInt S>
inline TBuf8<S> &TBuf8<S>::operator=(const TUint8 *aString)
	{Copy(aString);return(*this);}
template <TInt S>
inline TBuf8<S> &TBuf8<S>::operator=(const TDesC8 &aDes)
	{Copy(aDes);return(*this);}
template <TInt S>
inline TBuf8<S>& TBuf8<S>::operator=(const TBuf8<S>& aBuf)
	{Copy(aBuf);return *this;}

 
template <TInt S>
inline const TDesC8* TLitC8<S>::operator&() const
	{return (reinterpret_cast< const TDesC8* >( this )) ;}
template <TInt S>
inline const TDesC8& TLitC8<S>::operator()() const
	{return *operator&();}
template <TInt S>
inline TLitC8<S>::operator const TDesC8&() const
	{return *operator&();}
template <TInt S>
inline TLitC8<S>::operator const __TRefDesC8() const
	{return *operator&();}

 
inline TInt TDesC16::operator<(const TDesC16 &aDes) const
	{return(Compare(aDes)<0);}
inline TInt TDesC16::operator<=(const TDesC16 &aDes) const
	{return(Compare(aDes)<=0);}
inline TInt TDesC16::operator>(const TDesC16 &aDes) const
	{return(Compare(aDes)>0);}
inline TInt TDesC16::operator>=(const TDesC16 &aDes) const
	{return(Compare(aDes)>=0);}
inline TInt TDesC16::operator==(const TDesC16 &aDes) const
	{return(Compare(aDes)==0);}
inline TInt TDesC16::operator!=(const TDesC16 &aDes) const
	{return(Compare(aDes)!=0);}
inline const TUint16 &TDesC16::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TInt TDesC16::Length() const
	{

	return(iLength&KMaskDesLength16);



	}
inline TInt TDesC16::Size() const
	{return(Length()<<1);}
inline void TDesC16::DoSetLength(TInt aLength)
	{

	iLength=(iLength&(~KMaskDesLength16))|aLength;



	}

 
inline void TPtrC16::Set(const TUint16 *aBuf,TInt aLength)
	{new(this) TPtrC16(aBuf,aLength);}
inline void TPtrC16::Set(const TDesC16 &aDes)
	{new(this) TPtrC16(aDes);}
inline void TPtrC16::Set(const TPtrC16& aPtr)
	{new(this) TPtrC16(aPtr);}

 
inline TPtr16 TBufCBase16::DoDes(TInt aMaxLength)
	{return TPtr16(*this,aMaxLength);}

 
template <TInt S>
inline TBufC16<S>::TBufC16()
	: TBufCBase16()
	{}
template <TInt S>
inline TBufC16<S>::TBufC16(const TUint16 *aString)
	: TBufCBase16(aString,S)
	{}
template <TInt S>
inline TBufC16<S>::TBufC16(const TDesC16 &aDes)
	: TBufCBase16(aDes,S)
	{}
template <TInt S>
inline TBufC16<S> &TBufC16<S>::operator=(const TUint16 *aString)
	{Copy(aString,S);return(*this);}
template <TInt S>
inline TBufC16<S> &TBufC16<S>::operator=(const TDesC16 &aDes)
	{Copy(aDes,S);return(*this);}
template <TInt S>
inline TPtr16 TBufC16<S>::Des()
	{return(DoDes(S));}

 
inline HBufC16 &HBufC16::operator=(const HBufC16 &aLcb)
	{return *this=static_cast<const TDesC16&>(aLcb);}

 
inline TDes16 &TDes16::operator=(const TUint16 *aString)
    {Copy(aString);return(*this);}
inline TDes16 &TDes16::operator=(const TDesC16 &aDes)
    {Copy(aDes);return(*this);}
inline TDes16 &TDes16::operator=(const TDes16 &aDes)
    {Copy(aDes);return(*this);}
inline TDes16 &TDes16::operator+=(const TDesC16 &aDes)
	{Append(aDes);return(*this);}
inline const TUint16 &TDes16::operator[](TInt anIndex) const
	{return(AtC(anIndex));}
inline TUint16 &TDes16::operator[](TInt anIndex)
	{return((TUint16 &)AtC(anIndex));}
inline TInt TDes16::MaxLength() const
	{return(iMaxLength);}
inline TInt TDes16::MaxSize() const
	{return(iMaxLength<<1);}
inline TUint16 * TDes16::WPtr() const
	{return((TUint16 *)Ptr());}

 
inline TPtr16 &TPtr16::operator=(const TUint16 *aString)
	{Copy(aString);return(*this);}
inline TPtr16 &TPtr16::operator=(const TDesC16 &aDes)
	{Copy(aDes);return(*this);}
inline TPtr16 &TPtr16::operator=(const TPtr16 &aDes)
	{Copy(aDes);return(*this);}
inline void TPtr16::Set(TUint16 *aBuf,TInt aLength,TInt aMaxLength)
	{new(this) TPtr16(aBuf,aLength,aMaxLength);}
inline void TPtr16::Set(const TPtr16 &aPtr)
	{new(this) TPtr16(aPtr);}

 
template <TInt S>
inline TBuf16<S>::TBuf16()
	: TBufBase16(S)
	{}
template <TInt S>
inline TBuf16<S>::TBuf16(TInt aLength)
	: TBufBase16(aLength,S)
	{}
template <TInt S>
inline TBuf16<S>::TBuf16(const TUint16 *aString)
	: TBufBase16(aString,S)
	{}
template <TInt S>
inline TBuf16<S>::TBuf16(const TDesC16 &aDes)
	: TBufBase16(aDes,S)
	{}
template <TInt S>
inline TBuf16<S> &TBuf16<S>::operator=(const TUint16 *aString)
	{Copy(aString);return(*this);}
template <TInt S>
inline TBuf16<S> &TBuf16<S>::operator=(const TDesC16 &aDes)
	{Copy(aDes);return(*this);}
template <TInt S>
inline TBuf16<S>& TBuf16<S>::operator=(const TBuf16<S>& aBuf)
	{Copy(aBuf);return *this;}


 
 






inline void RBuf8::CreateL(RReadStream &aStream,TInt aMaxLength)
	{
	Assign(HBufC8::NewL(aStream,aMaxLength));
	}

 
 






inline void RBuf16::CreateL(RReadStream &aStream,TInt aMaxLength)
	{
	Assign(HBufC16::NewL(aStream,aMaxLength));
	}


 
template <TInt S>
inline const TDesC16* TLitC16<S>::operator&() const
	{return (reinterpret_cast< const TDesC16* >( this )) ;}
template <TInt S>
inline const TDesC16& TLitC16<S>::operator()() const
	{return *operator&();}
template <TInt S>
inline TLitC16<S>::operator const TDesC16&() const
	{return *operator&();}
template <TInt S>
inline TLitC16<S>::operator const __TRefDesC16() const
	{return *operator&();}

 

template <TInt S>
inline TBufC<S>::TBufC()
	: TBufCBase16()
	{}
template <TInt S>
inline TBufC<S>::TBufC(const TText *aString)
	: TBufCBase16(aString,S)
	{}
template <TInt S>
inline TBufC<S>::TBufC(const TDesC &aDes)
	: TBufCBase16(aDes,S)
	{}

template <TInt S>
inline TBufC<S> &TBufC<S>::operator=(const TText *aString)
	{Copy(aString,S);return(*this);}
template <TInt S>
inline TBufC<S> &TBufC<S>::operator=(const TDesC &aDes)
	{Copy(aDes,S);return(*this);}
template <TInt S>
inline TPtr TBufC<S>::Des()
	{return(DoDes(S));}

 

template <TInt S>
inline TBuf<S>::TBuf()
	: TBufBase16(S)
	{}
template <TInt S>
inline TBuf<S>::TBuf(TInt aLength)
	: TBufBase16(aLength,S)
	{}
template <TInt S>
inline TBuf<S>::TBuf(const TText *aString)
	: TBufBase16(aString,S)
	{}
template <TInt S>
inline TBuf<S>::TBuf(const TDesC &aDes)
	: TBufBase16(aDes,S)
	{}

template <TInt S>
inline TBuf<S> &TBuf<S>::operator=(const TText *aString)
	{Copy(aString);return(*this);}
template <TInt S>
inline TBuf<S> &TBuf<S>::operator=(const TDesC &aDes)
	{Copy(aDes);return(*this);}
template <TInt S>
inline TBuf<S> &TBuf<S>::operator=(const TBuf<S> &aBuf)
	{Copy(aBuf);return(*this);}

 
template <TInt S>
inline const TDesC* TLitC<S>::operator&() const
	{return (reinterpret_cast< const TDesC* >( this )) ;}
template <TInt S>
inline const TDesC& TLitC<S>::operator()() const
	{return *operator&();}
template <TInt S>
inline TLitC<S>::operator const TDesC&() const
	{return *operator&();}
template <TInt S>
inline TLitC<S>::operator const __TRefDesC() const
	{return *operator&();}

 
template <class T>
inline TPckgC<T>::TPckgC(const T &aRef)
	: TPtrC8((const TUint8 *)&aRef,sizeof(T))
	{}
template <class T>
inline const T &TPckgC<T>::operator()() const
	{return(*((const T *)iPtr));}

 
template <class T>
inline TPckg<T>::TPckg(const T &aRef)
	: TPtr8((TUint8 *)&aRef,sizeof(T),sizeof(T))
	{}
template <class T>
inline T &TPckg<T>::operator()()
	{return(*((T *)iPtr));}

 
template <class T>
inline TPckgBuf<T>::TPckgBuf()
	: TBuf8<sizeof(T)>(sizeof(T))
	{new(&iBuf[0]) T;}
template <class T>
inline TPckgBuf<T>::TPckgBuf(const T &aRef)
	: TBuf8<sizeof(T)>(sizeof(T))
	{new(&iBuf[0]) T(aRef);}
template <class T>
inline TPckgBuf<T> &TPckgBuf<T>::operator=(const TPckgBuf<T> &aRef)
	{Copy(aRef);return(*this);}
template <class T>
inline T &TPckgBuf<T>::operator=(const T &aRef)
	{Copy((TUint8 *)&aRef,sizeof(T));return(*((T *)&iBuf[0]));}
template <class T>
inline T &TPckgBuf<T>::operator()()
	{return(*((T *)&iBuf[0]));}
template <class T>
inline const T &TPckgBuf<T>::operator()() const
	{return(*((T *)&iBuf[0]));}

 
inline TDateTime::TDateTime()
	: iYear(1980),
	  iMonth(EJanuary), 
	  iDay(1),
	  iHour(0),
	  iMinute(0),
	  iSecond(0),
	  iMicroSecond(0)
	{}    

 








       
inline TInt TDateTime::Year() const
	{return(iYear);}

 









inline TMonth TDateTime::Month() const
	{return(iMonth);}

 








inline TInt TDateTime::Day() const
	{return(iDay);}

 







inline TInt TDateTime::Hour() const
	{return(iHour);}

 







inline TInt TDateTime::Minute() const
	{return(iMinute);}

 







inline TInt TDateTime::Second() const
	{return(iSecond);}

 







inline TInt TDateTime::MicroSecond() const
	{return(iMicroSecond);}

 

 









inline TTimeIntervalMicroSeconds::TTimeIntervalMicroSeconds()
	{}
inline TTimeIntervalMicroSeconds::TTimeIntervalMicroSeconds(const TInt64& aInterval)
	: iInterval(aInterval)
	{}

 











inline TTimeIntervalMicroSeconds& TTimeIntervalMicroSeconds::operator=(const TInt64& aInterval)
	{iInterval=aInterval;return(*this);}

 











inline TBool TTimeIntervalMicroSeconds::operator==(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval==aInterval.iInterval);}

 










inline TBool TTimeIntervalMicroSeconds::operator!=(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval!=aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator>=(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval>=aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator<=(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval<=aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator>(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval>aInterval.iInterval);}

 











inline TBool TTimeIntervalMicroSeconds::operator<(const TTimeIntervalMicroSeconds& aInterval) const
	{return(iInterval<aInterval.iInterval);}

 







inline const TInt64& TTimeIntervalMicroSeconds::Int64() const
	{return(iInterval);}

 
inline TTimeIntervalBase::TTimeIntervalBase()
	{}
inline TTimeIntervalBase::TTimeIntervalBase(TInt aInterval)
	: iInterval(aInterval)
	{}

 










inline TInt TTimeIntervalBase::operator==(TTimeIntervalBase aInterval) const
	{return(iInterval==aInterval.iInterval);}

 









inline TInt TTimeIntervalBase::operator!=(TTimeIntervalBase aInterval) const
	{return(iInterval!=aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator>=(TTimeIntervalBase aInterval) const
	{return(iInterval>=aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator<=(TTimeIntervalBase aInterval) const
	{return(iInterval<=aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator>(TTimeIntervalBase aInterval) const
	{return(iInterval>aInterval.iInterval);}

 










inline TInt TTimeIntervalBase::operator<(TTimeIntervalBase aInterval) const
	{return(iInterval<aInterval.iInterval);}

 







inline TInt TTimeIntervalBase::Int() const
	{return(iInterval);}

 

inline TTimeIntervalMicroSeconds32::TTimeIntervalMicroSeconds32()
	{}

 









inline TTimeIntervalMicroSeconds32::TTimeIntervalMicroSeconds32(TInt aInterval)
    : TTimeIntervalBase(aInterval)
	{}

 











inline TTimeIntervalMicroSeconds32& TTimeIntervalMicroSeconds32::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

 








inline TTimeIntervalSeconds::TTimeIntervalSeconds()
	{}
inline TTimeIntervalSeconds::TTimeIntervalSeconds(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalSeconds& TTimeIntervalSeconds::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

inline TTimeIntervalMinutes::TTimeIntervalMinutes()
	{}

 








inline TTimeIntervalMinutes::TTimeIntervalMinutes(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalMinutes& TTimeIntervalMinutes::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

 








inline TTimeIntervalHours::TTimeIntervalHours()
	{}
inline TTimeIntervalHours::TTimeIntervalHours(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalHours& TTimeIntervalHours::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 

inline TTimeIntervalDays::TTimeIntervalDays()
	{}

 








inline TTimeIntervalDays::TTimeIntervalDays(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalDays& TTimeIntervalDays::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 
inline TTimeIntervalMonths::TTimeIntervalMonths()
	{}

 








inline TTimeIntervalMonths::TTimeIntervalMonths(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalMonths& TTimeIntervalMonths::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 
inline TTimeIntervalYears::TTimeIntervalYears()
	{}

 









inline TTimeIntervalYears::TTimeIntervalYears(TInt aInterval)
	: TTimeIntervalBase(aInterval)
	{}

 










inline TTimeIntervalYears& TTimeIntervalYears::operator=(TInt aInterval)
	{iInterval=aInterval;return(*this);}

 
inline TTime::TTime()
	{}
inline TTime::TTime(const TInt64& aTime)
	: iTime(aTime)
	{}
inline TTime &TTime::operator=(const TInt64& aTime)
	{iTime=aTime;return(*this);}

 










inline TBool TTime::operator==(TTime aTime) const
	{return(iTime==aTime.iTime);}

 










inline TBool TTime::operator!=(TTime aTime) const
	{return(iTime!=aTime.iTime);}

 










inline TBool TTime::operator>=(TTime aTime) const
	{return(iTime>=aTime.iTime);}

 










inline TBool TTime::operator<=(TTime aTime) const
	{return(iTime<=aTime.iTime);}

 










inline TBool TTime::operator>(TTime aTime) const
	{return(iTime>aTime.iTime);}

 










inline TBool TTime::operator<(TTime aTime) const
	{return(iTime<aTime.iTime);}

 







inline const TInt64& TTime::Int64() const
	{return(iTime);}

 
inline TLexMark8::TLexMark8()
	: iPtr(0L )
	{}
inline TLexMark8::TLexMark8(const TUint8 *aString) 
	: iPtr(aString)
	{}

 
inline TLex8::TLex8(const TUint8 *aString)
	{Assign(TPtrC8(aString));}
inline TLex8::TLex8(const TDesC8 &aDes)
	{Assign(aDes);}
inline TLex8& TLex8::operator=(const TUint8* aString)
	{Assign(TPtrC8(aString));return(*this);}
inline TLex8& TLex8::operator=(const TDesC8& aBuf)
	{Assign(aBuf);return(*this);}
inline TBool TLex8::Eos() const
	{return(iNext==iEnd);}
inline void TLex8::Mark()
	{Mark(iMark);}
inline void TLex8::Mark(TLexMark8& aMark) const
	{aMark.iPtr=iNext;}
inline void TLex8::UnGetToMark()
    {UnGetToMark(iMark);}
inline void TLex8::SkipAndMark(TInt aNumber)
    {SkipAndMark(aNumber,iMark);}
inline void TLex8::SkipSpaceAndMark()
    {SkipSpaceAndMark(iMark);}
inline TInt TLex8::TokenLength() const
	{return(iNext-iMark.iPtr);}
inline TInt TLex8::MarkedOffset() const
    {return(iMark.iPtr-iBuf);}
inline TInt TLex8::Val(TInt &aVal)
	{return(Val((TInt32&)aVal));}
inline TInt TLex8::Val(TUint &aVal,TRadix aRadix)
	{return(Val((TUint32&)aVal,aRadix));}
inline void TLex8::Assign(const TLex8& aLex)
	{new(this) TLex8(aLex);}

 
inline TLexMark16::TLexMark16()
	: iPtr(0L )
	{}
inline TLexMark16::TLexMark16(const TUint16 *aString) 
	: iPtr(aString)
	{}

 
inline TLex16::TLex16(const TUint16 *aString)
	{Assign(TPtrC16(aString));}
inline TLex16::TLex16(const TDesC16 &aDes)
	{Assign(aDes);}
inline TLex16& TLex16::operator=(const TUint16* aString)
	{Assign(TPtrC16(aString));return(*this);}
inline TLex16& TLex16::operator=(const TDesC16& aBuf)
	{Assign(aBuf);return(*this);}
inline TBool TLex16::Eos() const
	{return(iNext==iEnd);}
inline void TLex16::Mark(TLexMark16& aMark) const
	{aMark.iPtr=iNext;}
inline void TLex16::Mark()
	{iMark.iPtr=iNext;}
inline void TLex16::UnGetToMark()
    {UnGetToMark(iMark);}
inline void TLex16::SkipAndMark(TInt aNumber)
    {SkipAndMark(aNumber,iMark);}
inline void TLex16::SkipSpaceAndMark()
    {SkipSpaceAndMark(iMark);}
inline TInt TLex16::TokenLength() const
	{return(iNext-iMark.iPtr);}
inline TInt TLex16::MarkedOffset() const
    {return(iMark.iPtr-iBuf);}
inline TInt TLex16::Val(TInt &aVal)
	{return(Val((TInt32&)aVal));}
inline TInt TLex16::Val(TUint &aVal,TRadix aRadix)
	{return(Val((TUint32&)aVal,aRadix));}
inline void TLex16::Assign(const TLex16& aLex)
	{new(this) TLex16(aLex);}

 

 











inline TInt TLocale::CountryCode() const
	{return(iCountryCode);}

 












inline void TLocale::SetCountryCode(TInt aCode)
	{iCountryCode=aCode;}

 









inline TTimeIntervalSeconds TLocale::UniversalTimeOffset() const
	{return(iUniversalTimeOffset);}

 









inline void TLocale::SetUniversalTimeOffset(const TTimeIntervalSeconds& anOffset)
	{iUniversalTimeOffset=anOffset;}

 







inline TDateFormat TLocale::DateFormat() const
	{return(iDateFormat);}

 







inline void TLocale::SetDateFormat(TDateFormat aFormat)
	{iDateFormat=aFormat;}

 









inline TTimeFormat TLocale::TimeFormat() const
	{return(iTimeFormat);}

 









inline void TLocale::SetTimeFormat(TTimeFormat aFormat)
	{iTimeFormat=aFormat;}

 











inline TLocalePos TLocale::CurrencySymbolPosition() const
	{return(iCurrencySymbolPosition);}

 










inline void TLocale::SetCurrencySymbolPosition(TLocalePos aPos)
	{iCurrencySymbolPosition=aPos;}

 











inline TBool TLocale::CurrencySpaceBetween() const
	{return(iCurrencySpaceBetween);}

 









inline void TLocale::SetCurrencySpaceBetween(TBool aSpace)
	{iCurrencySpaceBetween=aSpace;}

 







inline TInt TLocale::CurrencyDecimalPlaces() const
	{return(iCurrencyDecimalPlaces);}

 








inline void TLocale::SetCurrencyDecimalPlaces(TInt aPlaces)
	{iCurrencyDecimalPlaces=aPlaces;}

 















inline TBool TLocale::CurrencyNegativeInBrackets() const				             
	{return((TBool)iNegativeCurrencyFormat);}							

 

















inline void TLocale::SetCurrencyNegativeInBrackets(TBool aBool)			
	{iNegativeCurrencyFormat=(aBool)?EInBrackets:ELeadingMinusSign;}	

 










inline TBool TLocale::CurrencyTriadsAllowed() const
	{return(iCurrencyTriadsAllowed);}

 








inline void TLocale::SetCurrencyTriadsAllowed(TBool aBool)
	{iCurrencyTriadsAllowed=aBool;}

 











inline TChar TLocale::ThousandsSeparator() const
	{return(iThousandsSeparator);}

 











inline void TLocale::SetThousandsSeparator(const TChar& aChar)
	{iThousandsSeparator=aChar;}

 








inline TChar TLocale::DecimalSeparator() const
	{return(iDecimalSeparator);}

 








inline void TLocale::SetDecimalSeparator(const TChar& aChar)
	{iDecimalSeparator=aChar;}

 

















inline TChar TLocale::DateSeparator(TInt aIndex) const
	{return(iDateSeparator[aIndex]);}

 
















inline void TLocale::SetDateSeparator(const TChar& aChar,TInt aIndex)
	{ ;
	iDateSeparator[aIndex]=aChar;}

 

















inline TChar TLocale::TimeSeparator(TInt aIndex) const
	{return(iTimeSeparator[aIndex]);}

 
















inline void TLocale::SetTimeSeparator(const TChar& aChar,TInt aIndex)
	{ ;
	iTimeSeparator[aIndex]=aChar;}

 









inline TLocalePos TLocale::AmPmSymbolPosition() const
	{return(iAmPmSymbolPosition);}

 









inline void TLocale::SetAmPmSymbolPosition(TLocalePos aPos)
	{iAmPmSymbolPosition=aPos;}

 









inline TBool TLocale::AmPmSpaceBetween() const
	{return(iAmPmSpaceBetween);}

 









inline void TLocale::SetAmPmSpaceBetween(TBool aSpace)
	{iAmPmSpaceBetween=aSpace;}

 




















inline TUint TLocale::DaylightSaving() const
	{return(iDaylightSaving);} 

 



























inline void TLocale::SetDaylightSaving(TUint aDaylightSaving)
	{iDaylightSaving=aDaylightSaving;} 

 








inline TBool TLocale::QueryHomeHasDaylightSavingOn() const
	{return((iHomeDaylightSavingZone|EDstHome) & iDaylightSaving);}

 








inline TDaylightSavingZone TLocale::HomeDaylightSavingZone() const
	{return(iHomeDaylightSavingZone);}

 








inline void TLocale::SetHomeDaylightSavingZone(TDaylightSavingZone aZone)
	{iHomeDaylightSavingZone=aZone;}

 











inline TUint TLocale::WorkDays() const
	{return(iWorkDays);}

 










inline void TLocale::SetWorkDays(TUint aMask)
	{iWorkDays=aMask;}

 







inline TDay TLocale::StartOfWeek() const
	{return(iStartOfWeek);}

 







inline void TLocale::SetStartOfWeek(TDay aDay)
	{iStartOfWeek=aDay;}

 







inline TClockFormat TLocale::ClockFormat() const
	{return(iClockFormat);}

 







inline void TLocale::SetClockFormat(TClockFormat aFormat)
	{iClockFormat=aFormat;}

 










inline TUnitsFormat TLocale::UnitsGeneral() const
	{return(iUnitsGeneral);}

 










inline void TLocale::SetUnitsGeneral(TUnitsFormat aFormat)
	{iUnitsGeneral=aFormat;}

 










inline TUnitsFormat TLocale::UnitsDistanceShort() const
	{return(iUnitsDistanceShort);}

 










inline void TLocale::SetUnitsDistanceShort(TUnitsFormat aFormat)
	{iUnitsDistanceShort=aFormat;}

 










inline TUnitsFormat TLocale::UnitsDistanceLong() const
	{return(iUnitsDistanceLong);}

 










inline void TLocale::SetUnitsDistanceLong(TUnitsFormat aFormat)
	{iUnitsDistanceLong=aFormat;}

 








inline TLocale::TNegativeCurrencyFormat TLocale::NegativeCurrencyFormat() const
	{return(iNegativeCurrencyFormat);}

 








inline void TLocale::SetNegativeCurrencyFormat(TLocale::TNegativeCurrencyFormat aNegativeCurrencyFormat)
	{iNegativeCurrencyFormat = aNegativeCurrencyFormat;}

 











inline TBool TLocale::NegativeLoseSpace() const
	{ 
	if((iExtraNegativeCurrencyFormatFlags|EFlagNegativeLoseSpace)==iExtraNegativeCurrencyFormatFlags)
		return ETrue;
	else
		return EFalse;
	}

 












inline void TLocale::SetNegativeLoseSpace(TBool aBool)
	{
	if(aBool)
		iExtraNegativeCurrencyFormatFlags |= EFlagNegativeLoseSpace;
	else
		iExtraNegativeCurrencyFormatFlags &= ~EFlagNegativeLoseSpace;
	}

 















inline TBool TLocale::NegativeCurrencySymbolOpposite() const
	{
	if((iExtraNegativeCurrencyFormatFlags|EFlagNegativeCurrencySymbolOpposite)==iExtraNegativeCurrencyFormatFlags)
		return ETrue;
	else
		return EFalse;
	}

 















inline void TLocale::SetNegativeCurrencySymbolOpposite(TBool aBool)
	{
	if (aBool)
		iExtraNegativeCurrencyFormatFlags |= EFlagNegativeCurrencySymbolOpposite;
	else
		iExtraNegativeCurrencyFormatFlags &= ~EFlagNegativeCurrencySymbolOpposite;
	}

inline TLanguage TLocale::LanguageDowngrade(TInt aIndex) const
	{
	 ;
	return static_cast<TLanguage>(iLanguageDowngrade[aIndex]);
	}

inline void TLocale::SetLanguageDowngrade(TInt aIndex, TLanguage aLanguage)
	{
	 ;
	iLanguageDowngrade[aIndex] = static_cast<TUint16>(aLanguage);
	}
 







inline TDigitType TLocale::DigitType() const
	{ return iDigitType; }
 







inline void TLocale::SetDigitType(TDigitType aDigitType)
	{ iDigitType=aDigitType; }

 





inline void TLocale::SetDeviceTime(TDeviceTimeState aState)
	{
	iDeviceTimeState=aState;
	}

 





inline TLocale::TDeviceTimeState TLocale::DeviceTime() const
	{
	return iDeviceTimeState;
	}

 
inline TPoint::TPoint()
	: iX(0),iY(0)
	{}
inline TPoint::TPoint(TInt aX,TInt aY)
	: iX(aX),iY(aY)
	{}

 
inline TSize::TSize()
	: iWidth(0),iHeight(0)
	{}
inline TSize::TSize(TInt aWidth,TInt aHeight)
	: iWidth(aWidth),iHeight(aHeight)
	{}

 
inline TRequestStatus::TRequestStatus()
	{}
inline TRequestStatus::TRequestStatus(TInt aVal)
	: iStatus(aVal)
	{}
inline TInt TRequestStatus::operator=(TInt aVal)
	{return(iStatus=aVal);}
inline TInt TRequestStatus::operator==(TInt aVal) const
	{return(iStatus==aVal);}
inline TInt TRequestStatus::operator!=(TInt aVal) const
	{return(iStatus!=aVal);}
inline TInt TRequestStatus::operator>=(TInt aVal) const
	{return(iStatus>=aVal);}
inline TInt TRequestStatus::operator<=(TInt aVal) const
	{return(iStatus<=aVal);}
inline TInt TRequestStatus::operator>(TInt aVal) const
	{return(iStatus>aVal);}
inline TInt TRequestStatus::operator<(TInt aVal) const
	{return(iStatus<aVal);}
inline TInt TRequestStatus::Int() const
	{return(iStatus);}

 
inline TInt TFindHandleBase::Handle() const
	{return(iFindHandle);}

 
inline RHandleBase::RHandleBase()
	: iHandle(0)
	{}
inline RHandleBase::RHandleBase(TInt aHandle)
	: iHandle(aHandle)
	{}
inline void RHandleBase::SetHandle(TInt aHandle)
	{iHandle=aHandle;}
inline TInt RHandleBase::Handle() const
	{return(iHandle);}

 
inline TFindSemaphore::TFindSemaphore()
    : TFindHandleBase()
    {}
inline TFindSemaphore::TFindSemaphore(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindMutex::TFindMutex()
    : TFindHandleBase()
    {}
inline TFindMutex::TFindMutex(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindChunk::TFindChunk()
    : TFindHandleBase()
    {}
inline TFindChunk::TFindChunk(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindThread::TFindThread()
    : TFindHandleBase()
    {}
inline TFindThread::TFindThread(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindProcess::TFindProcess()
    : TFindHandleBase()
    {}
inline TFindProcess::TFindProcess(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindLogicalDevice::TFindLogicalDevice()
    : TFindHandleBase()
    {}
inline TFindLogicalDevice::TFindLogicalDevice(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindPhysicalDevice::TFindPhysicalDevice()
    : TFindHandleBase()
    {}
inline TFindPhysicalDevice::TFindPhysicalDevice(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindLogicalChannel::TFindLogicalChannel()
    : TFindHandleBase()
    {}
inline TFindLogicalChannel::TFindLogicalChannel(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindServer::TFindServer()
    : TFindHandleBase()
    {}
inline TFindServer::TFindServer(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TFindLibrary::TFindLibrary()
    : TFindHandleBase()
    {}
inline TFindLibrary::TFindLibrary(const TDesC &aMatch)
    : TFindHandleBase(aMatch)
    {}

 
inline TInt RDevice::Open(const TFindLogicalDevice& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TInt RSemaphore::Open(const TFindSemaphore& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TBool RCriticalSection::IsBlocked() const
	{return(iBlocked!=1);}

 
inline TInt RMutex::Open(const TFindMutex& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TInt RChunk::Open(const TFindChunk& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}
inline TBool RChunk::IsReadable() const
	{return (Attributes()&RHandleBase::EDirectReadAccess); }
inline TBool RChunk::IsWritable() const
	{return (Attributes()&RHandleBase::EDirectWriteAccess); }

 
inline TThreadId::TThreadId()
	{}
inline TThreadId::TThreadId(TUint aId)
	: iId(aId)
	{}
inline TThreadId::operator TUint() const
	{ return iId; }
inline TInt TThreadId::operator==(TThreadId aId) const
	{return iId==aId.iId;}
inline TInt TThreadId::operator!=(TThreadId aId) const
	{return iId!=aId.iId;}

 
inline RThread::RThread()
	: RHandleBase(KCurrentThreadHandle)
	{}
inline TInt RThread::Open(const TFindThread& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}

 
inline TProcessId::TProcessId()
	{}
inline TProcessId::TProcessId(TUint aId)
	: iId(aId)
	{}
inline TProcessId::operator TUint() const
	{ return iId; }
inline TInt TProcessId::operator==(TProcessId aId) const
	{return iId==aId.iId;}
inline TInt TProcessId::operator!=(TProcessId aId) const
	{return iId!=aId.iId;}

 
inline RProcess::RProcess()
	: RHandleBase(KCurrentProcessHandle)
	{}
inline RProcess::RProcess(TInt aHandle)
	: RHandleBase(aHandle)
	{}
inline TInt RProcess::Open(const TFindProcess& aFind,TOwnerType aType)
	{return(RHandleBase::Open(aFind,aType));}



 
inline RMessagePtr::RMessagePtr()
	: iHandle(0)
	{}
inline RMessagePtr::RMessagePtr(const RMessage& aMessage)
	: iHandle(aMessage.iHandle)
	{}
inline TBool RMessagePtr::IsNull() const
	{return iHandle==0;}
inline TBool operator==(RMessagePtr aLeft,RMessagePtr aRight)
	{return aLeft.iHandle==aRight.iHandle;}
inline TBool operator!=(RMessagePtr aLeft,RMessagePtr aRight)
	{return !(aLeft==aRight);}

 
inline TInt RMessage::Function() const
	{return(iFunction);}
inline const RThread &RMessage::Client() const
	{return(iClient);}
inline TInt RMessage::Int0() const
	{return(iArgs[0]);}
inline TInt RMessage::Int1() const
	{return(iArgs[1]);}
inline TInt RMessage::Int2() const
	{return(iArgs[2]);}
inline TInt RMessage::Int3() const
	{return(iArgs[3]);}
inline const TAny *RMessage::Ptr0() const
	{return((const TAny *)iArgs[0]);}
inline const TAny *RMessage::Ptr1() const
	{return((const TAny *)iArgs[1]);}
inline const TAny *RMessage::Ptr2() const
	{return((const TAny *)iArgs[2]);}
inline const TAny *RMessage::Ptr3() const
	{return((const TAny *)iArgs[3]);}
inline const RMessagePtr RMessage::MessagePtr() const
	{return(RMessagePtr(*this));}

 
inline const RMessage &RServer::Message() const
	{return iMessage;}



 

inline TInt RSessionBase::Share(TAttachMode aAttachMode)
 


	{return DoShare(aAttachMode);}
inline TInt RSessionBase::Send(TInt aFunction,TAny* aPtr) const
 


	{return DoSend(aFunction,aPtr);}
inline void RSessionBase::SendReceive(TInt aFunction,TAny* aPtr,TRequestStatus& aStatus) const
 


	{DoSendReceive(aFunction,aPtr,aStatus);}
inline TInt RSessionBase::SendReceive(TInt aFunction,TAny* aPtr) const
 


	{return DoSendReceive(aFunction,aPtr);}

inline TInt RSessionBase::ShareAuto()
 








	{return DoShare(EAutoAttach);}
inline TInt RSessionBase::CreateSession(const TDesC& aServer,const TVersion& aVersion)
 








	{return CreateSession(aServer,aVersion,-1);}
inline TInt RSessionBase::Send(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSend(aFunction,(TAny*)&aArgs);}
inline void RSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const
 










	{DoSendReceive(aFunction,(TAny*)&aArgs,aStatus);}
inline TInt RSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSendReceive(aFunction,(TAny*)&aArgs);}
inline TInt RSessionBase::Send(TInt aFunction) const
 













	{return DoSend(aFunction,0L );}
inline void RSessionBase::SendReceive(TInt aFunction,TRequestStatus& aStatus) const
 










	{DoSendReceive(aFunction,0L ,aStatus);}
inline TInt RSessionBase::SendReceive(TInt aFunction) const
 








	{return DoSendReceive(aFunction,0L );}

 
inline RSubSessionBase::RSubSessionBase()
	: iSubSessionHandle(0)
 


	{}
inline TInt RSubSessionBase::SubSessionHandle() const
 




	{return iSubSessionHandle;}
inline RSessionBase& RSubSessionBase::Session()
 




	{return iSession;}

inline TInt RSubSessionBase::CreateSubSession(RSessionBase& aSession,TInt aFunction,const TAny* aPtr)
 


	{ return DoCreateSubSession(aSession,aFunction,aPtr); }

inline TInt RSubSessionBase::CreateSubSession(RSessionBase& aSession,TInt aFunction,const TIpcArgs& aArgs)
 












	{ return DoCreateSubSession(aSession,aFunction,(TAny*)&aArgs); }
inline TInt RSubSessionBase::CreateSubSession(RSessionBase& aSession,TInt aFunction)
 











	{ return DoCreateSubSession(aSession,aFunction,0L ); }

inline TInt RSubSessionBase::Send(TInt aFunction,const TAny* aPtr) const
 


	{return DoSend(aFunction,aPtr);}
inline void RSubSessionBase::SendReceive(TInt aFunction,const TAny* aPtr,TRequestStatus& aStatus) const
 


	{DoSendReceive(aFunction,aPtr,aStatus);}
inline TInt RSubSessionBase::SendReceive(TInt aFunction,const TAny* aPtr) const
 


	{return DoSendReceive(aFunction,aPtr);}

inline TInt RSubSessionBase::Send(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSend(aFunction,(TAny*)&aArgs);}
inline void RSubSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs,TRequestStatus& aStatus) const
 











	{DoSendReceive(aFunction,(TAny*)&aArgs,aStatus);}
inline TInt RSubSessionBase::SendReceive(TInt aFunction,const TIpcArgs& aArgs) const
 














	{return DoSendReceive(aFunction,(TAny*)&aArgs);}
inline TInt RSubSessionBase::Send(TInt aFunction) const
 














	{return DoSend(aFunction,0L );}
inline void RSubSessionBase::SendReceive(TInt aFunction,TRequestStatus& aStatus) const
 











	{ DoSendReceive(aFunction,0L ,aStatus);}
inline TInt RSubSessionBase::SendReceive(TInt aFunction) const
 








	{return DoSendReceive(aFunction,0L );}

 
inline RMessagePtr2::RMessagePtr2()
	: iHandle(0)
 


	{}
inline TBool RMessagePtr2::IsNull() const
 





	{return iHandle==0;}
inline TInt RMessagePtr2::Handle() const
 




	{return iHandle;}
inline TBool RMessagePtr2::ClientDataCaging() const
 





 
	{return ClientProcessFlags();}
inline TBool operator==(RMessagePtr2 aLeft,RMessagePtr2 aRight)
 





	{return aLeft.Handle()==aRight.Handle();}
inline TBool operator!=(RMessagePtr2 aLeft,RMessagePtr2 aRight)
 





	{return aLeft.Handle()!=aRight.Handle();}

 
inline RMessage2::RMessage2()
 


	{}
inline TInt RMessage2::Function() const
 




	{return(iFunction);}
inline TInt RMessage2::Int0() const
 




	{return(iArgs[0]);}
inline TInt RMessage2::Int1() const
 




	{return(iArgs[1]);}
inline TInt RMessage2::Int2() const
 




	{return(iArgs[2]);}
inline TInt RMessage2::Int3() const
 




	{return(iArgs[3]);}
inline const TAny *RMessage2::Ptr0() const
 




	{return((const TAny *)iArgs[0]);}
inline const TAny *RMessage2::Ptr1() const
 




	{return((const TAny *)iArgs[1]);}
inline const TAny *RMessage2::Ptr2() const
 




	{return((const TAny *)iArgs[2]);}
inline const TAny *RMessage2::Ptr3() const
 




	{return((const TAny *)iArgs[3]);}
inline CSession2* RMessage2::Session() const
 




	{return (CSession2*)iSessionPtr; }

 
inline RRefBase::RRefBase()
	: iPtr(0L )
	{}
inline RRefBase::RRefBase(const RRefBase &aRef)
	{Copy(aRef);}

 
template <class T>
inline RRef<T>::RRef()
	{}
template <class T>
inline RRef<T>::RRef(const RRef<T> &anObject)
	{Copy(anObject);}
template <class T>
inline void RRef<T>::operator=(const RRef<T> &anObject)
	{Copy(anObject);}
template <class T>
inline T *RRef<T>::operator->()
	{return((T *)iPtr);}
template <class T>
inline RRef<T>::operator T*()
	{return((T *)iPtr);}
template <class T>
void RRef<T>::Alloc(const T &anObject)
	{DoAlloc(&anObject,sizeof(T));}
template <class T>
void RRef<T>::Alloc(const T &anObject,TInt aSize)
	{DoAlloc(&anObject,aSize);}
template <class T>
void RRef<T>::AllocL(const T &anObject)
	{DoAllocL(&anObject,sizeof(T));}
template <class T>
void RRef<T>::AllocL(const T &anObject,TInt aSize)
	{DoAllocL(&anObject,aSize);}

 
inline TBool TRegion::CheckError() const
	{return(iError);}
inline TInt TRegion::Count() const
	{return(iCount);}
inline const TRect *TRegion::RectangleList() const
	{return(((TRegion *)this)->RectangleListW());}
inline TRegion::TRegion()
	{}

 
inline TInt RRegion::CheckSpare() const
	{return(iAllocedRects-iCount);}

 
template <TInt S>
inline TRegionFix<S>::TRegionFix() : TRegion(-S)
	{}
template <TInt S>
inline TRegionFix<S>::TRegionFix(const TRect &aRect) : TRegion(-S)
	{AddRect(aRect);}
template <TInt S>
inline TRegionFix<S>::TRegionFix(const TRegionFix<S> &aRegion)
	{*this=aRegion;}

template <TInt S>
inline RRegionBuf<S>::RRegionBuf() : RRegion(-S&(~ERRegionBuf),S)
	{}
template <TInt S>
inline RRegionBuf<S>::RRegionBuf(const RRegion &aRegion) 
	{*this=aRegion;}
template <TInt S>
inline RRegionBuf<S>::RRegionBuf(const TRect &aRect) : RRegion(-S&(~ERRegionBuf),S)
	{AddRect(aRect);}
template <TInt S>
inline RRegionBuf<S>::RRegionBuf(const RRegionBuf<S> &aRegion)
    {*this=aRegion;}

 
inline TTrap::TTrap()
	{}

 
inline TTimerLockSpec &operator++(TTimerLockSpec &aLock)
	{
	return aLock=((aLock==ETwelveOClock) ? EOneOClock : (TTimerLockSpec)((TInt)aLock+1));
	}
inline TTimerLockSpec operator++(TTimerLockSpec &aLock, TInt)
	{
	TTimerLockSpec l=aLock;
	aLock=((aLock==ETwelveOClock) ? EOneOClock : (TTimerLockSpec)((TInt)aLock+1));
	return l;
	}

 
inline TUid TUid::Uid(TInt aUid)
	{TUid uid={aUid};return uid;}
inline TUid TUid::Null()
	{TUid uid={KNullUidValue};return uid;}

 
inline const TUidType& TCheckedUid::UidType() const
    {return(iType);}

 
template <class T>
inline TArray<T>::TArray(TInt (*aCount)(const CBase *aPtr),const TAny *(*anAt)(const CBase *aPtr,TInt anIndex),const CBase *aPtr)
	: iPtr(aPtr),iCount(aCount),iAt(anAt)
	{}
template <class T>
inline TInt TArray<T>::Count() const
	{return((*iCount)(iPtr));}
template <class T>
inline const T &TArray<T>::operator[](TInt anIndex) const
	{return(*((const T *)(*iAt)(iPtr,anIndex)));}

 
template <class T>
void _DeleteArray(T** aBegin,T** aEnd)
	{for (;;) if (aBegin<aEnd) delete *aBegin++; else return;}
template <class T>
struct _ArrayUtil
	{
	static inline void Delete(T* aBegin,T* aEnd,CBase*)
		{::_DeleteArray((CBase**)aBegin,(CBase**)aEnd);}
	static inline void Delete(T* aBegin,T* aEnd,TAny*)
		{::_DeleteArray(aBegin,aEnd);}
	static inline void Delete(T* aArray,TInt aCount)
		{Delete(aArray,aArray+aCount,*aArray);}
	};


 
  void PanicTFixedArray();

template <class T,TInt S>
inline TFixedArray<T,S>::TFixedArray()
	{}
template <class T,TInt S>
inline void TFixedArray<T,S>::Copy(const T* aList,TInt aLength)
	{ ;Mem::Copy(iRep,aList,aLength*sizeof(T));}
template <class T,TInt S>
inline TFixedArray<T,S>::TFixedArray(const T* aList,TInt aLength)
	{Copy(aList,aLength);}
template <class T,TInt S>
inline void TFixedArray<T,S>::Reset()
	{Mem::FillZ(iRep,sizeof(iRep));}
template <class T,TInt S>
inline TInt TFixedArray<T,S>::Count() const
	{return S;}
template <class T,TInt S>
inline TInt TFixedArray<T,S>::Length() const
	{return sizeof(T);}
template <class T,TInt S>
inline TBool TFixedArray<T,S>::InRange(TInt aIndex)
	{return TUint(aIndex)<S;}
template <class T,TInt S>
inline T& TFixedArray<T,S>::operator[](TInt aIndex)
	{ ;return iRep[aIndex];}
template <class T,TInt S>
inline const T& TFixedArray<T,S>::operator[](TInt aIndex) const
	{return (const_cast< ThisClass& >( *this )) [aIndex];}
template <class T,TInt S>
inline T& TFixedArray<T,S>::At(TInt aIndex)
	{(void)(( InRange(aIndex) )||( PanicTFixedArray() ,0)) ;return iRep[aIndex];}
template <class T,TInt S>
inline const T& TFixedArray<T,S>::At(TInt aIndex) const
	{return (const_cast< ThisClass& >( *this )) .At(aIndex);}
template <class T,TInt S>
inline T* TFixedArray<T,S>::Begin()
	{return &iRep[0];}
template <class T,TInt S>
inline T* TFixedArray<T,S>::End()
	{return &iRep[S];}
template <class T,TInt S>
inline const T* TFixedArray<T,S>::Begin() const
	{return &iRep[0];}
template <class T,TInt S>
inline const T* TFixedArray<T,S>::End() const
	{return &iRep[S];}
template <class T,TInt S>
inline TInt TFixedArray<T,S>::CountFunctionR(const CBase*)
	{return S;}
template <class T,TInt S>
inline const TAny* TFixedArray<T,S>::AtFunctionR(const CBase* aThis,TInt aIndex)
	{return & (reinterpret_cast< const ThisClass& >( *aThis )) [aIndex];}
template <class T,TInt S>
inline TArray<T> TFixedArray<T,S>::Array() const
	{return TArray<T>(CountFunctionR,AtFunctionR,(reinterpret_cast< const CBase* >( this )) );}
template <class T,TInt S>
inline void TFixedArray<T,S>::DeleteAll()
	{_ArrayUtil<T>::Delete(iRep,S);}

 
template <class T>
inline TIdentityRelation<T>::TIdentityRelation( TBool(*anIdentity)(const T&, const T&) )
	{ iIdentity=(TGeneralIdentityRelation)anIdentity; }
template <class T>
inline TIdentityRelation<T>::operator TGeneralIdentityRelation() const
	{ return iIdentity; }

 
template <class T>
inline TLinearOrder<T>::TLinearOrder( TInt(*anOrder)(const T&, const T&) )
	{ iOrder=(TGeneralLinearOrder)anOrder; }
template <class T>
inline TLinearOrder<T>::operator TGeneralLinearOrder() const
	{ return iOrder; }

 
template <class T>
inline RPointerArray<T>::RPointerArray()
	: RPointerArrayBase()
	{}
template <class T>
inline RPointerArray<T>::RPointerArray(TInt aGranularity)
	: RPointerArrayBase(aGranularity)
	{}
template <class T>
inline RPointerArray<T>::RPointerArray(T** aEntries, TInt aCount)
	: RPointerArrayBase((TAny **)aEntries, aCount)
	{}
template <class T>
inline void RPointerArray<T>::Close()
	{RPointerArrayBase::Close();}
template <class T>
inline TInt RPointerArray<T>::Count() const
	{ return RPointerArrayBase::Count(); }
template <class T>
inline T* const& RPointerArray<T>::operator[](TInt anIndex) const
	{return (T* const&)At(anIndex);}
template <class T>
inline T*& RPointerArray<T>::operator[](TInt anIndex)
	{return (T*&)At(anIndex);}
template <class T>
inline TInt RPointerArray<T>::Append(const T* anEntry)
	{ return RPointerArrayBase::Append(anEntry); }
template <class T>
inline TInt RPointerArray<T>::Insert(const T* anEntry, TInt aPos)
	{ return RPointerArrayBase::Insert(anEntry,aPos); }
template <class T>
inline void RPointerArray<T>::Remove(TInt anIndex)
	{RPointerArrayBase::Remove(anIndex);}
template <class T>
inline void RPointerArray<T>::Compress()
	{RPointerArrayBase::Compress();}
template <class T>
inline void RPointerArray<T>::GranularCompress()
	{RPointerArrayBase::GranularCompress();}
template <class T>
inline void RPointerArray<T>::Reset()
	{RPointerArrayBase::Reset();}
template <class T>
inline TInt RPointerArray<T>::Find(const T* anEntry) const
	{ return RPointerArrayBase::Find(anEntry); }
template <class T>
inline TInt RPointerArray<T>::Find(const T* anEntry, TIdentityRelation<T> anIdentity) const
	{ return RPointerArrayBase::Find(anEntry,anIdentity); }
template <class T>
inline TInt RPointerArray<T>::FindInAddressOrder(const T* anEntry) const
	{ return RPointerArrayBase::FindIsqUnsigned((TUint)anEntry); }
template <class T>
inline TInt RPointerArray<T>::FindInOrder(const T* anEntry, TLinearOrder<T> anOrder) const
	{ return RPointerArrayBase::FindIsq(anEntry,anOrder); }
template <class T>
inline TInt RPointerArray<T>::FindInAddressOrder(const T* anEntry, TInt& anIndex) const
	{ return RPointerArrayBase::BinarySearchUnsigned((TUint)anEntry,anIndex); }
template <class T>
inline TInt RPointerArray<T>::FindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{ return RPointerArrayBase::BinarySearch(anEntry,anIndex,anOrder); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInAddressOrder(const T* anEntry, TInt aMode) const
	{ return RPointerArrayBase::FindIsqUnsigned((TUint)anEntry, aMode); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInOrder(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const
	{ return RPointerArrayBase::FindIsq(anEntry,anOrder,aMode); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInAddressOrder(const T* anEntry, TInt& anIndex, TInt aMode) const
	{ return RPointerArrayBase::BinarySearchUnsigned((TUint)anEntry,anIndex,aMode); }
template <class T>
inline TInt RPointerArray<T>::SpecificFindInOrder(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
	{ return RPointerArrayBase::BinarySearch(anEntry,anIndex,anOrder,aMode); }
template <class T>
inline TInt RPointerArray<T>::InsertInAddressOrder(const T* anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned((TUint)anEntry,EFalse); }
template <class T>
inline TInt RPointerArray<T>::InsertInOrder(const T* anEntry, TLinearOrder<T> anOrder)
	{ return RPointerArrayBase::InsertIsq(anEntry,anOrder,EFalse); }
template <class T>
inline TInt RPointerArray<T>::InsertInAddressOrderAllowRepeats(const T* anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned((TUint)anEntry,ETrue); }
template <class T>
inline TInt RPointerArray<T>::InsertInOrderAllowRepeats(const T* anEntry, TLinearOrder<T> anOrder)
	{ return RPointerArrayBase::InsertIsq(anEntry,anOrder,ETrue); }
template <class T>
inline void RPointerArray<T>::SortIntoAddressOrder()
	{ HeapSortUnsigned(); }
template <class T>
inline void RPointerArray<T>::Sort(TLinearOrder<T> anOrder)
	{ HeapSort(anOrder); }
template <class T>
inline TArray<T*> RPointerArray<T>::Array() const
	{ return TArray<T*>(GetCount,GetElementPtr,(const CBase*)this); }

template <class T>
void RPointerArray<T>::ResetAndDestroy()
	{
	TInt c=Count();
	T** pE=(T**)Entries();
	ZeroCount();
	TInt i;
	for (i=0; i<c; i++)
		{
		delete *pE;
		pE++;
		}
	Reset();
	}

template <class T>
inline RArray<T>::RArray()
	: RArrayBase(sizeof(T))
	{}
template <class T>
inline RArray<T>::RArray(TInt aGranularity)
	: RArrayBase(sizeof(T),aGranularity)
	{}
template <class T>
inline RArray<T>::RArray(TInt aGranularity, TInt aKeyOffset)
	: RArrayBase(sizeof(T),aGranularity,aKeyOffset)
	{}
template <class T>
inline RArray<T>::RArray(TInt aEntrySize,T* aEntries, TInt aCount)
	: RArrayBase(aEntrySize,aEntries,aCount)
	{}
template <class T>
inline void RArray<T>::Close()
	{RArrayBase::Close();}
template <class T>
inline TInt RArray<T>::Count() const
	{return RArrayBase::Count();}
template <class T>
inline const T& RArray<T>::operator[](TInt anIndex) const
	{return *(const T*)At(anIndex); }
template <class T>
inline T& RArray<T>::operator[](TInt anIndex)
	{return *(T*)At(anIndex); }
template <class T>
inline TInt RArray<T>::Append(const T& anEntry)
	{return RArrayBase::Append(&anEntry);}
template <class T>
inline TInt RArray<T>::Insert(const T& anEntry, TInt aPos)
	{return RArrayBase::Insert(&anEntry,aPos);}
template <class T>
inline void RArray<T>::Remove(TInt anIndex)
	{RArrayBase::Remove(anIndex);}
template <class T>
inline void RArray<T>::Compress()
	{RArrayBase::Compress();}
template <class T>
inline void RArray<T>::GranularCompress()
	{RArrayBase::GranularCompress();}
template <class T>
inline void RArray<T>::Reset()
	{RArrayBase::Reset();}
template <class T>
inline TInt RArray<T>::Find(const T& anEntry) const
	{return RArrayBase::Find(&anEntry);}
template <class T>
inline TInt RArray<T>::Find(const T& anEntry, TIdentityRelation<T> anIdentity) const
	{return RArrayBase::Find(&anEntry,anIdentity);}
template <class T>
inline TInt RArray<T>::FindInSignedKeyOrder(const T& anEntry) const
	{return RArrayBase::FindIsqSigned(&anEntry);}
template <class T>
inline TInt RArray<T>::FindInUnsignedKeyOrder(const T& anEntry) const
	{return RArrayBase::FindIsqUnsigned(&anEntry);}
template <class T>
inline TInt RArray<T>::FindInOrder(const T& anEntry, TLinearOrder<T> anOrder) const
	{return RArrayBase::FindIsq(&anEntry,anOrder);}
template <class T>
inline TInt RArray<T>::FindInSignedKeyOrder(const T& anEntry, TInt& anIndex) const
	{return RArrayBase::BinarySearchSigned(&anEntry,anIndex);}
template <class T>
inline TInt RArray<T>::FindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex) const
	{return RArrayBase::BinarySearchUnsigned(&anEntry,anIndex);}
template <class T>
inline TInt RArray<T>::FindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{return RArrayBase::BinarySearch(&anEntry,anIndex,anOrder);}
template <class T>
inline TInt RArray<T>::SpecificFindInSignedKeyOrder(const T& anEntry, TInt aMode) const
 	{return RArrayBase::FindIsqSigned(&anEntry,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt aMode) const
 	{return RArrayBase::FindIsqUnsigned(&anEntry,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInOrder(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const
 	{return RArrayBase::FindIsq(&anEntry,anOrder,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInSignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const
 	{return RArrayBase::BinarySearchSigned(&anEntry,anIndex,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInUnsignedKeyOrder(const T& anEntry, TInt& anIndex, TInt aMode) const
 	{return RArrayBase::BinarySearchUnsigned(&anEntry,anIndex,aMode);}
template <class T>
inline TInt RArray<T>::SpecificFindInOrder(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
 	{return RArrayBase::BinarySearch(&anEntry,anIndex,anOrder,aMode);}
template <class T>
inline TInt RArray<T>::InsertInSignedKeyOrder(const T& anEntry)
	{return RArrayBase::InsertIsqSigned(&anEntry,EFalse);}
template <class T>
inline TInt RArray<T>::InsertInUnsignedKeyOrder(const T& anEntry)
	{return RArrayBase::InsertIsqUnsigned(&anEntry,EFalse);}
template <class T>
inline TInt RArray<T>::InsertInOrder(const T& anEntry, TLinearOrder<T> anOrder)
	{return RArrayBase::InsertIsq(&anEntry,anOrder,EFalse);}
template <class T>
inline TInt RArray<T>::InsertInSignedKeyOrderAllowRepeats(const T& anEntry)
	{return RArrayBase::InsertIsqSigned(&anEntry,ETrue);}
template <class T>
inline TInt RArray<T>::InsertInUnsignedKeyOrderAllowRepeats(const T& anEntry)
	{return RArrayBase::InsertIsqUnsigned(&anEntry,ETrue);}
template <class T>
inline TInt RArray<T>::InsertInOrderAllowRepeats(const T& anEntry, TLinearOrder<T> anOrder)
	{return RArrayBase::InsertIsq(&anEntry,anOrder,ETrue);}
template <class T>
inline void RArray<T>::SortSigned()
	{HeapSortSigned();}
template <class T>
inline void RArray<T>::SortUnsigned()
	{HeapSortUnsigned();}
template <class T>
inline void RArray<T>::Sort(TLinearOrder<T> anOrder)
	{HeapSort(anOrder);}
template <class T>
inline TArray<T> RArray<T>::Array() const
	{ return TArray<T>(GetCount,GetElementPtr,(const CBase*)this); }

inline RArray<TInt>::RArray()
	: RPointerArrayBase()
	{}
inline RArray<TInt>::RArray(TInt aGranularity)
	: RPointerArrayBase(aGranularity)
	{}
inline void RArray<TInt>::Close()
	{RPointerArrayBase::Close();}
inline TInt RArray<TInt>::Count() const
	{ return RPointerArrayBase::Count(); }
inline const TInt& RArray<TInt>::operator[](TInt anIndex) const
	{return (const TInt&)At(anIndex);}
inline TInt& RArray<TInt>::operator[](TInt anIndex)
	{return (TInt&)At(anIndex);}
inline TInt RArray<TInt>::Append(TInt anEntry)
	{ return RPointerArrayBase::Append((const TAny*)anEntry); }
inline TInt RArray<TInt>::Insert(TInt anEntry, TInt aPos)
	{ return RPointerArrayBase::Insert((const TAny*)anEntry,aPos); }
inline void RArray<TInt>::Remove(TInt anIndex)
	{RPointerArrayBase::Remove(anIndex);}
inline void RArray<TInt>::Compress()
	{RPointerArrayBase::Compress();}
inline void RArray<TInt>::GranularCompress()
	{RPointerArrayBase::GranularCompress();}
inline void RArray<TInt>::Reset()
	{RPointerArrayBase::Reset();}
inline TInt RArray<TInt>::Find(TInt anEntry) const
	{ return RPointerArrayBase::Find((const TAny*)anEntry); }
inline TInt RArray<TInt>::FindInOrder(TInt anEntry) const
	{ return RPointerArrayBase::FindIsqSigned(anEntry); }
inline TInt RArray<TInt>::FindInOrder(TInt anEntry, TInt& anIndex) const
	{ return RPointerArrayBase::BinarySearchSigned(anEntry,anIndex); }
inline TInt RArray<TInt>::SpecificFindInOrder(TInt anEntry, TInt aMode) const
 	{ return RPointerArrayBase::FindIsqSigned(anEntry,aMode); }
inline TInt RArray<TInt>::SpecificFindInOrder(TInt anEntry, TInt& anIndex, TInt aMode) const
 	{ return RPointerArrayBase::BinarySearchSigned(anEntry,anIndex,aMode); }
inline TInt RArray<TInt>::InsertInOrder(TInt anEntry)
	{ return RPointerArrayBase::InsertIsqSigned(anEntry,EFalse); }
inline TInt RArray<TInt>::InsertInOrderAllowRepeats(TInt anEntry)
	{ return RPointerArrayBase::InsertIsqSigned(anEntry,ETrue); }
inline void RArray<TInt>::Sort()
	{ HeapSortSigned(); }
inline TArray<TInt> RArray<TInt>::Array() const
	{ return TArray<TInt>(GetCount,GetElementPtr,(const CBase*)this); }

inline RArray<TUint>::RArray()
	: RPointerArrayBase()
	{}
inline RArray<TUint>::RArray(TInt aGranularity)
	: RPointerArrayBase(aGranularity)
	{}
inline void RArray<TUint>::Close()
	{RPointerArrayBase::Close();}
inline TInt RArray<TUint>::Count() const
	{return RPointerArrayBase::Count(); }
inline const TUint& RArray<TUint>::operator[](TInt anIndex) const
	{return (const TUint&)At(anIndex);}
inline TUint& RArray<TUint>::operator[](TInt anIndex)
	{return (TUint&)At(anIndex);}
inline TInt RArray<TUint>::Append(TUint anEntry)
	{ return RPointerArrayBase::Append((const TAny*)anEntry); }
inline TInt RArray<TUint>::Insert(TUint anEntry, TInt aPos)
	{ return RPointerArrayBase::Insert((const TAny*)anEntry,aPos); }
inline void RArray<TUint>::Remove(TInt anIndex)
	{RPointerArrayBase::Remove(anIndex);}
inline void RArray<TUint>::Compress()
	{RPointerArrayBase::Compress();}
inline void RArray<TUint>::Reset()
	{RPointerArrayBase::Reset();}
inline TInt RArray<TUint>::Find(TUint anEntry) const
	{ return RPointerArrayBase::Find((const TAny*)anEntry); }
inline TInt RArray<TUint>::FindInOrder(TUint anEntry) const
	{ return RPointerArrayBase::FindIsqUnsigned(anEntry); }
inline TInt RArray<TUint>::FindInOrder(TUint anEntry, TInt& anIndex) const
	{ return RPointerArrayBase::BinarySearchUnsigned(anEntry,anIndex); }
inline TInt RArray<TUint>::SpecificFindInOrder(TUint anEntry, TInt aMode) const
 	{ return RPointerArrayBase::FindIsqUnsigned(anEntry,aMode); }
inline TInt RArray<TUint>::SpecificFindInOrder(TUint anEntry, TInt& anIndex, TInt aMode) const
 	{ return RPointerArrayBase::BinarySearchUnsigned(anEntry,anIndex,aMode); }
inline TInt RArray<TUint>::InsertInOrder(TUint anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned(anEntry,EFalse); }
inline TInt RArray<TUint>::InsertInOrderAllowRepeats(TUint anEntry)
	{ return RPointerArrayBase::InsertIsqUnsigned(anEntry,ETrue); }
inline void RArray<TUint>::Sort()
	{ HeapSortUnsigned(); }
inline TArray<TUint> RArray<TUint>::Array() const
	{ return TArray<TUint>(GetCount,GetElementPtr,(const CBase*)this); }



inline void TIpcArgs::Set(TInt,TNothing)
 








	{}
inline void TIpcArgs::Set(TInt aIndex,TInt aValue)
 








	{
	iArgs[aIndex] = aValue;
	iFlags |= EUnspecified<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,const TAny* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EUnspecified<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,const TDesC8* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDesC8<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,const TDesC16* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDesC16<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,TDes8* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDes8<<(aIndex*KBitsPerType);
	}
inline void TIpcArgs::Set(TInt aIndex,TDes16* aValue)
 








	{
	iArgs[aIndex] = (TInt)aValue;
	iFlags |= EDes16<<(aIndex*KBitsPerType);
	}
inline TIpcArgs::TArgType TIpcArgs::Type(TNothing)
	{ return EUnspecified; }
inline TIpcArgs::TArgType TIpcArgs::Type(TInt)
	{ return EUnspecified; }
inline TIpcArgs::TArgType TIpcArgs::Type(const TAny*)
	{ return EUnspecified; }
inline TIpcArgs::TArgType TIpcArgs::Type(const TDesC8*)
	{ return EDesC8; }
inline TIpcArgs::TArgType TIpcArgs::Type(const TDesC16*)
	{ return EDesC16; }
inline TIpcArgs::TArgType TIpcArgs::Type(TDes8*)
	{ return EDes8; }
inline TIpcArgs::TArgType TIpcArgs::Type(TDes16*)
	{ return EDes16; }
inline void TIpcArgs::Assign(TInt&,TIpcArgs::TNothing)
	{}
inline void TIpcArgs::Assign(TInt& aArg,TInt aValue)
	{ aArg = aValue; }
inline void TIpcArgs::Assign(TInt& aArg,const TAny* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,const TDesC8* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,const TDesC16* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,TDes8* aValue)
	{ aArg = (TInt)aValue; }
inline void TIpcArgs::Assign(TInt& aArg,TDes16* aValue)
	{ aArg = (TInt)aValue; }

 
 
 
inline TSecureId::TSecureId()
	{}
inline TSecureId::TSecureId(TUint32 aId)
	: iId(aId) {}
inline TSecureId::operator TUint32() const
	{ return iId; }
inline TSecureId::TSecureId(TUid aId)
	: iId(aId.iUid) {}
inline TSecureId::operator TUid() const
	{ return (TUid&)iId; }

 
 
 
inline const TSecureId* SSecureId::operator&() const
	{ return (const TSecureId*)this; }
inline SSecureId::operator const TSecureId&() const
	{ return (const TSecureId&)iId; }
inline SSecureId::operator TUint32() const
	{ return iId; }
inline SSecureId::operator TUid() const
	{ return (TUid&)iId; }

 
 
 
inline TVendorId::TVendorId()
	{}
inline TVendorId::TVendorId(TUint32 aId)
	: iId(aId) {}
inline TVendorId::operator TUint32() const
	{ return iId; }
inline TVendorId::TVendorId(TUid aId)
	: iId(aId.iUid) {}
inline TVendorId::operator TUid() const
	{ return (TUid&)iId; }

 
 
 
inline const TVendorId* SVendorId::operator&() const
	{ return (const TVendorId*)this; }
inline SVendorId::operator const TVendorId&() const
	{ return (const TVendorId&)iId; }
inline SVendorId::operator TUint32() const
	{ return iId; }
inline SVendorId::operator TUid() const
	{ return (TUid&)iId; }

 


inline TSecurityPolicy::TSecurityPolicy()
	{ new (this) TSecurityPolicy(EAlwaysFail); }

 
 
 
inline const TSecurityPolicy* SSecurityPolicyV1C7::operator&() const
	{ return (const TSecurityPolicy*)this; }
inline SSecurityPolicyV1C7::operator const TSecurityPolicy&() const
	{ return *(const TSecurityPolicy*)this; }
inline const TSecurityPolicy& SSecurityPolicyV1C7::operator()() const
	{ return *(const TSecurityPolicy*)this; }
inline const TSecurityPolicy* SSecurityPolicyV1SVC3::operator&() const
	{ return (const TSecurityPolicy*)this; }
inline SSecurityPolicyV1SVC3::operator const TSecurityPolicy&() const
	{ return *(const TSecurityPolicy*)this; }
inline const TSecurityPolicy& SSecurityPolicyV1SVC3::operator()() const
	{ return *(const TSecurityPolicy*)this; }


inline TBool SSecurityPolicyV1C7::CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aProcess, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1C7::CheckPolicy(RThread aThread, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aThread, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1C7::CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aMsgPtr, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1SVC3::CheckPolicy(RProcess aProcess, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aProcess, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1SVC3::CheckPolicy(RThread aThread, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aThread, aDiagnosticMessage); }
inline TBool SSecurityPolicyV1SVC3::CheckPolicy(RMessagePtr2 aMsgPtr, const char* aDiagnosticMessage) const
	{ return ((TSecurityPolicy*)this)->CheckPolicy(aMsgPtr, aDiagnosticMessage); }

 







inline TBool TSecurityPolicy::CheckPolicy(RProcess  , const char*  ) const
	{ return ETrue; }

 









inline TBool TSecurityPolicy::CheckPolicy(RThread  , const char*  ) const
	{ return ETrue; }

 








inline TBool TSecurityPolicy::CheckPolicy(RMessagePtr2  , const char*  ) const
	{ return ETrue; }

 
 
 

inline TBool PlatSec::IsCapabilityEnforced(TCapability  )
	{ return 0; }
inline TInt PlatSec::ConfigSetting(TConfigSetting  )
	{ return 0; }



 





template <class T>
inline void RPointerArray<T>::AppendL(const T* anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 











template <class T>
inline void RPointerArray<T>::InsertL(const T* anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry,aPos)); }


 












template <class T>
inline TInt RPointerArray<T>::FindL(const T* anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 
















template <class T>
inline TInt RPointerArray<T>::FindL(const T* anEntry, TIdentityRelation<T> anIdentity) const
	{ return User::LeaveIfError(Find(anEntry, anIdentity));}


 










template <class T>
inline TInt RPointerArray<T>::FindInAddressOrderL(const T* anEntry) const
	{ return User::LeaveIfError(FindInAddressOrder(anEntry));}


 














template <class T>
inline TInt RPointerArray<T>::FindInOrderL(const T* anEntry, TLinearOrder<T> anOrder) const
	{ return User::LeaveIfError(FindInOrder(anEntry, anOrder));}


 
















template <class T>
inline void RPointerArray<T>::FindInAddressOrderL(const T* anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInAddressOrder(anEntry, anIndex)); }


 




















template <class T>
inline void RPointerArray<T>::FindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex, anOrder)); }


 
















template <class T>
inline TInt RPointerArray<T>::SpecificFindInAddressOrderL(const T* anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInAddressOrder(anEntry, aMode));}


 





















template <class T>
inline TInt RPointerArray<T>::SpecificFindInOrderL(const T* anEntry, TLinearOrder<T> anOrder, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInOrder(anEntry, anOrder, aMode));}


 



















template <class T>
inline void RPointerArray<T>::SpecificFindInAddressOrderL(const T* anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInAddressOrder(anEntry, anIndex, aMode)); }


 
























template <class T>
inline void RPointerArray<T>::SpecificFindInOrderL(const T* anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, anOrder, aMode)); }


 








template <class T>
inline void RPointerArray<T>::InsertInAddressOrderL(const T* anEntry)
	{ User::LeaveIfError(InsertInAddressOrder(anEntry)); }


 
















template <class T>
inline void RPointerArray<T>::InsertInOrderL(const T* anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrder(anEntry, anOrder)); }


 













template <class T>
inline void RPointerArray<T>::InsertInAddressOrderAllowRepeatsL(const T* anEntry)
	{ User::LeaveIfError(InsertInAddressOrderAllowRepeats(anEntry)); }


 
















template <class T>
inline void RPointerArray<T>::InsertInOrderAllowRepeatsL(const T* anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry, anOrder)); }


 





template <class T>
inline void RArray<T>::AppendL(const T& anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 












template <class T>
inline void RArray<T>::InsertL(const T& anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry, aPos));}


 














template <class T>
inline TInt RArray<T>::FindL(const T& anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 

















template <class T>
inline TInt RArray<T>::FindL(const T& anEntry, TIdentityRelation<T> anIdentity) const
	{ return User::LeaveIfError(Find(anEntry, anIdentity));}


 











template <class T>
inline TInt RArray<T>::FindInSignedKeyOrderL(const T& anEntry) const
	{ return User::LeaveIfError(FindInSignedKeyOrder(anEntry));}


 











template <class T>
inline TInt RArray<T>::FindInUnsignedKeyOrderL(const T& anEntry) const
	{ return User::LeaveIfError(FindInUnsignedKeyOrder(anEntry));}


 














template <class T>
inline TInt RArray<T>::FindInOrderL(const T& anEntry, TLinearOrder<T> anOrder) const
{ return User::LeaveIfError(FindInOrder(anEntry, anOrder));}


 













template <class T>
inline void RArray<T>::FindInSignedKeyOrderL(const T& anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInSignedKeyOrder(anEntry, anIndex));}


 













template <class T>
inline void RArray<T>::FindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInUnsignedKeyOrder(anEntry, anIndex));}


 
















template <class T>
inline void RArray<T>::FindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex, anOrder));}


 


















template <class T>
inline TInt RArray<T>::SpecificFindInSignedKeyOrderL(const T& anEntry, TInt aMode) const
{ return User::LeaveIfError(SpecificFindInSignedKeyOrder(anEntry, aMode));}


 


















template <class T>
inline TInt RArray<T>::SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInUnsignedKeyOrder(anEntry, aMode));}


 



















template <class T>
inline TInt RArray<T>::SpecificFindInOrderL(const T& anEntry, TLinearOrder<T> anOrder, TInt aMode) const
{ return User::LeaveIfError(SpecificFindInOrder(anEntry, anOrder, aMode));}


 




















template <class T>
inline void RArray<T>::SpecificFindInSignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInSignedKeyOrder(anEntry, anIndex, aMode));}


 




















template <class T>
inline void RArray<T>::SpecificFindInUnsignedKeyOrderL(const T& anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInUnsignedKeyOrder(anEntry, anIndex, aMode));}


 






















template <class T>
inline void RArray<T>::SpecificFindInOrderL(const T& anEntry, TInt& anIndex, TLinearOrder<T> anOrder, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, anOrder, aMode));}


 










template <class T>
inline void RArray<T>::InsertInSignedKeyOrderL(const T& anEntry)
	{ User::LeaveIfError(InsertInSignedKeyOrder(anEntry));}


 









template <class T>
inline void RArray<T>::InsertInUnsignedKeyOrderL(const T& anEntry)
	{ User::LeaveIfError(InsertInUnsignedKeyOrder(anEntry));}


 















template <class T>
inline void RArray<T>::InsertInOrderL(const T& anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrder(anEntry, anOrder));}


 














template <class T>
inline void RArray<T>::InsertInSignedKeyOrderAllowRepeatsL(const T& anEntry)
	{ User::LeaveIfError(InsertInSignedKeyOrderAllowRepeats(anEntry));}


 














template <class T>
inline void RArray<T>::InsertInUnsignedKeyOrderAllowRepeatsL(const T& anEntry)
	{ User::LeaveIfError(InsertInUnsignedKeyOrderAllowRepeats(anEntry));}


 

















template <class T>
inline void RArray<T>::InsertInOrderAllowRepeatsL(const T& anEntry, TLinearOrder<T> anOrder)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry, anOrder));}


 





inline void RArray<TInt>::AppendL(TInt anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 











inline void RArray<TInt>::InsertL(TInt anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry, aPos));}


 










inline TInt RArray<TInt>::FindL(TInt anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 









inline TInt RArray<TInt>::FindInOrderL(TInt anEntry) const
	{ return User::LeaveIfError(FindInOrder(anEntry));}


 













inline void RArray<TInt>::FindInOrderL(TInt anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex));}


 
















inline TInt RArray<TInt>::SpecificFindInOrderL(TInt anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInOrder(anEntry, aMode));}


 


















inline void RArray<TInt>::SpecificFindInOrderL(TInt anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, aMode));}


 








inline void RArray<TInt>::InsertInOrderL(TInt anEntry)
	{ User::LeaveIfError(InsertInOrder(anEntry));}


 












inline void RArray<TInt>::InsertInOrderAllowRepeatsL(TInt anEntry)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry));}


 





inline void RArray<TUint>::AppendL(TUint anEntry)
	{ User::LeaveIfError(Append(anEntry));}


 












inline void RArray<TUint>::InsertL(TUint anEntry, TInt aPos)
	{ User::LeaveIfError(Insert(anEntry, aPos));}


 









inline TInt RArray<TUint>::FindL(TUint anEntry) const
	{ return User::LeaveIfError(Find(anEntry));}


 











inline TInt RArray<TUint>::FindInOrderL(TUint anEntry) const
	{ return User::LeaveIfError(FindInOrder(anEntry));}


 
















inline void RArray<TUint>::FindInOrderL(TUint anEntry, TInt& anIndex) const
	{ User::LeaveIfError(FindInOrder(anEntry, anIndex));}


 
















inline TInt RArray<TUint>::SpecificFindInOrderL(TUint anEntry, TInt aMode) const
	{ return User::LeaveIfError(SpecificFindInOrder(anEntry, aMode));}


 


















inline void RArray<TUint>::SpecificFindInOrderL(TUint anEntry, TInt& anIndex, TInt aMode) const
	{ User::LeaveIfError(SpecificFindInOrder(anEntry, anIndex, aMode));}


 








inline void RArray<TUint>::InsertInOrderL(TUint anEntry)
	{ User::LeaveIfError(InsertInOrder(anEntry));}


 













inline void RArray<TUint>::InsertInOrderAllowRepeatsL(TUint anEntry)
	{ User::LeaveIfError(InsertInOrderAllowRepeats(anEntry));}


 




inline void RMessagePtr2::SetProcessPriorityL(TProcessPriority aPriority) const
	{ User::LeaveIfError(SetProcessPriority(aPriority));}


 







inline void RMessagePtr2::ClientL(RThread& aClient, TOwnerType aOwnerType) const
	{ User::LeaveIfError(Client(aClient, aOwnerType));}


inline void RMessagePtr2::HasCapabilityL(TCapability  ,const char*  ) const
	{}

inline void RMessagePtr2::HasCapabilityL(TCapability  ,TCapability  ,const char*  ) const
	{}
# 5503 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32std.h" 2



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.h" 2


 


class CBase
	{
public:
	  virtual ~CBase();
	inline TAny* operator new(TUint aSize,TAny *aBase);
	  TAny* operator new(TUint aSize);
	inline TAny* operator new(TUint aSize, TLeave);
	  TAny* operator new(TUint aSize,TUint anExtraSize);
	inline TAny* operator new(TUint aSize, TLeave, TUint aExtraSize);
protected:
	  CBase();
private:
	CBase(const CBase&);
	CBase& operator=(const CBase&);
	  static TAny* newL(TUint aSize);
	};
 
class CBufBase : public CBase
	{
public:
	  ~CBufBase();
	inline TInt Size() const;
	  void Reset();
	  void Read(TInt aPos,TDes8& aDes) const;
	  void Read(TInt aPos,TDes8& aDes,TInt aLength) const;
	  void Read(TInt aPos,TAny* aPtr,TInt aLength) const;
	  void Write(TInt aPos,const TDesC8& aDes);
	  void Write(TInt aPos,const TDesC8& aDes,TInt aLength);
	  void Write(TInt aPos,const TAny* aPtr,TInt aLength);
	  void InsertL(TInt aPos,const TDesC8& aDes);
	  void InsertL(TInt aPos,const TDesC8& aDes,TInt aLength);
	  void InsertL(TInt aPos,const TAny* aPtr,TInt aLength);
	  void ExpandL(TInt aPos,TInt aLength);
	  void ResizeL(TInt aSize);
 
    virtual void Compress()=0;
	virtual void Delete(TInt aPos,TInt aLength)=0;
	virtual TPtr8 Ptr(TInt aPos)=0;
	virtual TPtr8 BackPtr(TInt aPos)=0;
private:
	virtual void DoInsertL(TInt aPos,const TAny* aPtr,TInt aLength)=0;
protected:
	  CBufBase(TInt anExpandSize);
protected:
	TInt iSize;
	TInt iExpandSize;
	};
 
class CBufFlat : public CBufBase
	{
public:
	  ~CBufFlat();
	  static CBufFlat* NewL(TInt anExpandSize);
	inline TInt Capacity() const;
	  void SetReserveL(TInt aSize);
	  void Compress();
	  void Delete(TInt aPos,TInt aLength);
	  TPtr8 Ptr(TInt aPos);
	  TPtr8 BackPtr(TInt aPos);
protected:
	  CBufFlat(TInt anExpandSize);
private:
	  void DoInsertL(TInt aPos,const TAny* aPtr,TInt aLength);
private:
	TInt iMaxSize;
	TUint8* iPtr;
	};
 
class TBufSegLink;
class CBufSeg : public CBufBase
	{
public:
	  ~CBufSeg();
	  static CBufSeg* NewL(TInt anExpandSize);
      void Compress();
	  void Delete(TInt aPos,TInt aLength);
	  TPtr8 Ptr(TInt aPos);
	  TPtr8 BackPtr(TInt aPos);
protected:
	  CBufSeg(TInt anExpandSize);
	void InsertIntoSegment(TBufSegLink* aSeg,TInt anOffset,const TAny* aPtr,TInt aLength);
	void DeleteFromSegment(TBufSegLink* aSeg,TInt anOffset,TInt aLength);
	void FreeSegment(TBufSegLink* aSeg);
    void SetSBO(TInt aPos);
	void AllocSegL(TBufSegLink* aSeg,TInt aNumber);
private:
	  void DoInsertL(TInt aPos,const TAny* aPtr,TInt aLength);
private:
    TDblQue<TBufSegLink> iQue;
	TBufSegLink* iSeg;
	TInt iBase;
	TInt iOffset;
	};
 
class TKeyArrayFix : public TKey
	{
public:
	  TKeyArrayFix(TInt anOffset,TKeyCmpText aType);
	  TKeyArrayFix(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKeyArrayFix(TInt anOffset,TKeyCmpNumeric aType);
protected:
	  virtual void Set(CBufBase* aBase,TInt aRecordLength);
	  TAny* At(TInt anIndex) const;
protected:
	TInt iRecordLength;
	CBufBase* iBase;
	friend class CArrayFixBase;
	};
 
typedef CBufBase*(*TBufRep)(TInt anExpandSize);
class CArrayFixBase : public CBase
	{
public:
	  ~CArrayFixBase();
	inline TInt Count() const;
	inline TInt Length() const;
	  void Compress();
	  void Reset();
	  TInt Sort(TKeyArrayFix& aKey);
	  TAny* At(TInt anIndex) const;
	  TAny* End(TInt anIndex) const;
	  TAny* Back(TInt anIndex) const;
	  void Delete(TInt anIndex);
	  void Delete(TInt anIndex,TInt aCount);
	  TAny* ExpandL(TInt anIndex);
	  TInt Find(const TAny* aPtr,TKeyArrayFix& aKey,TInt& anIndex) const;
	  TInt FindIsq(const TAny* aPtr,TKeyArrayFix& aKey,TInt& anIndex) const;
	  void InsertL(TInt anIndex,const TAny* aPtr);
	  void InsertL(TInt anIndex,const TAny* aPtr,TInt aCount);
	  TInt InsertIsqL(const TAny* aPtr,TKeyArrayFix& aKey);
	  TInt InsertIsqAllowDuplicatesL(const TAny* aPtr,TKeyArrayFix& aKey);
	  void ResizeL(TInt aCount,const TAny* aPtr);
protected:
	  CArrayFixBase(TBufRep aRep,TInt aRecordLength,TInt aGranularity);
	  void InsertRepL(TInt anIndex,const TAny* aPtr,TInt aReplicas);
	  void SetKey(TKeyArrayFix& aKey) const;
	  void SetReserveFlatL(TInt aCount);
	  static TInt CountR(const CBase* aPtr);
	  static const TAny* AtR(const CBase* aPtr,TInt anIndex);
private:
	TInt iCount;
	TInt iGranularity;
	TInt iLength;
	TBufRep iCreateRep;
	CBufBase* iBase;
	};
 
template <class T>
class CArrayFix : public CArrayFixBase
	{
public:
	inline CArrayFix(TBufRep aRep,TInt aGranularity);
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline const T& At(TInt anIndex) const;
	inline const T* End(TInt anIndex) const;
	inline const T* Back(TInt anIndex) const;
	inline T& At(TInt anIndex);
	inline T* End(TInt anIndex);
	inline T* Back(TInt anIndex);
	inline void AppendL(const T& aRef);
	inline void AppendL(const T* aPtr,TInt aCount);
	inline void AppendL(const T& aRef,TInt aReplicas);
	inline T& ExpandL(TInt anIndex);
	inline T& ExtendL();
	inline TInt Find(const T& aRef,TKeyArrayFix& aKey,TInt& anIndex) const;
	inline TInt FindIsq(const T& aRef,TKeyArrayFix& aKey,TInt& anIndex) const;
	inline void InsertL(TInt anIndex,const T& aRef);
	inline void InsertL(TInt anIndex,const T* aPtr,TInt aCount);
	inline void InsertL(TInt anIndex,const T& aRef,TInt aReplicas);
	inline TInt InsertIsqL(const T& aRef,TKeyArrayFix& aKey);
	inline TInt InsertIsqAllowDuplicatesL(const T& aRef,TKeyArrayFix& aKey);
	inline void ResizeL(TInt aCount);
	inline void ResizeL(TInt aCount,const T& aRef);
	inline const TArray<T> Array() const;
	};
  class CArrayFix<TAny> : public CArrayFixBase
	{
public:
	inline CArrayFix(TBufRep aRep,TInt aRecordLength,TInt aGranularity);
	inline const TAny* At(TInt anIndex) const;
	inline const TAny* End(TInt anIndex) const;
	inline const TAny* Back(TInt anIndex) const;
	inline TAny* At(TInt anIndex);
	inline TAny* End(TInt anIndex);
	inline TAny* Back(TInt anIndex);
	inline void AppendL(const TAny* aPtr);
	inline void AppendL(const TAny* aPtr,TInt aCount);
	inline TAny* ExtendL();
	};
 
template <class T>
class CArrayFixFlat : public CArrayFix<T>
	{
public:
	inline CArrayFixFlat(TInt aGranularity);
	inline void SetReserveL(TInt aCount);
	};
  class CArrayFixFlat<TAny> : public CArrayFix<TAny>
	{
public:
	inline CArrayFixFlat(TInt aRecordLength,TInt aGranularity);
	inline void SetReserveL(TInt aCount);
	};
  class CArrayFixFlat<TInt> : public CArrayFix<TInt>
	{
public:
	  CArrayFixFlat(TInt aGranularity);
	  ~CArrayFixFlat();
	inline void SetReserveL(TInt aCount);
	};
  class CArrayFixFlat<TUid> : public CArrayFix<TUid>
	{
public:
	  CArrayFixFlat(TInt aGranularity);
	  ~CArrayFixFlat();
	inline void SetReserveL(TInt aCount);
	};
 
template <class T>
class CArrayFixSeg : public CArrayFix<T>
	{
public:
	inline CArrayFixSeg(TInt aGranularity);
	};
  class CArrayFixSeg<TAny> : public CArrayFix<TAny>
	{
public:
	inline CArrayFixSeg(TInt aRecordLength,TInt aGranularity);
	};
 
template <class T>
class CArrayPtr : public CArrayFix<T*>
	{
public:
	inline CArrayPtr(TBufRep aRep,TInt aGranularity);
    void ResetAndDestroy();
	};
 
template <class T>
class CArrayPtrFlat : public CArrayPtr<T>
	{
public:
	inline CArrayPtrFlat(TInt aGranularity);
	inline void SetReserveL(TInt aCount);
	};
 
template <class T>
class CArrayPtrSeg : public CArrayPtr<T>
	{
public:
	inline CArrayPtrSeg(TInt aGranularity);
	};
 
class TKeyArrayVar : public TKey
	{
public:
	  TKeyArrayVar(TInt anOffset,TKeyCmpText aType);
	  TKeyArrayVar(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKeyArrayVar(TInt anOffset,TKeyCmpNumeric aType);
protected:
	  virtual void Set(CBufBase* aBase);
	  TAny* At(TInt anIndex) const;
protected:
	CBufBase* iBase;
	friend class CArrayVarBase;
	};
 
class CArrayVarBase : public CBase
	{
public:
	  ~CArrayVarBase();
	inline TInt Count() const;
	  TInt Length(TInt anIndex) const;
	  void Compress();
	  void Reset();
	  TInt Sort(TKeyArrayVar& aKey);
	  TAny* At(TInt anIndex) const;
	  void Delete(TInt anIndex);
	  void Delete(TInt anIndex,TInt aCount);
	  TAny* ExpandL(TInt anIndex,TInt aLength);
	  TInt Find(const TAny* aPtr,TKeyArrayVar& aKey,TInt& anIndex) const;
	  TInt FindIsq(const TAny* aPtr,TKeyArrayVar& aKey,TInt& anIndex) const;
	  void InsertL(TInt anIndex,const TAny* aPtr,TInt aLength);
	  TInt InsertIsqL(const TAny* aPtr,TInt aLength,TKeyArrayVar& aKey);
	  TInt InsertIsqAllowDuplicatesL(const TAny* aPtr,TInt aLength,TKeyArrayVar& aKey);
protected:
	  CArrayVarBase(TBufRep aRep,TInt aGranularity);
	  void SetKey(TKeyArrayVar& aKey) const;
	  static TInt CountR(const CBase* aPtr);
	  static const TAny* AtR(const CBase* aPtr,TInt anIndex);
private:
	TInt iCount;
	TInt iGranularity;
	TBufRep iCreateRep;
	CBufBase* iBase;
	};
 
template <class T>
class CArrayVar : public CArrayVarBase
	{
public:
	inline CArrayVar(TBufRep aRep,TInt aGranularity);
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline const T& At(TInt anIndex) const;
	inline T& At(TInt anIndex);
	inline void AppendL(const T& aRef,TInt aLength);
	inline T& ExpandL(TInt anIndex,TInt aLength);
	inline T& ExtendL(TInt aLength);
	inline TInt Find(const T& aRef,TKeyArrayVar& aKey,TInt& anIndex) const;
	inline TInt FindIsq(const T& aRef,TKeyArrayVar& aKey,TInt& anIndex) const;
	inline void InsertL(TInt anIndex,const T& aRef,TInt aLength);
	inline TInt InsertIsqL(const T& aRef,TInt aLength,TKeyArrayVar& aKey);
 	inline TInt InsertIsqAllowDuplicatesL(const T& aRef,TInt aLength,TKeyArrayVar& aKey);
	inline const TArray<T> Array() const;
	};
  class CArrayVar<TAny> : public CArrayVarBase
	{
public:
	inline CArrayVar(TBufRep aRep,TInt aGranularity);
	inline const TAny* At(TInt anIndex) const;
	inline TAny* At(TInt anIndex);
	inline void AppendL(const TAny* aPtr,TInt aLength);
	inline TAny* ExtendL(TInt aLength);
	};
 
template <class T>
class CArrayVarFlat : public CArrayVar<T>
	{
public:
	inline CArrayVarFlat(TInt aGranularity);
	};
 
template <class T>
class CArrayVarSeg : public CArrayVar<T>
	{
public:
	inline CArrayVarSeg(TInt aGranularity);
	};
 
class TKeyArrayPak : public TKeyArrayVar
	{
public:
	  TKeyArrayPak(TInt anOffset,TKeyCmpText aType);
	  TKeyArrayPak(TInt anOffset,TKeyCmpText aType,TInt aLength);
	  TKeyArrayPak(TInt anOffset,TKeyCmpNumeric aType);
protected:
	  virtual void Set(CBufBase* aBase);
	  TAny* At(TInt anIndex) const;
private:
	TInt iCacheIndex;
	TInt iCacheOffset;
	friend class CArrayPakBase;
	};
 
class CArrayPakBase : public CBase
	{
public:
	  ~CArrayPakBase();
	inline TInt Count() const;
	  TInt Length(TInt anIndex) const;
	  void Compress();
	  void Reset();
	  void SortL(TKeyArrayVar& aKey);
	  TAny* At(TInt anIndex) const;
	  void Delete(TInt anIndex);
	  void Delete(TInt anIndex,TInt aCount);
	  TAny* ExpandL(TInt anIndex,TInt aLength);
	  TInt Find(const TAny* aPtr,TKeyArrayPak& aKey,TInt& anIndex) const;
	  TInt FindIsq(const TAny* aPtr,TKeyArrayPak& aKey,TInt& anIndex) const;
	  void InsertL(TInt anIndex,const TAny* aPtr,TInt aLength);
	  TInt InsertIsqL(const TAny* aPtr,TInt aLength,TKeyArrayPak& aKey);
	  TInt InsertIsqAllowDuplicatesL(const TAny* aPtr,TInt aLength,TKeyArrayPak& aKey);
protected:
	  CArrayPakBase(TBufRep aRep,TInt aGranularity);
	  void SetKey(TKeyArrayPak& aKey) const;
	  TInt GetOffset(TInt anIndex) const;
	  void BuildVarArrayL(CArrayVarFlat<TAny>*& aVarFlat);
	  static TInt CountR(const CBase* aPtr);
	  static const TAny* AtR(const CBase* aPtr,TInt anIndex);
private:
	TInt iCount;
	TInt iGranularity;
	TBufRep iCreateRep;
	CBufBase* iBase;
	TInt iCacheIndex;
	TInt iCacheOffset;
	};
 
template <class T>
class CArrayPak : public CArrayPakBase
	{
public:
	inline CArrayPak(TBufRep aRep,TInt aGranularity);
	inline const T& operator[](TInt anIndex) const;
	inline T& operator[](TInt anIndex);
	inline const T& At(TInt anIndex) const;
	inline T& At(TInt anIndex);
	inline void AppendL(const T& aRef,TInt aLength);
	inline T& ExpandL(TInt anIndex,TInt aLength);
	inline T& ExtendL(TInt aLength);
	inline TInt Find(const T& aRef,TKeyArrayPak& aKey,TInt& anIndex) const;
	inline TInt FindIsq(const T& aRef,TKeyArrayPak& aKey,TInt& anIndex) const;
	inline void InsertL(TInt anIndex,const T& aRef,TInt aLength);
	inline TInt InsertIsqL(const T& aRef,TInt aLength,TKeyArrayPak& aKey);
	inline TInt InsertIsqAllowDuplicatesL(const T& aRef,TInt aLength,TKeyArrayPak& aKey);
	inline const TArray<T> Array() const;
	};
  class CArrayPak<TAny> : public CArrayPakBase
	{
public:
	inline CArrayPak(TBufRep aRep,TInt aGranularity);
	inline const TAny* At(TInt anIndex) const;
	inline TAny* At(TInt anIndex);
	inline void AppendL(const TAny* aPtr,TInt aLength);
	inline TAny* ExtendL(TInt aLength);
	};
 
template <class T>
class CArrayPakFlat : public CArrayPak<T>
	{
public:
	inline CArrayPakFlat(TInt aGranularity);
	};
 
class CObjectCon;
class CObject : public CBase
	{
public:
	  CObject();
	  ~CObject();
	  virtual TInt Open();
	  virtual void Close();
	  virtual TName Name() const;
	  virtual TFullName FullName() const;
	  TInt SetName(const TDesC* aName);
	  void SetNameL(const TDesC* aName);
	inline CObject* Owner() const;
	inline void SetOwner(CObject* anOwner);
	inline TInt AccessCount() const;
protected:
	inline TInt UniqueID() const;
	inline void Inc();
	inline void Dec();
private:
	TInt iAccessCount;
	CObject* iOwner;
	CObjectCon* iContainer;
	HBufC* iName;
	friend class CObjectCon;
	friend class CObjectIx;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};
 
struct SObjectIxRec
	{
	TInt16 instance;
	TInt16 uniqueID;
	CObject* obj;
	};
 
class CObjectIx : public CBase
	{
public:
	enum {ENoClose=KHandleNoClose,ELocalHandle=0x40000000};
public:
	  static CObjectIx* NewL();
	  ~CObjectIx();
	  TInt AddL(CObject* anObj);
	  void Remove(TInt aHandle);
	  CObject* At(TInt aHandle,TInt aUniqueID);
	  CObject* At(TInt aHandle);
	  CObject* AtL(TInt aHandle,TInt aUniqueID);
	  CObject* AtL(TInt aHandle);
	  TInt At(const CObject* anObject) const;
	  TInt Count(CObject* anObject) const;
	  CObject* operator[](TInt anIndex);
	inline TInt Count() const;
	inline TInt ActiveCount() const;
protected:
	  CObjectIx();
private:
	TInt iNumEntries;		 
	TInt iHighWaterMark;	 
	TInt iAllocated;		 
	TInt iNextInstance;
	SObjectIxRec *iObjects;
	TInt iFree;				 
	};
 
inline TBool IsLocalHandle(TInt aHandle)
	{return(aHandle&CObjectIx::ELocalHandle);}
inline void SetLocalHandle(TInt &aHandle)
	{aHandle|=CObjectIx::ELocalHandle;}
inline void UnSetLocalHandle(TInt &aHandle)
	{aHandle&=(~CObjectIx::ELocalHandle);}
 
 
class CObjectCon : public CBase
	{
protected:
	enum {ENotOwnerID};
public:
	  static CObjectCon* NewL();
	  ~CObjectCon();
	  void Remove(CObject* anObj);
	  void AddL(CObject* anObj);
	  CObject* operator[](TInt anIndex);
	  CObject* At(TInt aFindHandle) const;
	  CObject* AtL(TInt aFindHandle) const;
	  TInt CheckUniqueFullName(const CObject* anOwner,const TDesC& aName) const;
	  TInt CheckUniqueFullName(const CObject* anObject) const;
	  TInt FindByName(TInt& aFindHandle,const TDesC& aMatch,TName& aName) const;
	  TInt FindByFullName(TInt& aFindHandle,const TDesC& aMatch,TFullName& aFullName) const;
	inline TInt UniqueID() const;
	inline TInt Count() const;
protected:
	  CObjectCon(TInt aUniqueID);
	TBool NamesMatch(const CObject* anObject, const CObject* aCurrentObject) const;
	TBool NamesMatch(const CObject* anObject, const TName& anObjectName, const CObject* aCurrentObject) const;
public:
	TInt iUniqueID;
private:
	TInt iCount;
	TInt iAllocated;
	CObject** iObjects;
	friend class CObjectConIx;
	};
 
class CObjectConIx : public CBase
	{
public:
	  static CObjectConIx* NewL();
	  ~CObjectConIx();
	  CObjectCon* Lookup(TInt aUniqueID) const;
	  CObjectCon* CreateL();
	  void Remove(CObjectCon* aCon);
protected:
	  CObjectConIx();
	  void CreateContainerL(CObjectCon*& anObject);
private:
	TInt iCount;
	TInt iAllocated;
	TInt iNextUniqueID;
	CObjectCon** iContainers;
	};
 
class CBitMapAllocator : public CBase
	{
public:
	  static CBitMapAllocator* New(TInt aSize);
	  static CBitMapAllocator* NewL(TInt aSize);
	  ~CBitMapAllocator();
	  TInt Alloc();
	  TInt AllocFrom(TInt aPos);
	  TInt Alloc(TInt aCount, TInt& aConsecutive);
	  TInt AllocAligned(TInt anAlignment);
	  TInt AllocAlignedBlock(TInt anAlignment);
	  TInt AllocFromTop();
	  TInt AllocFromTopFrom(TInt aPos);
	  void AllocAt(TInt aPos);
	  void AllocAt(TInt aPos, TInt aCount);
	  TBool IsFree(TInt aPos);
	  TBool IsFree(TInt aPos, TInt aCount);
	  void Free(TInt aPos);
	  void Free(TInt aPos, TInt aCount);
	  TInt Avail();
	  TInt Size();
	  TInt ExtractRamPages(TInt aConsecutive,TInt& aPageNo);
protected:
	  CBitMapAllocator(TInt aSize,TInt aLength);
protected:
	TInt iAvail;
	TInt iSize;
	TInt iLength;
	TUint iMap[1];
	};
 
typedef void (*TCleanupOperation)(TAny*);
 
class TCleanupItem
	{
public:
	inline TCleanupItem(TCleanupOperation anOperation);
	inline TCleanupItem(TCleanupOperation anOperation,TAny* aPtr);
private:
	TCleanupOperation iOperation;
	TAny* iPtr;
	friend class TCleanupStackItem;
	};
 
class CCleanup : public CBase
	{
public:
	  static CCleanup* New();
	  static CCleanup* NewL();
	  ~CCleanup();
	  void NextLevel();
	  void PreviousLevel();
	  void PushL(TAny* aPtr);
	  void PushL(CBase* anObject);
	  void PushL(TCleanupItem anItem);
	  void Pop();
	  void Pop(TInt aCount);
	  void PopAll();
	  void PopAndDestroy();
	  void PopAndDestroy(TInt aCount);
	  void PopAndDestroyAll();
	  void Check(TAny* aExpectedItem);
protected:
	  void DoPop(TInt aCount,TBool aDestroy);
	  void DoPopAll(TBool aDestroy);
protected:
	  CCleanup();
protected:
	TCleanupStackItem* iBase;
	TCleanupStackItem* iTop;
	TCleanupStackItem* iNext;
	};
 
class TCleanupTrapHandler : public TTrapHandler
	{
public:
	TCleanupTrapHandler();
	virtual void Trap();
	virtual void UnTrap();
	virtual void Leave(TInt aValue);
	inline CCleanup& Cleanup();
private:
	CCleanup* iCleanup;
	friend class CTrapCleanup;
	};
 
template <class T>
class TAutoClose
	{
public:
	inline ~TAutoClose();
	inline void PushL();
	inline void Pop();
private:
	static void Close(TAny *aObj);
public:
	T iObj;
	};
 
class CTrapCleanup : public CBase
	{
public:
	  static CTrapCleanup* New();
	  ~CTrapCleanup();
protected:
	  CTrapCleanup();
private:
	TCleanupTrapHandler iHandler;
	TTrapHandler* iOldHandler;
	};
 
class CCirBufBase : public CBase
	{
public:
	  ~CCirBufBase();
	inline TInt Count() const;
	inline TInt Length() const;
	  void SetLengthL(TInt aLength);
	  void Reset();
protected:
	  CCirBufBase(TInt aSize);
	  TInt DoAdd(const TUint8* aPtr);
	  TInt DoAdd(const TUint8* aPtr,TInt aCount);
	  TInt DoRemove(TUint8* aPtr);
	  TInt DoRemove(TUint8* aPtr,TInt aCount);
protected:
	TInt iCount;
	TInt iSize;
	TInt iLength;
	TUint8* iPtr;
	TUint8* iPtrE;
	TUint8* iHead;
	TUint8* iTail;
	};
 
template <class T>
class CCirBuf : public CCirBufBase
	{
public:
	inline CCirBuf();



	inline TInt Add(const T* aPtr);
	inline TInt Add(const T* aPtr,TInt aCount);
	inline TInt Remove(T* aPtr);
	inline TInt Remove(T* aPtr,TInt aCount);
	};
 
class CCirBuffer : public CCirBuf<TUint8>
	{
public:
	  CCirBuffer();
	  ~CCirBuffer();
	  TInt Get();
	  TInt Put(TInt aVal);
	};
 
class CSecurityEncryptBase : public CBase
	{
public:
	virtual TInt EncryptL(TDes8& aOutput,const TDesC8& aInput) =0;
	virtual TInt CompleteL(TDes8& aOutput,const TDesC8& aInput) =0;
protected:
	  CSecurityEncryptBase();
	};
 
class CSecurityDecryptBase : public CBase
	{
public:
	virtual TInt DecryptL(TDes8& aOutput,const TDesC8& aInput) =0;
protected:
	  CSecurityDecryptBase();
	};
 
class CSecurityBase : public CBase
	{
public:
 
	virtual void SetL(const TDesC& aOldPassword,const TDesC& aNewPassword) =0;
	virtual TPtrC8 SecurityData() const =0;
	virtual CSecurityEncryptBase* NewEncryptL(const TDesC8& aInit) const =0;  
 
	virtual void PrepareL(const TDesC& aPassword) =0;
	virtual CSecurityDecryptBase* NewDecryptL(const TDesC8& aInit) const =0;  
 
	virtual TInt IsEnabled() const =0;
	virtual void SetEnabledL(const TDesC& aPassword,TBool aIsEnabled) =0;
protected:
	  CSecurityBase();
	};
 
class CBoundedSecurityBase : public CSecurityBase
	{
public:
	virtual TInt MaxCipherLength(TInt aPlainTextLength) const =0;
protected:
	inline CBoundedSecurityBase() {}
	};
 
class CActive : public CBase
	{
public:
enum TPriority
	{
	EPriorityIdle=-100,
	EPriorityLow=-20,
	EPriorityStandard=0,
	EPriorityUserInput=10,
	EPriorityHigh=20,
	};
public:
	  ~CActive();
	  void Cancel();
	  void Deque();
	  void SetPriority(TInt aPriority);
	inline TBool IsActive() const;
	inline TBool IsAdded() const;
	inline TInt Priority() const;
protected:
	  CActive(TInt aPriority);
	  void SetActive();
 
	virtual void DoCancel() =0;
	virtual void RunL() =0;
	  virtual TInt RunError(TInt aError);
public:
	TRequestStatus iStatus;
private:
	TBool iActive;
	TPriQueLink iLink;
	friend class CActiveScheduler;
	friend class CServer;
	friend class CServer2;
	};
 
class CIdle : public CActive
	{
public:
	  static CIdle* New(TInt aPriority);
	  static CIdle* NewL(TInt aPriority);
	  ~CIdle();
	  void Start(TCallBack aCallBack);
protected:
	  CIdle(TInt aPriority);
	  void RunL();
	  void DoCancel();
protected:
	TCallBack iCallBack;
	};
 
class CAsyncOneShot : public CActive
	{
public:
	  CAsyncOneShot(TInt aPriority);
	  virtual void DoCancel();
	  virtual void Call();
	  virtual ~CAsyncOneShot();
	inline RThread& Thread();
private:
	void Setup();
	RThread iThread;
	};

class CAsyncCallBack : public CAsyncOneShot
	{
public:
	  CAsyncCallBack(TInt aPriority);
	  CAsyncCallBack(const TCallBack& aCallBack, TInt aPriority);
	  void Set(const TCallBack& aCallBack);
	  void CallBack();
	  virtual ~CAsyncCallBack();
protected:
	virtual void RunL();
 
protected:
	TCallBack iCallBack;
	};
 
class TDeltaTimerEntry
	{
	friend class CDeltaTimer;
public:
	inline TDeltaTimerEntry(TCallBack& aCallback);
	inline TDeltaTimerEntry();
	inline void Set(TCallBack& aCallback);
private:
	TCallBack iCallBack; 
	TDeltaQueLink iLink;
	};
class CDeltaTimer : public CActive
	{
public:
	  virtual void Queue(TTimeIntervalMicroSeconds32 aTimeInMicroSeconds,TDeltaTimerEntry& aHandle);
	  virtual void Remove(TDeltaTimerEntry& anEntry);
	  static CDeltaTimer* NewL(TInt aPriority);
	  static CDeltaTimer* NewL(TInt aPriority,TTimeIntervalMicroSeconds32 aGranularity);
	virtual ~CDeltaTimer();
protected:
	  CDeltaTimer(TInt aPriority,TTimeIntervalMicroSeconds32 aGranularity);
	void DoCancel();
	void RunL();
	inline TTimeIntervalMicroSeconds32 Granularity() const;
protected:
	void Activate();
	RTimer iTimer;
	TDeltaQue<TDeltaTimerEntry> iQueue;
	TTimeIntervalMicroSeconds32 iGranularity;
	};
 
class CTimer : public CActive
	{
public:
	  ~CTimer();
	  void At(const TTime& aTime);
	  void After(TTimeIntervalMicroSeconds32 anInterval);
	  void Lock(TTimerLockSpec aLock);
	  void Inactivity(TTimeIntervalSeconds aSeconds);
protected:
	  CTimer(TInt aPriority);
	  void ConstructL();
	  void DoCancel();
private:
	RTimer iTimer;
	};
 
class CPeriodic : public CTimer
	{
public:
	  static CPeriodic* New(TInt aPriority);
	  static CPeriodic* NewL(TInt aPriority);
	  ~CPeriodic();
	  void Start(TTimeIntervalMicroSeconds32 aDelay,TTimeIntervalMicroSeconds32 anInterval,TCallBack aCallBack);
protected:
	  CPeriodic(TInt aPriority);
	  void RunL();
private:
	TTimeIntervalMicroSeconds32 iInterval;
	TCallBack iCallBack;
	};
 
class MBeating
	{
public:
	virtual void Beat() =0;
	virtual void Synchronize() =0;
	};
 
class CHeartbeat : public CTimer
	{
public:
	  static CHeartbeat* New(TInt aPriority);
	  static CHeartbeat* NewL(TInt aPriority);
	  ~CHeartbeat();
	  void Start(TTimerLockSpec aLock,MBeating *aBeating);
protected:
	  CHeartbeat(TInt aPriority);
	  void RunL();
private:
	TTimerLockSpec iLock;
	MBeating *iBeating;
	};
 



class CServer;
class CSharableSession : public CBase
 



	{
	friend class CServer;
public:
	  ~CSharableSession() =0;
	  virtual void CreateL(const CServer& aServer);
 
	inline const CServer* Server() const;
	inline const RMessage& Message() const;
	  void ResourceCountMarkStart();
	  void ResourceCountMarkEnd();
	  virtual TInt CountResources();
 
	virtual void ServiceL(const RMessage& aMessage) =0;
protected:
	  CSharableSession();
public:
	enum TPanicNo {ESesCountResourcesNotImplemented=1,ESesFoundResCountHeaven};
private:
	TInt iResourceCountMark;
	TDblQueLink iLink;
	const CServer* iServer;
	};

class CSession : public CSharableSession
 



	{
public:
	  ~CSession() =0;
 
	inline const RThread& Client() const;
	  void ReadL(const TAny* aPtr,TDes8& aDes) const;
	  void ReadL(const TAny* aPtr,TDes8& aDes,TInt anOffset) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes) const;
	  void ReadL(const TAny* aPtr,TDes16& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC8& aDes,TInt anOffset) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes) const;
	  void WriteL(const TAny* aPtr,const TDesC16& aDes,TInt anOffset) const;
	  void Panic(const TDesC& aCategory,TInt aReason) const;
	  void Kill(TInt aReason) const;
	  void Terminate(TInt aReason) const;
protected:
	  CSession(RThread aClient);
private:
	RThread iClient;
	};
 
class CServer : public CActive
 



	{
protected:
	enum TServerType {EUnsharableSessions,ESharableSessions};
public:
	  ~CServer() =0;
	  TInt Start(const TDesC& aName);
	  void StartL(const TDesC& aName);
 
	  void ReStart();
	inline const RMessage& Message() const;
protected:
	  CServer(TInt aPriority,TServerType aType=EUnsharableSessions);
	  void DoCancel();
	  void RunL();
private:
	virtual CSharableSession* NewSessionL(const TVersion& aVersion) const =0;
	void Connect();
private:
	const TServerType iSessionType;
	RServer iServer;
	TDblQue<CSharableSession> iSessionQ;
protected:
	TDblQueIter<CSharableSession> iSessionIter;
	};



class CServer2;
class CSession2 : public CBase
 



	{
	friend class CServer2;
public:
	  virtual ~CSession2() =0;
private:
	  virtual void CreateL();  
public:
	inline const CServer2* Server() const;
	  void ResourceCountMarkStart();
	  void ResourceCountMarkEnd(const RMessage2& aMessage);
	  virtual TInt CountResources();
	 






	virtual void ServiceL(const RMessage2& aMessage) =0;
	  virtual void ServiceError(const RMessage2& aMessage,TInt aError);
protected:
	  CSession2();
	  virtual void Disconnect(const RMessage2& aMessage);
public:
	 

	enum TPanicNo
		{
		 

		ESesCountResourcesNotImplemented=1,
		 

		ESesFoundResCountHeaven
		};
private:
	TInt iResourceCountMark;
	TDblQueLink iLink;
	const CServer2* iServer;
	};

class CServer2 : public CActive
 



	{
protected:
	 

	enum TServerType
		{
		 

		EUnsharableSessions,
		 

		ESharableSessions
		};
public:
	  virtual ~CServer2() =0;
	  TInt Start(const TDesC& aName);
	  void StartL(const TDesC& aName);
	  void ReStart();
	inline RServer2 Server() const;
protected:
	inline const RMessage2& Message() const;
	  CServer2(TInt aPriority,TServerType aType=EUnsharableSessions);
	  void DoCancel();
	  void RunL();
	  TInt RunError(TInt aError);
	  virtual void DoConnect(const RMessage2& aMessage);
private:
	  virtual CSession2* NewSessionL(const TVersion& aVersion,const RMessage2& aMessage) const =0;
	void Connect(const RMessage2& aMessage);
public:
	 

	enum TPanic
		{
		 

		EBadMessageNumber,
		 

		ESessionNotConnected,
		 

		ESessionAlreadyConnected,
		};
private:
	const TServerType iSessionType;
	RServer2 iServer;
	RMessage2 iMessage;
	TDblQue<CSession2> iSessionQ;
protected:
	TDblQueIter<CSession2> iSessionIter;
private:
	void Disconnect(const RMessage2& aMessage);
	void BadMessage(const RMessage2& aMessage);
	void NotConnected(const RMessage2& aMessage);
	};
 
class CActiveSchedulerWait : public CBase
	{
public:
	  ~CActiveSchedulerWait();
	  void Start();
	  void AsyncStop();
	  void AsyncStop(const TCallBack& aCallMeWhenStopped);
	  TBool IsStarted() const;
	  TBool CanStopNow() const;

private:
	friend class CActiveScheduler;
	class TOwnedSchedulerLoop
		{
	public:
		TOwnedSchedulerLoop(CActiveSchedulerWait* aWait);
	public:
		TInt iRunning;
		TCallBack iCb;
		TBool iLevelDropped;
		CActiveSchedulerWait* iWait;
		};
	TOwnedSchedulerLoop* iLoop;
	};
 
class CActiveScheduler : public CBase
	{
public:
	  CActiveScheduler();
	  ~CActiveScheduler();
	  static void Install(CActiveScheduler* aScheduler);
	  static CActiveScheduler* Current();
	  static void Add(CActive* anActive);
	  static void Start();
	  static void Stop();
	  static TBool RunIfReady(TInt& aError, TInt aMinimumPriority);
	  static CActiveScheduler* Replace(CActiveScheduler* aNewActiveScheduler);
	  virtual void WaitForAnyRequest();
	  virtual void Error(TInt anError) const;
private:
	void DoStart();
	void OwnedStartLoop(TInt& aRunning);
	  virtual void OnStarting();
	  virtual void OnStopping();
	  virtual void Reserved_1();
	  virtual void Reserved_2();
private:
	 
	friend class CActiveSchedulerWait;
	static void OwnedStart(CActiveSchedulerWait& aOwner);
protected:
	inline TInt Level() const;
private:
	TInt iLevel;
	TPriQue<CActive> iActiveQ;
	};
 
class CleanupStack
	{
public:
	  static void PushL(TAny* aPtr);
	  static void PushL(CBase* aPtr);
	  static void PushL(TCleanupItem anItem);
	  static void Pop();
	  static void Pop(TInt aCount);
	  static void PopAndDestroy();
	  static void PopAndDestroy(TInt aCount);
	  static void Check(TAny* aExpectedItem);
	inline static void Pop(TAny* aExpectedItem);
	inline static void Pop(TInt aCount, TAny* aLastExpectedItem);
	inline static void PopAndDestroy(TAny* aExpectedItem);
	inline static void PopAndDestroy(TInt aCount, TAny* aLastExpectedItem);
	};
 
template <class T>
class CleanupDelete
	{
public:
	inline static void PushL(T* aPtr);
private:
	static void Delete(TAny *aPtr);
	};
template <class T>
inline void CleanupDeletePushL(T* aPtr);
 
template <class T>
class CleanupArrayDelete
	{
public:
	inline static void PushL(T* aPtr);
private:
	static void ArrayDelete(TAny *aPtr);
	};
template <class T>
inline void CleanupArrayDeletePushL(T* aPtr);
 
template <class T>
class CleanupClose
	{
public:
	inline static void PushL(T& aRef);
private:
	static void Close(TAny *aPtr);
	};
template <class T>
inline void CleanupClosePushL(T& aRef);
 
template <class T>
class CleanupRelease
	{
public:
	inline static void PushL(T& aRef);
private:
	static void Release(TAny *aPtr);
	};
template <class T>
inline void CleanupReleasePushL(T& aRef);
 
class CConsoleBase;
class Console
	{
public:
	  static CConsoleBase* NewL(const TDesC& aTitle,TSize aSize);
	};
 
class Security
	{
public:
	  static CBoundedSecurityBase* NewL();
	  static CBoundedSecurityBase* NewL(const TDesC8& aSecurityData);
	};
 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.inl" 1
 
 
 
 
 






 
inline TAny* CBase::operator new(TUint aSize, TAny* aBase)
	{Mem::FillZ(aBase,aSize);return(aBase);}
inline TAny* CBase::operator new(TUint aSize, TLeave)
	{return newL(aSize);}
inline TAny* CBase::operator new(TUint aSize, TLeave, TUint aExtraSize)
	{return newL(aSize + aExtraSize);}

 
inline TInt CBufBase::Size() const
	{return(iSize);}

 
inline TInt CBufFlat::Capacity() const
	{return(iMaxSize);}

 
inline TInt CArrayFixBase::Count() const
	{return(iCount);}
inline TInt CArrayFixBase::Length() const
	{return(iLength);}

 
template <class T>
inline CArrayFix<T>::CArrayFix(TBufRep aRep,TInt aGranularity)
	: CArrayFixBase(aRep,sizeof(T),aGranularity)
	{}
template <class T>
inline const T &CArrayFix<T>::operator[](TInt anIndex) const
	{return(*((const T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline T &CArrayFix<T>::operator[](TInt anIndex)
	{return(*((T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline const T &CArrayFix<T>::At(TInt anIndex) const
	{return(*((const T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline const T *CArrayFix<T>::End(TInt anIndex) const
	{return((const T *)CArrayFixBase::End(anIndex));}
template <class T>
inline const T *CArrayFix<T>::Back(TInt anIndex) const
	{return((const T *)CArrayFixBase::Back(anIndex));}
template <class T>
inline T &CArrayFix<T>::At(TInt anIndex)
	{return(*((T *)CArrayFixBase::At(anIndex)));}
template <class T>
inline T *CArrayFix<T>::End(TInt anIndex)
	{return(((T *)CArrayFixBase::End(anIndex)));}
template <class T>
inline T *CArrayFix<T>::Back(TInt anIndex)
	{return(((T *)CArrayFixBase::Back(anIndex)));}
template <class T>
inline void CArrayFix<T>::AppendL(const T &aRef)
	{CArrayFixBase::InsertL(Count(),&aRef);}
template <class T>
inline void CArrayFix<T>::AppendL(const T *aPtr,TInt aCount)
	{CArrayFixBase::InsertL(Count(),aPtr,aCount);}
template <class T>
inline void CArrayFix<T>::AppendL(const T &aRef,TInt aReplicas)
	{CArrayFixBase::InsertRepL(Count(),&aRef,aReplicas);}
template <class T>
inline T &CArrayFix<T>::ExpandL(TInt anIndex)
	{return(*new(CArrayFixBase::ExpandL(anIndex)) T);}
template <class T>
inline T &CArrayFix<T>::ExtendL()
	{return(*new(CArrayFixBase::ExpandL(Count())) T);}
template <class T>
inline TInt CArrayFix<T>::Find(const T &aRef,TKeyArrayFix &aKey,TInt &anIndex) const
	{return(CArrayFixBase::Find(&aRef,aKey,anIndex));}
template <class T>
inline TInt CArrayFix<T>::FindIsq(const T &aRef,TKeyArrayFix &aKey,TInt &anIndex) const
	{return(CArrayFixBase::FindIsq(&aRef,aKey,anIndex));}
template <class T>
inline void CArrayFix<T>::InsertL(TInt anIndex,const T &aRef)
	{CArrayFixBase::InsertL(anIndex,&aRef);}
template <class T>
inline void CArrayFix<T>::InsertL(TInt anIndex,const T *aPtr,TInt aCount)
	{CArrayFixBase::InsertL(anIndex,aPtr,aCount);}
template <class T>
inline void CArrayFix<T>::InsertL(TInt anIndex,const T &aRef,TInt aReplicas)
	{CArrayFixBase::InsertRepL(anIndex,&aRef,aReplicas);}
template <class T>
inline TInt CArrayFix<T>::InsertIsqL(const T &aRef,TKeyArrayFix &aKey)
	{return(CArrayFixBase::InsertIsqL(&aRef,aKey));}
template <class T>
inline TInt CArrayFix<T>::InsertIsqAllowDuplicatesL(const T &aRef,TKeyArrayFix &aKey)
	{return(CArrayFixBase::InsertIsqAllowDuplicatesL(&aRef,aKey));}
template <class T>
inline void CArrayFix<T>::ResizeL(TInt aCount)
	{TUint8 b[sizeof(T)]; new(&b[0]) T; CArrayFixBase::ResizeL(aCount,&b[0]);}
template <class T>
inline void CArrayFix<T>::ResizeL(TInt aCount,const T &aRef)
	{CArrayFixBase::ResizeL(aCount,&aRef);}
template <class T>
inline const TArray<T> CArrayFix<T>::Array() const
	{return(TArray<T>(CountR,AtR,this));}
inline CArrayFix<TAny>::CArrayFix(TBufRep aRep,TInt aRecordLength,TInt aGranularity)
	: CArrayFixBase(aRep,aRecordLength,aGranularity)
	{}
inline const TAny *CArrayFix<TAny>::At(TInt anIndex) const
	{return(CArrayFixBase::At(anIndex));}
inline const TAny *CArrayFix<TAny>::End(TInt anIndex) const
	{return(CArrayFixBase::End(anIndex));}
inline const TAny *CArrayFix<TAny>::Back(TInt anIndex) const
	{return(CArrayFixBase::Back(anIndex));}
inline TAny *CArrayFix<TAny>::At(TInt anIndex)
	{return(CArrayFixBase::At(anIndex));}
inline TAny *CArrayFix<TAny>::End(TInt anIndex)
	{return(CArrayFixBase::End(anIndex));}
inline TAny *CArrayFix<TAny>::Back(TInt anIndex)
	{return(CArrayFixBase::Back(anIndex));}
inline void CArrayFix<TAny>::AppendL(const TAny *aPtr)
	{CArrayFixBase::InsertL(Count(),aPtr);}
inline void CArrayFix<TAny>::AppendL(const TAny *aPtr,TInt aCount)
	{CArrayFixBase::InsertL(Count(),aPtr,aCount);}
inline TAny *CArrayFix<TAny>::ExtendL()
	{return(CArrayFixBase::ExpandL(Count()));}

 
template <class T>
inline CArrayFixFlat<T>::CArrayFixFlat(TInt aGranularity)
	: CArrayFix<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}
template <class T>
inline void CArrayFixFlat<T>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}
inline CArrayFixFlat<TAny>::CArrayFixFlat(TInt aRecordLength,TInt aGranularity)
	: CArrayFix<TAny>((TBufRep)CBufFlat::NewL,aRecordLength,aGranularity)
	{}
inline void CArrayFixFlat<TAny>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}
inline void CArrayFixFlat<TInt>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}
inline void CArrayFixFlat<TUid>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}

 
template <class T>
inline CArrayFixSeg<T>::CArrayFixSeg(TInt aGranularity)
	: CArrayFix<T>((TBufRep)CBufSeg::NewL,aGranularity)
	{}
inline CArrayFixSeg<TAny>::CArrayFixSeg(TInt aRecordLength,TInt aGranularity)
	: CArrayFix<TAny>((TBufRep)CBufSeg::NewL,aRecordLength,aGranularity)
	{}

 
template <class T>
inline CArrayPtr<T>::CArrayPtr(TBufRep aRep,TInt aGranularity)
	: CArrayFix<T*>(aRep,aGranularity)
	{}
template <class T>
void CArrayPtr<T>::ResetAndDestroy()
	{
	for (TInt i=0;i<Count();++i)
		delete At(i);
	Reset();
	}

 
template <class T>
inline CArrayPtrFlat<T>::CArrayPtrFlat(TInt aGranularity)
	: CArrayPtr<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}
template <class T>
inline void CArrayPtrFlat<T>::SetReserveL(TInt aCount)
	{SetReserveFlatL(aCount);}

 
template <class T>
inline CArrayPtrSeg<T>::CArrayPtrSeg(TInt aGranularity)
	: CArrayPtr<T>((TBufRep)CBufSeg::NewL,aGranularity)
	{}

 
inline TInt CArrayVarBase::Count() const
	{return(iCount);}

 
template <class T>
inline CArrayVar<T>::CArrayVar(TBufRep aRep,TInt aGranularity)
	: CArrayVarBase(aRep,aGranularity)
	{}
template <class T>
inline const T &CArrayVar<T>::operator[](TInt anIndex) const
	{return(*((const T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline T &CArrayVar<T>::operator[](TInt anIndex)
	{return(*((T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline const T &CArrayVar<T>::At(TInt anIndex) const
	{return(*((const T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline T &CArrayVar<T>::At(TInt anIndex)
	{return(*((T *)CArrayVarBase::At(anIndex)));}
template <class T>
inline void CArrayVar<T>::AppendL(const T &aRef,TInt aLength)
	{CArrayVarBase::InsertL(Count(),&aRef,aLength);}
template <class T>
inline T &CArrayVar<T>::ExpandL(TInt anIndex,TInt aLength)
	{return(*new(CArrayVarBase::ExpandL(anIndex,aLength)) T);}
template <class T>
inline T &CArrayVar<T>::ExtendL(TInt aLength)
	{return(*new(CArrayVarBase::ExpandL(Count(),aLength)) T);}
template <class T>
inline TInt CArrayVar<T>::Find(const T &aRef,TKeyArrayVar &aKey,TInt &anIndex) const
	{return(CArrayVarBase::Find(&aRef,aKey,anIndex));}
template <class T>
inline TInt CArrayVar<T>::FindIsq(const T &aRef,TKeyArrayVar &aKey,TInt &anIndex) const
	{return(CArrayVarBase::FindIsq(&aRef,aKey,anIndex));}
template <class T>
inline void CArrayVar<T>::InsertL(TInt anIndex,const T &aRef,TInt aLength)
	{CArrayVarBase::InsertL(anIndex,&aRef,aLength);}
template <class T>
inline TInt CArrayVar<T>::InsertIsqL(const T &aRef,TInt aLength,TKeyArrayVar &aKey)
	{return(CArrayVarBase::InsertIsqL(&aRef,aLength,aKey));}
template <class T>
inline TInt CArrayVar<T>::InsertIsqAllowDuplicatesL(const T &aRef,TInt aLength,TKeyArrayVar &aKey)
	{return(CArrayVarBase::InsertIsqAllowDuplicatesL(&aRef,aLength,aKey));}
template <class T>
inline const TArray<T> CArrayVar<T>::Array() const
	{return(TArray<T>(CountR,AtR,this));}
inline const TAny *CArrayVar<TAny>::At(TInt anIndex) const
	{return(CArrayVarBase::At(anIndex));}
inline CArrayVar<TAny>::CArrayVar(TBufRep aRep,TInt aGranularity)
	: CArrayVarBase(aRep,aGranularity)
	{}
inline TAny *CArrayVar<TAny>::At(TInt anIndex)
	{return(CArrayVarBase::At(anIndex));}
inline void CArrayVar<TAny>::AppendL(const TAny *aPtr,TInt aLength)
	{CArrayVarBase::InsertL(Count(),aPtr,aLength);}
inline TAny *CArrayVar<TAny>::ExtendL(TInt aLength)
	{return(CArrayVarBase::ExpandL(Count(),aLength));}

 
template <class T>
inline CArrayVarFlat<T>::CArrayVarFlat(TInt aGranularity)
	: CArrayVar<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}

 
template <class T>
inline CArrayVarSeg<T>::CArrayVarSeg(TInt aGranularity)
	: CArrayVar<T>((TBufRep)CBufSeg::NewL,aGranularity)
	{}

 
inline TInt CArrayPakBase::Count() const
	{return(iCount);}

 
template <class T>
inline CArrayPak<T>::CArrayPak(TBufRep aRep,TInt aGranularity)
	: CArrayPakBase(aRep,aGranularity)
	{}
template <class T>
inline const T &CArrayPak<T>::operator[](TInt anIndex) const
	{return(*((const T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline T &CArrayPak<T>::operator[](TInt anIndex)
	{return(*((T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline const T &CArrayPak<T>::At(TInt anIndex) const
	{return(*((const T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline T &CArrayPak<T>::At(TInt anIndex)
	{return(*((T *)CArrayPakBase::At(anIndex)));}
template <class T>
inline void CArrayPak<T>::AppendL(const T &aRef,TInt aLength)
	{CArrayPakBase::InsertL(Count(),&aRef,aLength);}
template <class T>
inline T &CArrayPak<T>::ExpandL(TInt anIndex,TInt aLength)
	{return(*new(CArrayPakBase::ExpandL(anIndex,aLength)) T);}
template <class T>
inline T &CArrayPak<T>::ExtendL(TInt aLength)
	{return(*new(CArrayPakBase::ExpandL(Count(),aLength)) T);}
template <class T>
inline TInt CArrayPak<T>::Find(const T &aRef,TKeyArrayPak &aKey,TInt &anIndex) const
	{return(CArrayPakBase::Find(&aRef,aKey,anIndex));}
template <class T>
inline TInt CArrayPak<T>::FindIsq(const T &aRef,TKeyArrayPak &aKey,TInt &anIndex) const
	{return(CArrayPakBase::FindIsq(&aRef,aKey,anIndex));}
template <class T>
inline void CArrayPak<T>::InsertL(TInt anIndex,const T &aRef,TInt aLength)
	{CArrayPakBase::InsertL(anIndex,&aRef,aLength);}
template <class T>
inline TInt CArrayPak<T>::InsertIsqL(const T &aRef,TInt aLength,TKeyArrayPak &aKey)
	{return(CArrayPakBase::InsertIsqL(&aRef,aLength,aKey));}
template <class T>
inline TInt CArrayPak<T>::InsertIsqAllowDuplicatesL(const T &aRef,TInt aLength,TKeyArrayPak &aKey)
	{return(CArrayPakBase::InsertIsqAllowDuplicatesL(&aRef,aLength,aKey));}
template <class T>
inline const TArray<T> CArrayPak<T>::Array() const
	{return(TArray<T>(CountR,AtR,this));}
inline CArrayPak<TAny>::CArrayPak(TBufRep aRep,TInt aGranularity)
	: CArrayPakBase(aRep,aGranularity)
	{}
inline const TAny *CArrayPak<TAny>::At(TInt anIndex) const
	{return(CArrayPakBase::At(anIndex));}
inline TAny *CArrayPak<TAny>::At(TInt anIndex)
	{return(CArrayPakBase::At(anIndex));}
inline void CArrayPak<TAny>::AppendL(const TAny *aPtr,TInt aLength)
	{CArrayPakBase::InsertL(Count(),aPtr,aLength);}
inline TAny *CArrayPak<TAny>::ExtendL(TInt aLength)
	{return(CArrayPakBase::ExpandL(Count(),aLength));}

 
template <class T>
inline CArrayPakFlat<T>::CArrayPakFlat(TInt aGranularity)
	: CArrayPak<T>((TBufRep)CBufFlat::NewL,aGranularity)
	{}

 
inline TInt CObject::UniqueID() const
	{return(iContainer->UniqueID());}
inline TInt CObject::AccessCount() const
	{return(iAccessCount);}
inline void CObject::Inc()
	{iAccessCount++;}
inline void CObject::Dec()
	{iAccessCount--;}
inline CObject * CObject::Owner() const
	{return(iOwner);}
inline void CObject::SetOwner(CObject *anOwner)
	{iOwner=anOwner;}

 
inline TInt CObjectIx::Count() const
	{return iHighWaterMark;}
inline TInt CObjectIx::ActiveCount() const
	{return iNumEntries;}

 
inline TInt CObjectCon::UniqueID() const
	{return iUniqueID;}
inline TInt CObjectCon::Count() const
	{return iCount;}

 
inline TInt CCirBufBase::Count() const
	{return(iCount);}
inline TInt CCirBufBase::Length() const
	{return(iLength);}

 
template <class T>
inline CCirBuf<T>::CCirBuf()
	: CCirBufBase(sizeof(T))
	{}
template <class T>
inline TInt CCirBuf<T>::Add(const T *aPtr)
	{return(DoAdd((const TUint8 *)aPtr));}
template <class T>
inline TInt CCirBuf<T>::Add(const T *aPtr,TInt aCount)
	{return(DoAdd((const TUint8 *)aPtr,aCount));}
template <class T>
inline TInt CCirBuf<T>::Remove(T *aPtr)
	{return(DoRemove((TUint8 *)aPtr));}
template <class T>
inline TInt CCirBuf<T>::Remove(T *aPtr,TInt aCount)
	{return(DoRemove((TUint8 *)aPtr,aCount));}

 
inline TBool CActive::IsActive() const
	{return(iActive);}
inline TBool CActive::IsAdded() const
	{return(iLink.iNext!= 0L );}
inline TInt CActive::Priority() const
	{return iLink.iPriority;}

 
inline TDeltaTimerEntry::TDeltaTimerEntry(TCallBack& aCallback)
	{iCallBack=aCallback;}
inline TDeltaTimerEntry::TDeltaTimerEntry()
	{}
inline void TDeltaTimerEntry::Set(TCallBack& aCallback)
	{iCallBack=aCallback;}
inline TTimeIntervalMicroSeconds32 CDeltaTimer::Granularity() const
	{return iGranularity;}



 
inline const RMessage &CServer::Message() const
	{return iServer.Message();}
 
inline const CServer *CSharableSession::Server() const
	{return iServer;}
inline const RMessage& CSharableSession::Message() const
	{return iServer->Message();}
 
inline const RThread &CSession::Client() const
	{return iClient;}



 
inline const RMessage2 &CServer2::Message() const
 




	{return iMessage;}
inline RServer2 CServer2::Server() const
 




	{return iServer;}

 
inline const CServer2 *CSession2::Server() const
 




	{return iServer;}

 
inline RThread& CAsyncOneShot::Thread()
	{ return iThread; }

 
inline TInt CActiveScheduler::Level() const
	{return(iLevel);}

 
# 460 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.inl"

inline void CleanupStack::Pop(TAny*)
	{ CleanupStack::Pop(); }
inline void CleanupStack::Pop(TInt aCount, TAny*)
	{ CleanupStack::Pop(aCount); }
inline void CleanupStack::PopAndDestroy(TAny*)
	{ CleanupStack::PopAndDestroy(); }
inline void CleanupStack::PopAndDestroy(TInt aCount, TAny*)
	{ CleanupStack::PopAndDestroy(aCount); }


 
inline TCleanupItem::TCleanupItem(TCleanupOperation anOperation)
	: iOperation(anOperation)
	{}
inline TCleanupItem::TCleanupItem(TCleanupOperation anOperation,TAny *aPtr)
	: iOperation(anOperation), iPtr(aPtr)
	{}

 
inline CCleanup &TCleanupTrapHandler::Cleanup()
	{return(*iCleanup);}

 
template <class T>
inline TAutoClose<T>::~TAutoClose()
	{iObj.Close();}
template <class T>
inline void TAutoClose<T>::PushL()
	{CleanupStack::PushL(TCleanupItem(Close, (TAny *)&iObj));}
template <class T>
inline void TAutoClose<T>::Pop()
	{CleanupStack::Pop();}
template <class T>
void TAutoClose<T>::Close(TAny *aObj)
	{((T *)aObj)->Close();}

 
template <class T>
inline void CleanupDelete<T>::PushL(T* aPtr)
	{CleanupStack::PushL(TCleanupItem(&Delete,aPtr));}
template <class T>
void CleanupDelete<T>::Delete(TAny *aPtr)
	{delete (static_cast< T* >( aPtr )) ;}
template <class T>
inline void CleanupDeletePushL(T* aPtr)
	{CleanupDelete<T>::PushL(aPtr);}

 
template <class T>
inline void CleanupArrayDelete<T>::PushL(T* aPtr)
	{CleanupStack::PushL(TCleanupItem(&ArrayDelete,aPtr));}
template <class T>
void CleanupArrayDelete<T>::ArrayDelete(TAny *aPtr)
	{delete [] (static_cast< T* >( aPtr )) ;}
template <class T>
inline void CleanupArrayDeletePushL(T* aPtr)
	{CleanupArrayDelete<T>::PushL(aPtr);}

 
template <class T>
inline void CleanupClose<T>::PushL(T& aRef)
	{CleanupStack::PushL(TCleanupItem(&Close,&aRef));}
template <class T>
void CleanupClose<T>::Close(TAny *aPtr)
	{((static_cast< T* >( aPtr )) )->Close();}
template <class T>
inline void CleanupClosePushL(T& aRef)
	{CleanupClose<T>::PushL(aRef);}

 
template <class T>
inline void CleanupRelease<T>::PushL(T& aRef)
	{CleanupStack::PushL(TCleanupItem(&Release,&aRef));}
template <class T>
void CleanupRelease<T>::Release(TAny *aPtr)
	{((static_cast< T* >( aPtr )) )->Release();}
template <class T>
inline void CleanupReleasePushL(T& aRef)
	{CleanupRelease<T>::PushL(aRef);}



# 1261 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32base.h" 2



# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 1
 
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32keys.h" 1
 
 
 
 
 








 

 



 



enum TEventModifier
	{
	EModifierAutorepeatable=0x00000001,
	EModifierKeypad=0x00000002,
	EModifierLeftAlt=0x00000004,
	EModifierRightAlt=0x00000008,
	EModifierAlt=0x00000010,
	EModifierLeftCtrl=0x00000020,
	EModifierRightCtrl=0x00000040,
	EModifierCtrl=0x00000080,
	EModifierLeftShift=0x00000100,
	EModifierRightShift=0x00000200,
	EModifierShift=0x00000400,
	EModifierLeftFunc=0x00000800,
	EModifierRightFunc=0x00001000,
	EModifierFunc=0x00002000,
	EModifierCapsLock=0x00004000,
	EModifierNumLock=0x00008000,
	EModifierScrollLock=0x00010000,
	EModifierKeyUp=0x00020000,
	EModifierSpecial=0x00040000,
	EModifierDoubleClick=0x00080000,
    EModifierPureKeycode=0x00100000,
	EModifierKeyboardExtend=0x00200000,
	EAllModifiers=0x002fffff
	};

enum TModifierState
    {
    ETurnOnModifier=0x40,
    ETurnOffModifier,
    EToggleModifier
    };

enum TStdScanCode
	{
	EStdKeyNull=0x00,
	EStdKeyBackspace=0x01,
	EStdKeyTab=0x02,
	EStdKeyEnter=0x03,
	EStdKeyEscape=0x04,
	EStdKeySpace=0x05,
	EStdKeyPrintScreen=0x06,
	EStdKeyPause=0x07,
	EStdKeyHome=0x08,
	EStdKeyEnd=0x09,
	EStdKeyPageUp=0x0a,
	EStdKeyPageDown=0x0b,
	EStdKeyInsert=0x0c,
	EStdKeyDelete=0x0d,
	EStdKeyLeftArrow=0x0e,
	EStdKeyRightArrow=0x0f,
	EStdKeyUpArrow=0x10,
	EStdKeyDownArrow=0x11,
	EStdKeyLeftShift=0x12,
	EStdKeyRightShift=0x13,
	EStdKeyLeftAlt=0x14,
	EStdKeyRightAlt=0x15,
	EStdKeyLeftCtrl=0x16,
	EStdKeyRightCtrl=0x17,
	EStdKeyLeftFunc=0x18,
	EStdKeyRightFunc=0x19,
	EStdKeyCapsLock=0x1a,
	EStdKeyNumLock=0x1b,
	EStdKeyScrollLock=0x1c,
	EStdKeyF1=0x60,
	EStdKeyF2=0x61,
	EStdKeyF3=0x62,
	EStdKeyF4=0x63,
	EStdKeyF5=0x64,
	EStdKeyF6=0x65,
	EStdKeyF7=0x66,
	EStdKeyF8=0x67,
	EStdKeyF9=0x68,
	EStdKeyF10=0x69,
	EStdKeyF11=0x6a,
	EStdKeyF12=0x6b,
	EStdKeyF13=0x6c,
	EStdKeyF14=0x6d,
	EStdKeyF15=0x6e,
	EStdKeyF16=0x6f,
	EStdKeyF17=0x70,
	EStdKeyF18=0x71,
	EStdKeyF19=0x72,
	EStdKeyF20=0x73,
	EStdKeyF21=0x74,
	EStdKeyF22=0x75,
	EStdKeyF23=0x76,
	EStdKeyF24=0x77,
	EStdKeyXXX=0x78,
	EStdKeyComma=0x79,
	EStdKeyFullStop=0x7a,
	EStdKeyForwardSlash=0x7b,
	EStdKeyBackSlash=0x7c,
	EStdKeySemiColon=0x7d,
	EStdKeySingleQuote=0x7e,
	EStdKeyHash=0x7f,
	EStdKeySquareBracketLeft=0x80,
	EStdKeySquareBracketRight=0x81,
	EStdKeyMinus=0x82,
	EStdKeyEquals=0x83,
	EStdKeyNkpForwardSlash=0x84,
	EStdKeyNkpAsterisk=0x85,
	EStdKeyNkpMinus=0x86,
	EStdKeyNkpPlus=0x87,
	EStdKeyNkpEnter=0x88,
	EStdKeyNkp1=0x89,
	EStdKeyNkp2=0x8a,
	EStdKeyNkp3=0x8b,
	EStdKeyNkp4=0x8c,
	EStdKeyNkp5=0x8d,
	EStdKeyNkp6=0x8e,
	EStdKeyNkp7=0x8f,
	EStdKeyNkp8=0x90,
	EStdKeyNkp9=0x91,
	EStdKeyNkp0=0x92,
	EStdKeyNkpFullStop=0x93,
    EStdKeyMenu=0x94,
    EStdKeyBacklightOn=0x95,
    EStdKeyBacklightOff=0x96,
    EStdKeyBacklightToggle=0x97,
    EStdKeyIncContrast=0x98,
    EStdKeyDecContrast=0x99,
    EStdKeySliderDown=0x9a,
    EStdKeySliderUp=0x9b,
    EStdKeyDictaphonePlay=0x9c,
    EStdKeyDictaphoneStop=0x9d,
    EStdKeyDictaphoneRecord=0x9e,
    EStdKeyHelp=0x9f,
    EStdKeyOff=0xa0,
    EStdKeyDial=0xa1,
    EStdKeyIncVolume=0xa2,
    EStdKeyDecVolume=0xa3,
    EStdKeyDevice0=0xa4,
    EStdKeyDevice1=0xa5,
    EStdKeyDevice2=0xa6,
    EStdKeyDevice3=0xa7,
    EStdKeyDevice4=0xa8,
    EStdKeyDevice5=0xa9,
    EStdKeyDevice6=0xaa,
    EStdKeyDevice7=0xab,
    EStdKeyDevice8=0xac,
    EStdKeyDevice9=0xad,
    EStdKeyDeviceA=0xae,
    EStdKeyDeviceB=0xaf,
    EStdKeyDeviceC=0xb0,
    EStdKeyDeviceD=0xb1,
    EStdKeyDeviceE=0xb2,
    EStdKeyDeviceF=0xb3,
    EStdKeyApplication0=0xb4,
    EStdKeyApplication1=0xb5,
    EStdKeyApplication2=0xb6,
    EStdKeyApplication3=0xb7,
    EStdKeyApplication4=0xb8,
    EStdKeyApplication5=0xb9,
    EStdKeyApplication6=0xba,
    EStdKeyApplication7=0xbb,
    EStdKeyApplication8=0xbc,
    EStdKeyApplication9=0xbd,
    EStdKeyApplicationA=0xbe,
    EStdKeyApplicationB=0xbf,
    EStdKeyApplicationC=0xc0,
    EStdKeyApplicationD=0xc1,
    EStdKeyApplicationE=0xc2,
    EStdKeyApplicationF=0xc3,
	EStdKeyYes=0xc4,
	EStdKeyNo=0xc5,
	EStdKeyIncBrightness=0xc6,
	EStdKeyDecBrightness=0xc7,
	EStdKeyKeyboardExtend=0xc8 
	};

enum TKeyCode
	{
	EKeyNull=0x0000,
	EKeyBell=0x0007,
	EKeyBackspace=0x0008,
	EKeyTab=0x0009,
	EKeyLineFeed=0x000a,
	EKeyVerticalTab=0x000b,
	EKeyFormFeed=0x000c,
	EKeyEnter=0x000d,
	EKeyEscape=0x001b,
	EKeySpace=0x0020,
	EKeyDelete=0x007f,
	EKeyPrintScreen= 0xf800 ,
	EKeyPause,
	EKeyHome,
	EKeyEnd,
	EKeyPageUp,
	EKeyPageDown,
	EKeyInsert,
	EKeyLeftArrow,
	EKeyRightArrow,
	EKeyUpArrow,
	EKeyDownArrow,
	EKeyLeftShift,
	EKeyRightShift,
	EKeyLeftAlt,
	EKeyRightAlt,
	EKeyLeftCtrl,
	EKeyRightCtrl,
	EKeyLeftFunc,
	EKeyRightFunc,
	EKeyCapsLock,
	EKeyNumLock,
	EKeyScrollLock,
	EKeyF1,
	EKeyF2,
	EKeyF3,
	EKeyF4,
	EKeyF5,
	EKeyF6,
	EKeyF7,
	EKeyF8,
	EKeyF9,
	EKeyF10,
	EKeyF11,
	EKeyF12,
	EKeyF13,
	EKeyF14,
	EKeyF15,
	EKeyF16,
	EKeyF17,
	EKeyF18,
	EKeyF19,
	EKeyF20,
	EKeyF21,
	EKeyF22,
	EKeyF23,
	EKeyF24,
    EKeyOff,
    EKeyIncContrast,
    EKeyDecContrast,
    EKeyBacklightOn,
    EKeyBacklightOff,
    EKeyBacklightToggle,
    EKeySliderDown,
    EKeySliderUp,
    EKeyMenu,
    EKeyDictaphonePlay,
    EKeyDictaphoneStop,
    EKeyDictaphoneRecord,
    EKeyHelp,
    EKeyDial,
	EKeyScreenDimension0,
	EKeyScreenDimension1,
	EKeyScreenDimension2,
	EKeyScreenDimension3,
	EKeyIncVolume,
	EKeyDecVolume,
	EKeyDevice0,
	EKeyDevice1,
	EKeyDevice2,
	EKeyDevice3,
	EKeyDevice4,
	EKeyDevice5,
	EKeyDevice6,
	EKeyDevice7,
	EKeyDevice8,
	EKeyDevice9,
	EKeyDeviceA,
	EKeyDeviceB,
	EKeyDeviceC,
	EKeyDeviceD,
	EKeyDeviceE,
	EKeyDeviceF,
	EKeyApplication0,
	EKeyApplication1,
	EKeyApplication2,
	EKeyApplication3,
	EKeyApplication4,
	EKeyApplication5,
	EKeyApplication6,
	EKeyApplication7,
	EKeyApplication8,
	EKeyApplication9,
	EKeyApplicationA,
	EKeyApplicationB,
	EKeyApplicationC,
	EKeyApplicationD,
	EKeyApplicationE,
	EKeyApplicationF,
	EKeyYes,
	EKeyNo,
	EKeyIncBrightness,
	EKeyDecBrightness,
	EKeyKeyboardExtend
	};



# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32hal.h" 1
 
 
 
 
 









const TInt KMaxRomDevices=8;

enum TDigitizerCalibrationType
    {
    EFactory,
    ESaved
    };

class TDigitizerCalibration
    {
public:
    TPoint iTl;
    TPoint iBl;
    TPoint iTr;
    TPoint iBr;
    };

 







enum TMachineStartupType
	{
	EStartupCold,EStartupColdReset,EStartupNewOs,
	EStartupPowerFail,EStartupWarmReset,EStartupKernelFault,
	EStartupSafeReset
	};

 





enum TXYInputType
	{
	EXYInputNone,
	EXYInputPointer,
	EXYInputMouse,
	EXYInputDeltaMouse
	};

 





class TMachineInfoV1
	{
public:
	TVersion iRomVersion;
	TXYInputType iXYInputType;
	TBool iKeyboardPresent;
	TBool iBacklightPresent;
    TSize iDisplaySizeInPixels;
    TSize iXYInputSizeInPixels;
    TSize iPhysicalScreenSize;
	TPoint iOffsetToDisplayInPixels;
	TInt iKeyboardId;
	TInt iDisplayId;
	TInt64 iMachineUniqueId;
    TUint iLedCapabilities;
    TInt iProcessorClockInKHz;
    TInt iSpeedFactor;
    TInt iMaximumDisplayColors;
	};
typedef TPckgBuf<TMachineInfoV1> TMachineInfoV1Buf;

 





class TMachineInfoV2 : public TMachineInfoV1
	{
public:
	TInt iLanguageIndex;
    TInt iKeyboardIndex;
    };
typedef TPckgBuf<TMachineInfoV2> TMachineInfoV2Buf;

 





class TMemoryInfoV1
    {
public:
    TInt iTotalRamInBytes;
    TInt iTotalRomInBytes;
    TInt iMaxFreeRamInBytes;
    TInt iFreeRamInBytes;
    TInt iInternalDiskRamInBytes;
    TBool iRomIsReprogrammable;
    };
typedef TPckgBuf<TMemoryInfoV1> TMemoryInfoV1Buf;

 





class TRomInfoEntryV1
	{
public:
    enum TRomTypeV1
    	{
    	ERomTypeRom=0,
    	ERomTypeFlash=1
    	};
	TInt iSize;		     
	TInt iWidth;		 
	TInt iSpeed;		 
	TRomTypeV1 iType;	 
	};

 





class TRomInfoV1
	{
public:
	TRomInfoEntryV1	iEntry[KMaxRomDevices];
	};
typedef TPckgBuf<TRomInfoV1> TRomInfoV1Buf;

const TUint KRuggedFileSystem=0x01;
class TDriveInfoV1
    {
public:
	TInt iTotalSupportedDrives;
	TInfoName iDriveName[KMaxLocalDrives];
	TInt iTotalSockets;
	TInfoName iSocketName[KMaxPBusSockets];
	TInt iRuggedFileSystem;
	};
typedef TPckgBuf<TDriveInfoV1> TDriveInfoV1Buf;

class TExcInfo
	{
public:
	TAny *iCodeAddress;
	TAny *iDataAddress;
	TInt iExtraData;
	};

 





class UserHal
	{
public:
	  static TInt MachineInfo(TDes8& anInfo);
	  static TInt MemoryInfo(TDes8& anInfo);
	  static TInt DriveInfo(TDes8& anInfo);
	  static TInt RomInfo(TDes8& anInfo);
	  static TInt StartupReason(TMachineStartupType& aReason);
	  static TInt FaultReason(TInt &aReason);
	  static TInt ExceptionId(TInt &anId);
	  static TInt ExceptionInfo(TExcInfo &aInfo);
	  static TInt PageSizeInBytes(TInt& aSize);
	  static TInt TickPeriod(TTimeIntervalMicroSeconds32& aPeriod);
   	  static TInt SwitchOff();
	  static TInt SetXYInputCalibration(const TDigitizerCalibration& aCalibration);
	  static TInt CalibrationPoints(TDigitizerCalibration& aCalibration);
	  static TInt SaveXYInputCalibration();
	  static TInt RestoreXYInputCalibration(TDigitizerCalibrationType aType);
	};


# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32pccd.h" 1
 
 
 
 
 









typedef signed int TSocket;

 
enum TMediaDevice
	{EFixedMedia0,EFixedMedia1,EFixedMedia2,EFixedMedia3,
	EFixedMedia4,EFixedMedia5,EFixedMedia6,EFixedMedia7,
	ERemovableMedia0,ERemovableMedia1,ERemovableMedia2,ERemovableMedia3,EInvalidMedia};



class TLDriveAssignInfo
	{
public:
	TMediaDevice iDevice;
	TInt iPriority;
	};

class TMediaDeviceAssignInfo
	{
public:
	TInt iFirstMedia;
	TInt iLastMedia;	
	};



# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32svr.h" 2


 
 
 
class TRealTimeThreadCreate
	{
public:
	TThreadFunction iFunction;
	TInt iStackSize;
	TInt iHeapSize;
	TAny *iPtr;
	TInt iHandle;
	TInt iSpare;
	};
 
 
 
const TInt KLoaderMajorVersionNumber=1;
const TInt KLoaderMinorVersionNumber=0;
 
const TInt KFormatSectorSize=0x00000200;		 
const TInt KFormatSectorShift=9;	
const TUint KFormatSectorMask=0xFFFFFE00;
 
enum TBlockType {EBlocked,EUnBlocked,ERelease};
 
class TRawEvent
	{
public:
	enum TType
		{
		ENone,
		EPointerMove,
        EPointerSwitchOn,
		EKeyDown,EKeyUp,
		ERedraw,
		ESwitchOn,
        EActive,
		EInactive,
		EUpdateModifiers,
		EButton1Down,EButton1Up,
		EButton2Down,EButton2Up,
		EButton3Down,EButton3Up,
		ESwitchOff, EKeyRepeat,
		ECaseOpen, ECaseClose
		};
public:
	inline TRawEvent()
		: iType(ENone)
		{}
	inline TType Type() const
		{return iType;}
	  TPoint Pos() const;
	  TInt ScanCode() const;
      TInt Modifiers() const;
	inline TUint Ticks() const
		{return iTicks;}
	  void Set(TType aType,TInt aScanCode);
	  void Set(TType aType,TInt aX,TInt aY);
	  void Set(TType aType);
protected:
	TType iType;
	TUint iTicks;
	union
		{
		struct {TInt x;TInt y;} pos;
		TInt scanCode;
		TInt modifiers;
		} iU;
	};
 
class TRawEventBuf : public TPckgBuf<TRawEvent>
	{
public:
	inline TRawEvent &Event() const {return(*((TRawEvent *)&iBuf[0]));}
	};
 
class TScreenInfoV01
	{
public:
	TBool iWindowHandleValid;
	TAny *iWindowHandle;
	TBool iScreenAddressValid;
	TAny *iScreenAddress;
	TSize iScreenSize;
	};
 
enum TLoaderMsg {ELoadProcess=1,ELoadLibrary=2};
 
class RLoader : public RSessionBase
	{
public:
	  TInt Connect();
	TVersion Version() const;
	TInt LoadProcess(TInt &aHandle,const TDesC &aFileName,const TDesC &aCommand,const TUidType &aUidType, TOwnerType aType);
	  TInt LoadLibrary(TInt &aHandle,const TDesC &aFileName,const TDesC &anExt, const TDesC &aPath, const TUidType &aType);
	};
 
class TLoaderInfo
	{
public:
	  TLoaderInfo();
public:
	TUidType iType;
	TUint32 iCheck;
	TUint32 iCheckSumCode;
	TInt iCodeSize;
	TInt iDataSize;
	TInt iHeapSizeMin;
	TInt iHeapSizeMax;
	TInt iStackSize;
	TInt iBssSize;
	TUint iEntryPoint;
	TDllRefTable* iDllRefTable;
	TInt iDllRefTableCount;
	TUint iExportDir;
	TInt iExportDirCount;
	TUint iTargetCodeAddress;
	TUint32 iTargetCodeBase;
	TUint iTargetDataAddress;
	TUint32 iTargetDataBase;
	TFileName iFileName;
	TFileName iRootName;
	TPath iPath;
	TBool isLoadedFromRam;
	TBool isDll;
	TBool isAlreadyLoaded;
	TInt iHandle;
	TInt iThreadHandle;
	TInt iProcessHandle;  
	TInt iLibraryHandle;  
	TUint iHandleMask;
	TProcessPriority iPriority;
	TInt iTextSize;
	TAny *iLibPtr;		 
	};
 

enum TNotifierMessage 
	{
	ENotifierNotify,
	ENotifierInfoPrint,
	EStartNotifier,
	ECancelNotifier,
	EUpdateNotifier,
	EStartNotifierAndGetResponse,
	EStartNotifierFromSpecifiedDll,
	EStartNotifierFromSpecifiedDllAndGetResponse,
	ENotifierNotifyCancel,
	ENotifierNotifySync,
	};
 
class TBusDevOpenModeData
   {
public:
   	inline TBusDevOpenModeData(const TDesC &aDeviceName,TInt aUnit) 
	: iDeviceName(aDeviceName), iUnit(aUnit) {}
public:
	const TDesC &iDeviceName;
	TInt iUnit;
   	};
 
class TLocalDriveCaps
	{
public:
	  TLocalDriveCaps();
public:
	TInt64 iSize;
	TMediaType iType;
	TBatteryState iBattery;
	TUint iDriveAtt;
	TUint iMediaAtt;
    TUint8* iBaseAddress;
	TUint iFileSystemId;
	};
typedef TPckgBuf<TLocalDriveCaps> TLocalDriveCapsBuf;
 
class TLocalDriveCapsV2 : public TLocalDriveCaps
	{
public:
	TUint iHiddenSectors;
	TUint iEraseBlockSize;
    };
typedef TPckgBuf<TLocalDriveCapsV2> TLocalDriveCapsV2Buf;
 
class TLDFormatInfo
	{
public:
	TInt64 iCapacity;
	TUint16 iSectorsPerCluster;
	TUint16 iSectorsPerTrack;
	TUint16 iNumberOfSides;
	enum TFATBits {EFBDontCare, EFB12 = 12, EFB16 = 16};
	TFATBits iFATBits;
	};
 
class TLocalDriveCapsV3 : public TLocalDriveCapsV2
	{
public:
	TLDFormatInfo iFormatInfo;
    };
typedef TPckgBuf<TLocalDriveCapsV3> TLocalDriveCapsV3Buf;
 
class TLocalDriveCapsV4 : public TLocalDriveCapsV3
	{
public:
	TInt iPrefFormatSizeInBytes;
    };
typedef TPckgBuf<TLocalDriveCapsV4> TLocalDriveCapsV4Buf;
 
class TFormatInfo
	{
public:
	  TFormatInfo();
public:
	TBool iFormatIsCurrent;
	TInt i512ByteSectorsFormatted; 
	};
 
class TLocalDriveData
	{
public:
	TLocalDriveData(TInt64& aPos,TInt *aLength) : iPos(aPos), iLength(aLength) {}
public:
	TInt64 iPos;
	TInt *iLength;
	};
 
class TLocalDriveMessageData
	{
public:
	TLocalDriveMessageData(const TAny* aPtr,TInt aHandle,TInt anOffset) : iPtr(aPtr), iHandle(aHandle), iOffset(anOffset) {}
public:
	const TAny* iPtr;
	TInt iHandle;
	TInt iOffset;
	};
 
class TPBusPasswordData
	{
public:
	TDesC8 *iCurrentPassword;
	TDesC8 *iNewPassword;
	TBool iStorePassword;
	};
typedef TPckgBuf<TPBusPasswordData> TPBusPasswordDataPckg;
 
 
 
const TUint KLocDrvRemountForceMediaChange=0x00000001;
const TUint KLocDrvRemountPostponeRemount=0x00000010;
const TUint KLocDrvRemountKernelSideFlags=0x0000000F;
const TUint KLocDrvRemountReserved=0xFFFF0000;
 
class TBusLocalDrive : public MBusDev
	{
public:
	  TBusLocalDrive();
	  TInt Connect(TInt aDriveNumber,TBool &aChangedFlag);
	  void Disconnect();
	  TInt Enlarge(TInt aLength);
	  TInt ReduceSize(TInt aPos,TInt aLength);
	  TInt Read(TInt64 aPos,TInt aLength,const TAny* aTrg,TInt aThreadHandle,TInt anOffset);
	  TInt Read(TInt64 aPos,TInt aLength,TDes8& aTrg);
	  TInt Write(TInt64 aPos,TInt aLength,const TAny* aSrc,TInt aThreadHandle,TInt anOffset);
	  TInt Write(TInt64 aPos,const TDesC8& aSrc);
	  TInt Caps(TDes8& anInfo);
	  TInt Format(TFormatInfo &anInfo);
	  TInt Format(TInt64 aPos,TInt aLength);
	  TInt SetMountInfo(const TDesC8* aMountInfo,TInt aMountInfoThreadHandle=KCurrentThreadHandle);
	  TInt ForceRemount(TUint aFlags=0);

	  TInt Unlock(TMediaPassword &aPassword, TBool aStorePassword);
	  TInt Lock(TMediaPassword &aOldPassword, TMediaPassword &aNewPassword, TBool aStorePassword);
	  TInt Clear(TMediaPassword &aPassword);
	  static TInt ReadPasswordData(TDes8 &aBuf);
	  static TInt WritePasswordData(TDesC8 &aBuf);
	  static TInt PasswordStoreLengthInBytes();
	  TInt ControlIO(TInt aCommand,TAny* aParam1, TAny* aParam2);
	  TInt ErasePassword();
private:
	TInt CheckMount();
    void Open(TInt aStartResult);
private:
	TAny *iDrive;
	};
 
struct TFatUtilityFunctions;  
class UserExec
	{
public:
	  static const TFatUtilityFunctions* FatUtilityFunctions();
	};
 
class UserSvr
	{
public:
	  static void InitRegisterCallback(TCallBack aCallBack, TInt aPriority);
	  static void CaptureEventHook();
	  static void ReleaseEventHook();
	  static void RequestEvent(TRawEventBuf &anEvent,TRequestStatus &aStatus);
	  static void RequestEventCancel();
	  static TInt AddEvent(const TRawEvent& anEvent);
	  static void ScreenInfo(TDes8& anInfo);
 
	  static TInt DllGlobalAlloc(TInt aHandle,TInt aSize);
	  static TBool DllGlobalAllocated(TInt aHandle);
	  static TInt DllGlobalRead(TInt aHandle,TInt aPos,TInt aLength,TDes8 &aDes);
	  static TInt DllGlobalWrite(TInt aHandle,TInt aPos,const TDesC8 &aDes);
	  static TInt DllSetTls(TInt aHandle,TAny *aPtr);
	  static TAny *DllTls(TInt aHandle);
	  static void DllFreeTls(TInt aHandle);
	  static TInt DllInitialiseData(TInt aHandle);
	  static void DllFreeData(TInt aHandle);
	  static void DllFileName(TInt aHandle, TDes &aFileName);
 
	  static void KernelStartup(TThreadFunction aFunction);
	  static void FsRegisterThread(TThreadFunction aFileServer);
	  static void WsRegisterThread(TThreadFunction aWindowServer);
	  static void ServerStarted();
	  static void BlockThreads(TBlockType aType);
 
	  static TInt ProcessCreate(TLoaderInfo &anInfo, HBufC *aCommand);
	  static void ProcessLoaded(TLoaderInfo &anInfo);
	  static TInt LibraryCreateExact(TLoaderInfo &anInfo);
	  static TInt LibraryLoaded(TLoaderInfo &anInfo);
 
	static TInt StaticCallList(TInt aHandle, TInt& aCount, TUint*& aList);
	static TInt DynamicCallList(TInt aHandle, TInt& aCount, TUint*& aList);
 
      static TBool TestBootSequence();
 
      static void WsRegisterSwitchOnScreenHandling(TBool aState);
      static void WsSwitchOnScreen();
 
      static TInt ChangeLocale(RLibrary aLibrary);   
 
	  static TInt DllAddDependency(TAny *anImportingDll, TAny *anExportingDll);
	  static TInt ExeAddDependency(TAny *anImportingExe, TAny *anExportingDll);
	  static TInt ResetMachine(TMachineStartupType aType);
	  static void UnlockRamDrive();
	  static void LockRamDrive();
	  static TUint32 RomRootDirectoryAddress();

	  static void ForceRemountMedia(TMediaDevice aDevice);
	  static TInt MediaChangeNotify(TMediaDevice aDevice,TRequestStatus *aReqStat);
	  static TUint32 RomHeaderAddress();
	  static TUint32 DebugMask();  

	  static TInt HalGet(TInt aFunction, TAny* aParam);
	  static TInt HalSet(TInt aFunction, TAny* aParam);

	  static TInt SetMemoryThresholds(TInt aLowThreshold, TInt aGoodThreshold);
	};
 
class TMaskedModifiers
	{
public:
	TUint iMask;
	TUint iValue;
	};
 
enum TPattern
	{
	EAnyKey=0x00,
	EAnyAlphaNumeric,
	EAnyAlpha,
	EAnyAlphaLowerCase,
	EAnyAlphaUpperCase,
	EAnyDecimalDigit,
	EAnyDigitGivenRadix,
	EAnyModifierKey,
	EMatchKey=0x40,
	EMatchKeyCaseInsens,
	EMatchLeftOrRight
	};
 
class TKeyCodePattern
	{
public:
	TUint16 iKeyCode;
	TInt8   iPattern;
	TInt8   iFiller;
	};
 
class TCaptureKey
	{
public:
	TMaskedModifiers iModifiers;
	TKeyCodePattern  iKeyCodePattern;
	TUint iApp;
	TUint iHandle;
	};
 
class TKeyData
	{
public:
	TInt  iModifiers;
	TInt  iApp;
	TInt  iHandle;
	TBool iIsCaptureKey;
	TUint iKeyCode;
	};
 
class CCaptureKeys: public CBase
	{
public:
	  CCaptureKeys();
	  ~CCaptureKeys();
	  void Construct();
	  void AddCaptureKeyL(const TCaptureKey &aCaptureKey);
	  void AddCaptureKeyL(const TCaptureKey &aCaptureKey, TUint8 aPriority);
	  void SetCaptureKey(TUint32 aHandle, const TCaptureKey &aCaptureKey);
	  void SetCaptureKey(TUint32 aHandle, const TCaptureKey &aCaptureKey, TUint8 aPriority);
	  void CancelCaptureKey(TUint32 aHandle);
	  void CancelAllCaptureKeys(TUint32 aApp);
	  void ProcessCaptureKeys(TKeyData &aKeyData) const;
protected:
	void CheckCaptureKey(const TCaptureKey &aCaptureKey);
	void removeCaptureKey(TUint index);
protected:
	RArray<TCaptureKey> iCKarray;
	};
 
class CKeyTranslator: public CBase
	{
public:
	  static CKeyTranslator *New();
	virtual TInt GetModifierState()=0;
	virtual void SetModifierState(TEventModifier aModifier,TModifierState aState)=0;
	virtual TBool TranslateKey(TUint aScanCode,TBool aKeyUp,const CCaptureKeys &aCaptureKeys,TKeyData &aKeyData)=0;
    virtual void UpdateModifiers(TInt aModifiers)=0;
    virtual TInt ChangeKeyData(const TDesC& aLibraryName)=0;
	};
 
enum TDebugExceptionType
    {
    EPanic,
    EBreakPoint,
    EException,
	ENewThread
    };
 
class DThread;
 
const TInt KMaxProfiles=64;
 
class TProfile
    {
public:
    TInt iTime;
    TInt iCount;
    };
 
struct SDebugInfo
    {
    TBuf<0x20> iCategory;
    TFullName iName;
    TThreadId iId;
    TUint iCodeAddr;
	TUint iDataAddr;
    TUint iBssSize;
    TUint iCodeSize;
    TInt iPanicType;
    TDebugExceptionType iDebugType;
    };
 
struct SRegisterInfo
    {
    TInt iNumberOfPcRegister;
    TInt iNumberOfStatusRegister;
    TInt iNumberOfRegisters;
    TInt iThreadStartRegister;
    };
 
enum TDebugFunctionNo
    {
    EDebugFunctionContinue,
    EDebugFunctionSingleStep,
    EDebugFunctionGetRegister,
    EDebugFunctionSetRegister,
    EDebugFunctionSetBreakPoint,
    EDebugFunctionClrBreakPoint,
    EDebugFunctionSetWatchPoint,
    EDebugFunctionClrWatchPoint,
    EDebugFunctionReadMemory,
    EDebugFunctionWriteMemory,
    EDebugFunctionGetException,
    EDebugFunctionSuspendThread,
    EDebugFunctionRegisterInfo,
    EDebugFunctionSupervisorMode,
    EDebugFunctionPrint,
    EDebugFunctionProfileResult,
    EDebugFunctionProfileReset,
	EDebugFunctionFault,
	EDebugFunctionReadXtalError,
	EDebugFunctionSetXtalError,
    EDebugFunctionResumeThread,
    };
 
class TDebugFunction
    {
public:
    TDebugFunctionNo iFunction;		 
    TThreadId iThread;				 
    };
 
class RDebug
	{
public:
      static TInt Open(TInt aMaxBreak=16,TInt aMaxWatch=16,TInt aMaxPanic=16,TUint aDebugLimit=0x50000000);
      static TInt Close();
      static TInt SetBreakPoint(const TThreadId aId,TUint aAddr);
      static TInt SetBreakPoint(const TThreadId aId,TUint32 aAddr, TUint32 aFlags, TUint32 aCpuInfo);
      static TInt ClrBreakPoint(const TThreadId aId,TUint aAddr);
      static TInt SetWatchPoint(const TThreadId aId,TUint aAddr,TInt aLength);
      static TInt ClrWatchPoint(const TThreadId aId,TUint aAddr);
      static TInt GetRegister(const TThreadId aId,TInt aReg,TUint& aValue);
      static TInt SetRegister(const TThreadId aId,TInt aReg,TUint aValue);
      static TInt Continue(const TThreadId aId);
      static TInt SingleStep(const TThreadId aId);
      static TInt GetException(SDebugInfo& aReason,TRequestStatus& aStatus);
      static void CancelGetException();
      static TInt ReadMemory(const TThreadId aId,TUint aAddr,TDes8& aDes,TInt aLength);
      static TInt WriteMemory(const TThreadId aId,TUint aAddr,TDesC8& aDes,TInt aLength);
      static TInt KillThread(const TThreadId aId);
      static TInt RegisterInfo(SRegisterInfo& aInfo);
      static TInt Print(TRefByValue<const TDesC> aFmt,...);
	  static TInt RawPrint(const TDesC& aDes);
      static TInt SupervisorMode(TBool aState);
      static TInt Fault(TInt aFault);
      static TInt ProfileResult(TProfile* aProfile,TInt aStart,TInt aCount);
      static TInt ProfileReset(TInt aStart,TInt aCount);
      static TInt ProfileStart(TInt aProfile);
      static TInt ProfileEnd(TInt aProfile);
      static TInt SuspendThread(const TThreadId aId);
	  static TInt ReadXtalError();
	  static void SetXtalError(TInt anError);
      static TInt ResumeThread(const TThreadId aId);
};
 
const TInt KMaxLocaleMessageText=0x80;
 
enum TLocaleMessage
	{
	EFileServer_Button1,
	EFileServer_Button2,
	EFileServer_PutTheCardBackLine1,
	EFileServer_PutTheCardBackLine2,
	EFileServer_LowPowerLine1,
	EFileServer_LowPowerLine2,
	EFileServer_DiskErrorLine1,
	EFileServer_DiskErrorLine2,
	ESoundDriver_Chimes,
	ESoundDriver_Rings,
	ESoundDriver_Signal,
	EMediaDriver_DiskNameInternal,
	EMediaDriver_DiskNameExternal1,
	EMediaDriver_DiskNameExternal2,
	EMediaDriver_DiskNameExternal3,
	EMediaDriver_DiskNameExternal4,
	EMediaDriver_DiskNameExternal5,
	EMediaDriver_DiskNameExternal6,
	EMediaDriver_DiskNameExternal7,
	EMediaDriver_DiskNameExternal8,
	EMediaDriver_SocketName0,
	EMediaDriver_SocketName1,
	EMediaDriver_SocketName2,
	EMediaDriver_SocketName3,
	ELocaleMessages_LastMsg
	};

class TLocaleMessageText : public TBuf<KMaxLocaleMessageText>
	{
public:
	  TLocaleMessageText();
	  TLocaleMessageText(TLocaleMessage aMessageNo);
	  void Set(TLocaleMessage aMessageNo);
	};

class TModuleInfo
	{
public:
	TInt iCodeSize;
	TInt iConstDataSize;
	TInt iDataSize;
	TInt iBssSize;
	TUint8 *iCodeRunAddress;
	TUint8 *iCodeHomeAddress;
	TUint8 *iDataRunAddress;
	TUint8 *iDataHomeAddress;
	};





# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 2





 
const TInt KDefaultDrive=KMaxTInt;
const TInt KDriveAbsent=0x00;
const TInt KFileServerDefaultMessageSlots=4;
const TInt KEntryArraySize=(0x200*sizeof(TText));
const TInt KPathDelimiter='\\';
const TInt KDriveDelimiter=':';
const TInt KExtDelimiter='.';
 
const TInt KMaxDrives=26;
typedef TBuf8<KMaxDrives> TDriveList;
const TInt KMaxDriveName=0x02;
typedef TBuf<KMaxDriveName> TDriveName;
 
const TUint KEntryAttNormal=0x0000;
const TUint KEntryAttReadOnly=0x0001;
const TUint KEntryAttHidden=0x0002;
const TUint KEntryAttSystem=0x0004;
const TUint KEntryAttVolume=0x0008;
const TUint KEntryAttDir=0x0010;
const TUint KEntryAttArchive=0x0020;
const TUint KEntryAttMatchMask=(KEntryAttHidden|KEntryAttSystem|KEntryAttDir);
const TUint KEntryAttMaskSupported=0x3f;
 
const TUint KEntryAttMatchExclusive=0x40000000;
const TUint KEntryAttMatchExclude=0x08000000;
const TUint KEntryAttAllowUid=0x10000000;
 
const TUint KDebugNotifyMask=0xFF000000;  
enum TNotifyType {ENotifyEntry=0x00,ENotifyAll=0x01,ENotifyFile=0x04,ENotifyDir=0x08,
				  ENotifyAttributes=0x10,ENotifyWrite=0x20,ENotifyDisk=0x40};

 
enum TDriveNumber
	{
	EDriveA,   EDriveB,   EDriveC,   EDriveD,   EDriveE,
	EDriveF,   EDriveG,   EDriveH,   EDriveI,   EDriveJ,
	EDriveK,   EDriveL,   EDriveM,   EDriveN,   EDriveO, 
	EDriveP,   EDriveQ,   EDriveR,   EDriveS,   EDriveT,
	EDriveU,   EDriveV,   EDriveW,   EDriveX,   EDriveY,
	EDriveZ
	};
 
enum TEntryKey
	{
	ESortNone=0,ESortByName,ESortByExt,ESortBySize,ESortByDate,ESortByUid,
	EDirsAnyOrder=0,EDirsFirst=0x100,EDirsLast=0x200,
	EAscending=0,EDescending=0x400,EDirDescending=0x800
	};
 
enum TFileMode
	{
	EFileShareExclusive,EFileShareReadersOnly,EFileShareAny,
	EFileStream=0,EFileStreamText=0x100,
	EFileRead=0,EFileWrite=0x200
	};
 
const TUint KFileShareMask=0xff;
const TUint KFileNotShareMask = 0xffffff00;
 
enum TFormatMode 
	{
	EHighDensity,ELowDensity,
	EFullFormat=0,EQuickFormat=0x100,ESpecialFormat=0x200
	};
 
enum TSeek {ESeekAddress,ESeekStart,ESeekCurrent,ESeekEnd};
 
class TEntry
	{
public:
	  TEntry();
	  TEntry(const TEntry& aEntry);
	  TEntry& operator=(const TEntry& aEntry);
	  TBool IsReadOnly() const;
	  TBool IsHidden() const;
	  TBool IsSystem() const;
	  TBool IsDir() const;
	  TBool IsArchive() const;
	inline const TUid& operator[](TInt anIndex) const;
	inline TBool IsUidPresent(TUid aUid) const;
	inline TBool IsTypeValid() const;
	inline TUid MostDerivedUid() const;
public:
	TUint iAtt;
	TInt iSize;
	TTime iModified;
	TUidType iType;
	TBufC<KMaxFileName> iName;
	};
 
class TEntryArray
	{
public:
	  TEntryArray();
	  TInt Count() const;
	  const TEntry& operator[](TInt anIndex) const;
private:
	TInt iCount;
	TInt iIndex;
	const TEntry* iPos;
	TBuf8<KEntryArraySize> iBuf;
	friend class RDir;
	friend class RFs;
	};
 
class TDriveInfo
	{
public:
	TMediaType iType;
	TBatteryState iBattery;
	TUint iDriveAtt;
	TUint iMediaAtt;
	};
 
class TVolumeInfo
	{
public:
	  TVolumeInfo();
	TDriveInfo iDrive;
	TUint iUniqueID;
	TInt64 iSize;
	TInt64 iFree;
	TBufC<KMaxFileName> iName;
	};
 
class TDriveUnit
	{
public:
	inline TDriveUnit() {};
	  TDriveUnit(TInt aDrive);
	  TDriveUnit(const TDesC& aDrive);
	  TDriveUnit& operator=(TInt aDrive);
	  TDriveUnit& operator=(const TDesC& aDrive);
	inline operator TInt() const;
	  TDriveName Name() const;
private:
	TInt iDrive;
	};
 
class RFs;
 
class TParseBase
	{
private:
	struct SField {TUint8 pos;TUint8 len;TUint8 present;TUint8 filler;};
	enum TField {EDrive,EPath,EName,EExt,EMaxFields};
	enum TWild {EWildName=0x01,EWildExt=0x02,EWildEither=0x04,EIsRoot=0x08,EWildIsKMatchOne=0x10,EWildIsKMatchAny=0x20};
public:
	  TParseBase();
	  TInt PopDir();
	  TInt AddDir(const TDesC& aName);
	  const TDesC& FullName() const;
	  TPtrC Drive() const;
	  TPtrC Path() const;
	  TPtrC DriveAndPath() const;
	  TPtrC Name() const;
	  TPtrC Ext() const;
	  TPtrC NameAndExt() const;
	  TBool DrivePresent() const;
	  TBool PathPresent() const;
	  TBool NamePresent() const;
	  TBool ExtPresent() const;
	  TBool NameOrExtPresent() const;
	  TBool IsRoot() const;
	  TBool IsWild() const;
	  TBool IsKMatchOne() const;
	  TBool IsKMatchAny() const;
	  TBool IsNameWild() const;
	  TBool IsExtWild() const;
protected:
	virtual TDes& NameBuf() = 0;
	virtual const TDesC& NameBufC() const = 0;
	TInt Set(const TDesC* aName,const TDesC* aRelated,const TDesC* aDefault,TBool allowWild);
private:
	TInt ParseDrive(TLex& aName,TBool& aDone);
	TInt ParsePath(TLex& aName,TBool& aDone);
	TInt ParseName(TLex& aName,TBool& aDone);
	TInt ParseExt(TLex& aName,TBool& aDone);
private:
	TInt iWild;
	SField iField[EMaxFields];
	};
 
class TParsePtr : public TParseBase
	{
public:
	  TParsePtr(TDes& aName);
protected:
	  TDes& NameBuf();
	  const TDesC& NameBufC() const;
private:
	TPtr iNameBuf;
	};
 
class TParsePtrC : public TParseBase
	{
public:
	  TParsePtrC(const TDesC& aName);
protected:
	  TDes& NameBuf();
	  const TDesC& NameBufC() const;
private:
	TPtrC iNameBuf;
	};
 
class TParse : public TParseBase
	{
public:
	  TParse();
	  TInt Set(const TDesC& aName,const TDesC* aRelated,const TDesC* aDefault);
	  TInt SetNoWild(const TDesC& aName,const TDesC* aRelated,const TDesC* aDefault);
protected:
	  TDes& NameBuf();
	  const TDesC& NameBufC() const;
private:
	TFileName iNameBuf;
	};
 
class CDir : public CBase
	{
public:
	  virtual ~CDir();
	  TInt Count() const;
	  const TEntry& operator[](TInt anIndex) const;
	  TInt Sort(TUint aEntrySortKey);
protected:
	  CDir();
	  static CDir* NewL();
	  void AddL(const TEntry& anEntry);
	  void ExtractL(TBool aRemove,CDir*& aDir);
	  void Compress();
protected:
	CArrayPakFlat<TEntry>* iArray;
	friend class RFs;
	friend class TOpenFileScan;
	};
 
class RFs : public RSessionBase
	{
public:
	  TInt Connect(TInt aMessageSlots=KFileServerDefaultMessageSlots);
	  TVersion Version() const;
	  TInt AddFileSystem(const TDesC& aFileName) const;
	  TInt MountFileSystem(const TDesC& aFileSystemName,TInt aDrive) const;
	  TInt MountFileSystemAndScan(const TDesC& aFileSystemName,TInt aDrive,TBool& aIsMountSuccess) const;
	  TInt MountFileSystem(const TDesC& aFileSystemName,const TDesC& aExtensionName,TInt aDrive);
	  TInt DismountFileSystem(const TDesC& aFileSystemName,TInt aDrive) const;
	  TInt RemoveFileSystem(const TDesC& aFileSystemName) const;
	  TInt SwapFileSystem(const TDesC& aOldFileSystemName,const TDesC& aNewFileSystemName,TInt aDrive) const;
	  TInt FileSystemName(TDes& aName,TInt aDrive) const;
	  TInt AddExtension(const TDesC& aFileName);
	  TInt MountExtension(const TDesC& aExtensionName,TInt aDrive);
	  TInt DismountExtension(const TDesC& aExtensionName,TInt aDrive);
	  TInt RemoveExtension(const TDesC& aExtensionName);
	  TInt ExtensionName(TDes& aExtensionName,TInt aDrive,TInt aPos);
	  TInt RemountDrive(TInt aDrive,const TDesC8* aMountInfo= 0L ,TUint aFlags=0);
	  void NotifyChange(TNotifyType aType,TRequestStatus& aStat);
	  void NotifyChange(TNotifyType aType,TRequestStatus& aStat,const TDesC& aPathName);
	  void NotifyChangeCancel();
	  void NotifyChangeCancel(TRequestStatus& aStat);
	  void NotifyDiskSpace(TInt64 aThreshold,TInt aDrive,TRequestStatus& aStat);
	  void NotifyDiskSpaceCancel(TRequestStatus& aStat);
	  void NotifyDiskSpaceCancel();
	  TInt DriveList(TDriveList& aList) const;
	  TInt Drive(TDriveInfo& anInfo,TInt aDrive=KDefaultDrive) const;
	  TInt Volume(TVolumeInfo& aVol,TInt aDrive=KDefaultDrive) const;
	  TInt SetVolumeLabel(const TDesC& aName,TInt aDrive=KDefaultDrive);
	  TInt Subst(TDes& aPath,TInt aDrive=KDefaultDrive) const;
	  TInt SetSubst(const TDesC& aPath,TInt aDrive=KDefaultDrive);
	  TInt RealName(const TDesC& aName,TDes& aResult) const;
	  TInt DefaultPath(TDes& aPath) const;
	  TInt SetDefaultPath(const TDesC& aPath);
	  TInt SessionPath(TDes& aPath) const;
	  TInt SetSessionPath(const TDesC& aPath);
	  TInt Parse(const TDesC& aName,TParse& aParse) const;
	  TInt Parse(const TDesC& aName,const TDesC& aRelated,TParse& aParse) const;
	  TInt MkDir(const TDesC& aPath);
	  TInt MkDirAll(const TDesC& aPath);
	  TInt RmDir(const TDesC& aPath);
	  TInt GetDir(const TDesC& aName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList) const;
	  TInt GetDir(const TDesC& aName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList,CDir*& aDirList) const;
	  TInt GetDir(const TDesC& aName,const TUidType& anEntryUid,TUint anEntrySortKey,CDir*& aFileList) const;
	  TInt Delete(const TDesC& aName);
	  TInt Rename(const TDesC& anOldName,const TDesC& aNewName);
	  TInt Replace(const TDesC& anOldName,const TDesC& aNewName);
	  TInt Att(const TDesC& aName,TUint& aAttValue) const;
	  TInt SetAtt(const TDesC& aName,TUint aSetAttMask,TUint aClearAttMask);
	  TInt Modified(const TDesC& aName,TTime& aTime) const;
	  TInt SetModified(const TDesC& aName,const TTime& aTime);
	  TInt Entry(const TDesC& aName,TEntry& anEntry) const;
	  TInt SetEntry(const TDesC& aName,const TTime& aTime,TUint aSetAttMask,TUint aClearAttMask);
	  TInt ReadFileSection(const TDesC& aName,TInt aPos,TDes8& aDes,TInt aLength) const;
	  static TBool IsValidDrive(TInt aDrive);
	  static TInt CharToDrive(TChar aChar,TInt& aDrive);
	  static TInt DriveToChar(TInt aDrive,TChar& aChar);
	  static TBool IsRomAddress(TAny* aAny);
	  void ResourceCountMarkStart() const;
	  void ResourceCountMarkEnd() const;
	  TInt ResourceCount() const;
	  TInt IsFileOpen(const TDesC& aFile,TBool& anAnswer) const;
	  TInt CheckDisk(const TDesC& aDrive) const;
	  TInt ScanDrive(const TDesC& aDrive) const;
	  TInt GetShortName(const TDesC& aLongName,TDes& aShortName) const;
	  TInt GetLongName(const TDesC& aShortName,TDes& aLongName) const;
	  TBool GetNotifyUser();
	  void SetNotifyUser(TBool aValue);
	  TUint8* IsFileInRom(const TDesC& aFileName) const;
	  TBool IsValidName(const TDesC& anEntryName) const;
	  TBool IsValidName(const TDesC& aFileName,TText& aBadChar) const;
	  TInt GetDriveName(TInt aDrive,TDes& aDriveName) const;
	  TInt SetDriveName(TInt aDrive,const TDesC& aDriveName);
	  TInt LoaderHeapFunction(TInt aFunction, TAny *aArg1= 0L , TAny *aArg2= 0L );
	  TInt SetErrorCondition(TInt anError,TInt aCount=0);
	  TInt SetDebugRegister(TInt aVal);
	  TInt SetAllocFailure(TInt aAllocNum);
	  void DebugNotify(TInt aDrive,TUint aNotifyType,TRequestStatus& aStat);
	  TInt ControlIo(TInt aDrive,TInt aCommand,TAny* aParam1,TAny* aParam2);
	  TInt LockDrive(TInt aDrv, const TMediaPassword &aOld, const TMediaPassword &aNew, TBool aStr);
	  TInt UnlockDrive(TInt aDrv, const TMediaPassword &Pswd, TBool aStr);
	  TInt ClearPassword(TInt aDrv, const TMediaPassword &aPswd);
	  TInt ErasePassword(TInt aDrv);
	  void StartupInitComplete(TRequestStatus& aStat);
	  TInt LoadVirusScanner(const TDesC& aFileName, TRequestStatus& aStat);
	  TInt VirusScannerName(TDes& aVsName);
	  TInt SetSessionToPrivate(TInt aDrive);
	  TInt PrivatePath(TDes& aPath);
	  TInt CreatePrivatePath(TInt aDrive);	
	  TInt ReserveDriveSpace(TInt aDriveNo, TInt aSpace);
	  TInt GetReserveAccess(TInt aDriveNo);
	  TInt ReleaseReserveAccess(TInt aDriveNo);
private:
	void GetDirL(const TDesC& aMatchName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList,CDir*& aDirList,RDir& aDir) const;
	void GetDirL(const TDesC& aMatchName,TUint anEntryAttMask,TUint anEntrySortKey,CDir*& anEntryList,RDir& aDir) const;
	void GetDirL(const TDesC& aMatchName,const TUidType& aUidType,TUint anEntrySortKey,CDir*& anEntryList,RDir& aDir) const;
	void DoGetDirL(TUint anEntrySortKey,CDir*& anEntryList,RDir& aDir) const;
	TInt GetOpenFileList(TInt& aSessionNum,TInt& aLocalPos,TThreadId& aThreadId,TEntryArray& anArray) const;
	friend class TOpenFileScan;
	};
 
class RFsBase : public RSubSessionBase
	{
public:
	  void Close();
	};
 
class RFile : public RFsBase
	{
public:
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	  TInt Read(TDes8& aDes) const;
	  void Read(TDes8& aDes,TRequestStatus& aStatus) const;
	  TInt Read(TDes8& aDes,TInt aLength) const;
	  void Read(TDes8& aDes,TInt aLength,TRequestStatus& aStatus) const;
	  TInt Read(TInt aPos,TDes8& aDes) const;
	  void Read(TInt aPos,TDes8& aDes,TRequestStatus& aStatus) const;
	  TInt Read(TInt aPos,TDes8& aDes,TInt aLength) const;
	  void Read(TInt aPos,TDes8& aDes,TInt aLength,TRequestStatus& aStatus) const;
	  TInt Write(const TDesC8& aDes);
	  void Write(const TDesC8& aDes,TRequestStatus& aStatus);
	  TInt Write(const TDesC8& aDes,TInt aLength);
	  void Write(const TDesC8& aDes,TInt aLength,TRequestStatus& aStatus);
	  TInt Write(TInt aPos,const TDesC8& aDes);
	  void Write(TInt aPos,const TDesC8& aDes,TRequestStatus& aStatus);
	  TInt Write(TInt aPos,const TDesC8& aDes,TInt aLength);
	  void Write(TInt aPos,const TDesC8& aDes,TInt aLength,TRequestStatus& aStatus);
	  TInt Lock(TInt aPos,TInt aLength) const;
	  TInt UnLock(TInt aPos,TInt aLength) const;
	  TInt Seek(TSeek aMode,TInt& aPos) const;
	  TInt Flush();
	  TInt Size(TInt& aSize) const;
	  TInt SetSize(TInt aSize);
	  TInt Att(TUint& aAttValue) const;
	  TInt SetAtt(TUint aSetAttMask,TUint aClearAttMask);
	  TInt Modified(TTime& aTime) const;
	  TInt SetModified(const TTime& aTime);
	  TInt Set(const TTime& aTime,TUint aSetAttMask,TUint aClearAttMask);
	  TInt ChangeMode(TFileMode aNewMode);
	  TInt Rename(const TDesC& aNewName);
	  TInt Drive(TInt &aDriveNumber, TDriveInfo &aDriveInfo) const;
	};
 
class RDir : public RFsBase
	{
public:
	  TInt Open(RFs& aFs,const TDesC& aMatchName,const TUidType& aUidType);
	  TInt Open(RFs& aFs,const TDesC& aMatchName,TUint anEntryAttMask);
	  TInt Read(TEntryArray& anArray) const;
	  void Read(TEntryArray& anArray,TRequestStatus& aStatus) const;
	  TInt Read(TEntry& anEntry) const;
	  void Read(TPckg<TEntry>& anEntry,TRequestStatus& aStatus) const;
	};
 
class RFormat : public RFsBase
	{
public:
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFormatMode,TInt& aCount);
	  TInt Next(TInt& aStep);
	  void Next(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus);
	};
 
class RRawDisk : public RSubSessionBase
	{
public:
	  TInt Open(RFs& aFs,TInt aDrive);
	  void Close();
	  TInt Read(TInt aPos,TDes8& aDes);
	  TInt Write(TInt aPos,TDesC8& aDes);
	  TInt Read(TInt64 aPos,TDes8& aDes);
	  TInt Write(TInt64 aPos,TDesC8& aDes);
private:
	TInt iDrive;
	};
 
class CDirStack;
class CDirScan : public CBase
    {
public:
	enum TScanDirection {EScanUpTree,EScanDownTree};
public:
	  static CDirScan* NewL(RFs& aFs);
	  static CDirScan* NewLC(RFs& aFs);
	  ~CDirScan();
	  void SetScanDataL(const TDesC& aMatchName,TUint anEntryAttMask,TUint anEntrySortMask,TScanDirection aScanDir=EScanDownTree);
	  void NextL(CDir*& aDirEntries);
	  TPtrC AbbreviatedPath();
	  TPtrC FullPath();
protected:
	CDirScan(RFs& aFs);
private:
	inline RFs& Fs();
	void UpdateAbbreviatedPath();
	void ScanUpTreeL(CDir*& aDirEntries);
	void ScanDownTreeL(CDir*& aDirEntries);
	void GetDirEntriesL(CDir*& aDirEntries);
private:
	RFs* const iFs;
	TParse iFullPath;
	TPtrC iAbbreviatedPath;
	TInt iAbbreviatedPathPos;
	TUint iEntryAttMask;
	TUint iEntrySortMask;
	TBool iScanning;
	TScanDirection iScanDir;
	CDirStack* iStack;
	};
 
enum TFileManError
	{
	ENoExtraInformation,
	EInitializationFailed,
	EScanNextDirectoryFailed,
	ESrcOpenFailed,
	ETrgOpenFailed,
	ENoFilesProcessed
	};

class MFileManObserver
	{
public:
	enum TControl {EContinue,ERetry,EAbort,ECancel};
public:
	  virtual TControl NotifyFileManStarted();
	  virtual TControl NotifyFileManOperation();
	  virtual TControl NotifyFileManEnded();
	};

class CFileBase : public CBase
	{
public:
	  void SetObserver(MFileManObserver* anObserver);
public:
	  const TEntry& CurrentEntry();
	  TPtrC AbbreviatedPath();
	  TPtrC FullPath();
	  TInt GetLastError();
	  TFileManError GetMoreInfoAboutError();
protected:
	  CFileBase(RFs& anFs);
	  void ConstructL();
	  ~CFileBase();
	  void RunL();
	  void RunInSeparateThreadL(TThreadFunction aThreadFunction);
 
	virtual void CompleteOperationL() {};
	virtual void DoOperationL() = 0;
protected:
	RFs iFs;
	RFs iFsOld;
	RThread iFManThread;
	RSemaphore iSynchronizer;
	CDirScan* iScanner;
	CDir* iDirList;
	TInt iCurrentEntry;
	TUint iMatchEntry;
	TUint iSwitches;
	TParse iSrcFile;
	MFileManObserver* iObserver;
	TInt iLastError;
	TFileManError iErrorInfo;
	TRequestStatus* iStatus;
	HBufC* iSessionPath;
	TInt iNumberOfFilesProcessed;

friend void DoFManBaseOperationL(TAny* aPtr);
friend TInt FManBaseThreadFunction(TAny* aPtr);
	};

class CFileMan : public CFileBase
	{
public:
	enum TAction {ENone,EAttribs,ECopy,EDelete,EMove,ERename,ERmDir,ERenameInvalidEntry,ECopyShareAny};
	enum TSwitch {EOverWrite=1,ERecurse=2,EShareAnyCopy=0x10000};
public:
	  static CFileMan* NewL(RFs& aFs);
	  static CFileMan* NewL(RFs& aFs,MFileManObserver* anObserver);
	  TAction CurrentAction();
	  void GetCurrentTarget(TFileName& aFile);
	  void GetCurrentSource(TFileName& aFile);
	  TInt BytesTransferredByCopyStep();
public:
	  TInt Attribs(const TDesC& aName,TUint aSetMask,TUint aClearMask,const TTime& aTime,TUint aSwitch=0);
	  TInt Attribs(const TDesC& aName,TUint aSetMask,TUint aClearMask,const TTime& aTime,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Copy(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
	  TInt Copy(const TDesC& anOld,const TDesC& aNew,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Delete(const TDesC& aName,TUint aSwitch=0);
	  TInt Delete(const TDesC& aName,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Move(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
	  TInt Move(const TDesC& anOld,const TDesC& aNew,TUint aSwitch,TRequestStatus& aStatus);
	  TInt Rename(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
	  TInt Rename(const TDesC& anOld,const TDesC& aNew,TUint aSwitch,TRequestStatus& aStatus);
	  TInt RmDir(const TDesC& aDirName);
	  TInt RmDir(const TDesC& aDirName,TRequestStatus& aStatus);
protected:
	CFileMan(RFs& aFs);
	TInt RenameInvalidEntry(const TDesC& anOld,const TDesC& aNew,TUint aSwitch=EOverWrite);
private:
	void CompleteOperationL();
	void DoOperationL();
	void CheckForDirectory();
	void SetFlags(TBool aOverWrite,TBool aRecurse,TBool aScanDirection);
	TInt GetSrcAndTrg(TParse& aSrcName,TFileName& aTrgName);
	void DoSynchronize(TInt aRetVal);
	TInt CheckRenameAllowed(const TDesC& aSrcName,const TDesC& aTrgName);
private:
	void DoAttribsL();
	void DoCopyOrMoveL();
	void DoDeleteL();
	void DoRenameL();
	void DoRmDirL();
private:
	TParse iTrgFile;
	TAction iAction;
	TUint iSetMask;
	TUint iClearMask;
	TTime iTime;
	TInt iBytesTransferred;
friend void RenameInvalidEntryL(RFs& aFs,TParse& aSrcFile);
	};

class TFindFile
	{
public:
	  TFindFile(RFs& aFs);
	  TInt FindByPath(const TDesC& aFileName,const TDesC* aPathList);
	  TInt FindByDir(const TDesC& aFileName,const TDesC& aDirPath);
	  TInt Find();
	  TInt FindWildByPath(const TDesC& aFileName,const TDesC* aPathList,CDir*& aDirList);
	  TInt FindWildByDir(const TDesC& aFileName,const TDesC& aDirPath,CDir*& aDir);
	  TInt FindWild(CDir*& aDirList);
	inline const TDesC& File() const;
private:
	TInt DoFind();
	TInt DoFindByPath(const TDesC& aFileName,const TDesC* aPathList);
	TInt DoFindByDir(const TDesC& aFileName,const TDesC& aDir);
	TInt DoFindInDir();
	TInt DoFindNextInPath();
	TInt DoFindNextInDriveList();
private:
	RFs* const iFs;
	TParse iFile;
	TInt iPathPos;
	TInt iCurrentDrive;
	TInt iMode;
	const TDesC* iPath;
	TDriveList iDrvList;
	CDir** iDir;
	};
 
typedef CDir CFileList;
class TOpenFileScan
	{
public:
	  TOpenFileScan(RFs& aFs);
	  void NextL(CFileList*& aFileList);
	  TThreadId ThreadId() const;
private:
	RFs* iFs;
	TThreadId iThreadId;
	TInt iScanPos;
	TInt iEntryListPos;
	};
 
class TFileText
	{
public:
	enum TFileState{EStartOfFile,ENormal,EReverse};
public:
	  TFileText();
	  void Set(RFile& aFile);
	  TInt Read(TDes& aDes);
	  TInt Write(const TDesC& aDes);
	  TInt Seek(TSeek aMode);
private:
	void NextRecord();
	TInt CheckForTerminator(TBool& anAnswer);
	TInt FillBuffer();
private:
	const TText* iNext;
	const TText* iEnd;
	TFileState iState;
	RFile iFile;
	TBuf8<0x100> iReadBuf; 
	};
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.inl" 1
 
 
 
 
 






 
inline const TUid& TEntry::operator[](TInt anIndex) const
    {return(iType[anIndex]);}
inline TBool TEntry::IsUidPresent(TUid aUid) const
    {return(iType.IsPresent(aUid));}
inline TBool TEntry::IsTypeValid() const
    {return(iType.IsValid());}
inline TUid TEntry::MostDerivedUid() const
    {return(iType.MostDerived());}
 
inline TInt EntrySize(const TEntry& anEntry)
	{return(sizeof(TUint)+sizeof(TInt)+sizeof(TTime)+sizeof(TInt)+sizeof(TUidType)+anEntry.iName.Size());}

 
inline const TDesC& TFindFile::File() const
	{return iFile.FullName();}

 
inline RFs& CDirScan::Fs()
	{return(*iFs);}

 
inline TDriveUnit::operator TInt() const
	{return(iDrive);}
# 649 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 2


# 69 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h" 1
 
 
 
 






 
const TInt KMaxCardinality=0x1fffffff;
 
class MStreamBuf;
class RWriteStream;

 









class RReadStream
	{
public:
	inline RReadStream();
	inline RReadStream(MStreamBuf* aSource);
	inline MStreamBuf* Source();
	inline void Close();
	  void Release();
 
	  void PushL();
	inline void Pop();
 
	  void ReadL(TDes8& aDes);
	  void ReadL(TDes8& aDes,TInt aLength);
	  void ReadL(TDes8& aDes,TChar aDelim);
	  void ReadL(TUint8* aPtr,TInt aLength);
	  void ReadL(TInt aLength);
	inline void ReadL(RWriteStream& aStream);
	inline void ReadL(RWriteStream& aStream,TInt aLength);
 
	  void ReadL(TDes16& aDes);
	  void ReadL(TDes16& aDes,TInt aLength);
	  void ReadL(TDes16& aDes,TChar aDelim);
	  void ReadL(TUint16* aPtr,TInt aLength);
 
	  TInt8 ReadInt8L();
	  TInt16 ReadInt16L();
	  TInt32 ReadInt32L();
	  TUint8 ReadUint8L();
	  TUint16 ReadUint16L();
	  TUint32 ReadUint32L();
	  TReal32 ReadReal32L();
	  TReal64 ReadReal64L();
protected:
	inline void Attach(MStreamBuf* aSource);
	inline void Detach();
private:
	MStreamBuf* iSrc;
private:
	friend class RWriteStream;
	};
template <class T>
class MExternalizer;
class TStreamRef;

 









class RWriteStream
	{
public:
	inline RWriteStream();
	inline RWriteStream(const MExternalizer<TStreamRef>& anExter);
	inline RWriteStream(MStreamBuf* aSink);
	inline MStreamBuf* Sink();
	  void Close();
	  void Release();
	  void CommitL();
 
	  void PushL();
	inline void Pop();
 
	  void WriteL(const TDesC8& aDes);
	  void WriteL(const TDesC8& aDes,TInt aLength);
	  void WriteL(const TUint8* aPtr,TInt aLength);
	  void WriteL(RReadStream& aStream);
	  void WriteL(RReadStream& aStream,TInt aLength);
 
	  void WriteL(const TDesC16& aDes);
	  void WriteL(const TDesC16& aDes,TInt aLength);
	  void WriteL(const TUint16* aPtr,TInt aLength);
 
	  void WriteInt8L(TInt aValue);
	  void WriteInt16L(TInt aValue);
	  void WriteInt32L(TInt32 aValue);
	  void WriteUint8L(TUint aValue);
	  void WriteUint16L(TUint aValue);
	  void WriteUint32L(TUint32 aValue);
	  void WriteReal32L(TReal aValue);
	  void WriteReal64L(TReal64 aValue);
protected:
	inline void Attach(MStreamBuf* aSink);
	inline void Detach();
private:
	  void WriteRefL(TStreamRef aRef);
private:
	MStreamBuf* iSnk;
	const MExternalizer<TStreamRef>* iExterL;
private:
	friend class TStreamRef;
	};
 
template <class T>
inline RWriteStream& operator<<(RWriteStream& aStream,const T& anObject);
template <class T>
inline RReadStream& operator>>(RReadStream& aStream,T& anObject);

 










class TCardinality
	{
public:
	TCardinality() {}
	inline TCardinality(TInt aCount);
	inline operator TInt() const;
 
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
private:
	TInt iCount;
private:
	  static void __DbgChkRange(TInt aCount);
	};
 
 

typedef void (*TExternalizeFunction)(const TAny* aPtr,RWriteStream& aStream);
 
typedef void (*TInternalizeFunction)(TAny* aPtr,RReadStream& aStream);

 







template <class T>
class TExternalizer
	{
public:
	inline void operator()(const T& anObject,RWriteStream& aStream) const;
	inline static TExternalizeFunction Function();
private:
	static void ExternalizeAsL(const TAny* aPtr,RWriteStream& aStream);
	};

 






  class TExternalizer<TAny>
	{
public:
	 
	TExternalizer() {}
	
	 


	inline TExternalizer(TExternalizeFunction aFunction);
	inline void operator()(const TAny* aPtr,RWriteStream& aStream) const;
	
	 


	inline TExternalizeFunction Function() const;
private:
	TExternalizeFunction iFunc;
	};

 





template <class T>
class TInternalizer
	{
public:
	inline void operator()(T& anObject,RReadStream& aStream) const;
	inline static TInternalizeFunction Function();
private:
	static void InternalizeAsL(TAny* aPtr,RReadStream& aStream);
	};

 





  class TInternalizer<TAny>
	{
public:
	 
	TInternalizer() {}
	
	 


	inline TInternalizer(TInternalizeFunction aFunction);
	inline void operator()(TAny* aPtr,RReadStream& aStream) const;
	
	 


	inline TInternalizeFunction Function() const;
private:
	TInternalizeFunction iFunc;
	};

 







template <class T>
class MExternalizer
	{
public:
	inline void operator()(const T& anObject,RWriteStream& aStream) const;
private:
	 





	virtual void ExternalizeL(const T& anObject,RWriteStream& aStream) const=0;
	};

 







template <class T>
class MInternalizer
	{
public:
	inline void operator()(T& anObject,RReadStream& aStream) const;
private:
	 





	virtual void InternalizeL(T& anObject,RReadStream& aStream) const=0;
	};

 





class TStreamRef
	{
public:
	inline TStreamRef(const TAny* aPtr,TExternalizeFunction aFunction);
	inline const TAny* Ptr() const;
	inline TExternalizeFunction Function() const;
 
	inline void ExternalizeL(RWriteStream& aStream) const;
private:
	const TAny* iPtr;
	TExternalizeFunction iFunc;
	};

 





class Externalize
	{
public:
	 

	class Member {};

	 

	class Function {};
	};

 





class Internalize
	{
public:
	 

	class Member {};

	 

	class Function {};
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.inl" 1
 
 
 
 

 
inline RReadStream::RReadStream()
	: iSrc(0L )
 


	{}
inline RReadStream::RReadStream(MStreamBuf* aSource)
	: iSrc(aSource)
 



	{}
inline MStreamBuf* RReadStream::Source()
 










	{return iSrc;}
inline void RReadStream::Close()
 


	{Release();}
inline void RReadStream::ReadL(RWriteStream& aStream)
 


	{aStream.WriteL(*this);}
inline void RReadStream::ReadL(RWriteStream& aStream,TInt aLength)
 



	{aStream.WriteL(*this,aLength);}
inline void RReadStream::Pop()
 
	{CleanupStack::Pop();}
inline void RReadStream::Attach(MStreamBuf* aSource)
 












	{iSrc=aSource;}
inline void RReadStream::Detach()
 






	{iSrc= 0L ;}

 
inline RWriteStream::RWriteStream()
	: iSnk(0L ),iExterL(0L )
 

	{}
inline RWriteStream::RWriteStream(const MExternalizer<TStreamRef>& anExter)
	: iSnk(0L ),iExterL(&anExter)
 




	{}
inline RWriteStream::RWriteStream(MStreamBuf* aSink)
	: iSnk(aSink),iExterL(0L )
 



	{}
inline MStreamBuf* RWriteStream::Sink()
 



	{return iSnk;}
inline void RWriteStream::Pop()
 
	{CleanupStack::Pop();}
inline void RWriteStream::Attach(MStreamBuf* aSink)
 










	{iSnk=aSink;}
inline void RWriteStream::Detach()
 





	{iSnk= 0L ;}

 
inline TCardinality::TCardinality(TInt aCount)
	:iCount(aCount)
 


	{



	}
inline TCardinality::operator TInt() const
	{



	return iCount;
	}

 
template <class T>
inline void TExternalizer<T>::operator()(const T& anObject,RWriteStream& aStream) const
	{aStream<<anObject;}
template <class T>
inline TExternalizeFunction TExternalizer<T>::Function()
 




	{return &ExternalizeAsL;}
template <class T>
void TExternalizer<T>::ExternalizeAsL(const TAny* aPtr,RWriteStream& aStream)
	{aStream<<*((const T*)aPtr);}
inline TExternalizer<TAny>::TExternalizer(TExternalizeFunction aFunction)
	: iFunc(aFunction)
	{}
inline void TExternalizer<TAny>::operator()(const TAny* aPtr,RWriteStream& aStream) const
	{(*iFunc)(aPtr,aStream);}
inline TExternalizeFunction TExternalizer<TAny>::Function() const
	{return iFunc;}

 
template <class T>
inline void TInternalizer<T>::operator()(T& anObject,RReadStream& aStream) const
	{aStream>>anObject;}
template <class T>
inline TInternalizeFunction TInternalizer<T>::Function()
 




	{return &InternalizeAsL;}
template <class T>
void TInternalizer<T>::InternalizeAsL(TAny* aPtr,RReadStream& aStream)
	{aStream>>*((T*)aPtr);}
inline TInternalizer<TAny>::TInternalizer(TInternalizeFunction aFunction)
	: iFunc(aFunction)
	{}
inline void TInternalizer<TAny>::operator()(TAny* aPtr,RReadStream& aStream) const
	{(*iFunc)(aPtr,aStream);}
inline TInternalizeFunction TInternalizer<TAny>::Function() const
	{return iFunc;}

 
template <class T>
inline void MExternalizer<T>::operator()(const T& anObject,RWriteStream& aStream) const
	{ExternalizeL(anObject,aStream);}

 
template <class T>
inline void MInternalizer<T>::operator()(T& anObject,RReadStream& aStream) const
	{InternalizeL(anObject,aStream);}

 
inline TStreamRef::TStreamRef(const TAny* aPtr,TExternalizeFunction aFunction)
	: iPtr(aPtr),iFunc(aFunction)
 



	{}
inline const TAny* TStreamRef::Ptr() const
 


	{return iPtr;}
inline TExternalizeFunction TStreamRef::Function() const
 


	{return iFunc;}
inline void TStreamRef::ExternalizeL(RWriteStream& aStream) const
 


	{aStream.WriteRefL(*this);}

 
  void ExternalizeL(TInt64 anInt64,RWriteStream& aStream);
  void InternalizeL(TInt64& anInt64,RReadStream& aStream);

  void ExternalizeL(const TDesC8& aDes8,RWriteStream& aStream);
  void ExternalizeL(const TDesC16& aDes16,RWriteStream& aStream);
  void InternalizeL(TDes8& aDes8,RReadStream& aStream);
  void InternalizeL(TDes16& aDes16,RReadStream& aStream);

  void ExternalizeL(const TCheckedUid& aUid,RWriteStream& aStream);
  void InternalizeL(TCheckedUid& aUid,RReadStream& aStream);

  void ExternalizeL(TPoint aPoint,RWriteStream& aStream);
  void ExternalizeL(TSize aSize,RWriteStream& aStream);
  void ExternalizeL(const TRect& aRect,RWriteStream& aStream);
  void InternalizeL(TPoint& aPoint,RReadStream& aStream);
  void InternalizeL(TSize& aSize,RReadStream& aStream);
  void InternalizeL(TRect& aRect,RReadStream& aStream);

  void ExternalizeL(const CBufBase& aBuf,RWriteStream& aStream);
  void InternalizeL(CBufBase& aBuf,RReadStream& aStream);

  void ArrayExternalizeCountL(TInt aCount,RWriteStream& aStream);
  void DoExternalizeAllL(const CArrayFixBase& anArray,RWriteStream& aStream,TExternalizer<TAny> anExter);
  TInt ArrayInternalizeCountL(RReadStream& aStream);
  void DoInternalizeAllL(CArrayFixBase& anArray,RReadStream& aStream,TInternalizer<TAny> anInter);

template <class T>
inline void ExternalizeCountL(const CArrayFix<T>& anArray,RWriteStream& aStream)
	{ArrayExternalizeCountL(anArray.Count(),aStream);}
template <class T>
inline void ExternalizeAllL(const CArrayFix<T>& anArray,RWriteStream& aStream)
	{DoExternalizeAllL(anArray,aStream,TExternalizer<T>::Function());}
template <class T>
void InternalizeCountL(CArrayFix<T>& anArray,RReadStream& aStream)
	{
	TInt n=ArrayInternalizeCountL(aStream);
	anArray.ResizeL(n);
	}
template <class T>
inline void InternalizeAllL(CArrayFix<T>& anArray,RReadStream& aStream)
	{DoInternalizeAllL(anArray,aStream,TInternalizer<T>::Function());}

template <class T>
void ExternalizeL(const CArrayFix<T>& anArray,RWriteStream& aStream)
	{
	ExternalizeCountL(anArray,aStream);
	ExternalizeAllL(anArray,aStream);
	}
template <class T>
void InternalizeL(CArrayFix<T>& anArray,RReadStream& aStream)
	{
	InternalizeCountL(anArray,aStream);
	InternalizeAllL(anArray,aStream);
	}

template <class T>
inline void ExternalizeL(const T* aPtr,RWriteStream& aStream)
	{aStream<<TStreamRef(aPtr,TExternalizer<T>::Function());}

template <class T>
inline void DoExternalizeL(const T& anObject,RWriteStream& aStream,Externalize::Member)
	{anObject.ExternalizeL(aStream);}
template <class T>
inline void DoInternalizeL(T& anObject,RReadStream& aStream,Internalize::Member)
	{anObject.InternalizeL(aStream);}

template <class T>
inline void DoExternalizeL(const T& anObject,RWriteStream& aStream,Externalize::Function)
	{ExternalizeL(anObject,aStream);}
template <class T>
inline void DoInternalizeL(T& anObject,RReadStream& aStream,Internalize::Function)
	{InternalizeL(anObject,aStream);}

 
inline Externalize::Member Externalization(const TAny*)
	{return Externalize::Member();}
inline Internalize::Member Internalization(TAny*)
	{return Internalize::Member();}

inline Externalize::Function Externalization(const TDesC8*)
	{return Externalize::Function();}
inline Externalize::Function Externalization(const TDesC16*)
	{return Externalize::Function();}
inline Internalize::Function Internalization(TDes8*)
	{return Internalize::Function();}
inline Internalize::Function Internalization(TDes16*)
	{return Internalize::Function();}

inline Externalize::Function Externalization(const CBufBase*)
	{return Externalize::Function();}
inline Externalize::Function Externalization(const CArrayFixBase*)
	{return Externalize::Function();}
inline Internalize::Function Internalization(CBufBase*)
	{return Internalize::Function();}
inline Internalize::Function Internalization(CArrayFixBase*)
	{return Internalize::Function();}

template <class T>
inline Externalize::Function Externalization(T*const*)
	{return Externalize::Function();}

 
template <class T>
inline RWriteStream& operator<<(RWriteStream& aStream,const T& anObject)
	{DoExternalizeL(anObject,aStream,Externalization(&anObject));return aStream;}
template <class T>
inline RReadStream& operator>>(RReadStream& aStream,T& anObject)
	{DoInternalizeL(anObject,aStream,Internalization(&anObject));return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TInt8& anInt8)
	{aStream.WriteInt8L(anInt8);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TInt16& anInt16)
	{aStream.WriteInt16L(anInt16);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TInt32& anInt32)
	{aStream.WriteInt32L(anInt32);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TUint8& aUint8)
	{aStream.WriteUint8L(aUint8);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TUint16& aUint16)
	{aStream.WriteUint16L(aUint16);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TUint32& aUint32)
	{aStream.WriteUint32L(aUint32);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TReal32& aReal32)
	{aStream.WriteReal32L(aReal32);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TReal64& aReal64)
	{aStream.WriteReal64L(aReal64);return aStream;}

inline RReadStream& operator>>(RReadStream& aStream,TInt8& anInt8)
	{anInt8=aStream.ReadInt8L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TInt16& anInt16)
	{anInt16=aStream.ReadInt16L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TInt32& anInt32)
	{anInt32=aStream.ReadInt32L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUint8& aUint8)
	{aUint8=aStream.ReadUint8L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUint16& aUint16)
	{aUint16=aStream.ReadUint16L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUint32& aUint32)
	{aUint32=aStream.ReadUint32L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TReal32& aReal32)
	{aReal32=aStream.ReadReal32L();return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TReal64& aReal64)
	{aReal64=aStream.ReadReal64L();return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TInt64& anInt64)
	{ExternalizeL(anInt64,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TInt64& anInt64)
	{InternalizeL(anInt64,aStream);return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TUid& aUid)
	{return aStream<<aUid.iUid;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TCheckedUid& aUid)
	{ExternalizeL(aUid,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TUid& aUid)
	{return aStream>>aUid.iUid;}
inline RReadStream& operator>>(RReadStream& aStream,TCheckedUid& aUid)
	{InternalizeL(aUid,aStream);return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TPoint& aPoint)
	{ExternalizeL(aPoint,aStream);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TSize& aSize)
	{ExternalizeL(aSize,aStream);return aStream;}
inline RWriteStream& operator<<(RWriteStream& aStream,const TRect& aRect)
	{ExternalizeL(aRect,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TPoint& aPoint)
	{InternalizeL(aPoint,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TSize& aSize)
	{InternalizeL(aSize,aStream);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TRect& aRect)
	{InternalizeL(aRect,aStream);return aStream;}

inline RWriteStream& operator<<(RWriteStream& aStream,const TStreamRef& aRef)
	{aRef.ExternalizeL(aStream);return aStream;}

# 351 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h" 2


# 8 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 2



 
const TUint32 KNullStreamIdValue=0;
const TUint32 KMaxStreamIdValue=0xfffffff;
const TUint32 KMaskStreamIdValue=0xfffffff;
const TInt KShiftStreamIdValue=28;

 










class TStreamId
	{
public:
	 

	TStreamId() {}
	inline TStreamId(TUint32 aValue);
 
	inline TBool operator==(TStreamId anId) const;
	inline TBool operator!=(TStreamId anId) const;
 
	inline void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
 
	inline TUint32 Value() const;
private:
	TUint32 iVal;
private:
	  static void __DbgChkRange(TUint32 aValue);
	};






 
class CStreamStore;

 




class RStoreReadStream : public RReadStream
	{
public:
	  void OpenL(const CStreamStore& aStore,TStreamId anId);
	  void OpenLC(const CStreamStore& aStore,TStreamId anId);
	};

 














class RStoreWriteStream : public RWriteStream
	{
public:
	 

	RStoreWriteStream() {}
	inline RStoreWriteStream(const MExternalizer<TStreamRef>& anExter);
	  TStreamId CreateL(CStreamStore& aStore);
	  TStreamId CreateLC(CStreamStore& aStore);
	  void OpenL(CStreamStore& aStore,TStreamId anId);
	  void OpenLC(CStreamStore& aStore,TStreamId anId);
	  void ReplaceL(CStreamStore& aStore,TStreamId anId);
	  void ReplaceLC(CStreamStore& aStore,TStreamId anId);
	  void AppendL(CStreamStore& aStore,TStreamId anId);
	  void AppendLC(CStreamStore& aStore,TStreamId anId);
	};

 













class TSwizzleCBase
	{
public:
	inline TBool operator==(const TSwizzleCBase& aSwizzle) const;
	inline TBool operator==(const TAny* aPtr) const;
	inline TBool operator!=(const TSwizzleCBase& aSwizzle) const;
	inline TBool operator!=(const TAny* aPtr) const;
 
	inline TBool IsPtr() const;
	inline TBool IsId() const;
	  TStreamId AsId() const;
	  void InternalizeL(RReadStream& aStream);
protected:
	TSwizzleCBase() {}
	inline TSwizzleCBase(const TAny* aPtr);
	  TSwizzleCBase(TStreamId anId);
	inline TSwizzleCBase(TStreamRef aRef);
	inline const TAny* Ptr() const;
	  void DoExternalizeL(RWriteStream& aStream,TExternalizer<TAny> anExter) const;
private:
	  static TBool IsPtrRep(const TAny* aPtr);
	  static TBool IsIdRep(const TAny* aPtr);
private:
	const TAny* iPtr;
private:
	  static void __DbgChkPtr(const TAny* aPtr);
	  static void __DbgChkRef(TStreamRef aRef);
	};
inline TBool operator==(const TAny* aPtr,const TSwizzleCBase& aSwizzle);
inline TBool operator!=(const TAny* aPtr,const TSwizzleCBase& aSwizzle);

 











class TSwizzleBase : public TSwizzleCBase
	{
protected:
	TSwizzleBase() {}
	inline TSwizzleBase(TAny* aPtr);
	inline TSwizzleBase(TStreamId anId);
	inline TAny* Ptr() const;
	};

 
















template <class T>
class TSwizzle : public TSwizzleBase
	{
public:
	 

	TSwizzle() {}
	inline TSwizzle(T* aPtr);
	inline TSwizzle(TStreamId anId);
	inline TSwizzle<T>& operator=(T* aPtr);
	inline T* AsPtr() const;
	inline operator T*() const;
	inline T& operator*() const;
	inline T* operator->() const;
	inline void ExternalizeL(RWriteStream& aStream) const;
	};

 






  class TSwizzle<TAny> : public TSwizzleBase
	{
public:
	 


	TSwizzle() {}
	inline TSwizzle(TAny* aPtr);
	inline TSwizzle(TStreamId anId);
	inline TSwizzle(const TSwizzleBase& aSwizzle);
	inline TSwizzle<TAny>& operator=(TAny* aPtr);
	inline TSwizzle<TAny>& operator=(const TSwizzleBase& aSwizzle);
	inline TAny* AsPtr() const;
	inline operator TAny*() const;
	};

 

















template <class T>
class TSwizzleC : public TSwizzleCBase
	{
public:
	 

	TSwizzleC() {}
	inline TSwizzleC(const T* aPtr);
	inline TSwizzleC(TStreamId anId);
	inline TSwizzleC(TSwizzle<T> aSwizzle);
	inline TSwizzleC<T>& operator=(const T* aPtr);
	inline const T* AsPtr() const;
	inline operator const T*() const;
	inline const T& operator*() const;
	inline const T* operator->() const;
	inline void ExternalizeL(RWriteStream& aStream) const;
	};

 





  class TSwizzleC<TAny> : public TSwizzleCBase
	{
public:
	 


	TSwizzleC() {}
	inline TSwizzleC(const TAny* aPtr);
	inline TSwizzleC(TStreamId anId);
	inline TSwizzleC(const TSwizzleCBase& aSwizzle);
	inline TSwizzleC(TStreamRef aRef);
	inline TSwizzleC<TAny>& operator=(const TAny* aPtr);
	inline TSwizzleC<TAny>& operator=(const TSwizzleCBase& aSwizzle);
	inline const TAny* AsPtr() const;
	inline operator const TAny*() const;
	};

 












class CStoreMap : public CBase,public MExternalizer<TStreamRef>
	{
public:
	 



	struct TEntry {TSwizzleC<TAny> swizzle;TStreamId id;};
	typedef const TEntry* TIterator;
public:
	  static CStoreMap* NewL(CStreamStore& aStore);
	  static CStoreMap* NewLC(CStreamStore& aStore);
	  CStoreMap(CStreamStore& aStore);
	  ~CStoreMap();
 
	  void BindL(TSwizzleC<TAny> aSwizzle,TStreamId anId);
	  void Unbind(TSwizzleC<TAny> aSwizzle);
	  void Forget(TStreamId anId);
	  void Reset();
	  void ResetAndDestroy();
 
	  TStreamId At(TSwizzleC<TAny> aSwizzle) const;
	  TSwizzleC<TAny> Label(TStreamId anId) const;
	  TIterator Begin() const;
	  TIterator End() const;
private:
	void ExternalizeL(const TStreamRef& aRef,RWriteStream& aStream) const;
private:
	CArrayFixFlat<TEntry> iArray;
	TStreamId iFree;
	CStreamStore* iStore;
	};

 













class CStreamDictionary : public CBase
	{
public:
	  static CStreamDictionary* NewL();
	  static CStreamDictionary* NewLC();
	  CStreamDictionary();
	  ~CStreamDictionary();
 
	  void AssignL(TUid aUid,TStreamId anId);
	  void Remove(TUid aUid);
	  TStreamId At(TUid aUid) const;
	  TBool IsNull() const;
	 
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
private:
	
	class TEntry
		{
	public:
		TEntry() {}
		inline TEntry(TUid aUid,TStreamId anId);
		void ExternalizeL(RWriteStream& aStream) const;
		void InternalizeL(RReadStream& aStream);
	public:
		TUid iUid;
		TStreamId iId;
		};
private:
	CArrayFixSeg<TEntry> iArray;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.inl" 1
 
 
 
 

 
inline TStreamId::TStreamId(TUint32 aValue)
	: iVal(aValue)
 












	{



	}
inline TBool TStreamId::operator==(TStreamId anId) const
 




	{return iVal==anId.iVal;}
inline TBool TStreamId::operator!=(TStreamId anId) const
 




	{return iVal!=anId.iVal;}
inline void TStreamId::ExternalizeL(RWriteStream& aStream) const
 





	{



	aStream<<iVal;
	}
inline TUint32 TStreamId::Value() const
 


	{



	return iVal;
	}

 
inline RStoreWriteStream::RStoreWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
 



	{}

 
inline TSwizzleCBase::TSwizzleCBase(TStreamRef aRef)
	: iPtr(aRef.Ptr())
	{



    }
inline TBool TSwizzleCBase::operator==(const TSwizzleCBase& aSwizzle) const
 













	{return iPtr==aSwizzle.iPtr;}
inline TBool TSwizzleCBase::operator==(const TAny* aPtr) const
 










	{return iPtr==aPtr;}
inline TBool TSwizzleCBase::operator!=(const TSwizzleCBase& aSwizzle) const
 













	{return iPtr!=aSwizzle.iPtr;}
inline TBool TSwizzleCBase::operator!=(const TAny* aPtr) const
 










	{return iPtr!=aPtr;}
inline TBool TSwizzleCBase::IsPtr() const
 




	{return IsPtrRep(iPtr);}
inline TBool TSwizzleCBase::IsId() const
 




	{return IsIdRep(iPtr);}
inline TSwizzleCBase::TSwizzleCBase(const TAny* aPtr)
	: iPtr(aPtr)
	{



    }
inline const TAny* TSwizzleCBase::Ptr() const
	{



	return iPtr;
	}
inline TBool operator==(const TAny* aPtr,const TSwizzleCBase& aSwizzle)
	{return aSwizzle==aPtr;}
inline TBool operator!=(const TAny* aPtr,const TSwizzleCBase& aSwizzle)
	{return aSwizzle!=aPtr;}

 
inline TSwizzleBase::TSwizzleBase(TAny* aPtr)
	: TSwizzleCBase(aPtr)
	{}
inline TSwizzleBase::TSwizzleBase(TStreamId anId)
	: TSwizzleCBase(anId)
	{}
inline TAny* TSwizzleBase::Ptr() const
	{return (TAny*)TSwizzleCBase::Ptr();}

 
template <class T>
inline TSwizzle<T>::TSwizzle(T* aPtr)
	: TSwizzleBase(aPtr)
 


	{}
template <class T>
inline TSwizzle<T>::TSwizzle(TStreamId anId)
	: TSwizzleBase(anId)
 



	{}
template <class T>
inline TSwizzle<T>& TSwizzle<T>::operator=(T* aPtr)
 




	{return *this=TSwizzle<T>(aPtr);}
template <class T>
inline T* TSwizzle<T>::AsPtr() const
 





	{return (T*)Ptr();}
template <class T>
inline TSwizzle<T>::operator T*() const
	{return AsPtr();}
template <class T>
inline T& TSwizzle<T>::operator*() const
 


	{return *AsPtr();}
template <class T>
inline T* TSwizzle<T>::operator->() const
 




	{return AsPtr();}
template <class T>
inline void TSwizzle<T>::ExternalizeL(RWriteStream& aStream) const
 
















	{TSwizzleBase::DoExternalizeL(aStream,TExternalizer<T>::Function());}
inline TSwizzle<TAny>::TSwizzle(TAny* aPtr)
	: TSwizzleBase(aPtr)
 


	{}
inline TSwizzle<TAny>::TSwizzle(TStreamId anId)
	: TSwizzleBase(anId)
 



	{}
inline TSwizzle<TAny>::TSwizzle(const TSwizzleBase& aSwizzle)
	: TSwizzleBase(aSwizzle)
 




	{}
inline TSwizzle<TAny>& TSwizzle<TAny>::operator=(TAny* aPtr)
 




	{return *this=TSwizzle<TAny>(aPtr);}
inline TSwizzle<TAny>& TSwizzle<TAny>::operator=(const TSwizzleBase& aSwizzle)
	 





	{return *this=TSwizzle<TAny>(aSwizzle);}
inline TAny* TSwizzle<TAny>::AsPtr() const
 


	{return Ptr();}
inline TSwizzle<TAny>::operator TAny*() const
	{return AsPtr();}

 
template <class T>
inline TSwizzleC<T>::TSwizzleC(const T* aPtr)
	: TSwizzleCBase(aPtr)
 



	{}
template <class T>
inline TSwizzleC<T>::TSwizzleC(TStreamId anId)
	: TSwizzleCBase(anId)
 




	{}
template <class T>
inline TSwizzleC<T>::TSwizzleC(TSwizzle<T> aSwizzle)
	: TSwizzleCBase(aSwizzle)
 









	{}
template <class T>
inline TSwizzleC<T>& TSwizzleC<T>::operator=(const T* aPtr)
 





	{return *this=TSwizzleC<T>(aPtr);}
template <class T>
inline const T* TSwizzleC<T>::AsPtr() const
 









	{return (const T*)Ptr();}
template <class T>
inline TSwizzleC<T>::operator const T*() const
	{return AsPtr();}
template <class T>
inline const T& TSwizzleC<T>::operator*() const
 



	{return *AsPtr();}
template <class T>
inline const T* TSwizzleC<T>::operator->() const
 









	{return AsPtr();}
template <class T>
inline void TSwizzleC<T>::ExternalizeL(RWriteStream& aStream) const
 
















	{TSwizzleCBase::DoExternalizeL(aStream,TExternalizer<T>::Function());}
inline TSwizzleC<TAny>::TSwizzleC(const TAny* aPtr)
	: TSwizzleCBase(aPtr)
 


	{}
inline TSwizzleC<TAny>::TSwizzleC(TStreamId anId)
	: TSwizzleCBase(anId)
 



	{}
inline TSwizzleC<TAny>::TSwizzleC(const TSwizzleCBase& aSwizzle)
	: TSwizzleCBase(aSwizzle)
 




	{}
inline TSwizzleC<TAny>::TSwizzleC(TStreamRef aRef)
	: TSwizzleCBase(aRef)
 


 	{}
inline TSwizzleC<TAny>& TSwizzleC<TAny>::operator=(const TAny* aPtr)
 



	{return *this=TSwizzleC<TAny>(aPtr);}
inline TSwizzleC<TAny>& TSwizzleC<TAny>::operator=(const TSwizzleCBase& aSwizzle)
 





	{return *this=TSwizzleC<TAny>(aSwizzle);}
inline const TAny* TSwizzleC<TAny>::AsPtr() const
 


	{return Ptr();}
inline TSwizzleC<TAny>::operator const TAny*() const
	{return AsPtr();}

# 375 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 2


# 70 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 1
 
 
 
 



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32buf.h" 1
 
 
 
 






 





enum TStreamLocation 
	 

	{EStreamBeginning,
	 
	EStreamMark,
	 

	EStreamEnd};

 


















class TStreamPos
	{
public:
	 
	TStreamPos() {}
	inline TStreamPos(TInt anOffset);
 
	inline TBool operator==(TStreamPos aPos) const;
	inline TBool operator!=(TStreamPos aPos) const;
	inline TBool operator<(TStreamPos aPos) const;
	inline TBool operator<=(TStreamPos aPos) const;
	inline TBool operator>(TStreamPos aPos) const;
	inline TBool operator>=(TStreamPos aPos) const;
 
	inline TInt operator-(TStreamPos aPos) const;
	inline TStreamPos operator+(TInt anOffset) const;
	inline TStreamPos operator-(TInt anOffset) const;
 
	inline TStreamPos& operator+=(TInt anOffset);
	inline TStreamPos& operator-=(TInt anOffset);
 
	inline TInt Offset() const;
private:
	TInt iOff;
	};
inline TStreamPos operator+(TInt anOffset,TStreamPos aPos);

 








 















class TStreamTransfer
	{
public:
	 


	enum TUnlimited {EUnlimited};
public:
	 








	TStreamTransfer() {}
	inline TStreamTransfer(TInt aMaxLength);
	inline TStreamTransfer(TUnlimited);
 
	inline TBool operator==(TInt aLength) const;
	inline TBool operator>(TInt aLength) const;
	inline TStreamTransfer operator-(TInt aLength) const;
	inline TInt operator[](TInt aMaxLength) const;
 
	inline TStreamTransfer& operator-=(TInt aLength);
 
	inline TInt Left() const;
private:
	TInt iVal;
private:
	  static void __DbgChkNonNegative(TInt aLength);
	};
inline TBool operator==(TInt aLength,TStreamTransfer aTransfer);
inline TBool operator<(TInt aLength,TStreamTransfer aTransfer);

 









 
class MStreamInput;
class MStreamOutput;

 


































class MStreamBuf
	{
public:
	 

	enum TRead {ERead=0x01};

	 

	enum TWrite {EWrite=0x02};

	 












	typedef TInt TMark;
public:
	  void Close();
	inline void Release();
	  TInt Synch();
	inline void SynchL();
 
	  void PushL();
 
	inline TInt ReadL(TAny* aPtr,TInt aMaxLength);
	  TInt Read(TDes8& aDes,TRequestStatus& aStatus);
	  TInt Read(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TInt ReadL(TDes8& aDes,TRequestStatus& aStatus);
	inline TInt ReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer ReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	  TInt ReadL(MStreamInput& anInput,TInt aMaxLength);
	inline void ReadL(MStreamInput& anInput);
 
	inline void WriteL(const TAny* aPtr,TInt aLength);
	  TInt Write(const TDesC8& aDes,TRequestStatus& aStatus);
	  TInt Write(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TInt WriteL(const TDesC8& aDes,TRequestStatus& aStatus);
	inline TInt WriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer WriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
	  TInt WriteL(MStreamOutput& anOutput,TInt aMaxLength);
	inline void WriteL(MStreamOutput& anOutput);
 
	inline void SeekL(TMark aMark,TStreamPos aPos);
	inline TStreamPos SeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TRead,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TWrite,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TRead,TInt anOffset);
	inline TStreamPos SeekL(TWrite,TInt anOffset);
 
	inline TStreamPos TellL(TRead) const;
	inline TStreamPos TellL(TWrite) const;
	inline TInt SizeL() const;
protected:
	MStreamBuf() {}
private:
	MStreamBuf(const MStreamBuf&);
	MStreamBuf& operator=(const MStreamBuf&);
 
	virtual   void DoRelease();
	virtual   void DoSynchL();
	virtual   TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	virtual   TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	virtual   TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	virtual   void DoWriteL(const TAny* aPtr,TInt aLength);
	virtual   TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	virtual   TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
	virtual   TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
	};

 













class MStreamInput
	{
public:
	 











	virtual TInt PushL(const TAny* aPtr,TInt aMaxLength)=0;

	 












	virtual	TStreamTransfer ReadFromL(MStreamBuf& aSource,TStreamTransfer aTransfer)=0;
	};

 













class MStreamOutput
	{
public:
	 











	virtual TInt PullL(TAny* aPtr,TInt aMaxLength)=0;

	 












	virtual TStreamTransfer WriteToL(MStreamBuf& aSink,TStreamTransfer aTransfer)=0;
	};

 


















class TStreamBuf : public MStreamBuf
	{
protected:
	 












	typedef TInt TArea;
protected:
	  TStreamBuf();
 
	  void SetBuf(TArea anArea,TUint8* aPtr,TUint8* anEnd);
	  void SetPtr(TArea anArea,TUint8* aPtr);
	  void SetEnd(TArea anArea,TUint8* anEnd);
	  TUint8* Ptr(TArea anArea) const;
	  TUint8* End(TArea anArea) const;
	  TInt Avail(TArea anArea) const;
 
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
 
	inline void SetBuf(TRead,TUint8* aPtr,TUint8* anEnd);
	inline void SetBuf(TWrite,TUint8* aPtr,TUint8* anEnd);
	inline void SetPtr(TRead,TUint8* aPtr);
	inline void SetPtr(TWrite,TUint8* aPtr);
	inline void SetEnd(TRead,TUint8* anEnd);
	inline void SetEnd(TWrite,TUint8* anEnd);
	inline TUint8* Ptr(TRead) const;
	inline TUint8* Ptr(TWrite) const;
	inline TUint8* End(TRead) const;
	inline TUint8* End(TWrite) const;
	inline TInt Avail(TRead) const;
	inline TInt Avail(TWrite) const;
private:
	 








	virtual TInt UnderflowL(TInt aMaxLength)=0;

	 




	virtual void OverflowL()=0;
private:
	TUint8* iRPtr;
	TUint8* iREnd;
	TUint8* iWPtr;
	TUint8* iWEnd;
	};

 









class TStreamFilter : public MStreamBuf
	{
public:
	enum {EAttached=0x10};
protected:
	  TStreamFilter();
	inline void Set(MStreamBuf* aHost,TInt aMode);
	inline void Committed();
	inline TBool IsCommitted() const;
	  void EmitL(const TAny* aPtr,TInt aLength);
 
	  void DoRelease();
	  void DoSynchL();
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
private:
	 





	virtual TInt Capacity(TInt aMaxLength)=0;

	 









	virtual TInt FilterL(TAny* aPtr,TInt aMaxLength,const TUint8*& aFrom,const TUint8* anEnd)=0;
private:
	MStreamBuf* iHost;
	TInt iMode;
private:
	friend class TFilterInput;
	friend class TFilterOutput;
private:
	  static void __DbgChkMode(TInt aMode);
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32buf.inl" 1
 
 
 
 

 
inline TStreamPos::TStreamPos(TInt anOffset)
	: iOff(anOffset)
 


	{}
inline TBool TStreamPos::operator==(TStreamPos aPos) const
 




	{return iOff==aPos.iOff;}
inline TBool TStreamPos::operator!=(TStreamPos aPos) const
 




	{return iOff!=aPos.iOff;}
inline TBool TStreamPos::operator<(TStreamPos aPos) const
 




	{return iOff<aPos.iOff;}
inline TBool TStreamPos::operator<=(TStreamPos aPos) const
 





	{return iOff<=aPos.iOff;}
inline TBool TStreamPos::operator>(TStreamPos aPos) const
 




	{return iOff>aPos.iOff;}
inline TBool TStreamPos::operator>=(TStreamPos aPos) const
 





	{return iOff>=aPos.iOff;}
inline TInt TStreamPos::operator-(TStreamPos aPos) const
 




	{return iOff-aPos.iOff;}
inline TStreamPos TStreamPos::operator+(TInt anOffset) const
 




	{return TStreamPos(iOff+anOffset);}
inline TStreamPos TStreamPos::operator-(TInt anOffset) const
 




	{return TStreamPos(iOff-anOffset);}
inline TStreamPos& TStreamPos::operator+=(TInt anOffset)
 



	{iOff+=anOffset;return *this;}
inline TStreamPos& TStreamPos::operator-=(TInt anOffset)
 



	{iOff-=anOffset;return *this;}
inline TInt TStreamPos::Offset() const
 


	{return iOff;}
inline TStreamPos operator+(TInt anOffset,TStreamPos aPos)
	{return aPos+anOffset;}

 
inline TStreamTransfer::TStreamTransfer(TInt aMaxLength)
	: iVal(aMaxLength)
 






	{



	}
inline TStreamTransfer::TStreamTransfer(TUnlimited)
	: iVal(-1)
 








	{}
inline TBool TStreamTransfer::operator==(TInt aLength) const
 





	{



	return iVal==aLength;
	}
inline TBool TStreamTransfer::operator>(TInt aLength) const
 





	{



	return TUint(iVal)>TUint(aLength);
	}
inline TStreamTransfer TStreamTransfer::operator-(TInt aLength) const
 








	{



	return iVal<0?*this:TStreamTransfer(iVal-aLength);
	}
inline TInt TStreamTransfer::operator[](TInt aMaxLength) const
	{return *this>aMaxLength?aMaxLength:iVal;}
inline TStreamTransfer& TStreamTransfer::operator-=(TInt aLength)
 













	{



	if (iVal>=0)
		{
		iVal-=aLength;



		}
	return *this;
	}
inline TInt TStreamTransfer::Left() const
 


	{



	return iVal;
	}
inline TBool operator==(TInt aLength,TStreamTransfer aTransfer)
	{return aTransfer==aLength;}
inline TBool operator<(TInt aLength,TStreamTransfer aTransfer)
	{return aTransfer>aLength;}

 
inline void MStreamBuf::Release()
 








	{DoRelease();}
inline void MStreamBuf::SynchL()
 






	{DoSynchL();}
inline TInt MStreamBuf::ReadL(TAny* aPtr,TInt aMaxLength)
 









	{return DoReadL(aPtr,aMaxLength);}
inline TInt MStreamBuf::ReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 














	{return DoReadL(aDes,aMaxLength,aStatus);}
inline TStreamTransfer MStreamBuf::ReadL(MStreamInput& anInput,TStreamTransfer aTransfer)
 







	{return DoReadL(anInput,aTransfer);}
inline void MStreamBuf::ReadL(MStreamInput& anInput)
 







	{DoReadL(anInput,TStreamTransfer(TStreamTransfer::EUnlimited) );}
inline void MStreamBuf::WriteL(const TAny* aPtr,TInt aLength)
 








	{DoWriteL(aPtr,aLength);}
inline TInt MStreamBuf::WriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 















	{return DoWriteL(aDes,aMaxLength,aStatus);}
inline TStreamTransfer MStreamBuf::WriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer)
 








	{return DoWriteL(anOutput,aTransfer);}
inline void MStreamBuf::WriteL(MStreamOutput& anOutput)
 








	{DoWriteL(anOutput,TStreamTransfer(TStreamTransfer::EUnlimited) );}
inline void MStreamBuf::SeekL(TMark aMark,TStreamPos aPos)
 











	{DoSeekL(aMark,EStreamBeginning,aPos.Offset());}
inline TStreamPos MStreamBuf::SeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset)
 























	{return DoSeekL(aMark,aLocation,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TRead,TStreamLocation aLocation,TInt anOffset)
 



















	{return DoSeekL(ERead,aLocation,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TWrite,TStreamLocation aLocation,TInt anOffset)
 



















	{return DoSeekL(EWrite,aLocation,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TRead,TInt anOffset)
 










	{return DoSeekL(ERead,EStreamMark,anOffset);}
inline TStreamPos MStreamBuf::SeekL(TWrite,TInt anOffset)
 










	{return DoSeekL(EWrite,EStreamMark,anOffset);}
inline TStreamPos MStreamBuf::TellL(TRead) const
 






	{return (const_cast< MStreamBuf* >( this )) ->DoSeekL(ERead,EStreamMark,0);}
inline TStreamPos MStreamBuf::TellL(TWrite) const
 






	{return (const_cast< MStreamBuf* >( this )) ->DoSeekL(EWrite,EStreamMark,0);}
inline TInt MStreamBuf::SizeL() const
 


	{return (const_cast< MStreamBuf* >( this )) ->DoSeekL(0,EStreamEnd,0).Offset();}

 
inline void TStreamBuf::SetBuf(TRead,TUint8* aPtr,TUint8* anEnd)
 








	{iRPtr=aPtr;iREnd=anEnd;}
inline void TStreamBuf::SetBuf(TWrite,TUint8* aPtr,TUint8* anEnd)
 








	{iWPtr=aPtr;iWEnd=anEnd;}
inline void TStreamBuf::SetPtr(TRead,TUint8* aPtr)
 






	{iRPtr=aPtr;}
inline void TStreamBuf::SetPtr(TWrite,TUint8* aPtr)
 






	{iWPtr=aPtr;}
inline void TStreamBuf::SetEnd(TRead,TUint8* anEnd)
	{iREnd=anEnd;}
inline void TStreamBuf::SetEnd(TWrite,TUint8* anEnd)
	{iWEnd=anEnd;}
inline TUint8* TStreamBuf::Ptr(TRead) const
 




	{return iRPtr;}
inline TUint8* TStreamBuf::Ptr(TWrite) const
 




	{return iWPtr;}
inline TUint8* TStreamBuf::End(TRead) const
 






	{return iREnd;}
inline TUint8* TStreamBuf::End(TWrite) const
 






	{return iWEnd;}
inline TInt TStreamBuf::Avail(TRead) const
 





	{return iREnd-iRPtr;}
inline TInt TStreamBuf::Avail(TWrite) const
 





	{return iWEnd-iWPtr;}

 
inline void TStreamFilter::Set(MStreamBuf* aHost,TInt aMode)
 













	{



	iHost=aHost;iMode=aMode;
	}
inline void TStreamFilter::Committed()
 
	{iMode&=~EWrite;}
inline TBool TStreamFilter::IsCommitted() const
 


	{return iHost== 0L ||!(iMode&EWrite);}

# 499 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32buf.h" 2


# 8 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h" 1
 
 
 
 
# 352 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32strm.h"

# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 2


class TStreamExchange;
 
















class TStreamMark
	{
public:
	inline TStreamMark();
	inline TStreamMark(TStreamPos aPos);
	inline TStreamMark& operator=(TStreamPos aPos);
	inline operator TStreamMark*();
	inline operator const TStreamMark*() const;
 
	inline TBool operator==(const TStreamMark& aMark) const;
	inline TBool operator==(const TStreamMark* aPtr) const;
	inline TBool operator!=(const TStreamMark& aMark) const;
	inline TBool operator!=(const TStreamMark* aPtr) const;
 
	inline TBool IsEmpty() const;
	inline void Clear();
	inline TStreamPos Position() const;
 
	inline TBool IsWith(TStreamExchange& aHost) const;
	inline TBool RelatesTo(TStreamExchange& aHost) const;
	inline void Withdraw(TStreamExchange& aHost);
	inline void ExtractL(TStreamExchange& aHost);
 
	inline TInt ReadL(TStreamExchange& aHost,TAny* aPtr,TInt aMaxLength);
	  TInt ReadL(TStreamExchange& aHost,TDes8& aDes,TRequestStatus& aStatus);
	inline TInt ReadL(TStreamExchange& aHost,TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer ReadL(TStreamExchange& aHost,MStreamInput& anInput,TStreamTransfer aTransfer);
	inline TInt ReadL(TStreamExchange& aHost,MStreamInput& anInput,TInt aMaxLength);
	inline void ReadL(TStreamExchange& aHost,MStreamInput& anInput);
 
	inline void WriteL(TStreamExchange& aHost,const TAny* aPtr,TInt aLength);
	  TInt WriteL(TStreamExchange& aHost,const TDesC8& aDes,TRequestStatus& aStatus);
	inline TInt WriteL(TStreamExchange& aHost,const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	inline TStreamTransfer WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TStreamTransfer aTransfer);
	inline TInt WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TInt aMaxLength);
	inline void WriteL(TStreamExchange& aHost,MStreamOutput& anOutput);
 
	inline void SeekL(TStreamExchange& aHost,TStreamPos aPos);
	inline TStreamPos SeekL(TStreamExchange& aHost,TStreamLocation aLocation,TInt anOffset=0);
	inline TStreamPos SeekL(TStreamExchange& aHost,TInt anOffset);
 
	inline TStreamPos TellL(TStreamExchange& aHost) const;
private:
	 






	TStreamMark(const TStreamMark&);
	TStreamMark& operator=(const TStreamMark&);
private:
	TStreamPos iPos;
private:
	inline TBool IsTracking(TStreamMark*const& aRef) const;
	inline void Track(TStreamMark*const& aRef);
private:
	friend class TStreamExchange;
private:
	  static void __DbgChkPos(TStreamPos aPos);
	};

 













class TStreamExchange
	{
public:
	inline TStreamExchange();
	inline TStreamExchange(MStreamBuf* aHost);
	inline void Share(MStreamBuf* aHost);
	inline TBool IsActive() const;
	  MStreamBuf* Host();
	  MStreamBuf* HostL();
	  void Release();
 
	  TInt SizeL() const;
private:
 












	typedef MStreamBuf::TMark TMark;
private:
	 


	TStreamExchange(const TStreamExchange&);
	TStreamExchange& operator=(const TStreamExchange&);
 
	  TBool RefersTo(const TStreamMark& aMark);
	  void Drop(const TStreamMark& aMark);
	  void GetL(TStreamMark& aMark);
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength,TStreamMark& aMark);
	  TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	  TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer,TStreamMark& aMark);
	  void DoWriteL(const TAny* aPtr,TInt aLength,TStreamMark& aMark);
	  TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	  TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer,TStreamMark& aMark);
	  TStreamPos DoSeekL(TStreamMark& aMark,TStreamLocation aLocation,TInt anOffset);
 
	void PrepareForReadingL(TStreamMark& aMark);
	void PrepareForWritingL(TStreamMark& aMark);
 
	TInt PrepareAndReadL(TAny* aPtr,TInt aMaxLength,TStreamMark& aMark);
	TInt PrepareAndReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	TStreamTransfer PrepareAndReadL(MStreamInput& anInput,TStreamTransfer aTransfer,TStreamMark& aMark);
	void PrepareAndWriteL(const TAny* aPtr,TInt aLength,TStreamMark& aMark);
	TInt PrepareAndWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus,TStreamMark& aMark);
	TStreamTransfer PrepareAndWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer,TStreamMark& aMark);
	TStreamPos MarkSeekL(TStreamMark& aMark,TStreamLocation aLocation,TInt anOffset);
 
	inline MStreamBuf& BufL() const;
	inline MStreamBuf& Buf() const;
private:
	MStreamBuf* iHost;
	TStreamMark* iRMrk;
	TStreamMark* iWMrk;
private:
	friend class TStreamMark;
	};

 
























class RShareBuf : public MStreamBuf
	{
public:
	  RShareBuf();
	  void Open(TStreamExchange& aHost,TStreamPos aPos,TInt aMode=ERead|EWrite);
	inline void Open(TStreamExchange& aHost,TInt aMode=ERead|EWrite);
protected:
	  void DoRelease();
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TStreamTransfer DoReadL(MStreamInput& anInput,TStreamTransfer aTransfer);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TStreamTransfer DoWriteL(MStreamOutput& anOutput,TStreamTransfer aTransfer);
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline TStreamExchange& Host() const;
private:
	TStreamExchange* iHost;
	TStreamMark iRMark;
	TStreamMark iWMark;
	};

 












class RShareReadStream : public RReadStream
	{
public:
	 




	RShareReadStream() {}
	  RShareReadStream(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
	  void Open(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
private:
	RShareBuf iSource;
	};

 












class RShareWriteStream : public RWriteStream
	{
public:
	 




	RShareWriteStream() {}
	inline RShareWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RShareWriteStream(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
	  void Open(TStreamExchange& aHost,TStreamPos aPos= TStreamPos(0) );
private:
	RShareBuf iSink;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.inl" 1
 
 
 
 

 
inline TStreamMark::TStreamMark()
	: iPos(TStreamPos(0) -1)
 






	{}
inline TStreamMark::TStreamMark(TStreamPos aPos)
	: iPos(aPos)
 






	{



	}
inline TStreamMark& TStreamMark::operator=(TStreamPos aPos)
 



	{



	iPos=aPos;
	return *this;
	}
inline TStreamMark::operator TStreamMark*()
	{return this;}
inline TStreamMark::operator const TStreamMark*() const
	{return this;}
inline TBool TStreamMark::operator==(const TStreamMark& aMark) const
 




	{return this==&aMark;}
inline TBool TStreamMark::operator==(const TStreamMark* aPtr) const
	{return this==aPtr;}
inline TBool TStreamMark::operator!=(const TStreamMark& aMark) const
 




	{return this!=&aMark;}
inline TBool TStreamMark::operator!=(const TStreamMark* aPtr) const
	{return this!=aPtr;}
inline TBool TStreamMark::IsEmpty() const
 


	{return iPos< TStreamPos(0) ;}
inline void TStreamMark::Clear()
 





	{iPos= TStreamPos(0) -1;}
inline TStreamPos TStreamMark::Position() const
 


	{



	return iPos;
	}
inline TBool TStreamMark::IsWith(TStreamExchange& aHost) const
 




	{return aHost.RefersTo(*this);}
inline TBool TStreamMark::RelatesTo(TStreamExchange& aHost) const
 







	{return iPos>= TStreamPos(0) ||aHost.RefersTo(*this);}
inline void TStreamMark::Withdraw(TStreamExchange& aHost)
 



	{aHost.Drop(*this);}
inline void TStreamMark::ExtractL(TStreamExchange& aHost)
 



	{aHost.GetL(*this);}
inline TInt TStreamMark::ReadL(TStreamExchange& aHost,TAny* aPtr,TInt aMaxLength)
 






	{return aHost.DoReadL(aPtr,aMaxLength,*this);}
inline TInt TStreamMark::ReadL(TStreamExchange& aHost,TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 











	{return aHost.DoReadL(aDes,aMaxLength,aStatus,*this);}
inline TStreamTransfer TStreamMark::ReadL(TStreamExchange& aHost,MStreamInput& anInput,TStreamTransfer aTransfer)
 






	{return aHost.DoReadL(anInput,aTransfer,*this);}
inline TInt TStreamMark::ReadL(TStreamExchange& aHost,MStreamInput& anInput,TInt aMaxLength)
 






	{return aMaxLength-aHost.DoReadL(anInput,TStreamTransfer(aMaxLength),*this).Left();}
inline void TStreamMark::ReadL(TStreamExchange& aHost,MStreamInput& anInput)
 





	{aHost.DoReadL(anInput,TStreamTransfer(TStreamTransfer::EUnlimited) ,*this);}
inline void TStreamMark::WriteL(TStreamExchange& aHost,const TAny* aPtr,TInt aLength)
 





	{aHost.DoWriteL(aPtr,aLength,*this);}
inline TInt TStreamMark::WriteL(TStreamExchange& aHost,const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus)
 













	{return aHost.DoWriteL(aDes,aMaxLength,aStatus,*this);}
inline TStreamTransfer TStreamMark::WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TStreamTransfer aTransfer)
 






	{return aHost.DoWriteL(anOutput,aTransfer,*this);}
inline TInt TStreamMark::WriteL(TStreamExchange& aHost,MStreamOutput& anOutput,TInt aMaxLength)
 





	{return aMaxLength-aHost.DoWriteL(anOutput,TStreamTransfer(aMaxLength),*this).Left();}
inline void TStreamMark::WriteL(TStreamExchange& aHost,MStreamOutput& anOutput)
 





	{aHost.DoWriteL(anOutput,TStreamTransfer(TStreamTransfer::EUnlimited) ,*this);}
inline void TStreamMark::SeekL(TStreamExchange& aHost,TStreamPos aPos)
	{aHost.DoSeekL(*this,EStreamBeginning,aPos.Offset());}
inline TStreamPos TStreamMark::SeekL(TStreamExchange& aHost,TStreamLocation aLocation,TInt anOffset)
 














	{return aHost.DoSeekL(*this,aLocation,anOffset);}
inline TStreamPos TStreamMark::SeekL(TStreamExchange& aHost,TInt anOffset)
 





	{return aHost.DoSeekL(*this,EStreamMark,anOffset);}
inline TStreamPos TStreamMark::TellL(TStreamExchange& aHost) const
 



	{return aHost.DoSeekL((const_cast< TStreamMark& >( *this )) ,EStreamMark,0);}

 
inline TStreamExchange::TStreamExchange()
	: iHost(0L ),iRMrk(0L ),iWMrk(0L )
 


	{}
inline TStreamExchange::TStreamExchange(MStreamBuf* aHost)
	: iHost(aHost),iRMrk(0L ),iWMrk(0L )
 



	{}
inline void TStreamExchange::Share(MStreamBuf* aHost)
 



	{iHost=aHost;}
inline TBool TStreamExchange::IsActive() const
 



	{return iHost!= 0L ;}
	
 
inline void RShareBuf::Open(TStreamExchange& aHost,TInt aMode)
 










	{Open(aHost,TStreamPos(0) ,aMode);}

 
inline RShareWriteStream::RShareWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

# 277 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32share.h" 2


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.h" 1
 
 
 
 






 
const TInt KPoolPageSize=512;
 
const TUint32 KNullPageRefValue=0;

 






class TPageRef
	{
public:
	 
	inline TPageRef() {}
	inline TPageRef(TUint32 aValue);
 
	inline TBool operator==(TPageRef aRef) const;
	inline TBool operator!=(TPageRef aRef) const;
 
	inline void ExternalizeL(RWriteStream& aStream) const;
	inline void InternalizeL(RReadStream& aStream);
 
	inline TUint32 Value() const;
private:
	TUint32 iVal;
	};







class MPagePool;
 



typedef void (*TPageAbandonFunction)(MPagePool& aPool);

 




enum TPageReclamation 
	 



	{EPageDeleteOnly,
	 



	EPageReclaimable};

 
enum TPageChange 
	 
	{EPageNoChange,
	 
	EPageDirty,
	 
	EPageUpdate,
	 
	EPageAbandon=-1};


 








class MPagePool
	{
public:
	  void PushL();
	inline void Pop();

	 


	virtual TPageAbandonFunction AcquireL()=0;
 
	virtual TAny* AllocL()=0;

	 



	virtual TAny* LockL(TPageRef aRef)=0;
 
	virtual TPageRef AssignL(const TAny* aPage,TPageReclamation aReclamation=EPageDeleteOnly)=0;

	 




	virtual void UpdateL(const TAny* aPage)=0;

	 



	virtual void Unlock(const TAny* aPage,TPageChange aChange=EPageNoChange)=0;
 
	  void Delete(TPageRef aRef);
	  void DeleteL(TPageRef aRef);
protected:
	virtual void DoDeleteL(TPageRef aRef)=0;
	};

 







class CMemPagePool : public CBase,public MPagePool
	{
public:
	  static CMemPagePool* NewL();
	  static CMemPagePool* NewLC();
	  CMemPagePool();
	  ~CMemPagePool();
 
	  TPageAbandonFunction AcquireL();
	  TAny* AllocL();
	  TAny* LockL(TPageRef aRef);
	  TPageRef AssignL(const TAny* aPage,TPageReclamation aReclamation=EPageDeleteOnly);
	  void UpdateL(const TAny* aPage);
	  void Unlock(const TAny* aPage,TPageChange aChange=EPageNoChange);
protected:
	  void DoDeleteL(TPageRef aRef);
private:
	TAny*& PageL(TPageRef aRef);
	static void DoAbandon(MPagePool& aPool);
private:
	CArrayFixSeg<TAny*> iPages;
	};
 



 
class TCachePage;
struct SCachePage;
class TCachePagePool;

 







class CPageCache : public CBase
	{
public:
	enum {EDefaultPages=20};
# 205 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.h"

public:
	  static CPageCache* NewL(TInt aPages=EDefaultPages);
	  static CPageCache* NewLC(TInt aPages=EDefaultPages);
	  CPageCache();
	  void ConstructL(TInt aPages=EDefaultPages);
	  ~CPageCache();
 




private:
	TCachePage* Find(TCachePagePool* aPool,TPageRef aRef);
private:
	SCachePage* iPages;
	SCachePage* iEnd;
	TDblQue<TCachePage> iFree;



private:
	friend class TCachePagePool;
	};

 










class TCachePagePool : public MPagePool
	{
public:
	inline void Set(CPageCache& aCache);
 
	  TPageAbandonFunction AcquireL();
	  TAny* AllocL();
	  TAny* LockL(TPageRef aRef);
	  TPageRef AssignL(const TAny* aPage,TPageReclamation aReclamation=EPageDeleteOnly);
	  void UpdateL(const TAny* aPage);
	  void Unlock(const TAny* aPage,TPageChange aChange=EPageNoChange);
 
	  TInt Flush();
	  void FlushL();
	  void Purge();
protected:
	inline TCachePagePool();
	inline TCachePagePool(CPageCache& aCache);
	  void DoDeleteL(TPageRef aRef);
private:
	virtual TPageRef ExtendL(const TAny* aPage,TPageReclamation aReclamation)=0;
	virtual void WriteL(TPageRef aRef,const TAny* aPage,TPageChange aChange)=0;
	virtual void ReadL(TPageRef aRef,TAny* aPage)=0;
 
	static void DoAbandon(MPagePool& aPool);
	static TCachePage* DoAllocL(CPageCache& aCache);
private:
	CPageCache* iCache;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.inl" 1
 
 
 
 

 
inline TPageRef::TPageRef(TUint32 aValue)
	: iVal(aValue)
 


	{}
inline TBool TPageRef::operator==(TPageRef aRef) const
 



	{return iVal==aRef.iVal;}
inline TBool TPageRef::operator!=(TPageRef aRef) const
 




	{return iVal!=aRef.iVal;}
inline void TPageRef::ExternalizeL(RWriteStream& aStream) const
 


	{aStream<<iVal;}
inline void TPageRef::InternalizeL(RReadStream& aStream)
 


	{aStream>>iVal;}
inline TUint32 TPageRef::Value() const
 


	{return iVal;}

 
inline void MPagePool::Pop()
 
	{CleanupStack::Pop();}

 
# 57 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.inl"


 







 
inline void TCachePagePool::Set(CPageCache& aCache)
 


	{iCache=&aCache;}
inline TCachePagePool::TCachePagePool()
	: iCache(0L )
	{}
inline TCachePagePool::TCachePagePool(CPageCache& aCache)
	: iCache(&aCache)
	{}

# 271 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32page.h" 2


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 2



class MIncrementalCollector;
 





class CStreamStore : public CBase
	{
public:
	inline TStreamId ExtendL();
	  void Delete(TStreamId anId);
	  void DeleteL(TStreamId anId);
 
	  TInt Commit();
	inline void CommitL();
	  void Revert();
	inline void RevertL();
 
	  TInt ReclaimL();
	  TInt CompactL();
private:
	virtual   TStreamId DoExtendL();
	virtual   void DoDeleteL(TStreamId anId);
	
	 









	virtual MStreamBuf* DoReadL(TStreamId anId) const=0;
	
	 






	virtual MStreamBuf* DoCreateL(TStreamId& anId)=0;
	virtual   MStreamBuf* DoWriteL(TStreamId anId);
	virtual   MStreamBuf* DoReplaceL(TStreamId anId);
	virtual   void DoCommitL();
	virtual   void DoRevertL();
	virtual   MIncrementalCollector* DoReclaimL();
	virtual   MIncrementalCollector* DoCompactL();
private:
	friend class RStoreReadStream;
	friend class RStoreWriteStream;
	friend class RStoreReclaim;
	};

 











class CPersistentStore : public CStreamStore
	{
public:
	inline TStreamId Root() const;
	inline void SetRootL(TStreamId anId);
protected:
	inline CPersistentStore();
private:
	virtual   void DoSetRootL(TStreamId anId);
protected:
	TStreamId iRoot;
	};

 























class RStoreReclaim
	{
public:
	inline RStoreReclaim();
	  void OpenL(CStreamStore& aStore,TInt& aCount);
	  void OpenLC(CStreamStore& aStore,TInt& aCount);
	  void CompactL(CStreamStore& aStore,TInt& aCount);
	  void CompactLC(CStreamStore& aStore,TInt& aCount);
	inline void Close();
	  void Release();
 
	  void ResetL(TInt& aCount);
	  void NextL(TInt& aStep);
	  void Next(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus);
	  void NextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus);
	  TInt Next(TInt& aStep);
 
	inline TInt Available() const;
private:
	MIncrementalCollector* iCol;
	TPckgBuf<TInt> iAvail;
	};

 















class CEmbeddedStore : public CPersistentStore
	{
public:
	  static CEmbeddedStore* FromL(RReadStream& aHost);
	  static CEmbeddedStore* FromLC(RReadStream& aHost);
	  static CEmbeddedStore* NewL(RWriteStream& aHost);
	  static CEmbeddedStore* NewLC(RWriteStream& aHost);
 
	inline static TStreamPos Position(TStreamId anId);
 
	  void Detach();
	inline void Reattach(MStreamBuf* aHost);
	inline MStreamBuf* Host() const;
	inline TStreamPos Start() const;
 
	  CEmbeddedStore(MStreamBuf* aHost);
	  void MarshalL(RReadStream& aStream);
	  void ConstructL(RWriteStream& aStream);
	  ~CEmbeddedStore();
protected:
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
private:
	  void DoSetRootL(TStreamId anId);
	  void DoCommitL();
 
	static CEmbeddedStore* DoNewLC(MStreamBuf* aHost);
private:
	  TStreamExchange iHost;
	TStreamPos iStart;
	};

 























class CDictionaryStore : public CBase
	{
public:
	  TBool IsNullL() const;
	  TBool IsPresentL(TUid aUid) const;
	  void Remove(TUid aUid);
	  void RemoveL(TUid aUid);
 
	  TInt Commit();
	  void CommitL();
	  void Revert();
	  void RevertL();
 
	  ~CDictionaryStore();
protected:
	  void ConstructL();
private:
	CStreamDictionary* DictionaryL() const;
	MStreamBuf* GetSourceL(TUid aUid) const;
	MStreamBuf* GetSinkL(TUid aUid);
protected:
	CPersistentStore* iStore;
private:
	  CStreamDictionary* iDictionary;
	TBool iDictionaryHasChanged;
private:
	friend class RDictionaryReadStream;
	friend class RDictionaryWriteStream;
	friend class HDictionaryStoreBuf;
	};
 
const TInt KDictionaryCommitThreshold = 1024;

 









class RDictionaryReadStream : public RReadStream
{
public:
	  void OpenL(const CDictionaryStore& aDictStore,TUid aUid);
	  void OpenLC(const CDictionaryStore& aDictStore,TUid aUid);
	};

 






class RDictionaryWriteStream : public RWriteStream
	{
public:
	 

	RDictionaryWriteStream() {}
	inline RDictionaryWriteStream(const MExternalizer<TStreamRef>& anExter);
	  void AssignL(CDictionaryStore& aDictStore,TUid aUid);
	  void AssignLC(CDictionaryStore& aDictStore,TUid aUid);
	};

 






class TStorePagePoolToken
	{
public:
	 
	enum TEmpty 
		 
		{EEmpty};
public:
	 
	TStorePagePoolToken() {}

	 


	inline TStorePagePoolToken(TEmpty);
	inline void Touch();
 
	inline TBool HasAvailable() const;
	inline TBool IsEmpty() const;
 
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
private:
	inline TStorePagePoolToken(TStreamId aHead,TPageRef anAvail);
private:
	TStreamId iHead;
	TPageRef iAvail;
private:
	friend class RStorePagePool;
	};







 























class RStorePagePool : public TCachePagePool
	{
	friend class StorePagePool;
public:
	  RStorePagePool();
	  RStorePagePool(CPageCache& aCache);
	  RStorePagePool(CStreamStore& aStore);
	  RStorePagePool(CStreamStore& aStore,const TStorePagePoolToken& aToken);
	  void Create(CStreamStore& aStore);
	  void Open(CStreamStore& aStore,const TStorePagePoolToken& aToken);
	  TStorePagePoolToken Token() const;
	  void Close();
	inline void Release();
 
	inline TBool IsDirty() const;
	inline void MarkCurrent();
	inline void MarkDirty();
 
	inline TBool HasAvailable() const;
	inline void Discard();
 
	inline TBool IsEmpty() const;
	  TBool ReclaimL();
	  void ReclaimAllL();
protected:
	  TPageRef ExtendL(const TAny* aPage,TPageReclamation aReclamation);
	  void WriteL(TPageRef aRef,const TAny* aPage,TPageChange aChange);
	  void ReadL(TPageRef aRef,TAny* aPage);
	  void DoDeleteL(TPageRef aRef);
private:
	inline void CacheDeleteL(TPageRef aRef);
private:
	CStreamStore* iStore;
	TStreamId iHead;
	TPageRef iAvail;
	TBool iDirty;
	};

 




















class MIncrementalCollector
	{
public:
	inline void Close();
	inline void Release();
 
	inline void ResetL(TInt& aCount);
	inline void NextL(TInt& aStep,TInt& aTotal);
	inline void NextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus,TPckgBuf<TInt>& aTotal);
protected:
	 







	MIncrementalCollector() {}
private:
	 







	MIncrementalCollector(const MIncrementalCollector&);
	MIncrementalCollector& operator=(const MIncrementalCollector&);
 
	virtual   void DoRelease();
	
	 





	virtual void DoResetL(TInt& aCount)=0;

	 











	virtual void DoNextL(TInt& aStep,TInt& aTotal)=0;
	virtual   void DoNextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus,TPckgBuf<TInt>& aTotal);
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.inl" 1
 
 
 
 

 
inline TStreamId CStreamStore::ExtendL()
 






	{return DoExtendL();}
inline void CStreamStore::CommitL()
 


	{DoCommitL();}
inline void CStreamStore::RevertL()
 






	{DoRevertL();}

 
inline CPersistentStore::CPersistentStore()
 
	{}
inline TStreamId CPersistentStore::Root() const
 


	{return iRoot;}
inline void CPersistentStore::SetRootL(TStreamId anId)
 


	{DoSetRootL(anId);}

 
inline RStoreReclaim::RStoreReclaim()
	: iCol(0L )
	{}
inline void RStoreReclaim::Close()
 










	{Release();}
inline TInt RStoreReclaim::Available() const
 



	{return (const_cast< TPckgBuf<TInt>& >( iAvail )) ();}

 
inline TStreamPos CEmbeddedStore::Position(TStreamId anId)
 




	{return TStreamPos(anId.Value());}
inline void CEmbeddedStore::Reattach(MStreamBuf* aHost)
 




	{iHost.Share(aHost);}
inline MStreamBuf* CEmbeddedStore::Host() const
 



	{return (const_cast< TStreamExchange& >( iHost )) .Host();}
inline TStreamPos CEmbeddedStore::Start() const
 


	{return iStart;}

 
inline RDictionaryWriteStream::RDictionaryWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
 




	{}

 
inline TStorePagePoolToken::TStorePagePoolToken(TEmpty)
	: iHead(TStreamId(KNullStreamIdValue) ),iAvail(TPageRef(KNullPageRefValue) )
 


	{}
inline void TStorePagePoolToken::Touch()
 
	{iAvail= TPageRef(KNullPageRefValue) ;}
inline TBool TStorePagePoolToken::HasAvailable() const
 


	{return iAvail!= TPageRef(KNullPageRefValue) ;}
inline TBool TStorePagePoolToken::IsEmpty() const
 


	{return iHead== TStreamId(KNullStreamIdValue) ;}

 
inline void RStorePagePool::Release()
 
	{Purge();iStore= 0L ;}
inline TBool RStorePagePool::IsDirty() const
 


	{return iDirty;}
inline void RStorePagePool::MarkCurrent()
 
	{iDirty=EFalse;}
inline void RStorePagePool::MarkDirty()	
 
	{iDirty=ETrue;}
inline TBool RStorePagePool::HasAvailable() const
 


	{return iAvail!= TPageRef(KNullPageRefValue) ;}
inline void RStorePagePool::Discard()
 




	{iAvail= TPageRef(KNullPageRefValue) ;}
inline TBool RStorePagePool::IsEmpty() const
 


	{return iHead== TStreamId(KNullStreamIdValue) ;}

 
inline void MIncrementalCollector::Close()
 


	{DoRelease();}
inline void MIncrementalCollector::Release()
 




	{DoRelease();}
inline void MIncrementalCollector::ResetL(TInt& aCount)
 






	{DoResetL(aCount);}
inline void MIncrementalCollector::NextL(TInt& aStep,TInt& aTotal)
 













	{DoNextL(aStep,aTotal);}
inline void MIncrementalCollector::NextL(TPckgBuf<TInt>& aStep,TRequestStatus& aStatus,TPckgBuf<TInt>& aTotal)
 
















	{DoNextL(aStep,aStatus,aTotal);}

# 470 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 2


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h" 2



 
const TInt KDefaultFileBufSize=0x600;

template <class T>
class TCapture;
class RPermanentFileStoreIter;

 


















class RFileBuf : public TStreamBuf
	{
public:
	  RFileBuf();
	  RFileBuf(TInt aSize);
	RFileBuf(TCapture<RFileBuf> aCapture);
	  void Reset();
	inline void Reset(TInt aSize);
 
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	  void Attach(RFile& aFile,TInt aPos=0);
	  void Close();
	inline void Detach();
	inline void Reattach(RFile& aFile);
 
	  void SetSizeL(TInt aSize);
	inline RFile& File() const;
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  void DoRelease();
	  void DoSynchL();
	  TInt DoReadL(TAny* aPtr,TInt aMaxLength);
	  TInt DoReadL(TDes8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TInt DoWriteL(const TDesC8& aDes,TInt aMaxLength,TRequestStatus& aStatus);
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
 
	inline void SetBuf(TRead,TUint8* aPtr,TUint8* anEnd);
	inline void SetBuf(TWrite,TUint8* aPtr,TUint8* anEnd);
	inline void SetBuf(TArea anArea,TUint8* aPtr,TUint8* anEnd);
private:
	TUint8* AllocL();
	void Free();
 
	void SetPos(TMark aMark,TInt aPos);
	inline void SetPos(TRead,TInt aPos);
	inline void SetPos(TWrite,TInt aPos);
	inline TInt Pos(TRead) const;
	inline TInt Pos(TWrite) const;
	inline TInt MovePos(TRead,TInt anOffset);
	inline TInt MovePos(TWrite,TInt anOffset);
	TInt FileReadL(TAny* aPtr,TInt aMaxLength);
	void FileWriteL(const TAny* aPtr,TInt aLength,TInt aSeek);
	void FileWriteL(const TAny* aPtr,TInt aLength);
	TInt EndL();
 
	inline TInt Lag(TRead) const;
	inline TInt Lag(TWrite) const;
	TInt Mark(TMark aMark) const;
	inline TInt Mark(TRead) const;
	inline TInt Mark(TWrite) const;
	inline TUint8* Limit(TWrite) const;
	inline void SetLimit(TWrite,TUint8* aLimit);
	inline TInt Span(TWrite) const;
	inline TInt Reach(TWrite) const;
private:
	TUint8* iBase;
	TInt iSize;
	  RFile iFile;
	TInt iRPos;
	TInt iWPos;
	TInt iExt;
	TUint8* iWLim;
	};

 




class RFileReadStream : public RReadStream
	{
public:
	 
	RFileReadStream() {}
	  RFileReadStream(RFile& aFile,TInt aPos=0);
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  void Attach(RFile& aFile,TInt aPos=0);
private:
	RFileBuf iSource;
	};

 




class RFileWriteStream : public RWriteStream
	{
public:
	 
	RFileWriteStream() {}
	inline RFileWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RFileWriteStream(RFile& aFile,TInt aPos=0);
	  TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	  void Attach(RFile& aFile,TInt aPos=0);
private:
	RFileBuf iSink;
	};
 
class CFileStore;

 





class FileStoreFactory
	{
public:
	  static CFileStore* DirectLC(RFileBuf& aBuf,const TUidType& aType);
	  static CFileStore* PermanentLC(RFileBuf& aBuf,const TUidType& aType);
	};
 
const TInt KDirectFileStoreLayoutUidValue=268435511;
 
const TInt KPermanentFileStoreLayoutUidValue=268435536;
 
const TUid KDirectFileStoreLayoutUid={KDirectFileStoreLayoutUidValue};
 
const TUid KPermanentFileStoreLayoutUid={KPermanentFileStoreLayoutUidValue};
 
typedef CFileStore* (*TFileStoreFactoryFunction)(RFileBuf& aBuf,const TUidType& aType);
 



 


















class CFileStore : public CPersistentStore
	{
public:
	  static CFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  static CFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	  static CFileStore* FromL(RFile& aFile);
	  static CFileStore* FromLC(RFile& aFile);
 
	  static CFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode,const TFileStoreFactoryFunction aFactory[]);
	  static CFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode,const TFileStoreFactoryFunction aFactory[]);
	  static CFileStore* FromL(RFile& aFile,const TFileStoreFactoryFunction aFactory[]);
	  static CFileStore* FromLC(RFile& aFile,const TFileStoreFactoryFunction aFactory[]);
 
	inline const TUidType& Type() const;
	  void SetTypeL(const TUidType& aType);
	 








	virtual TUid Layout() const=0;
 
	inline void Reset();
	inline void Reset(TInt aSize);
	inline void Detach();
	inline void Reattach(RFile& aFile);
	inline RFile& File() const;
 
	  void MarshalL();
	  ~CFileStore();
protected:
	typedef CFileStore* (*TNewFunction)(RFile& aFile);
protected:
	  static CFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode,TFileStoreFactoryFunction aFunction);
	  static CFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode,TFileStoreFactoryFunction aFunction);
	  static CFileStore* CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode,TNewFunction aFunction);
	  static CFileStore* TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode,TNewFunction aFunction);
 
	  static CFileStore* FromL(RFile& aFile,TFileStoreFactoryFunction aFunction);
	  static CFileStore* FromLC(RFile& aFile,TFileStoreFactoryFunction aFunction);
	  static CFileStore* NewL(RFile& aFile,TNewFunction aFunction);
	  static CFileStore* NewLC(RFile& aFile,TNewFunction aFunction);
 
	  CFileStore(RFile& aFile);
	  CFileStore(RFileBuf& aBuf,const TUidType& aType);
	  void Destruct();
 
	inline TStreamExchange& Host() const;
	inline TBool IsHost(const MStreamBuf* aBuf) const;
	  void SynchL();
	inline void SetSizeL(TInt aSize);
	  void ChangedL();
	  void RefreshL();
 
	  void DoCommitL();
	  void DoRevertL();
private:
	virtual void ExternalizeL(RWriteStream& aStream) const=0;
	virtual void InternalizeL(RReadStream& aStream)=0;
 
	static CFileStore* DoNewL(RFile& aFile,TNewFunction aFunction);
private:
	RFileBuf iBuf;
	TUidType iType;
	  TStreamExchange iHost;
	};
const TInt KFileStoreStartOffset=sizeof(TCheckedUid);






 










class CDirectFileStore : public CFileStore
	{
public:
	inline static CDirectFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CDirectFileStore* TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	inline static CDirectFileStore* TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
 
	inline static CDirectFileStore* FromL(RFile& aFile);
	inline static CDirectFileStore* FromLC(RFile& aFile);
	inline static CDirectFileStore* NewL(RFile& aFile);
	inline static CDirectFileStore* NewLC(RFile& aFile);
 
	  TUid Layout() const;
 
	  CDirectFileStore(RFile& aFile);
	  CDirectFileStore(RFileBuf& aBuf,const TUidType& aType);
protected:
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
private:
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
	  void DoSetRootL(TStreamId anId);
 
	  static CFileStore* DoNewL(RFile& aFile);
	};
 
class CPermanentStoreCoord;

 







class CPermanentFileStore : public CFileStore
	{
	friend class RPermanentFileStoreIter;
public:
	inline static CPermanentFileStore* OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline static CPermanentFileStore* TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	inline static CPermanentFileStore* TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
 
	inline static CPermanentFileStore* FromL(RFile& aFile);
	inline static CPermanentFileStore* FromLC(RFile& aFile);
	inline static CPermanentFileStore* NewL(RFile& aFile);
	inline static CPermanentFileStore* NewLC(RFile& aFile);
 
	  TUid Layout() const;
 
	  CPermanentFileStore(RFile& aFile);
	  CPermanentFileStore(RFileBuf& aBuf,const TUidType& aType);
	  void MarshalL();
	  ~CPermanentFileStore();
protected:
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
	  MStreamBuf* DoWriteL(TStreamId anId);
	  MStreamBuf* DoReplaceL(TStreamId anId);
private:
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
	  void DoSetRootL(TStreamId anId);
	  TStreamId DoExtendL();
	  void DoDeleteL(TStreamId anId);
	  void DoCommitL();
	  void DoRevertL();
	  MIncrementalCollector* DoReclaimL();
	  MIncrementalCollector* DoCompactL();
 
	inline CPermanentStoreCoord& Coord() const;
	CPermanentStoreCoord& CoordL() const;
	CPermanentStoreCoord& TrimL();
 
	  static CFileStore* DoNewL(RFile& aFile);
private:
	  CPermanentStoreCoord* iCoord;
	};

 









class CDictionaryFileStore : public CDictionaryStore
	{
public:
	  static CDictionaryFileStore* SystemL(RFs& aFs);
	  static CDictionaryFileStore* SystemLC(RFs& aFs);
	  static CDictionaryFileStore* OpenL(RFs& aFs,const TDesC& aName,TUid aUid3);
	  static CDictionaryFileStore* OpenLC(RFs& aFs,const TDesC& aName,TUid aUid3);
private:
	void ConstructL(RFs& aFs,const TDesC& aName,TUid aUid3);
	void CreateStoreL(RFile& aFile,const TUidType& aType);
	};

 














class RFilePagePool : public TCachePagePool
	{
public:
	  RFilePagePool();
	  RFilePagePool(CPageCache& aCache);
 
	inline TInt Open(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline TInt Create(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline TInt Replace(RFs& aFs,const TDesC& aName,TUint aFileMode);
	inline TInt Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode);
	inline void Attach(RFile& aFile);
	  void Close();
	  void Release();
	  TInt Flush();
	  void FlushL();
	inline void Detach();
 
	inline RFile& File() const;
protected:
	  TPageRef ExtendL(const TAny* aPage,TPageReclamation aReclamation);
	  void WriteL(TPageRef aRef,const TAny* aPage,TPageChange aChange);
	  void ReadL(TPageRef aRef,TAny* aPage);
private:
	  RFile iFile;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.inl" 1
 
 
 
 

 
inline void RFileBuf::Reset(TInt aSize)
 






	{Reset();iSize=aSize;}
inline void RFileBuf::Detach()
 







	{iFile=RFile();}
inline void RFileBuf::Reattach(RFile& aFile)
 









	{iFile=aFile;}
inline RFile& RFileBuf::File() const
 


	{return (const_cast< RFile& >( iFile )) ;}

 
inline RFileWriteStream::RFileWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

 
inline const TUidType& CFileStore::Type() const
 



	{return iType;}
inline void CFileStore::Reset()
 








	{iBuf.Reset();}
inline void CFileStore::Reset(TInt aSize)
 











	{iBuf.Reset(aSize);}
inline void CFileStore::Detach()
 











	{iBuf.Detach();}
inline void CFileStore::Reattach(RFile& aFile)
 




	{iBuf.Reattach(aFile);}
inline RFile& CFileStore::File() const
 





	{return iBuf.File();}
inline TStreamExchange& CFileStore::Host() const
	{return (const_cast< TStreamExchange& >( iHost )) ;}
inline TBool CFileStore::IsHost(const MStreamBuf* aBuf) const
	{return aBuf==&iBuf;}
inline void CFileStore::SetSizeL(TInt aSize)
	{iBuf.SetSizeL(aSize);}

 
inline CDirectFileStore* CDirectFileStore::OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CDirectFileStore* >( CFileStore::OpenL(aFs,aName,aFileMode,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CDirectFileStore* >( CFileStore::OpenLC(aFs,aName,aFileMode,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::CreateL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::CreateLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CDirectFileStore* >( CFileStore::ReplaceL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CDirectFileStore* >( CFileStore::ReplaceLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CDirectFileStore* >( CFileStore::TempL(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CDirectFileStore* >( CFileStore::TempLC(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::FromL(RFile& aFile)
 








	{return (static_cast< CDirectFileStore* >( CFileStore::FromL(aFile,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::FromLC(RFile& aFile)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::FromLC(aFile,(&FileStoreFactory::DirectLC) ) )) ;}
inline CDirectFileStore* CDirectFileStore::NewL(RFile& aFile)
 









	{return (static_cast< CDirectFileStore* >( CFileStore::NewL(aFile,&DoNewL) )) ;}
inline CDirectFileStore* CDirectFileStore::NewLC(RFile& aFile)
 










	{return (static_cast< CDirectFileStore* >( CFileStore::NewLC(aFile,&DoNewL) )) ;}

 
inline CPermanentFileStore* CPermanentFileStore::OpenL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CPermanentFileStore* >( CFileStore::OpenL(aFs,aName,aFileMode,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::OpenLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return (static_cast< CPermanentFileStore* >( CFileStore::OpenLC(aFs,aName,aFileMode,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::CreateL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::CreateL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::CreateLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::CreateLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::ReplaceL(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CPermanentFileStore* >( CFileStore::ReplaceL(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::ReplaceLC(RFs& aFs,const TDesC& aName,TUint aFileMode)
 










	{return (static_cast< CPermanentFileStore* >( CFileStore::ReplaceLC(aFs,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::TempL(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CPermanentFileStore* >( CFileStore::TempL(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::TempLC(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 















	{return (static_cast< CPermanentFileStore* >( CFileStore::TempLC(aFs,aPath,aName,aFileMode,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::FromL(RFile& aFile)
 








	{return (static_cast< CPermanentFileStore* >( CFileStore::FromL(aFile,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::FromLC(RFile& aFile)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::FromLC(aFile,(&FileStoreFactory::PermanentLC) ) )) ;}
inline CPermanentFileStore* CPermanentFileStore::NewL(RFile& aFile)
 









	{return (static_cast< CPermanentFileStore* >( CFileStore::NewL(aFile,&DoNewL) )) ;}
inline CPermanentFileStore* CPermanentFileStore::NewLC(RFile& aFile)
 










	{return (static_cast< CPermanentFileStore* >( CFileStore::NewLC(aFile,&DoNewL) )) ;}

 
inline TInt RFilePagePool::Open(RFs& aFs,const TDesC& aName,TUint aFileMode)
 








	{return iFile.Open(aFs,aName,aFileMode);}
inline TInt RFilePagePool::Create(RFs& aFs,const TDesC& aName,TUint aFileMode)
 









	{return iFile.Create(aFs,aName,aFileMode);}
inline TInt RFilePagePool::Replace(RFs& aFs,const TDesC& aName,TUint aFileMode)
 












	{return iFile.Replace(aFs,aName,aFileMode);}
inline TInt RFilePagePool::Temp(RFs& aFs,const TDesC& aPath,TFileName& aName,TUint aFileMode)
 









	{return iFile.Temp(aFs,aPath,aName,aFileMode);}
inline void RFilePagePool::Attach(RFile& aFile)
 


	{iFile=aFile;}
inline void RFilePagePool::Detach()
 
	{iFile=RFile();}
inline RFile& RFilePagePool::File() const
	{return (const_cast< RFile& >( iFile )) ;}

# 440 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h" 2


# 71 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 1
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/w32std.h" 1
 
 
 
 

 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 2


class TOpenFontCharMetrics;

 




const TInt KTwipsPerInch=1440;

 




const TInt KTwipsPerPoint=20;

 




const TInt KPointsPerInch=72;

 




const TInt KTwipsPerCm=567;

 






 





 





 






 






 






 






 





# 109 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h"



 


enum TGdiPanic
	{
	 
	EGdiPanic_Unknown				= 0,
	 
	EGdiPanic_InvalidInputParam		= 1,
	 
	EGdiPanic_OutOfText				= 2,
	 
	EGdiPanic_Invariant				= 3
	};

 
































class TRgb
	{
public:
	inline TRgb();
	inline TRgb(TUint32 aValue);
	inline TRgb(TInt aRed,TInt aGreen,TInt aBlue);
	inline TInt Red() const;
	inline TInt Green() const;
	inline TInt Blue() const;
	  void SetRed(TInt aRed);
	  void SetGreen(TInt aGreen);
	  void SetBlue(TInt aBlue);
	  static TRgb Gray2(TInt aGray2);
	  static TRgb Gray4(TInt aGray4);
	  static TRgb Gray16(TInt aGray16);
	  static TRgb Gray256(TInt aGray256);
	  static TRgb Color16(TInt aColor16);
	  static TRgb Color256(TInt aColor256);
	  static TRgb Color4K(TInt aColor4K);
	  static TRgb Color64K(TInt aColor64K);
	  static TRgb Color16M(TInt aColor16M);
	  TInt Gray2() const;
	  TInt Gray4() const;
	  TInt Gray16() const;
	  TInt Gray256() const;
	  TInt Color16() const;
	  TInt Color256() const;
	  TInt Color4K() const;
	  TInt Color64K() const;
	  TInt Color16M() const;
	inline TBool operator==(const TRgb& aColor) const;
	inline TBool operator!=(const TRgb& aColor) const;
	inline TRgb operator~() const;
	inline TRgb operator&(const TRgb& aColor);
	inline TRgb operator|(const TRgb& aColor);
	inline TRgb operator^(const TRgb& aColor);
	inline TRgb& operator&=(const TRgb& aColor);
	inline TRgb& operator|=(const TRgb& aColor);
	inline TRgb& operator^=(const TRgb& aColor);
	inline TUint32 Value() const;
	  TInt Difference(const TRgb& aColor) const;
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  static TRgb Color16MU(TInt a0RGB);
	  TInt Color16MU() const;

	inline TInt _Gray2() const;
	inline TInt _Gray4() const;
	inline TInt _Gray16() const;
	inline TInt _Gray256() const;
	inline TInt _Color4K() const;
	inline TInt _Color64K() const;
	inline TInt _Color16M() const;
	inline TInt _Color16MU() const;
	inline static TRgb _Gray2(TInt aGray2);
	inline static TRgb _Gray4(TInt aGray4);
	inline static TRgb _Gray16(TInt aGray16);
	inline static TRgb _Gray256(TInt aGray256);
	inline static TRgb _Color4K(TInt aColor4K);
	inline static TRgb _Color64K(TInt aColor64K);
	inline static TRgb _Color16M(TInt aColor16M);
	inline static TRgb _Color16MU(TInt a0RGB);

private:
	TUint32 iValue;
	};

 





















 



enum TDisplayMode
	{
	 
	ENone,
	 
	EGray2,
	 
	EGray4,
	 
	EGray16,
	 
	EGray256,
	 
	EColor16,
	 
	EColor256,
	 
	EColor64K,
	 
	EColor16M,
	 
	ERgb,
	 
	EColor4K,
	EColor16MU,
	 
	 
	 
	 
	EColorLast
	};



 



class TDisplayModeUtils
	{
public:
	  static TBool IsDisplayModeColor(TDisplayMode aDispMode);
	  static TInt NumDisplayModeColors(TDisplayMode aDispMode);
	  static TInt NumDisplayModeBitsPerPixel(TDisplayMode aDispMode);
	};


 






















class CPalette : public CBase
	{
public:
	  static CPalette* NewL(TInt aNumberOfEntries);
	  static CPalette* NewDefaultL(TDisplayMode aDispMode);
	  ~CPalette();
	  void Clear();
	inline TInt Entries() const;
	  TRgb GetEntry(TInt aPaletteIndex) const;
	  TRgb NearestEntry(const TRgb& aColor) const;
	  TInt NearestIndex(const TRgb& aColor) const;
	  void SetEntry(TInt aPaletteIndex,const TRgb& aPaletteEntry);
	  void GetDataPtr(TInt aFirstColor,TInt aNumColors,TPtr8& aPtr);
protected:
	  CPalette();
	void ConstructL(TInt aNumberOfEntries);
protected:
	TRgb* iArray;
	TInt iNumEntries;
	};


 




class TColor256Util
	{
public:
	  void Construct(const CPalette& aPalette);
	  TInt Color256(TRgb aRgb) const;
	  void Color256(TUint8* aDestination,const TRgb* aSource,TInt aNumPixels) const;
	inline TRgb Color256(TInt aColor256) const;
	  static const TColor256Util* Default();
public:
	 





	TUint32	iColorTable[256];

	 








	TUint8	iInverseColorTable[0x1000];
	};


 










class TLinearDDA
	{
public:
	 
	enum TLineMode
		{
		 
		ECenter,
		 

		ELeft
		};
public:
	  TLinearDDA();
	  TLinearDDA(const TLinearDDA& aLine);
	  void Construct(const TPoint& aStart,const TPoint& aFinish,TLineMode aMode=ECenter);
	  TBool SingleStep(TPoint& aPosition);
	  TBool SingleScanline(TPoint& aStartPosition,TPoint& aEndPosition);
	  TBool NextStep(TPoint& aPosition);
	  void JumpToRect(const TRect& aRect);
	  void JumpToXCoord(const TInt aXCoord,TInt& aYCoord);
	  void JumpToYCoord(TInt& aXCoord,const TInt aYCoord);
private:
	void UpdatePosition();
private:
	enum TLineStatus
		{
		EInitialised,
		ECurrent,
		EComplete
		};
private:
	TInt iCount;
	TSize iDifference;
	TPoint iFinish;
	TInt iGradient;
	TPoint iInc;
	TPoint iPos;
	TPoint iStart;
	TRect iBoundingRect;
	TBool iBoundingRectSet;
	TBool iInside;
	TLineStatus iStatus;
	};


 





enum TFontPosture
	{
	 
	EPostureUpright,
	 
	EPostureItalic
	};

 




enum TFontStrokeWeight
	{
	 
	EStrokeWeightNormal,
	 
	EStrokeWeightBold
	};

 





enum TFontPrintPosition
	{
	 
	EPrintPosNormal,
	 
	EPrintPosSuperscript,
	 
	EPrintPosSubscript
	};

 




enum TFontUnderline
	{
	 
	EUnderlineOff,
	 
	EUnderlineOn
	};

 




enum TFontStrikethrough
	{
	 
	EStrikethroughOff,
	 
	EStrikethroughOn
	};

 




const TInt KMaxTypefaceNameLength=0x18;


 













class TTypeface
    {
public:

	enum
		{
		 
		EProportional=1,
		 
		ESerif=2,
		 
		ESymbol=4
		};
public:
	  TTypeface();
	  TBool operator==(const TTypeface& aTypeface) const;
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  void SetAttributes(TInt aMask);
	  void SetIsProportional(TBool aIsProportional);
	  void SetIsSerif(TBool aIsSerif);
	  void SetIsSymbol(TBool aIsSymbol);
	  TInt Attributes() const;
	  TBool IsProportional() const;
	  TBool IsSerif() const;
	  TBool IsSymbol() const;
public:
	 
    TBufC<KMaxTypefaceNameLength> iName;
private:
    TUint32 iFlags;
    };


 









enum TGlyphBitmapType
	{
	 
	EDefaultGlyphBitmap = 0,	
	 

	EMonochromeGlyphBitmap,	
	 
	EAntiAliasedGlyphBitmap		
	};


 

















class TFontStyle
	{
public:
	  TFontStyle();
	  TFontStyle(TFontPosture aPost,TFontStrokeWeight aStrWgt,TFontPrintPosition aPrintPos);
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  TFontPosture Posture() const;
	  TFontStrokeWeight StrokeWeight() const;
	  TFontPrintPosition PrintPosition() const;
	  void SetPosture(TFontPosture aPosture);
	  void SetStrokeWeight(TFontStrokeWeight aStrokeWeight);
	  void SetPrintPosition(TFontPrintPosition aPrintPosition);
	inline TGlyphBitmapType BitmapType() const;
	inline void SetBitmapType(TGlyphBitmapType aBitmapType);
	inline TBool operator==(const TFontStyle& aFontStyle) const;
private:
	enum
		{
		EItalic=0x1,
		EBold=0x2,
		ESuper=0x4,
		ESub=0x8
		};
private:
	TUint32 iFlags;  
	};



 





class TFontSpec
	{
public:
	  TFontSpec();
	  TFontSpec(const TDesC& aTypefaceName,TInt aHeight);
	  TBool operator==(const TFontSpec& aFontSpec) const;
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
public:
	 
	TTypeface iTypeface;
	 
	TInt iHeight;
	 
	TFontStyle iFontStyle;
	};



 








class TTypefaceSupport
    {
public:
	 
    TTypeface iTypeface;
	 
    TInt iNumHeights;
	 
    TInt iMinHeightInTwips;
	 
    TInt iMaxHeightInTwips;
	 

    TBool iIsScalable;  
    };

 





const TInt KSuperSubScalingPercentage=67;

 





const TInt KSuperscriptOffsetPercentage=-28;

 





const TInt KSubscriptOffsetPercentage=14;

class CFont;



 







class CTypefaceStore : public CBase
	{
public:
	  ~CTypefaceStore();

	 








	virtual TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec)=0;

	 


	virtual TInt NumTypefaces() const=0;

	 










	virtual void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const=0;

	 








	virtual TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const=0;
	  void ReleaseFont(CFont* aFont);
	  static TInt BaselineOffset(TInt aHeight,TFontPrintPosition aPos);
	  static TInt SuperSubHeight(TInt aHeight,TFontPrintPosition aPos);
protected:
	  CTypefaceStore();
	  void ConstructL();
	  void AddFontL(CFont* aFont);
protected:
	class TFontAccess
	 





		{
	public:
		 
		CFont* iFont;
		 
		TInt iAccessCount;
		};
protected:
	 







	CArrayFixFlat<TFontAccess>* iFontAccess;
	};

 


const TInt KMaxFontCacheEntries=32;

 














class CFontCache : public CBase
	{
public:
	  CFontCache();
	  CFontCache(TInt aMaxEntries);
	  ~CFontCache();
	  CFont* Search(const TFontSpec& aFontSpec);
	  CFont* AddEntryL(CFont* aFont,const TFontSpec& aFontSpec);
	  CFont* RemoveFirstEntry();
public:
	 

	TInt iNumHits;
	 

	TInt iNumMisses;
private:
	class CFontCacheEntry : public CBase
		{
	public:
		CFontCacheEntry(CFont* aFont,const TFontSpec& aFontSpec,CFontCacheEntry* aNext);
	public:
		CFont* iFont;
		TFontSpec iSpec;
		CFontCacheEntry* iNext;
		};
private:
	TInt iNumEntries;
	TInt iMaxEntries;
	CFontCacheEntry* iFirst;
	};

 








class MGraphicsDeviceMap
    {
public:
	  MGraphicsDeviceMap();
	  virtual ~MGraphicsDeviceMap();
	  TPoint TwipsToPixels(const TPoint& aTwipPoint) const;
	  TRect TwipsToPixels(const TRect& aTwipRect) const;
	  TPoint PixelsToTwips(const TPoint& aPixelPoint) const;
	  TRect PixelsToTwips(const TRect& aPixelRect) const;

	 





	virtual TInt HorizontalTwipsToPixels(TInt aTwips) const=0;

	 





	virtual TInt VerticalTwipsToPixels(TInt aTwips) const=0;

	 





	virtual TInt HorizontalPixelsToTwips(TInt aPixels) const=0;

	 





	virtual TInt VerticalPixelsToTwips(TInt aPixels) const=0;

	 











	virtual TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec)=0;

	 









	virtual void ReleaseFont(CFont* aFont)=0;
    };

class CGraphicsContext;

 









class CGraphicsDevice : public CBase , public MGraphicsDeviceMap
    {
public:
	 


	virtual TDisplayMode DisplayMode() const=0;

	 


	virtual TSize SizeInPixels() const=0;

	 


	virtual TSize SizeInTwips() const=0;

 	 




    virtual TInt CreateContext(CGraphicsContext*& aGC)=0;

	 


    virtual TInt NumTypefaces() const=0;

 	 















    virtual void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const=0;

	 











	virtual TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const=0;

	 





	virtual void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const=0;

	 


	virtual void SetPalette(CPalette* aPalette)=0;

	 




	virtual TInt GetPalette(CPalette*& aPalette) const=0;
    };


 







class TCodeSection
	{
public:
	 
	TInt iStart;
	 
	TInt iEnd;
	};


 












class CFont: public CBase
    {
	friend class CTypefaceStore;
public:

	 






	enum TTextDirection
		{
	 
		EHorizontal,
	 
		EVertical
		};

	 










	class TPositionParam
		{
	public:
		TPositionParam():
			iDirection(EHorizontal),
			iFlags(0),
			iPosInText(0),
			iOutputGlyphs(0)
		 
			{
			}

		enum
			{
			EMaxInputChars = 18,	 
			EMaxOutputGlyphs = 8	 
			};

		 
		enum TFlags
			{
			 
			EFLogicalOrder = 1
			};
		 
		 
		TInt16 iDirection;
		 
		TUint16 iFlags;
		 
		TPtrC iText;

		 
		 
		TInt iPosInText;		
		 
		TPoint iPen;			

		 
		class TOutput
		 




			{
		public:
			 
			TOutput() : iBitmapSize(TSize::EUninitialized),
				iBounds(TRect::EUninitialized) {}
			 
			TUint iCode;			
			 
			const TUint8* iBitmap;	
			 

			TSize iBitmapSize;		
			 
			TRect iBounds;			
			};

		 
		TOutput iOutput[EMaxOutputGlyphs];	
		 
		TInt iOutputGlyphs;					
		};	


	 








	class TMeasureTextInput
		{
	public:
		TMeasureTextInput():
			iStartInputChar(0),
			iEndInputChar(KMaxTInt),
			iDirection(EHorizontal),
			iFlags(0),
			iMaxAdvance(KMaxTInt),
			iMaxBounds(KMaxTInt),
			iCharJustNum(0),
			iCharJustExcess(0),
			iWordJustNum(0),
			iWordJustExcess(0)
			{
			}

		 
		enum TFlags
			{
			 
			EFVisualOrder = 1
			};

		 




		TInt iStartInputChar;	
	
		 




		TInt iEndInputChar;		
	
		 
		TUint16 iDirection;
	
		 
		TUint16 iFlags;
	
		 
		TInt iMaxAdvance;		
		
		 
		TInt iMaxBounds;		
	
		 
		TInt iCharJustNum;		
	
		 
		TInt iCharJustExcess;	
		
		 
		TInt iWordJustNum;		
	
		 
		TInt iWordJustExcess;	
		};

	 








	class TMeasureTextOutput
		{
		public:
		 



		TInt iChars;			
		 
		TInt iGlyphs;			
		 


		TInt iGroups;			
		 
		TInt iSpaces;			
		 
		TRect iBounds;			
		 
		TSize iMaxGlyphSize;	
		};

	 










	enum TCharacterDataAvailability
		{
		 
		ENoCharacterData,
		 
		ECharacterWidthOnly,
		 
		EAllCharacterData
		};
public:
	 







	virtual TUid TypeUid() const=0;

	 


	virtual TInt HeightInPixels() const=0;

	 


	virtual TInt AscentInPixels() const=0;
	  virtual TInt DescentInPixels() const;

	 



	virtual TInt CharWidthInPixels(TChar aChar) const=0;

	 





	virtual TInt TextWidthInPixels(const TDesC& aText) const=0;

	 





	virtual TInt BaselineOffsetInPixels() const=0;

	 












	virtual TInt TextCount(const TDesC& aText,TInt aWidthInPixels) const=0;

	 













	virtual TInt TextCount(const TDesC& aText,TInt aWidthInPixels,TInt& aExcessWidthInPixels) const=0;

	 


	virtual TInt MaxCharWidthInPixels() const=0;

	 





	virtual TInt MaxNormalCharWidthInPixels() const=0;

	 


	virtual TFontSpec FontSpecInTwips() const=0;
	  virtual TCharacterDataAvailability GetCharacterData(TUint aCode,
		TOpenFontCharMetrics& aMetrics,const TUint8*& aBitmap,TSize& aBitmapSize) const;
	  virtual TBool GetCharacterPosition(TPositionParam& aParam) const;
	  virtual void Reserved();
	  TInt WidthZeroInPixels() const;
	  TInt MeasureText(const TDesC& aText,
		const TMeasureTextInput* aInput = 0L ,
		TMeasureTextOutput* aOutput = 0L ) const;
	  static TBool CharactersJoin(TInt aLeftCharacter,
		TInt aRightCharacter);
protected:
	  virtual ~CFont();
    };

class CFbsBitmap;


 




























class CGraphicsContext : public CBase
	{
public:


	 



	enum TTextAlign
		{
		 
		ELeft,
		 
		ECenter,
		 
		ERight
		};

	 






	enum TDrawModeComponents
		{
		 
		EInvertScreen=1,
		 
		EXor=2,
		 
		EOr=4,
		 
		EAnd=8,
		 
		ELogicalOp=14,
		 
		EInvertPen=16,
		 
		EPenmode=32
		};


	 















	enum TDrawMode
		{
		 

		EDrawModeAND=EAnd,
		 

		EDrawModeNOTAND=EInvertScreen|EAnd,
		 
		EDrawModePEN=EPenmode,
		 
		EDrawModeANDNOT=EAnd|EInvertPen,
		 

		EDrawModeXOR=EXor,
		 

		EDrawModeOR=EOr,
		 

		EDrawModeNOTANDNOT=EInvertScreen|EAnd|EInvertPen,
		 

		EDrawModeNOTXOR=EInvertScreen|EXor,
		 

		EDrawModeNOTSCREEN=EInvertScreen,
		 

		EDrawModeNOTOR=EInvertScreen|EOr,
		 
		EDrawModeNOTPEN=EInvertPen|EPenmode,
		 

		EDrawModeORNOT=EOr|EInvertPen,
		 
		EDrawModeNOTORNOT=EInvertScreen|EOr|EInvertPen
		};

	 






	enum TPenStyle
		{
		 
		ENullPen,
		 
		ESolidPen,
		 
		EDottedPen,
		 
		EDashedPen,
		 

		EDotDashPen,
		 

		EDotDotDashPen
		};

	 




	enum TBrushStyle
		{
		 
		ENullBrush,
		 

		ESolidBrush,
		 

		EPatternedBrush,
		 

		EVerticalHatchBrush,
		 

		EForwardDiagonalHatchBrush,
		 

		EHorizontalHatchBrush,
		 

		ERearwardDiagonalHatchBrush,
		 


		ESquareCrossHatchBrush,
		 


		EDiamondCrossHatchBrush
		};

	 













	enum TFillRule
		{
		 
		EAlternate,
		 
		EWinding
		};

	 
	struct TDrawTextParam
		{
	public:
		TDrawTextParam():
			iDirection(CFont::EHorizontal),
			iCharJustNum(0),
			iCharJustExcess(0),
			iWordJustNum(0),
			iWordJustExcess(0)
	 
			{}
	public:
		 
		CFont::TTextDirection iDirection;	
		 
		TInt iCharJustNum;					
		 
		TInt iCharJustExcess;				
		 
		TInt iWordJustNum;					
		 
		TInt iWordJustExcess;				
		};


	 


	struct TDrawTextExtendedParam : public TDrawTextParam
		{
	public:
		 
		TDrawTextExtendedParam():
			iParRightToLeft(EFalse)
			{}
	public:
		 

		TBool iParRightToLeft;	
		};
public:
	 


	virtual CGraphicsDevice* Device() const=0;

	 





	virtual void SetOrigin(const TPoint& aPos=TPoint(0,0))=0;

	 








































	virtual void SetDrawMode(TDrawMode aDrawingMode)=0;

	 





	virtual void SetClippingRect(const TRect& aRect)=0;

	 




	virtual void CancelClippingRect()=0;

	 











	virtual void Reset()=0;

    




















	virtual void UseFont(const CFont* aFont)=0;

	 




	virtual void DiscardFont()=0;

	 




	virtual void SetUnderlineStyle(TFontUnderline aUnderlineStyle)=0;

	 




	virtual void SetStrikethroughStyle(TFontStrikethrough aStrikethroughStyle)=0;
	  static TInt JustificationInPixels(TInt aExcessPixels,TInt aTotalUnits,TInt aFirstUnit,TInt aNumUnits);
	  static TInt JustificationInPixels(TInt& aExcessPixels,TInt& aTotalUnits);

	 












































	virtual void SetWordJustification(TInt aExcessWidth,TInt aNumGaps)=0;

	 









































































	virtual void SetCharJustification(TInt aExcessWidth,TInt aNumChars)=0;

	 












	virtual void SetPenColor(const TRgb& aColor)=0;

	 





































	virtual void SetPenStyle(TPenStyle aPenStyle)=0;

	 




































	virtual void SetPenSize(const TSize& aSize)=0;

	 














	virtual void SetBrushColor(const TRgb& aColor)=0;

	 


















	virtual void SetBrushStyle(TBrushStyle aBrushStyle)=0;

	 

























	virtual void SetBrushOrigin(const TPoint& aOrigin)=0;

	 






















	virtual void UseBrushPattern(const CFbsBitmap* aBitmap)=0;

	 











	virtual void DiscardBrushPattern()=0;


	 














	virtual void MoveTo(const TPoint& aPoint)=0;

	 














	virtual void MoveBy(const TPoint& aVector)=0;

	 











	virtual void Plot(const TPoint& aPoint)=0;

	 




































	virtual void DrawArc(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd)=0;

	 



	virtual void DrawLine(const TPoint& aPoint1,const TPoint& aPoint2)=0;

	 





	virtual void DrawLineTo(const TPoint& aPoint)=0;

	 










	virtual void DrawLineBy(const TPoint& aVector)=0;

	 





	virtual void DrawPolyLine(const CArrayFix<TPoint>* aPointList)=0;

	 






	virtual void DrawPolyLine(const TPoint* aPointList,TInt aNumPoints)=0;

	 












































	virtual void DrawPie(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd)=0;

	 













	virtual void DrawEllipse(const TRect& aRect)=0;

	 


	virtual void DrawRect(const TRect& aRect)=0;

	 

















	virtual void DrawRoundRect(const TRect& aRect,const TSize& aCornerSize)=0;

	 














	virtual TInt DrawPolygon(const CArrayFix<TPoint>* aPointList,TFillRule aFillRule=EAlternate)=0;

	 
















	virtual TInt DrawPolygon(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule=EAlternate)=0;

	 




















	virtual void DrawBitmap(const TPoint& aTopLeft,const CFbsBitmap* aSource)=0;

	 




















	virtual void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource)=0;

	 




















	virtual void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource,const TRect& aSourceRect)=0;

	 













	virtual void DrawText(const TDesC& aText,const TPoint& aPosition) = 0;

	 





















































	virtual void DrawText(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TTextAlign aAlignment = ELeft,
		TInt aLeftMargin = 0) = 0;
	  virtual void DrawText(const TDesC& aText,const TPoint& aPosition,const TDrawTextParam& aParam);
	  virtual void Reserved();
	  TInt DrawTextExtended(const TDesC& aText,const TPoint& aPosition,const TDrawTextExtendedParam& aParam);
	};


 






















class CBitmapContext : public CGraphicsContext
	{
public:
	 




	virtual void Clear()=0;

	 






	virtual void Clear(const TRect& aRect)=0;

	 






	virtual void CopyRect(const TPoint& aOffset,const TRect& aRect)=0;

	 






	virtual void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap)=0;

	 












	virtual void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aRect)=0;

	 































	virtual void BitBltMasked(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect,const CFbsBitmap* aMaskBitmap,TBool aInvertMask)=0;

	 


	virtual void SetFaded(TBool aFaded)=0;

	 


















	virtual void SetFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap)=0;
	};

 











class CBitmapDevice : public CGraphicsDevice
	{
public:
	 







	virtual void GetPixel(TRgb& aColor,const TPoint& aPixel) const=0;

	 















	virtual void GetScanLine(TDes8& aBuf,const TPoint& aStartPixel,TInt aLength,TDisplayMode aDispMode) const=0;

	 







	virtual TInt AddFile(const TDesC& aName,TInt& aId)=0;

	 




	virtual void RemoveFile(TInt aId=0)=0;

	 












	virtual TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec)=0;

	 




















	virtual TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const=0;
    inline TInt CreateBitmapContext(CBitmapContext*& aGC);
	};

 





class TMargins
    {
public:
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  TBool operator==(const TMargins& aMargins) const;
	  TBool operator!=(const TMargins& aMargins) const;
public:
	 
	TInt iLeft;
	 
	TInt iRight;
	 
    TInt iTop;
	 
	TInt iBottom;
	};

 






class TPictureCapability
	{
public:
	 
	enum TScalingType
		{
		 
		ENotScaleable,
		 
		EFullyScaleable,
		 

		EScaleableMaintainingAspectRatio
		};
public:
	inline TPictureCapability(TScalingType aScalingType,TBool aCroppable);
public:
	 
	TScalingType iScalingType;
	 
	TBool iIsCroppable;
	};

 


























class CPicture : public CBase
    {
public:
	 
	enum TDetach
		{
		 

		EDetachFull,
		 

		EDetachDraw
		};
public:
	  virtual ~CPicture();
	 











	virtual void Draw(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,MGraphicsDeviceMap* aMap) const=0;
	  virtual TStreamId StoreL(CStreamStore& aStore) const;  
	virtual void DetachFromStoreL(TDetach  =EDetachFull) {}

	 







	virtual void ExternalizeL(RWriteStream& aStream) const =0;

	 


	virtual void GetOriginalSizeInTwips(TSize& aSize) const =0;
	  virtual void SetScaleFactor(TInt aScaleFactorWidth,TInt aScaleFactorHeight);  
	  virtual void SetCropInTwips(const TMargins& aMargins);  
	  virtual TPictureCapability Capability() const;  
	  virtual void GetCropInTwips(TMargins& aMargins) const;  
	  virtual TInt ScaleFactorWidth() const;  
	  virtual TInt ScaleFactorHeight() const;  
	  virtual TBool LineBreakPossible(TUint aClass,TBool aBeforePicture,TBool aHaveSpaces) const;
	  virtual TBool NativePixelSize(TSize& aPixelSize);

	  void GetSizeInPixels(MGraphicsDeviceMap* aMap, TSize& aSize) const;
	  void SetSizeInPixels(MGraphicsDeviceMap* aMap, const TSize& aSize);
	  void AddCropInPixels(MGraphicsDeviceMap* aMap, const TMargins& aMargins);
	  void GetSizeInTwips(TSize& aSize) const;
	  void SetSizeInTwips(const TSize& aSize);
	  void ResetToOriginal();
protected:
	  CPicture();
	};


 











class TPictureHeader
	{
public:
	  TPictureHeader();
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  void DeletePicture();
public:
	 

	TSwizzle<CPicture> iPicture;
	 
	TUid iPictureType;
	 
	TSize iSize;
	};


 








class MPictureFactory
	{
public:
	 
















	virtual void NewPictureL(TPictureHeader& aHeader,const CStreamStore& aDeferredPictureStore)const=0;
	};

 

 





const TInt KMaxPrinterModelNameLength=0x20;

 






typedef TBuf<KMaxPrinterModelNameLength> TPrinterModelName;

 









	
class TPageSpec
	{
public:
	 
	enum TPageOrientation
		{
		 
		EPortrait,
		 
		ELandscape
		};
public:
	  TPageSpec();
	  TPageSpec(TPageOrientation aOrientation,const TSize& aSize);
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	  TSize OrientedPageSize() const;
	  TBool operator==(const TPageSpec& aPageSpec) const;
	  TBool operator!=(const TPageSpec& aPageSpec) const;
public:
	 




	TSize iPortraitPageSize;
	 
	TPageOrientation iOrientation;
	};


 








	
class TBandAttributes
    {
public:
	 
	TRect iRect;
	 
	TBool iTextIsIgnored;  
	 
	TBool iGraphicsIsIgnored;  
	 
	TBool iFirstBandOnPage;
	};

 











class CPrinterPort : public CBase
	{
public:
	 





	virtual void WriteRequest(const TDesC8& aBuf,TRequestStatus& aRequestStatus)=0;
 
	 
	virtual void Cancel()=0;
	};


 





class TPrinterModelEntry
  	{
public:
	 
	TPrinterModelName iModelName;
	 
	TBool iRequiresPrinterPort;
	 
	TUid iUid;
public:
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	};


 








class TPrinterModelHeader
    {
public:
	 
	TPrinterModelEntry iEntry;
	 
	TStreamId iModelDataStreamId;
public:
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
	};


 













class CPrinterControl : public CBase
    {
public:
	 
	enum TMoreOnPage
		{
		 
		EMoreOnPage,
		 
		ENoMoreOnPage
		};
public:
	  ~CPrinterControl();

	 


	virtual TInt BandsPerPage()=0;

	 












	virtual TMoreOnPage QueueGetBand(TRequestStatus& aStatus, TBandAttributes& aBand)=0;  

	 








	virtual void QueueEndPrint(TRequestStatus& aStatus)=0; 

	 


	virtual void AbortPrint()=0;  
protected:
	  CPrinterControl(CPrinterPort* aPrinterPort);
protected:
	 
	enum TState 
		{
		 
		ENotPrinting, 
		 
		EPrinting
		};
	 
	TState iState;
	 
	CPrinterPort* iPrinterPort;
	};

class CDictionaryStore;
class RFs;

 
























class CPrinterDevice : public CGraphicsDevice
	{
public:
	  ~CPrinterDevice();

	 


	inline TPageSpec CurrentPageSpecInTwips() const {return(iCurrentPageSpecInTwips);}

	 


	  virtual void SelectPageSpecInTwips(const TPageSpec& aPageSpec);
	  virtual TRect PrintablePageInPixels() const;

	 


	virtual TPrinterModelEntry Model()const =0;

	 





	virtual TInt SetModel(const TPrinterModelHeader& aModel,CStreamStore& aStore)=0;

	 







	virtual void CreateControlL(CPrinterPort* aPrinterPort)=0;
	  virtual void DeleteControl();

	 




	virtual void InternalizePropertiesL(RReadStream&  ) {}

	 




	virtual void ExternalizePropertiesL(RWriteStream&  ) const {}
	  void RestorePropertiesL();
	  void StorePropertiesL() const;
protected:
	  CPrinterDevice();
public:
	 



	CPrinterControl* iControl;
protected:
	 
	TPageSpec iCurrentPageSpecInTwips;
	};


 









class CPrinterModelList : public CBase
     {
public:
	 


    virtual TInt ModelCount() const=0;

	 








    virtual const TPrinterModelEntry operator[](TInt anIndex)=0;

	 



	virtual TInt UidToNum(TUid aModelUid) const=0;
    };


 








class MPageRegionPrinter
	{
public:
	 









	virtual void PrintBandL(CGraphicsDevice* aDevice,TInt aPageNo,const TBandAttributes& aBandInPixels)=0;
	};

 




const TInt KPdrStoreFileUidVal=268435514;

const TInt KPdlUidVal=268450588;
const TInt KUdlUidVal=268450589;


 













class CPrinterDriverUI : public CBase
    {
protected:
	  CPrinterDriverUI();
public:
	  virtual TBool BeforePrintL();
	  virtual void AfterPrintL();
	  virtual void SetPropertiesL();
	  virtual TBool CanSetProperties();

	 


	virtual TInt SetPrinterDevice(CPrinterDevice* aPrinterDevice)=0;
	};
								   
class CFileStore;


 
























class CPrinterDriver : public CBase
     {
public:
	  static CPrinterDriver* NewL();
	  ~CPrinterDriver();
	  void OpenPdrL(const TDesC &aName);
	  void Close();
	  TInt NumModels() const;
	  TPrinterModelEntry Model(TInt aNum) const;

	 


	inline CPrinterDevice* PrinterDevice() {return iPrinterDevice;}
	  CPrinterDevice* CreatePrinterDeviceL(TUid aModelUid);
	  CPrinterDriverUI* CreatePrinterDriverUIL();
private:
	CPrinterDriver();
	void DeletePrinterDevice();
	void DoOpenPdrL(const TDesC &aName);
	void DoCreatePrinterDeviceL(TUid aModelUid);
	void LoadLibraryL(RLibrary& aLibrary,const TDesC& aExt,TUid aUid2);
private:
	RFs iFs;
	CFileStore *iPdrStore;
	TInt iNumModels;
	TPrinterModelHeader* iModelList;
	TFileName iPdlName;
	TUid iPdlUid;
	RLibrary iPdlLibrary;
	CPrinterDevice* iPrinterDevice;
	RLibrary iUdlLibrary;
	};

class RResourceFile;


 



class CPdrModelList : public CPrinterModelList
    {
public:
	  static CPdrModelList* NewL();
	  virtual ~CPdrModelList();
      TInt ModelCount() const;
      const TPrinterModelEntry operator [] (TInt anIndex);
	  TInt UidToNum(TUid aModelUid) const;   
	  void AddDirectoryL(const TDesC& aDir);
	  CPrinterModelList* ScanForModelsL();
	  CPrinterDriver* CreatePrinterDriverL(TInt anIndex);
private:
	CPdrModelList();
	void ConstructL();
private:
	class TFileEntry
		{
	public:
		TFileName iFileName;
		TDesC* iDirectory;
		};
	class TModelEntry
		{
	public:
		TPrinterModelEntry iEntry;
		TFileEntry* iFile; 
		};
private:
	void ScanDirectoryL(TInt aDirIndex);
	void ListModelsL(TInt aFileIndex, TParse& aParser, TFileName& aNameOfLoadedResourceFile, TFileName& aTempFileName, RResourceFile& aResourceFile, HBufC8*& aResource);
	HBufC* NewPathBufL(const TFileEntry& aFileEntry);
private:
	CArrayFixSeg<TModelEntry>* iModelArray;
	CArrayFixFlat<TFileEntry>* iFileArray;
	CArrayFixFlat<HBufC*>* iDirectoryArray;
	RFs iFileServer;
	};

 
 










class TZoomFactor : public MGraphicsDeviceMap
	{
public:
	  TZoomFactor();
	  ~TZoomFactor();
	inline TZoomFactor(const MGraphicsDeviceMap* aDevice);
	  TInt ZoomFactor() const;
	  void SetZoomFactor(TInt aZoomFactor);
	inline void SetGraphicsDeviceMap(const MGraphicsDeviceMap* aDevice);
	inline const MGraphicsDeviceMap* GraphicsDeviceMap() const;
	  void SetTwipToPixelMapping(const TSize& aSizeInPixels,const TSize& aSizeInTwips);
	  TInt HorizontalTwipsToPixels(TInt aTwipWidth) const;
	  TInt VerticalTwipsToPixels(TInt aTwipHeight) const;
	  TInt HorizontalPixelsToTwips(TInt aPixelWidth) const;
	  TInt VerticalPixelsToTwips(TInt aPixelHeight) const;
	  TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  void ReleaseFont(CFont* aFont);
public:

	 
	enum {EZoomOneToOne=1000};
private:
	TInt iZoomFactor;
	const MGraphicsDeviceMap* iDevice;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.inl" 1
 
 
 
 

 
 
 


inline TRgb::TRgb():
	iValue(0x00ffffff)
	 
	{}

 
inline TRgb::TRgb(TUint32 aValue):
	iValue(aValue)
 







	{}

 
inline TRgb::TRgb(TInt aRed,TInt aGreen,TInt aBlue):
	iValue(aRed|aGreen<<8|aBlue<<16)
 






	{}


inline TInt TRgb::Red() const
 


	{return(iValue&0xff);}


inline TInt TRgb::Green() const
 


	{return((iValue&0xff00)>>8);}


inline TInt TRgb::Blue() const
 


	{return((iValue&0xff0000)>>16);}

 
inline TBool TRgb::operator==(const TRgb& aColor) const
 






 
	{return(iValue==aColor.iValue);}

 
inline TBool TRgb::operator!=(const TRgb& aColor) const
 







	{return(!(*this==aColor));}
 
inline TRgb& TRgb::operator&=(const TRgb& aColor)
 











	{iValue&=aColor.iValue;return(*this);}

inline TRgb& TRgb::operator|=(const TRgb& aColor)
 











	{iValue|=aColor.iValue;return(*this);}

 
inline TRgb& TRgb::operator^=(const TRgb& aColor)
 











	{iValue^=aColor.iValue;return(*this);}

 
inline TUint32 TRgb::Value() const
 


	{return(iValue);}

 
inline TRgb TRgb::operator~() const
 


	{return(TRgb(iValue^0x00ffffff));}

 
inline TRgb TRgb::operator&(const TRgb& aColor)
 



	{return(TRgb(iValue&aColor.iValue));}

 
inline TRgb TRgb::operator|(const TRgb& aColor)
 



	{return(TRgb(iValue|aColor.iValue));}

 
inline TRgb TRgb::operator^(const TRgb& aColor)
 



	{return(TRgb(iValue^aColor.iValue));}


 







inline TRgb TRgb::_Gray2(TInt aGray2)
	{
	if(aGray2) return(TRgb(TUint32(0x00ffffff)));
	return(TRgb(TUint32(0)));
	}
 
 







inline TRgb TRgb::_Gray4(TInt aGray4)
	{
	aGray4&=3;
	aGray4|=aGray4<<2;
	aGray4|=aGray4<<4;
	return(TRgb(aGray4,aGray4,aGray4));
	}
 
 







inline TRgb TRgb::_Gray16(TInt aGray16)
	{
	aGray16&=0xf;
	aGray16|=aGray16<<4;
	return(TRgb(aGray16,aGray16,aGray16));
	}

 







inline TRgb TRgb::_Gray256(TInt aGray256)
	{
	aGray256&=0xff;
	return(TRgb(aGray256,aGray256,aGray256));
	}

 






inline TRgb TRgb::_Color4K(TInt aColor4K)
	{
	TUint32 value = (aColor4K & 0xf00) >> 8;
	value |= (aColor4K & 0x0f0) << 4;
	value |= (aColor4K & 0x00f) << 16;
	return TRgb(value | (value << 4));
	}

 






inline TRgb TRgb::_Color64K(TInt aColor64K)
	{
	TInt red = (aColor64K&0xF800)>>8;
	red += red>>5;
	TInt green = (aColor64K&0x07E0)>>3;
	green += green>>6;
	TInt blue = (aColor64K&0x001F)<<3;
	blue += blue>>5;
	return TRgb(red,green,blue);
	}

 






inline TRgb TRgb::_Color16M(TInt aColor16M)
	{
	return TRgb(((aColor16M & 0xff0000) >> 16) | (aColor16M & 0x00ff00) | ((aColor16M & 0x0000ff) << 16));
	}

 





inline TRgb TRgb::_Color16MU(TInt a0RGB)
	{
	 
	return TRgb(((a0RGB & 0xff0000) >> 16) | (a0RGB & 0x00ff00) | ((a0RGB & 0x0000ff) << 16));
	 
	}

 


	
inline TInt TRgb::_Gray2() const
	{
	return(Gray256()>>7);
	}

 


	
inline TInt TRgb::_Gray4() const
	{
	return(Gray256()>>6);
	}

 


	
inline TInt TRgb::_Gray16() const
	{
	return(Gray256()>>4);
	}

 


	
inline TInt TRgb::_Gray256() const
	{
	return(((Red()<<1)+Green()+(Green()<<2)+Blue())>>3);
	}

 


	
inline TInt TRgb::_Color4K() const
	{
	TInt color4K = (iValue & 0x0000f0) << 4;
	color4K |= (iValue & 0x00f000) >> 8;
	color4K |= (iValue & 0xf00000) >> 20;
	return color4K;
	}

 


	
inline TInt TRgb::_Color64K() const
	{
	TInt color64K = (iValue & 0x0000f8) << 8;
	color64K |= (iValue & 0x00fc00) >> 5;
	color64K |= (iValue & 0xf80000) >> 19;
	return color64K;
	}

 


	
inline TInt TRgb::_Color16M() const
{
	TInt color16M = (iValue & 0x0000ff) << 16;
	color16M |= iValue & 0x00ff00;
	color16M |= (iValue & 0xff0000) >> 16;
	return color16M;
	}

 

inline TInt TRgb::_Color16MU() const
	{
	 
	return ((iValue & 0x0000ff) << 16) | (iValue & 0x00ff00) | ((iValue & 0xff0000) >> 16);
	 
	}

 
 
 

 
inline TInt CPalette::Entries() const
 


	{return(iNumEntries);}

 
 
 

 
inline TRgb TColor256Util::Color256(TInt aColor256) const
 




	{ return TRgb(iColorTable[aColor256]); }

 
 
 

 
inline TBool TFontStyle::operator==(const TFontStyle& aFontStyle) const
 



	{return(iFlags==aFontStyle.iFlags);}

 
inline TGlyphBitmapType TFontStyle::BitmapType() const
 


	{
	return (TGlyphBitmapType)(iFlags >> 16);
	}

 
inline void TFontStyle::SetBitmapType(TGlyphBitmapType aBitmapType)
 








	{
	iFlags &= 0xFFFF;
	iFlags |= (aBitmapType << 16);
	}

 
 
 

 
inline TInt CBitmapDevice::CreateBitmapContext(CBitmapContext*& aGC)
 




	{return(CreateContext((CGraphicsContext*&)aGC));}  

 
 
 

inline TPictureCapability::TPictureCapability(TScalingType aScalingType,TBool aCroppable):
	iScalingType(aScalingType),iIsCroppable(aCroppable)
 



	{}

 
 
 

 
inline TZoomFactor::TZoomFactor(const MGraphicsDeviceMap* aDevice):
	iZoomFactor(TZoomFactor::EZoomOneToOne),
	iDevice(aDevice)
 






	{}

 
inline void TZoomFactor::SetGraphicsDeviceMap(const MGraphicsDeviceMap* aDevice)
 


	{iDevice=aDevice;}

 
inline const MGraphicsDeviceMap* TZoomFactor::GraphicsDeviceMap() const
 


	{return(iDevice);}

# 3519 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gdi.h" 2


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/openfont.h" 1
 
 
 
 

 











class CFont;
class COpenFontFile;
class COpenFontGlyph;
class COpenFontGlyphCache;
class COpenFontGlyphTreeEntry;
class COpenFontPositioner;
class COpenFontSessionCache;
class COpenFontSessionCacheList;
class RFs;
class TCharacterMetrics;
class TFontSpec;
class TOpenFontFaceAttrib;
class CFontStore;
class TOpenFontFileData;

 





const TInt KUidOpenFontRasterizerValue = 0x10003B1F;

 











const TUint KReplacementCharacter = 0xF6DB;

 





const TInt KFillCharacterOffset = 0x7FFF;

class TOpenFontMetrics
 






	{
public:
	inline TOpenFontMetrics();
	  TOpenFontMetrics(const CFont* aFont);
	inline TInt Size() const;
	inline TInt Ascent() const;
	inline TInt Descent() const;
	inline TInt MaxHeight() const;
	inline TInt MaxDepth() const;
	inline TInt MaxWidth() const;
	inline void SetSize(TInt aSize);
	inline void SetAscent(TInt aAscent);
	inline void SetDescent(TInt aDescent);
	inline void SetMaxHeight(TInt aMaxHeight);
	inline void SetMaxDepth(TInt aMaxDepth);
	inline void SetMaxWidth(TInt aMaxWidth);
private:
	TInt16 iSize;			 
	TInt16 iAscent;			 
	TInt16 iDescent;		 
	TInt16 iMaxHeight;		 
	TInt16 iMaxDepth;		 
	TInt16 iMaxWidth;		 
	TInt32 iReserved;
	};

 
class TOpenFontCharMetrics
 


















	{
public:
	enum TUninitialized { EUninitialized };
public:
	inline TOpenFontCharMetrics();
 
	 



	TOpenFontCharMetrics(TUninitialized) {}
	  TOpenFontCharMetrics(const TCharacterMetrics& aMetrics);
	  TBool GetTCharacterMetrics(TCharacterMetrics& aMetrics) const;
	inline TInt Width() const;
	inline TInt Height() const;
	inline TInt HorizBearingX() const;
	inline TInt HorizBearingY() const;
	inline TInt HorizAdvance() const;
	inline TInt VertBearingX() const;
	inline TInt VertBearingY() const;
	inline TInt VertAdvance() const;
	inline void GetHorizBounds(TRect& aBounds) const;
	inline void GetVertBounds(TRect& aBounds) const;
	inline void SetWidth(TInt aWidth);
	inline void SetHeight(TInt aHeight);
	inline void SetHorizBearingX(TInt aHorizBearingX);
	inline void SetHorizBearingY(TInt aHorizBearingY);
	inline void SetHorizAdvance(TInt aHorizAdvance);
	inline void SetVertBearingX(TInt aVertBearingX);
	inline void SetVertBearingY(TInt aVertBearingY);
	inline void SetVertAdvance(TInt aVertAdvance);
private:
	TInt16 iWidth;			 
	TInt16 iHeight;			 
	TInt16 iHorizBearingX;	 
	TInt16 iHorizBearingY;	 
	TInt16 iHorizAdvance;	 
	TInt16 iVertBearingX;	 
	TInt16 iVertBearingY;	 
	TInt16 iVertAdvance;	 
	TInt32 iReserved;
	};

 
class TOpenFontGlyphData
 













	{
public:
	  static TOpenFontGlyphData* New(RHeap* aHeap,TInt aBufferSize);
	inline TBool Overflow() const;
	inline TInt BytesNeeded() const;
	inline TPtrC8 Bitmap() const;
	inline const TUint8* BitmapPointer() const;
	inline const TOpenFontCharMetrics* Metrics() const;
	inline TInt GlyphIndex() const;
	inline TUint8* BufferStart();
	inline TUint8* BufferEnd();
	inline void SetBytesNeeded(TInt aBytes);
	inline void SetBitmapPointer(const TUint8* aBitmap);
	inline void SetMetricsPointer(const TOpenFontCharMetrics* aMetrics);
	inline void SetPointersToInternalBuffers();
	inline void SetMetrics(TOpenFontCharMetrics& aMetrics);
	inline void SetGlyphIndex(TInt aGlyphIndex);
private:
	 



	TOpenFontGlyphData();
	~TOpenFontGlyphData();
private:
	TInt iBitmapBufferSize;					 
	TInt iBytesNeeded;						 
	TOpenFontCharMetrics iMetricsBuffer;	 
	const TUint8* iBitmap;					 
											 
	const TOpenFontCharMetrics* iMetrics;	 
											 
	TInt iGlyphIndex;						 
	TAny* iReserved;						 
	TUint8 iBitmapBuffer[1];				 
											 
	};

 class COpenFont: public CBase
 



























	{
public:
	 
























	virtual void RasterizeL(TInt aCode,TOpenFontGlyphData* aGlyphData) = 0;
	  virtual void Reserved();  
	  COpenFont(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,COpenFontFile* aFile);
	  COpenFont(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,COpenFontFile* aFile,TInt aFaceIndex);
	  ~COpenFont();
	  void operator delete(TAny*);
	inline const TOpenFontMetrics& Metrics() const;
	inline const TOpenFontFaceAttrib* FaceAttrib() const;
	inline COpenFontFile* File() const;
	inline TInt FaceIndex() const;
	inline TBool CharacterNeedsToBeRasterized(TInt aSessionHandle,TInt aCode) const;
	TBool Rasterize(TInt aSessionHandle,TInt aCode,TOpenFontGlyphData* aGlyphData);
	TBool HasCharacterL(TInt aCode) const;
	TBool GetCharacterData(TInt aSessionHandle,TInt aCode,const TOpenFontCharMetrics*& aMetrics,const TUint8*& aBitmap) const;
	void OnFileDeleted();
protected:
	RHeap* iHeap;
	TOpenFontMetrics iMetrics;
	const COpenFontPositioner* iPositioner;					 
															 
															 
private:
	const COpenFontGlyph* Glyph(TInt aSessionHandle,TInt aCode) const;
	const COpenFontGlyph* FontCacheGlyph(TInt aCode,COpenFontGlyphTreeEntry**& aNode);
	const COpenFontGlyph* SessionCacheGlyph(RHeap* aHeap,TInt aSessionHandle,TInt aCode,
											COpenFontSessionCache*& aCache,TInt& aIndex,TBool aCreate) const;
	void RasterizeHelperL(TInt aCode,TOpenFontGlyphData* aGlyphData,TOpenFontGlyphData*& aTempGlyphData);
private:
	COpenFontFile* iFile;									 
															 
	TInt iFaceIndex;										 
	COpenFontGlyphCache* iGlyphCache;						 
	COpenFontSessionCacheList* iSessionCacheList;			 
	TAny* iReserved;  
	};

 
class TOpenFontFaceAttribBase
 









	{
public:
	inline TOpenFontFaceAttribBase();
	inline TBool HasLatin() const;
	inline TBool HasGreek() const;
	inline TBool HasCyrillic() const;
	inline TBool HasKana() const;
	inline TBool HasHangul() const;
	inline TBool HasCJK() const;
	inline TBool IsSymbol() const;
	inline TBool IsBold() const;
	inline TBool IsItalic() const;
	inline TBool IsSerif() const;
	inline TBool IsMonoWidth() const;
	inline TPtrC Name() const;
	inline const TUint* Coverage() const;
	inline void SetName(const TDesC& aName);
	inline void SetCoverage(TUint aCoverage0,TUint aCoverage1 = 0,TUint aCoverage2 = 0,TUint aCoverage3 = 0);
	inline void SetBold(TBool aBold);
	inline void SetItalic(TBool aItalic);
	inline void SetSerif(TBool aSerif);
	inline void SetMonoWidth(TBool aMonoWidth);
	inline TBool operator==(const TOpenFontFaceAttribBase& aAttrib) const;

	 
	enum
		{
		ELatinSet = 0x1,			 
		EGreekSet = 0x80,			 
		ECyrillicSet = 0x200,		 
		EArmenianSet = 0x400,		 
		EHebrewSet = 0x800,			 
		EArabicSet = 0x2000,		 
		EDevanagariSet = 0x8000,	 
		EBengaliSet = 0x10000,		 
		EGurmukhiSet = 0x20000,		 
		EGujuratiSet = 0x40000,		 
		EOriyaSet = 0x80000,		 
		ETamilSet = 0x100000,		 
		ETeluguSet = 0x200000,		 
		EKannadaSet = 0x400000,		 
		EMalayalamSet = 0x800000,	 
		EThaiSet = 0x1000000,		 
		ELaoSet = 0x2000000,		 
		EGeorgianSet = 0x8000000,	 
		EHangulJamoSet = 0x10000000, 
		};

	 
	enum
		{
		ESymbolSets = 0xFFFE,
		EKanaSets = 0x60000,
		EHangulSet = 0x100000,
		ECJKSet = 0x8000000
		};

	 
	enum
		{
		EBold = 0x1,			 
		EItalic = 0x2,			 
		ESerif = 0x4,			 
		EMonoWidth = 0x8		 
		};

	 
	enum
		{
		ENameLength = 32		 
		};
protected:
	TBufC<ENameLength> iName;				 
											 
	TUint iCoverage[4];						 
											 
											 
	TInt iStyle;							 
	TInt32 iReserved;
	};

 
class TOpenFontFaceAttrib: public TOpenFontFaceAttribBase
 








	{
public:
	inline TOpenFontFaceAttrib();
	inline TBool operator==(const TOpenFontFaceAttrib& aAttrib) const;
	inline TPtrC FullName() const;
	inline TPtrC FamilyName() const;
	inline TPtrC LocalFullName() const;
	inline TPtrC LocalFamilyName() const;
	inline TPtrC ShortFullName() const;
	inline TPtrC ShortFamilyName() const;
	inline TPtrC ShortLocalFullName() const;
	inline TPtrC ShortLocalFamilyName() const;
	inline void SetFullName(const TDesC& aName);
	inline void SetFamilyName(const TDesC& aName);
	inline void SetLocalFullName(const TDesC& aName);
	inline void SetLocalFamilyName(const TDesC& aName);
	inline TInt MinSizeInPixels() const;
	inline void SetMinSizeInPixels(TInt aSize);
private:
	TBufC<ENameLength> iFamilyName;			 
	TBufC<ENameLength> iLocalFullName;		 
	TBufC<ENameLength> iLocalFamilyName;	 
	TInt iMinSizeInPixels;					 
	TInt32 iReserved2;
	};

 
class TOpenFontSpec: public TOpenFontFaceAttribBase
 
















	{
public:
	  TOpenFontSpec();
	  TOpenFontSpec(const TFontSpec& aFontSpec);
	  void operator=(const TFontSpec& aFontSpec);
	inline TBool operator==(const TOpenFontSpec& aFontSpec) const;
	  void SetAttrib(const TOpenFontFaceAttribBase& aAttrib);
	  void GetTFontSpec(TFontSpec& aFontSpec) const;
	  void CompensateForAspectRatio(TInt aKPixelWidth,TInt aKPixelHeight);
	  void CompensateForAspectRatio(const MGraphicsDeviceMap& aMap);
	inline TInt Height() const;
	inline TInt32 WidthFactor() const;
	inline TInt32 SlantFactor() const;
	inline TGlyphBitmapType BitmapType() const;
	inline TUint32 Effects() const;
	inline TFontPrintPosition PrintPosition() const;
	inline void SetHeight(TInt aHeight);
	inline void SetWidthFactor(TInt32 aWidthFactor);
	inline void SetSlantFactor(TInt32 aSlantFactor);
	inline void SetBitmapType(TGlyphBitmapType aBitmapType);
	inline void SetEffects(TUint32 aEffects);

	 


	enum
		{
		 
		EAlgorithmicBold = 1,
		 
		EDropShadow = 2,
		 
		EOutline = 4
		};
private:
	TInt iHeight;						 
	TInt32 iWidthFactor;				 
	TInt32 iSlantFactor;				 
	TInt iBitmapType;					 
	TUint32 iEffects;					 

	 
	TBool iSymbol;						 
	TFontPrintPosition iPrintPosition;	 

	TInt iReserved2;
	};

 



enum TOpenFontAttachment
	{
	EBaselineLeft,
	EBaselineRight,
	ETopLeft,
	ETopCenter,
	ETopRight,
	EBottomLeft,
	EBottomCenter,
	EBottomRight
	};


 
class COpenFontFile: public CBase
 





































	{
public:
	virtual void GetNearestFontInPixelsL(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,
										 const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
										 COpenFont*& aFont,TOpenFontSpec& aActualFontSpec) = 0;

	 




	virtual TBool HasUnicodeCharacterL(TInt aFaceIndex,TInt aCode) const = 0; 
	  virtual void Reserved();  
	  COpenFontFile(TInt aUid,const TDesC& aFileName);
	  ~COpenFontFile();
	  TBool GetNearestFontHelper(const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
										TInt& aFaceIndex,TOpenFontSpec& aActualFontSpec) const;
	  void AddFaceL(const TOpenFontFaceAttrib& aAttrib);
	inline TUid Uid() const;
	inline const TDesC& FileName() const;
	inline const TOpenFontFaceAttrib& FaceAttrib(TInt aFaceIndex) const;
	inline TInt FaceCount() const;
	inline void IncRefCount();
	inline TBool DecRefCount();
	TInt GetNearestFontInPixels(RHeap* aHeap,COpenFontSessionCacheList* aSessionCacheList,
								const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
								COpenFont*& aFont,TOpenFontSpec& aActualFontSpec);
	void RemoveFontFromList(const COpenFont* aFont);
	void SetFontStoreL(CFontStore* aFontStore);
protected:
	  TBool GetNearestFontHelperOld(const TOpenFontSpec& aDesiredFontSpec,TInt aPixelWidth,TInt aPixelHeight,
										TInt& aFaceIndex,TOpenFontSpec& aActualFontSpec) const;
private:
	 
	class TAttrib: public TOpenFontFaceAttrib
		{
		public:
		COpenFontPositioner* iPositioner;	 
		};
private:
	CArrayFixFlat<TAttrib> iFaceAttrib;
	TUid iUid;
	TBuf<KMaxFileName> iFileName;
	TInt iRefCount;
	CArrayPtrFlat<COpenFont> iFontList;
	TOpenFontFileData* iData;
	};

 
class COpenFontRasterizer: public CBase
 
































	{
public:
 	 





























	virtual COpenFontFile* NewFontFileL(TInt aUid,const TDesC& aFileName,RFs& aFileSession) = 0;
	  virtual void Reserved();  
private:
	TAny* iReserved;  
	};

 
class COpenFontRasterizerContext: public CBase
 













	{
public:
	inline COpenFontRasterizerContext();
	inline void StartGlyph(TOpenFontGlyphData* aGlyphData);
	inline void WriteGlyphBit(TInt aBit);
	inline void WriteGlyphByte(TInt aByte);
	inline void EndGlyph();
private:
	TOpenFontGlyphData* iGlyphData;
	TUint8* iGlyphDataStart;
	TUint8* iGlyphDataPtr;
	TUint8* iGlyphDataEnd;
	TInt iGlyphBit;
	TInt iBytesNeeded;
	TBool iOverflow;
	TAny* iReserved;  
	};


 
inline TOpenFontMetrics::TOpenFontMetrics()
 


	{
	Mem::FillZ(this,sizeof(*this));
	}

inline TInt TOpenFontMetrics::Size() const
 



	{
	return iSize;
	}
 
inline TInt TOpenFontMetrics::Ascent() const
 





	{
	return iAscent;
	}

inline TInt TOpenFontMetrics::Descent() const
 






	{
	return iDescent;
	}
 
inline TInt TOpenFontMetrics::MaxHeight() const
 













	{
	return iMaxHeight;
	}
 
inline TInt TOpenFontMetrics::MaxDepth() const
 









	{
	return iMaxDepth;
	}
 
inline TInt TOpenFontMetrics::MaxWidth() const
 



	{
	return iMaxWidth;
	}
 
inline void TOpenFontMetrics::SetSize(TInt aSize)
 



	{
	iSize = static_cast<TInt16>(aSize);
	}

inline void TOpenFontMetrics::SetAscent(TInt aAscent)
 



	{
	iAscent = static_cast<TInt16>(aAscent);
	}

inline void TOpenFontMetrics::SetDescent(TInt aDescent)
 



	{
	iDescent = static_cast<TInt16>(aDescent);
	}
 
inline void TOpenFontMetrics::SetMaxHeight(TInt aMaxHeight)
 



	{
	iMaxHeight = static_cast<TInt16>(aMaxHeight);
	}
 
inline void TOpenFontMetrics::SetMaxDepth(TInt aMaxDepth)
 



	{
	iMaxDepth = static_cast<TInt16>(aMaxDepth);
	}
 
inline void TOpenFontMetrics::SetMaxWidth(TInt aMaxWidth)
 



	{
	iMaxWidth = static_cast<TInt16>(aMaxWidth);
	}
 
inline TOpenFontCharMetrics::TOpenFontCharMetrics()
 



	{
	Mem::FillZ(this,sizeof(*this));
	}
 
inline TInt TOpenFontCharMetrics::Width() const
 


	{
	return iWidth;
	}
 
inline TInt TOpenFontCharMetrics::Height() const
 


	{
	return iHeight;
	}
 
inline TInt TOpenFontCharMetrics::HorizBearingX() const
 






	{
	return iHorizBearingX;
	}
 
inline TInt TOpenFontCharMetrics::HorizBearingY() const
 






	{
	return iHorizBearingY;
	}
 
inline TInt TOpenFontCharMetrics::HorizAdvance() const
 






	{
	return iHorizAdvance;
	}

inline TInt TOpenFontCharMetrics::VertBearingX() const
 






	{
	return iVertBearingX;
	}
 
inline TInt TOpenFontCharMetrics::VertBearingY() const
 






	{
	return iVertBearingY;
	}
 
inline TInt TOpenFontCharMetrics::VertAdvance() const
 









	{
	return iVertAdvance;
	}
 
inline void TOpenFontCharMetrics::GetHorizBounds(TRect& aBounds) const
 





	{
	aBounds.iTl.iX = iHorizBearingX;
	aBounds.iTl.iY = -iHorizBearingY;
	aBounds.iBr.iX = aBounds.iTl.iX + iWidth;
	aBounds.iBr.iY = aBounds.iTl.iY + iHeight;
	}
 
inline void TOpenFontCharMetrics::GetVertBounds(TRect& aBounds) const
 





	{
	aBounds.iTl.iX = -iVertBearingX;
	aBounds.iTl.iY = iVertBearingY;
	aBounds.iBr.iX = aBounds.iTl.iX + iWidth;
	aBounds.iBr.iY = aBounds.iTl.iY + iHeight;
	}
 
inline void TOpenFontCharMetrics::SetWidth(TInt aWidth)
 


	{
	iWidth = (TInt16)aWidth;
	}
 
inline void TOpenFontCharMetrics::SetHeight(TInt aHeight)
 


	{
	iHeight = (TInt16)aHeight;
	}
 
inline void TOpenFontCharMetrics::SetHorizBearingX(TInt aHorizBearingX)
 






	{
	iHorizBearingX = (TInt16)aHorizBearingX;
	}
 
inline void TOpenFontCharMetrics::SetHorizBearingY(TInt aHorizBearingY)
 






	{
	iHorizBearingY = (TInt16)aHorizBearingY;
	}
 
inline void TOpenFontCharMetrics::SetHorizAdvance(TInt aHorizAdvance)
 






	{
	iHorizAdvance = (TInt16)aHorizAdvance;
	}
 
inline void TOpenFontCharMetrics::SetVertBearingX(TInt aVertBearingX)
 






	{
	iVertBearingX = (TInt16)aVertBearingX;
	}
 
inline void TOpenFontCharMetrics::SetVertBearingY(TInt aVertBearingY)
 






	{
	iVertBearingY = (TInt16)aVertBearingY;
	}
 
inline void TOpenFontCharMetrics::SetVertAdvance(TInt aVertAdvance)
 









	{
	iVertAdvance = (TInt16)aVertAdvance;
	}
 
inline const TOpenFontMetrics& COpenFont::Metrics() const
 


	{
	return iMetrics;
	}

inline TInt TOpenFontGlyphData::GlyphIndex() const
 









	{
	return iGlyphIndex;
	}
 
inline const TOpenFontFaceAttrib* COpenFont::FaceAttrib() const
 




	{
	return iFile ? &iFile->FaceAttrib(iFaceIndex) : 0L ;
	}
 
inline COpenFontFile* COpenFont::File() const
 






	{
	return iFile;
	}
 
inline TInt COpenFont::FaceIndex() const
 


	{
	return iFaceIndex;
	}
 
inline TBool COpenFont::CharacterNeedsToBeRasterized(TInt aSessionHandle,TInt aCode) const
 








	{
	return Glyph(aSessionHandle,aCode) == 0L ;
	}
 
inline TOpenFontFaceAttribBase::TOpenFontFaceAttribBase()
 



	{
	Mem::FillZ(this,sizeof(*this));
	}
 
inline TOpenFontFaceAttrib::TOpenFontFaceAttrib():
	iMinSizeInPixels(0),
	iReserved2(0)
 



	{
	}
 
inline TBool TOpenFontFaceAttribBase::HasLatin() const
 





	{
	return iCoverage[0] & ELatinSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasGreek() const
 





	{
	return iCoverage[0] & EGreekSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasCyrillic() const
 





	{
	return iCoverage[0] & ECyrillicSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasKana() const
 










	{
	return iCoverage[1] & EKanaSets;
	}
 
inline TBool TOpenFontFaceAttribBase::HasHangul() const
 








	{
	return iCoverage[1] & EHangulSet;
	}
 
inline TBool TOpenFontFaceAttribBase::HasCJK() const
 







	{
	return iCoverage[1] & ECJKSet;
	}
 
inline TBool TOpenFontFaceAttribBase::IsSymbol() const
 


	{
	return iCoverage[0] == 0 && iCoverage[2] == 0 && iCoverage[3] == 0 &&
		   iCoverage[1] & ESymbolSets && !(iCoverage[1] & ~ESymbolSets);
	}
 
inline TBool TOpenFontFaceAttribBase::IsBold() const
 


	{
	return iStyle & EBold;
	}
 
inline TBool TOpenFontFaceAttribBase::IsItalic() const
 


	{
	return iStyle & EItalic;
	}
 
inline TBool TOpenFontFaceAttribBase::IsSerif() const
 


	{
	return iStyle & ESerif;
	}
 
inline TBool TOpenFontFaceAttribBase::IsMonoWidth() const
 


	{
	return iStyle & EMonoWidth;
	}
 
inline TPtrC TOpenFontFaceAttribBase::Name() const
 


	{
	return iName;
	}
 
inline TPtrC TOpenFontFaceAttrib::FullName() const
 






	{
	return Name();
	}
 
inline TPtrC TOpenFontFaceAttrib::FamilyName() const
 






	{
	return iFamilyName;
	}
 
inline TPtrC TOpenFontFaceAttrib::LocalFullName() const
 









	{
	return iLocalFullName;
	}
 
inline TPtrC TOpenFontFaceAttrib::LocalFamilyName() const
 









	{
	return iLocalFamilyName;
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortFullName() const
 










	{
	 
	return TPtrC(iName.Ptr(),Min(iName.Length(),KMaxTypefaceNameLength));
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortFamilyName() const
 









	{
	return TPtrC(iFamilyName.Ptr(),Min(iFamilyName.Length(),KMaxTypefaceNameLength));
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortLocalFullName() const
 










	{
	return TPtrC(iLocalFullName.Ptr(),Min(iLocalFullName.Length(),KMaxTypefaceNameLength));
	}
 
inline TPtrC TOpenFontFaceAttrib::ShortLocalFamilyName() const
 










	{
	return TPtrC(iLocalFamilyName.Ptr(),Min(iLocalFamilyName.Length(),KMaxTypefaceNameLength));
	}
 
inline const TUint* TOpenFontFaceAttribBase::Coverage() const
 











	{
	return iCoverage;
	}
 
inline TInt TOpenFontFaceAttrib::MinSizeInPixels() const
 




	{
	return iMinSizeInPixels;
	}
 
inline void TOpenFontFaceAttribBase::SetName(const TDesC& aName)
 


	{
	iName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttrib::SetFullName(const TDesC& aName)
 



	{
	SetName(aName);
	}
 
inline void TOpenFontFaceAttrib::SetFamilyName(const TDesC& aName)
 



	{
	iFamilyName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttrib::SetLocalFullName(const TDesC& aName)
 



	{
	iLocalFullName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttrib::SetLocalFamilyName(const TDesC& aName)
 



	{
	iLocalFamilyName = TPtrC(aName.Ptr(),Min(aName.Length(),(TInt)ENameLength));
	}
 
inline void TOpenFontFaceAttribBase::SetCoverage(TUint aCoverage0,TUint aCoverage1,TUint aCoverage2,TUint aCoverage3)
 













	{
	iCoverage[0] = aCoverage0;
	iCoverage[1] = aCoverage1;
	iCoverage[2] = aCoverage2;
	iCoverage[3] = aCoverage3;
	}
 
inline void TOpenFontFaceAttrib::SetMinSizeInPixels(TInt aSize)
 





	{
	iMinSizeInPixels = aSize;
	}
 
inline TBool TOpenFontFaceAttrib::operator==(const TOpenFontFaceAttrib& aAttrib) const
 







	{
	return TOpenFontFaceAttribBase::operator==(aAttrib) &&
		   iFamilyName == aAttrib.iFamilyName &&
		   iLocalFullName == aAttrib.iLocalFullName &&
		   iLocalFamilyName == aAttrib.iLocalFamilyName &&
		   iMinSizeInPixels == aAttrib.iMinSizeInPixels;
	}
 
inline void TOpenFontFaceAttribBase::SetBold(TBool aBold)
 


	{
	if (aBold)
		iStyle |= EBold;
	else
		iStyle &= ~EBold;
	}
 
inline void TOpenFontFaceAttribBase::SetItalic(TBool aItalic)
 


	{
	if (aItalic)
		iStyle |= EItalic;
	else
		iStyle &= ~EItalic;
	}
 
inline void TOpenFontFaceAttribBase::SetSerif(TBool aSerif)
 


	{
	if (aSerif)
		iStyle |= ESerif;
	else
		iStyle &= ~ESerif;
	}
 
inline void TOpenFontFaceAttribBase::SetMonoWidth(TBool aMonoWidth)
 


	{
	if (aMonoWidth)
		iStyle |= EMonoWidth;
	else
		iStyle &= ~EMonoWidth;
	}
 
inline TBool TOpenFontFaceAttribBase::operator==(const TOpenFontFaceAttribBase& aAttrib) const
 









	{
	return iStyle == aAttrib.iStyle &&
		   iCoverage[0] == aAttrib.iCoverage[0] &&
		   iCoverage[1] == aAttrib.iCoverage[1] &&
		   iCoverage[2] == aAttrib.iCoverage[2] &&
		   iCoverage[3] == aAttrib.iCoverage[3] &&
		   iName.CompareF(aAttrib.iName) == 0;
	}
 
inline TBool TOpenFontSpec::operator==(const TOpenFontSpec& aFontSpec) const
 






	{
	return TOpenFontFaceAttribBase::operator==(aFontSpec) &&
		   iHeight == aFontSpec.iHeight &&
		   iWidthFactor == aFontSpec.iWidthFactor &&
		   iSlantFactor == aFontSpec.iSlantFactor &&
		   iBitmapType == aFontSpec.iBitmapType &&
		   iEffects == aFontSpec.iEffects &&
		   iSymbol == aFontSpec.iSymbol &&
		   iPrintPosition == aFontSpec.iPrintPosition;
	}
 
inline TInt TOpenFontSpec::Height() const
 



	{
	return iHeight;
	}
 
inline TInt32 TOpenFontSpec::WidthFactor() const
 



	{
	return iWidthFactor;
	}
 
inline TInt32 TOpenFontSpec::SlantFactor() const
 



	{
	return iSlantFactor;
	}
 
inline TGlyphBitmapType TOpenFontSpec::BitmapType() const
 


	{
	return (TGlyphBitmapType)iBitmapType;
	}
 
inline TUint32 TOpenFontSpec::Effects() const
 






	{
	return iEffects;
	}

inline TFontPrintPosition TOpenFontSpec::PrintPosition() const
 


	{
	return iPrintPosition;
	}
 
inline void TOpenFontSpec::SetHeight(TInt aHeight)
 



	{
	iHeight = aHeight;
	}

inline void TOpenFontSpec::SetWidthFactor(TInt32 aWidthFactor)
 








	{
	iWidthFactor = aWidthFactor;
	}
 
inline void TOpenFontSpec::SetSlantFactor(TInt32 aSlantFactor)
 














	{
	iSlantFactor = aSlantFactor;
	}
 
inline void TOpenFontSpec::SetBitmapType(TGlyphBitmapType aBitmapType)
 








	{
	iBitmapType = aBitmapType;
	}
 
inline void TOpenFontSpec::SetEffects(TUint32 aEffects)
 






	{
	iEffects = aEffects;
	}
 
inline TUid COpenFontFile::Uid() const
 


	{
	return iUid;
	}
 
inline const TDesC& COpenFontFile::FileName() const
 





	{
	return iFileName;
	}
 
inline const TOpenFontFaceAttrib& COpenFontFile::FaceAttrib(TInt aFaceIndex) const
 





	{
	return iFaceAttrib[aFaceIndex];
	}
 
inline TInt COpenFontFile::FaceCount() const
 







	{
	return iFaceAttrib.Count();
	}
 
inline void COpenFontFile::IncRefCount()
 


	{
	iRefCount++;
	}
 
inline TBool COpenFontFile::DecRefCount()
 





	{
	iRefCount--;
	return iRefCount <= 0;
	}
 
inline COpenFontRasterizerContext::COpenFontRasterizerContext():
	iGlyphData(0L )
 
	{
	}
 
inline void COpenFontRasterizerContext::StartGlyph(TOpenFontGlyphData* aGlyphData)
 





	{
	aGlyphData->SetPointersToInternalBuffers();
	iGlyphData = aGlyphData;
	iGlyphDataStart = iGlyphDataPtr = aGlyphData->BufferStart();
	 
	iGlyphDataEnd = aGlyphData->BufferEnd() - 4;
	iGlyphBit = 1;
	*iGlyphDataPtr = 0;
	iBytesNeeded = 1;
	iOverflow = 0 ;
	}
 
inline void COpenFontRasterizerContext::WriteGlyphBit(TInt aBit)
 




	{
	if (aBit && !iOverflow)
		*iGlyphDataPtr |= iGlyphBit;
	iGlyphBit <<= 1;
	if (iGlyphBit == 256)
		{
		iGlyphBit = 1;
		iBytesNeeded++;
		if (++iGlyphDataPtr < iGlyphDataEnd)
			*iGlyphDataPtr = 0;
		else
			iOverflow = 1 ;
		}
	}

inline void COpenFontRasterizerContext::WriteGlyphByte(TInt aByte)
 



	
 	{
	if (iGlyphDataPtr < iGlyphDataEnd)
		*iGlyphDataPtr++ = (TUint8)aByte;
	else
		iOverflow = 1 ;
	iBytesNeeded++;
	}
 
inline void COpenFontRasterizerContext::EndGlyph()
 



	{
	 
	iGlyphData->SetBytesNeeded(iBytesNeeded + 4);
	iGlyphData = 0L ;
	}
    
inline TBool TOpenFontGlyphData::Overflow() const
 


	{
	return iBytesNeeded > iBitmapBufferSize;
	}
 
inline TInt TOpenFontGlyphData::BytesNeeded() const
 



	{
	return iBytesNeeded;
	}
 
inline TPtrC8 TOpenFontGlyphData::Bitmap() const
 



	{
	return TPtrC8(iBitmap,iBytesNeeded);
	}
 
inline const TUint8* TOpenFontGlyphData::BitmapPointer() const
 





	{
	return iBitmap;
	}
 
inline const TOpenFontCharMetrics* TOpenFontGlyphData::Metrics() const
 


	{
	return iMetrics;
	}
 
inline TUint8* TOpenFontGlyphData::BufferStart()
 


	{
	return iBitmapBuffer;
	}
 
inline TUint8* TOpenFontGlyphData::BufferEnd()
 


	{
	return iBitmapBuffer + iBitmapBufferSize;
	}
 
inline void TOpenFontGlyphData::SetBytesNeeded(TInt aBytes)
 



	{
	iBytesNeeded = aBytes;
	}
 
inline void TOpenFontGlyphData::SetBitmapPointer(const TUint8* aBitmap)
 


	{
	iBitmap = aBitmap;
	}
 
inline void TOpenFontGlyphData::SetMetricsPointer(const TOpenFontCharMetrics* aMetrics)
 


	{
	iMetrics = aMetrics;
	}
 
inline void TOpenFontGlyphData::SetPointersToInternalBuffers()
 



	{
	iBitmap = iBitmapBuffer;
	iMetrics = &iMetricsBuffer;
	}
 
inline void TOpenFontGlyphData::SetMetrics(TOpenFontCharMetrics& aMetrics)
 



	{
	iMetricsBuffer = aMetrics;
	iMetrics = &iMetricsBuffer;
	}
 
inline void TOpenFontGlyphData::SetGlyphIndex(TInt aGlyphIndex)
 


	{
	iGlyphIndex = aGlyphIndex;
	}


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fntstore.h" 2


class CFontStoreFile;
class CFontBitmap;
class RReadStream;
class TTypefaceFontBitmap;

class TCharacterMetrics
 


	{
	public:
	  TCharacterMetrics();

	TInt16 iAscentInPixels;
	TInt16 iHeightInPixels;
	TInt16 iLeftAdjustInPixels;
	TInt16 iMoveInPixels;
	TInt16 iRightAdjustInPixels;
	};

class TAlgStyle
 







	{
public:
	  TAlgStyle();
	  void SetIsBold(TBool aIsBold);
	  void SetIsItalic(TBool aIsItalic);
	  void SetIsMono(TBool aIsMono);
	  void SetWidthFactor(TInt aWidthFactor);
	  void SetHeightFactor(TInt aHeightFactor);
	  TBool IsBold() const;
	  TBool IsItalic() const;
	  TBool IsMono() const;
	  TInt WidthFactor() const;
	  TInt HeightFactor() const;
	  TBool operator==(const TAlgStyle& aAlgStyle) const;

public:
	 
	TInt iBaselineOffsetInPixels;
private:
	enum
		{
		EBold=1,
		EItalic=2,
		EMono=4,
		};
	 
    TInt8 iFlags;
	 
	TInt8 iWidthFactor;
	 
	TInt8 iHeightFactor;
	};

class CBitmapFont : public CFont
 









	{
	friend class CFontStore;
private:
	CBitmapFont(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,CFontBitmap* aFontBitmap);
	CBitmapFont(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,COpenFont* aOpenFont);
	void ConstructL();
	~CBitmapFont();
	  static CBitmapFont* NewL(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,CFontBitmap* aFontBitmap);
	static CBitmapFont* NewL(RHeap* aHeap,const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,COpenFont* aOpenFont);
public:
	  TUid TypeUid() const;
	TUid Uid() const;
	  TInt HeightInPixels() const;
	  TInt AscentInPixels() const;
	  TInt CharWidthInPixels(TChar aChar) const;
	  TInt TextWidthInPixels(const TDesC &aText) const;
	  TInt BaselineOffsetInPixels() const;
	  TInt TextCount(const TDesC &aText,TInt aWidthInPixels) const;
	  TInt TextCount(const TDesC &aText,TInt aWidthInPixels,TInt &aExcessWidthInPixels) const;
	  TInt MaxCharWidthInPixels() const;
	  TInt MaxNormalCharWidthInPixels() const;
	  TFontSpec FontSpecInTwips() const;
	  TCharacterMetrics CharacterMetrics(TInt aCode,const TUint8*& aBytes) const;
	  TBool GetCharacterData(TInt aSessionHandle,TInt aCode,TOpenFontCharMetrics& aMetrics,
									const TUint8*& aBitmap) const;
	  TBool Rasterize(TInt aSessionHandle,TInt aCode,TOpenFontGlyphData* aGlyphData) const;
	  void GetFontMetrics(TOpenFontMetrics& aMetrics) const;
	  TBool GetFaceAttrib(TOpenFontFaceAttrib& aAttrib) const;
	  TInt BitmapEncoding() const;
	  TBool HasCharacterL(TInt aCode) const;
	  TBool CharacterNeedsToBeRasterized(TInt aSessionHandle,TInt aCode) const;
	  void operator delete(TAny*);
	inline TBool IsOpenFont() const;
	inline COpenFont* OpenFont() const;
	inline TGlyphBitmapType GlyphBitmapType() const;
private:
	TInt Width(TInt aNum) const;
	TInt Height(TInt aNum) const;
	CFontBitmap* FontBitmap() const;
private:
	TFontSpec iFontSpecInTwips;
public:
	 
	TAlgStyle iAlgStyle;	 
private:
	RHeap* iHeap;
	TInt iFontBitmapOffset;
	COpenFont* iOpenFont;	 
	};

class CFontStore : public CTypefaceStore
 











    {
private:
	CFontStore();
	void ConstructL();
public:
	  static CFontStore* NewL(RHeap* aHeap);
	  ~CFontStore();
	  TUid AddFileL(const TDesC& aName);
	  void RemoveFile(TUid aFileUid);
	  TInt GetNearestFontInTwips(CFont *&aFont,const TFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont *&aFont,const TFontSpec &aFontSpec);
	  TInt GetNearestFontInTwips(CFont *&aFont,const TOpenFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont *&aFont,const TOpenFontSpec &aFontSpec);
 	  TInt GetFontById(CFont *&aFont,TUid aUid,const TAlgStyle& aAlgStyle);
	  TInt NumTypefaces() const;
	  void TypefaceSupport(TTypefaceSupport &aTypefaceSupport,TInt aTypefaceIndex) const;
	  TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  void InstallRasterizerL(COpenFontRasterizer* aRasterizer);
	  void DeleteSessionCache(TInt aSessionHandle);
	inline TGlyphBitmapType DefaultBitmapType() const;
	inline void SetDefaultBitmapType(TGlyphBitmapType aType);
	TInt BitmapFontFilesCount() const;
private:
	void InternalizeFontStoreFileL(CFontStoreFile* aFontStoreFile);
	TTypeface* GetNearestTypeface(const TTypeface& aTypeface) const;
	TTypefaceFontBitmap GetNearestTypefaceFontBitmap(const TFontSpec& aFontSpecInPixels);
	CFontBitmap* GetFontBitmapById(TUid aUid);
	CBitmapFont* FindFont(const TFontSpec& aFontSpecInPixels,const TAlgStyle& aAlgStyle,TUid aUid) const;
	CBitmapFont* FindFont(const TOpenFontSpec& aFontSpecInPixels,const TAlgStyle& aAlgStyle) const;
	CBitmapFont* NewFontL(const TFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,CFontBitmap* aFontBitmap);
	CBitmapFont* NewFontL(const TOpenFontSpec& aFontSpecInTwips,const TAlgStyle& aAlgStyle,COpenFont* aOpenFont);
	TInt VerticalPixelsToTwips(TInt aPixelHeight) const;
	TInt VerticalTwipsToPixels(TInt aTwipsHeight) const;
	TInt GetNearestBitmapFontInPixels(CBitmapFont *&aFont,TFontSpec &aFontSpec);
	TInt GetNearestOpenFontInPixels(CBitmapFont *&aFont,TOpenFontSpec &aFontSpec,
									const TOpenFontSpec& aIdealFontSpecInPixels);
	void UpdateTypefaceSupportListL();

public:
	 




	TInt iKPixelWidthInTwips;
	
	 




	TInt iKPixelHeightInTwips;
private:
	RFs iFs;
	RHeap* iHeap;
	CArrayPtrFlat<CFontStoreFile> iFontStoreFileList;
	CArrayPtrFlat<TTypeface> iTypefaceList;
	CArrayPtrFlat<CFontBitmap> iFontBitmapList;
	CArrayFixFlat<TTypefaceFontBitmap> iTypefaceFontBitmapList;
	CArrayPtrFlat<COpenFontFile> iOpenFontFileList;
	CArrayFixFlat<TTypefaceSupport> iOpenFontTypefaceSupportList;
	CArrayPtrFlat<COpenFontRasterizer> iOpenFontRasterizerList;
	COpenFontSessionCacheList* iOpenFontSessionCacheList;
	TInt iOpenFontUid;
	TGlyphBitmapType iDefaultBitmapType;
	};

 
inline TBool CBitmapFont::IsOpenFont() const
 




	{
	return iOpenFont != 0L ;
	}

inline COpenFont* CBitmapFont::OpenFont() const
 


	{ 
	return iOpenFont;
	}

inline TGlyphBitmapType CBitmapFont::GlyphBitmapType() const
 







	{
	return iFontSpecInTwips.iFontStyle.BitmapType();
	}

inline TGlyphBitmapType CFontStore::DefaultBitmapType() const
 


	{
	return iDefaultBitmapType;
	}

inline void CFontStore::SetDefaultBitmapType(TGlyphBitmapType aType)
 


	{
	iDefaultBitmapType = aType;
	}


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/w32std.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fbs.h" 1
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitmap.h" 1
 
 
 
 












 


const TUid KCBitwiseBitmapUid={268435520};
const TUid KCBitwiseBitmapHardwareUid={0x10009a3d};
const TUid KMultiBitmapFileImageUid={268435522};
const TInt KMaxLargeBitmapAlloc=0x1000;
const TInt KCompressionBookMarkThreshold=0x2000;

 
class CChunkPile;
class TCompressionBookMark;

 



enum TBitmapfileCompression
	{
	 
	ENoBitmapCompression,
	 
	EByteRLECompression,
	 
	ETwelveBitRLECompression,
	 
	ESixteenBitRLECompression,
	 
	ETwentyFourBitRLECompression,
	 
	ERLECompressionLast
	};

class TRgb24bit
 


	{
public:
	TUint8 iRed;
	TUint8 iGreen;
	TUint8 iBlue;
	};

 




class SEpocBitmapHeader
	{
public:
	 
	TInt iBitmapSize;
	 
	TInt iStructSize;
	 
	TSize iSizeInPixels;
	 
	TSize iSizeInTwips;
	 
	TInt iBitsPerPixel;
	 

	TBool iColor;
	 
	TInt iPaletteEntries;
	 
	TBitmapfileCompression iCompression;
	};

class TLineScanningPosition
 


	{
public:
	TLineScanningPosition(TUint32* aSrcDataPtr): iSrcDataPtr((TUint8*)aSrcDataPtr), iCursorPos(0), iScanLineBuffer(0L ) {}
public:
	TUint8* iSrcDataPtr;
	TInt iCursorPos;
	HBufC8* iScanLineBuffer;
	};

class CShiftedFileStore;
 




class CBitwiseBitmap
	{
	friend class CFbTop;
	friend class CFbClient;
	friend class CFbsBitmap;
	friend class CBitmapObject;
	friend class CFbsBitmapAsyncStreamer;
public:
	  TUid Uid() const;
	  void ExternalizeL(RWriteStream& aStream,const CFbsBitmap& aHandleBitmap) const;
	  void ExternalizeRectangleL(RWriteStream& aStream,const TRect& aRect,const CFbsBitmap& aHandleBitmap) const;
	  void InternalizeL(RReadStream& aStream);
	  static void InternalizeHeaderL(RReadStream& aStream,SEpocBitmapHeader& aHeader);
	  TSize SizeInPixels() const;
	  TSize SizeInTwips() const;
	  TDisplayMode DisplayMode() const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  void GetPixel(TRgb& aColor,const TPoint& aPos,TUint32* aBase) const;
	  TInt GetScanLinePtr(TUint32*& aSlptr, TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  TInt GetScanLinePtr(TUint32*& aSlptr, TInt& aLength, TPoint& aPixel,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  void GetScanLine(TUint32*& aSlptr, TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode) const;
	  void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase) const;
	  void GetVerticalScanLine(TDes8& aBuf,TInt aX,TBool aDither,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase) const;
	  void StretchScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase) const;
	  void StretchScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	  TUint32* ScanLineAddress(TUint32* aBase,TUint aY) const;
	  TBool IsMonochrome(TUint32* aBase) const;
	  void Compress(TUint8* aNewData,TUint8* aOldData);
	  TBool IsLargeBitmap() const;
	  TInt CompressData();
	  void SetCompressionBookmark(TLineScanningPosition& aLineScanningPosition, TUint32* aBase, const CFbsBitmap* aFbsBitmap);
	  TInt HardwareBitmapHandle() const;
	  TBool IsCompressedInRAM() const;
private:
	  void operator delete(TAny*);
	  CBitwiseBitmap(RHeap* aHeap,CChunkPile* aPile);
	  ~CBitwiseBitmap();
	  void Reset();
	  TInt Construct(const TSize& aSize,TDisplayMode aDispMode,TUid aCreatorUid);
	  void ConstructL(RFs& aFs,const TDesC& aFilename,TInt32 aId,TUint aFileOffset);
	  void ConstructL(CShiftedFileStore* aFileStore,TStreamId aStreamId);
	  TInt Resize(const TSize& aSize);
private:
	void GenerateLineFromCompressedTwelveBitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	void GenerateLineFromCompressedEightBitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength,TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	TUint8 GetGrayPixelEx(TInt aX,TUint32* aScanLineAddress) const;
	TRgb GetRgbPixelEx(TInt aX,TUint32* aScanLineAddress) const;
	void GetScanLineGray2(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TUint32* aScanlinePtr) const;
	void GetScanLineGray4(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TBool aDither,const TPoint& aDitherOffset,TUint32* aScanlinePtr) const;
	void GetScanLineGray16(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineGray256(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor16(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor256(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor4K(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor64K(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor16M(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColor16MU(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineColorRgb(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineExBits(TDes8& aBuf,TInt aX,TInt aLength,TUint32* aScanlinePtr) const;
	void GetScanLineExBytes(TDes8& aBuf,TInt aX,TInt aLength,TUint32* aScanlinePtr) const;
	void DoExternalizeDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeByteDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeTwelveBitDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeSixteenBitDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	void DoExternalizeTwentyFourBitDataCompressedL(RWriteStream& aStream,TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfByteDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfTwelveBitDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfSixteenBitDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TInt SizeOfTwentyFourBitDataCompressed(TUint8* aData,TInt aSizeInBytes) const;
	TBool TrueColorPointerCompare(TUint8* aColorPointer,TUint8 aComponent1,TUint8 aComponent2,TUint8 aComponent3) const;
	void DoInternalizeL(RReadStream& aStream,TInt aSrceSize,TUint32* aBase);
	void DoInternalizeCompressedDataL(RReadStream& aStream,TInt aSrceSize,TUint32* aBase,TBitmapfileCompression aCompression);
	void DoDecompressByteData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);

	void DoDecompressByteDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoDecompressTwelveBitData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);
	void DoDecompressTwelveBitDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoDecompressSixteenBitData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);
	void DoDecompressSixteenBitDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoDecompressTwentyFourBitData(TUint8* aDestBuffer,TInt aDestSize,TUint8* aSrceBuffer,TInt aSrceSize);
	void DoDecompressTwentyFourBitDataAltL(RReadStream& aStream,TInt aSrceSizeInBytes,TUint32* aBase);
	void DoStretchScanLine(TDes8& aBuf,TInt x,TInt y,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase,TLineScanningPosition& aLineScanningPosition) const;
	void DoCompressScanLine(TDes8& aBuf,TInt x,TInt y,TInt aClipStrchX,TInt aClipStrchLen,TInt aStretchLength,TInt aOrgX,TInt aOrgLen,const TPoint& aDitherOffset,TDisplayMode aDispMode,TUint32* aBase,TLineScanningPosition& aLineScanningPosition) const;
	TUint32 HashTo1bpp(TUint32 aGray256,TBool aOddX,TBool aOddY) const;
	TUint32 HashTo2bpp(TUint32 aGray256,TInt aDitherIndex) const;
	TBool IsWordMonochrome(TUint32 aWord) const;
	TUint32* DataAddress() const;
	static void WhiteFill(TUint8* aData,TInt aDataSize,TDisplayMode aDispMode);
	static TInt ByteWidth(TInt aPixelWidth,TDisplayMode aDispMode);
	static TInt Bpp(TDisplayMode aDispMode);
	static TBool IsColor(TDisplayMode aDispMode);
	static TDisplayMode DisplayMode(TInt aBpp,TBool aColor);
	static TBitmapfileCompression CompressionType(TInt aBpp);
	TInt DoGetScanLinePtr(TUint32*& aSlptr, TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	void GenerateLineFromCompressedSixteenBitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	TDisplayMode InitialDisplayMode() const;
	TInt SetDisplayMode(TDisplayMode aDisplayMode, TUint32* aDataAddress);
	TInt DisplayModeArgCheck(TDisplayMode aDisplayMode, TUint32* aDataAddress) const;
	void ChangeDisplayMode( TDisplayMode aNewDisplayMode,
							TInt aScanLineWidthNew,
							TUint8* aDataAddrNew,
							TUint32* aDataAddress,
							TInt aYStart,
							TInt aYInc,
							TInt aYEnd);
	void UpdateBitmapProperties(TDisplayMode aNewDisplayMode);
	TInt SwapWidthAndHeight(TUint32* aDataAddress);
	void CopyOldData(TUint8* aDest, const TUint8* aSrc, TInt aNewByteWidth, const TSize aNewSize);
	void DecompressOldData(TUint8* aDest, TInt aNewByteWidth, const TSize aNewSize, HBufC8* aScanLineBuf);
	TInt ResizeConditionsCheck(const TSize& aSize, TInt aNewByteWidth, TInt& aNewBitmapSize) const;
	TInt Alloc(TInt aNewBitmapSize, const TSize& aNewSize, TUint8*& aNewBuf, TInt& aNewDataOffset);
	void MoveData(TUint8* aDest, TUint8* aSrc, TInt aNewByteWidth, const TSize& aNewSize, HBufC8* aScanLineBuf);
	void ReinitializeHeader(const TSize& aNewSize, TInt aNewBitmapSize);
	void Free(TUint8* aSrc, TBool aLargeBmp, HBufC8* aScanLineBuf);
	void GenerateLineFromCompressed24BitData(TUint8* aDestBuffer, const TPoint& aPixel,TInt aLength, TUint32* aBase, TLineScanningPosition& aLineScanningPosition) const;
	void AdjustXCoord(TInt& aX) const;
	void GetLineScanPos(TLineScanningPosition& aLineScanPos, 
						const TCompressionBookMark*& aComprBookMark, 
						const TUint8* aBase) const;
	void UpdateBookMark(const TLineScanningPosition& aLineScanPos, 
						TCompressionBookMark* aComprBookMark, 
						const TUint8* aBase) const;
private:
	TUid iUid;
	struct TSettings
		{
		TSettings(TDisplayMode aDisplayMode);
		void SetDisplayModes(TDisplayMode aDisplayMode);
		void SetCurrentDisplayMode(TDisplayMode aDisplayMode);
		TDisplayMode CurrentDisplayMode() const;
		TDisplayMode InitialDisplayMode() const;
		TUint32 iData;
		} iSettings;
	RHeap* iHeap;
	CChunkPile* iPile;
	TInt iByteWidth;
	SEpocBitmapHeader iHeader;
	RChunk iLargeChunk;
	TInt iDataOffset;  
	TBool iIsCompressedInRAM;  
	};


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fbs.h" 2

 


const TUid KCFbsFontUid = { 268435518 };
 


const TUid KMultiBitmapRomImageUid = { 268435521 };
const TUint32 KFontBitmapServerUidValue = 0x10003a16;
const TUid KFontBitmapServerUid = { KFontBitmapServerUidValue };
 


  TInt FbsStartup();

 





  void DummyReserved1();


 




class SCharWidth
	{
public:
	 
	TInt iLeftAdjust;
	 
	TInt iRightAdjust;
	 
	TInt iMove;
	 
	TInt iWidth;
	};

class CFbsRalCache;

 




class RFbsSession : protected RSessionBase
	{
	 
	friend class RClean;
	friend class TestFbs;
	friend class RTestBitmap;
	
	friend class CFbsBitmap;
	friend class CFbsBitmapAsyncStreamer;
public:
	  RFbsSession();
	  static TInt Connect();
	  static void Disconnect();
	  static RFbsSession* GetSession();
	  void CallBack();
	  void SetCallBack(TCallBack aCallBack);
	  void ResetCallBack();
	  TInt ResourceCount();
	  TInt SendCommand(TInt aMessage,TInt aInt0=0,TInt aInt1=0,TInt aInt2=0,TInt aInt3=0) const;
	  TVersion Version();
	  TUint8* HeapBase() const;
	TInt SessionHandle() const { return Handle(); }
	TInt AllocScanLineBuffer(TInt aSize);
	HBufC8* GetScanLineBuffer();
private:
	TBool LookupBitmapInROM(const TDesC& aFilename, TAny*& aAddr);
private:
	TInt iConnections;
	TCallBack iCallBack;
	RChunk iSharedChunk;
	RMutex iAddressMutex;
	RChunk iLargeBitmapChunk;
	RFs iFileServer;
	CFbsRalCache* iRomFileAddrCache;
	TAny* iUnused;
	HBufC8* iScanLineBuffer;
	TUint32* iSpare;
	};

 











class CFbsFont: public CFont
	{
	friend class CFbsTypefaceStore;
public:
	 
	 




	TUid TypeUid() const { return KCFbsFontUid; }
	  TInt HeightInPixels() const;
	  TInt AscentInPixels() const;
	  TInt CharWidthInPixels(TChar aChar) const;
	  TInt TextWidthInPixels(const TDesC& aText) const;
	  TInt BaselineOffsetInPixels() const;
	  TInt TextCount(const TDesC& aText,TInt aWidthInPixels) const;
	  TInt TextCount(const TDesC& aText,TInt aWidthInPixels,TInt& aExcessWidthInPixels) const;
	  TInt MaxCharWidthInPixels() const;
	  TInt MaxNormalCharWidthInPixels() const;
	  TFontSpec FontSpecInTwips() const;
	  CFont::TCharacterDataAvailability GetCharacterData(TUint aCode,TOpenFontCharMetrics& aMetrics,
	const TUint8*& aBitmap,TSize& aBitmapSize) const;
	  TBool GetFontMetrics(TOpenFontMetrics& aMetrics) const;
	  void TextWidthInPixels(const TDesC& aText,SCharWidth& aCharWidth) const;
	  TInt Handle() const;
	  TCharacterMetrics CharacterMetrics(TInt aCode,const TUint8*& aBytes) const;
	  TInt RawTextWidthInPixels(const TDesC& aText) const;
	  TBool GetFaceAttrib(TOpenFontFaceAttrib& aAttrib) const;
	  TBool IsOpenFont() const;
	  TBool HasCharacter(TInt aCode) const;
protected:
	  CFbsFont();
	  ~CFbsFont();
	  CFbsFont(const CFbsFont& aFont);
	  CBitmapFont* Address() const;
	  TInt Duplicate(TInt aHandle);
	  void Reset();
protected:
	RFbsSession* iFbs;
	CBitmapFont* iAddressPointer;
	TInt iHandle;
	TInt iServerHandle;
	};

 













class CFbsBitmap : public CBase
	{
	friend class TBitmapUtil;
	friend class CBitwiseBitmap;
	friend class CFbsBitmapAsyncStreamer;
public:
	  CFbsBitmap();
	  ~CFbsBitmap();
	  void Reset();
	  static TInt ScanLineLength(TInt aLength,TDisplayMode aDispMode);
	  TDisplayMode DisplayMode() const;
	  TDisplayMode InitialDisplayMode() const;
	  TInt SetDisplayMode(TDisplayMode aDisplayMode);
	  TInt Create(const TSize& aSizeInPixels,TDisplayMode aDispMode);
	  TInt Duplicate(TInt aHandle);
	  TBool IsRomBitmap() const;
	  void SetRomBitmapL(CBitwiseBitmap* aRomBitmapPointer,TInt& aBitmapSizeInBytes);
	  TInt Load(const TDesC& aFileName,TInt32 aId=0,TBool aShareIfLoaded=ETrue);
	  TInt Load(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	  TInt LoadAndCompress(const TDesC& aFileName,TInt32 aId=0,TBool aShareIfLoaded=ETrue);
	  TInt LoadAndCompress(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	  TInt Save(const TDesC& aFilename);
	  static void StoreL(const TDesC& aFilename,TInt aNumSources,const TDesC* aSources[],TInt32 aSourceIds[]);
      void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TDisplayMode aDispMode) const;
      void SetScanLine(TDes8& aBuf,TInt aY) const;
	  void GetVerticalScanLine(TDes8& aBuf,TInt aX,TDisplayMode aDispMode) const;
	  void GetVerticalScanLine(TDes8& aBuf,TInt aX,const TPoint& aDitherOffset,TDisplayMode aDispMode) const;
	  TInt Handle() const;
	  SEpocBitmapHeader Header() const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  void GetPixel(TRgb& aColor,const TPoint& aPixel) const;
	  TInt Resize(const TSize& aSizeInPixels);
	  TSize SizeInPixels() const;
	  TSize SizeInTwips() const;
	  void SetSizeInTwips(const MGraphicsDeviceMap* aMap);
	  void SetSizeInTwips(const TSize& aSizeInTwips);
	  void ExternalizeL(RWriteStream& aStream) const;
	  void ExternalizeRectangleL(RWriteStream& aStream,const TRect& aRect) const;
	  void InternalizeL(RReadStream& aStream);
	  TInt Compress();
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  static TBool IsFileInRom(const TDesC& aFilename,TUint32*& aWord);
	  TBool IsMonochrome() const;
	  TBool IsLargeBitmap() const;
	  void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  void SetPalette(CPalette* aPalette);
	  TInt GetPalette(CPalette*& aPalette) const;
	  TUint32* DataAddress() const;
	  TInt CreateHardwareBitmap(const TSize& aSizeInPixels,TDisplayMode aDispMode,TUid aCreatorUid);
	  TInt HardwareBitmapHandle() const;
	  void LockHeap(TBool aAlways=EFalse) const;
	  void UnlockHeap(TBool aAlways=EFalse) const;
	  void LockHeapLC(TBool aAlways=EFalse) const;
	  static void UnlockHeap(TAny* aFbsBitmap);
	  TBool IsCompressedInRAM() const;
	  TInt SwapWidthAndHeight();
protected:
      void GetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,const TPoint& aDitherOffset,TDisplayMode aDispMode) const;
	CBitwiseBitmap* Address() const;
	void DoSaveL(RFile& aFile);
	TInt DoCreate(const TSize& aSizeInPixels,TDisplayMode aDispMode,TUid aCreatorUid);
private:
	TInt DoLoad(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	TInt DoLoadAndCompress(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded,TUint aFileOffset);
	TBool LoadShiftedRomBmpL(const TDesC& aFileName,TInt32 aId,TUint aFileOffset);
protected:
	RFbsSession* iFbs;
	CBitwiseBitmap* iAddressPointer;
	CBitwiseBitmap* iRomPointer;
	TInt iHandle;
	TInt iServerHandle;
	};

class CDirectFileStore;

 



class CFbsBitmapAsyncStreamer : public CBase
	{
public:
	enum TMode {ELoad, ESave};
public:
	  ~CFbsBitmapAsyncStreamer();
	  static CFbsBitmapAsyncStreamer* NewL(TMode aMode);
	  TInt Load(const TDesC& aFilename,TInt32 aId,TInt& aScanLines);
	  TBool LoadScanLinesL(TInt aNumberOfScanLines,CFbsBitmap*& aBitmap);
	  TInt Save(const TDesC& aFilename,CFbsBitmap* aBitmap,TInt32& aId,TInt& aScanLines);
	  TBool SaveScanLinesL(TInt aNumberOfScanLines);
private:
	CFbsBitmapAsyncStreamer(TMode aMode);
	void ConstructL();
	void DoLoadL(const TDesC& aFilename,TInt32 aId);
	void DoSaveL(RFile& aFile);
private:
	RFbsSession* iFbs;
	RStoreReadStream iReadStream;
	RStoreWriteStream iWriteStream;
	TStreamId iId;
	CDirectFileStore* iStore;
	TInt iCurrentScanLine;
	TUint32* iScanLineBase;
	CFbsBitmap* iBitmap;
	SEpocBitmapHeader iHeader;
	TDisplayMode iDispMode;
	TMode iMode;
	};


 

























class TBitmapUtil
	{
public:
	  void Begin(const TPoint& aPosition);
	  void Begin(const TPoint& aPosition,const TBitmapUtil& aUtil);
	  void End();
	  TBitmapUtil(CFbsBitmap* aBitmap);
	  TUint32 GetPixel() const;
	  void SetPixel(TUint32 aValue);
	  void SetPixel(const TBitmapUtil& aSource);
	  void SetPos(const TPoint& aPosition);
	  void DecXPos();
	  void DecYPos();
	  void IncXPos();
	  void IncYPos();
private:
	void DoBegin(const TPoint& aPosition,const TBitmapUtil* aUtil);
private:
	CFbsBitmap* iFbsBitmap;
	TUint32* iWordPos;
	TUint32* iMinWordPos;
	TUint32* iMaxWordPos;
	TInt iBpp;
	TInt iPixelShift;
	TInt iBitShift;
	TUint32 iMask;
	TInt iScanlineWordLength;
	TBool iHeapLocked;
	};

class TFontInfo;

 




class CFbsTypefaceStore : public CTypefaceStore
	{
public:
	  static CFbsTypefaceStore* NewL(CGraphicsDevice* aDevice);
	  ~CFbsTypefaceStore();
	  TInt AddFile(const TDesC& aName,TInt& aId);
	  TInt InstallFile(const TDesC& aName,TInt& aId);
	  void RemoveFile(TInt aId=0);
	  virtual TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec);
 	  TInt GetFontById(CFont *&aFont,TUid aUid,const TAlgStyle& aAlgStyle);
	  virtual TInt NumTypefaces() const;
	  virtual void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const;
	  virtual TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TGlyphBitmapType DefaultBitmapType() const;
	  void SetDefaultBitmapType(TGlyphBitmapType aType) const;
	  void SetFontNameAliasL(const TDesC& aFontAlias,const TDesC& aFontName) const;
	  static void RemoveFontFileLocksL();  
	  static void RemoveFontFileLocksL(const TDesC& aDrive, TBool aAllFonts);  
	  static void RemoveFontFileLocksL(const TDesC& aFileName);  
private:
	CFbsTypefaceStore(CGraphicsDevice* aDevice);
	TInt CreateFont(CFont*& aFont,const TFontInfo& aFontInfo);
	TInt FontHeight(TInt aTypefaceIndex,TInt aHeightIndex,TInt aMessage) const;
	void SetSize() const;
	TInt GetNearestFontInTwipsL(CFont*& aFont,const TFontSpec& aFontSpec);
private:
	RFbsSession* iFbs;
	CGraphicsDevice* iDevice;
	CFontCache* iTwipsCache;
	};

class CDitherColor256;

 





class CFbsColor256BitmapUtil : public CBase
	{
public:
	 
	enum TDither
		{
		 
		ENoDither,
		 
		EFloydSteinberg
		};
public:

	  static CFbsColor256BitmapUtil* NewL(const CPalette* aPalette);

	  TInt CopyBitmap(CFbsBitmap* aColor256Destination,CFbsBitmap* aSource,TDither aDither=ENoDither);

	~CFbsColor256BitmapUtil();
private:
	CFbsColor256BitmapUtil();
private:
	TColor256Util* iColor256Util;
	CDitherColor256* iDither;
	};


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitbase.h" 1
 
 
 
 






 


class TSpriteBase
	{
public:
	virtual void Hide(const TRect& aRect,const TRegion* aRegion)=0;
	virtual void Reveal(const TRect& aRect,const TRegion* aRegion)=0;
	};



# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitstd.h" 1
 
 
 
 









 



class CFbsBitGcFont : public CFbsFont
	{
public:
	  CFbsBitGcFont();
	  virtual ~CFbsBitGcFont();
	  CBitmapFont* Address() const;
	  TInt Duplicate(TInt aHandle);
	  void Reset();
	  void operator=(const CFbsBitGcFont& aFont);
protected:
	TBool iCopy;
	};


 




class CFbsBitGcBitmap : public CFbsBitmap

	{
public:
	  CBitwiseBitmap* Address() const;
	  void LockHeap() const;
	  void UnlockHeap() const;
	};

 



class TEllipse
	{
public:
	enum TEllipseStatus
		{
		EInitialised,
		EFirstSector,
		ESecondSector,
		EComplete,
		ELine
		};
public:
	  void Construct(const TRect& aRect);
	  TBool SingleStep(TPoint& aTopLeft,TPoint& aTopRight,TPoint& aBottomLeft,TPoint& aBottomRight);
	  TBool NextStep(TPoint& aTopLeft,TPoint& aTopRight,TPoint& aBottomLeft,TPoint& aBottomRight);
	  TPoint Intersection(const TRect& aRect,const TPoint& aPoint);
protected:
	  TBool Output(TPoint& aTopLeft,TPoint& aTopRight,TPoint& aBottomLeft,TPoint& aBottomRight);
protected:
	TEllipseStatus iStatus;
	TInt iA;
	TInt iB;
	TInt64 iASquared;
	TInt64 iBSquared;
	TInt64 iASquBSqu;
	TInt iX;
	TInt iY;
	TInt iXAdj;
	TInt iYAdj;
	TPoint iOffset;
	TInt64 iD1;
	TInt64 iD2;
	};

 



class CPolygonFiller : public CBase

	{
public:
	enum TUsage
		{
		EGetAllPixelRunsSequentially,
		EGetPixelRunsSequentiallyForSpecifiedScanLines
		};
public:
	  CPolygonFiller();
	  ~CPolygonFiller();
	  void Construct(const CArrayFix<TPoint>* aPointArray,CGraphicsContext::TFillRule aFillRule,TUsage aUsage=EGetAllPixelRunsSequentially);  
	  void Construct(const TPoint* aPointList,TInt aNumPoints, CGraphicsContext::TFillRule aFillRule, TUsage aUsage=EGetAllPixelRunsSequentially);  
	  void Reset();
	  void GetNextPixelRun(TBool& aExists, TInt& aScanLine, TInt& aStart, TInt& aEnd);
	  void GetNextPixelRunOnSpecifiedScanLine(TBool& aExists, TInt aScanLine, TInt& aStart, TInt& aEnd);
private:  
	struct SFastEdge
		{
		TInt upperVertex;
		TInt lowerVertex;
		TInt firstVertex;
		};
	struct SFastScanLineIntersection;
	struct SFastActiveEdge
		{
		SFastEdge* edgePtr;
		TLinearDDA lineGenerator;
		SFastScanLineIntersection* scanLineIntersectionPtr;
		};
	struct SFastScanLineIntersection
		{
		TInt firstPixel;
		TInt lastPixel;
		SFastActiveEdge* activeEdgePtr;
		};
private:  
	struct SSlowScanLineIntersection
		{
		TInt firstPixel;
		TInt lastPixel;
		TInt firstVertexOfEdge;
		};
private:  
	struct SFastData
		{
		TPoint* vertexList;
		SFastEdge* edgeList;
		SFastActiveEdge* activeEdgeList;
		SFastScanLineIntersection* scanLineIntersectionList;
		TInt numActiveEdges;
		TInt numScanLineIntersections;
		TInt nextEdgeToActivate;
		};
	struct SSlowData
		{
		enum {EStoreSize=8};
		TLinearDDA lineGenerator;
		SSlowScanLineIntersection scanLineIntersectionList[EStoreSize];
		TInt numIntersectionsWithSameFirstPixelPreviouslyMet;
		TInt numIntersectionsWithSameFirstPixelMetThisTime;
		TInt numScanLineIntersections;
		TBool scanLineComplete;
		TInt firstPixelOfLastIntersectionInPrevBuffer;
		};
private:
	void Construct(CGraphicsContext::TFillRule aFillRule,TUsage aUsage);
	void FastHandleVertexIntersection(TInt& aCurrentActiveEdge, TBool aIsLowerVertex);
	void SetFastIntersection(SFastActiveEdge& aActiveEdge, SFastScanLineIntersection& aScanLineIntersection);
	void SlowHandleVertexIntersection(SSlowScanLineIntersection& aScanLineIntersection, TInt& aVertexStartingCurrentEdge,TBool aIsLowerVertex);
	void JumpToCurrentScanLine(TLinearDDA& aLineGenerator, const TPoint& aUpper, const TPoint& aLower,TPoint& aStartPos, TPoint& aEndPos) const;
	const TPoint& Point(TInt aIndex);
private:
	const CArrayFix<TPoint>* iPointArray;  
	const TPoint* iPointList;  
	CGraphicsContext::TFillRule iFillRule;
	TBool iUseFastAlgorithm;
	TInt iNumVertexes;
	TBool iToggler;  
	TInt iNestingLevel;  
	TInt iScanLineIntersection;
	TInt iRightMostPixelOnScanLine;
	TInt iFirstVertex;
	TBool iPolygonIsAllHorizontal;
	TInt iFirstScanLine;
	TInt iLastScanLine;
	TInt iCurrentScanLine;
	SFastData iFastData;
	SSlowData iSlowData;
private:
	friend class TCompareEdgesUpperY;
	friend class TCompareActiveEdgesFirstVertex;
	friend class TCompareScanLineIntersectionsFirstPixel;
	friend class TSwapEdges;
	friend class TSwapActiveEdges;
	friend class TSwapScanLineIntersections;
	};

class CFbsDevice;
class TOpenFontCharMetrics;
class CGraphicsAccelerator;

 







class CFbsBitGc : public CBitmapContext
	{
public:


 
	enum TGraphicsOrientation
		{
	 
		EGraphicsOrientationNormal,
	 
		EGraphicsOrientationRotated90,
	 
		EGraphicsOrientationRotated180,
	 
		EGraphicsOrientationRotated270
		};
public:
	  static CFbsBitGc* NewL();
	  virtual ~CFbsBitGc();
	  void Activate(CFbsDevice* aDevice);
	  void ActivateNoJustAutoUpdate(CFbsDevice* aDevice);
	  void BitBlt(const TPoint& aPoint,const CFbsBitGc& aGc);
	  void BitBlt(const TPoint& aPoint,const CFbsBitGc& aGc,const TRect& aSourceRect);
	  void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap);
	  void BitBlt(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect);
	  void BitBltMasked(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect,const CFbsBitmap* aMaskBitmap,TBool aInvertMask);
	  void CancelClipping();
	  void CancelClippingRect();
	  void CancelClippingRegion();
	  void Clear();
	  void Clear(const TRect& aRect);
	  void CopyRect(const TPoint& aOffset,const TRect& aRect);
	  void CopySettings(const CFbsBitGc& aGc);
	  CGraphicsDevice* Device() const;
	  void DiscardBrushPattern();
	  void DiscardFont();
	  void DrawArc(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd);
	  void DrawPie(const TRect& aRect,const TPoint& aStart,const TPoint& aEnd);
	  void DrawBitmap(const TPoint& aTopLeft,const CFbsBitmap* aSource);
	  void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource);
	  void DrawBitmap(const TRect& aDestRect,const CFbsBitmap* aSource,const TRect& aSourceRect);
	  void DrawRoundRect(const TRect& aRect,const TSize& aEllipse);
	  void DrawPolyLine(const CArrayFix<TPoint>* aPointList);
	  void DrawPolyLineNoEndPoint(const CArrayFix<TPoint>* aPointList);
	  void DrawPolyLine(const TPoint* aPointList,TInt aNumPoints);
	  void DrawPolyLineNoEndPoint(const TPoint* aPointList,TInt aNumPoints);
	  TInt DrawPolygon(const CArrayFix<TPoint>* aPointList,CGraphicsContext::TFillRule aFillRule=CGraphicsContext::EAlternate);
	  TInt DrawPolygon(const TPoint* aPointList,TInt aNumPoints,CGraphicsContext::TFillRule aFillRule=CGraphicsContext::EAlternate);
	  void DrawEllipse(const TRect& aRect);
	  void DrawLine(const TPoint& aStart,const TPoint& aEnd);
	  void DrawLineTo(const TPoint& aPoint);
	  void DrawLineBy(const TPoint& aVector);
	  void DrawRect(const TRect& aRect);
	  void DrawText(const TDesC& aText);
	  void DrawText(const TDesC& aText,const TPoint& aPosition);
	  void DrawText(const TDesC& aText,const TRect& aBox);
	  void DrawText(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TTextAlign aHrz=ELeft,TInt aMargin=0);
	  void DrawText(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TInt aTextWidth,TTextAlign aHrz=ELeft,TInt aMargin=0);
	  void DrawTextVertical(const TDesC& aText,TBool aUp);
	  void DrawTextVertical(const TDesC& aText,const TPoint& aPosition,TBool aUp);
	  void DrawTextVertical(const TDesC& aText,const TRect& aBox,TBool aUp);
	  void DrawTextVertical(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TBool aUp,TTextAlign aVert=ELeft,TInt aMargin=0);
	  void DrawTextVertical(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TInt aTextWidth,TBool aUp,TTextAlign aVert=ELeft,TInt aMargin=0);
	  void MapColors(const TRect& aRect,const TRgb* aColors,TInt aNumPairs=2,TBool aMapForwards=ETrue);
	  void MoveTo(const TPoint& aPoint);
	  void MoveBy(const TPoint& aVector);
	  void OrientationsAvailable(TBool aOrientation[4]);
	  void Plot(const TPoint& aPoint);
	  void RectDrawnTo(TRect& aRect);
	  void Reset();
	  void Resized();
	  void SetBrushColor(const TRgb& aColor);
	  void SetBrushOrigin(const TPoint& aOrigin);
	  void SetBrushStyle(TBrushStyle aBrushStyle);
	  void SetClippingRegion(const TRegion* aRegion);
	  void SetClippingRect(const TRect& aRect);
	  void SetDitherOrigin(const TPoint& aPoint);
	  void SetDrawMode(TDrawMode);
	  void SetOrigin(const TPoint& aPoint=TPoint(0,0));
	  void SetPenColor(const TRgb& aColor);
	  void SetPenStyle(TPenStyle);
	  void SetPenSize(const TSize& aSize);
	  void SetCharJustification(TInt aExcessWidth,TInt aNumGaps);
	  void SetWordJustification(TInt aExcessWidth,TInt aNumChars);
	  void SetUnderlineStyle(TFontUnderline aUnderlineStyle);
	  void SetUserDisplayMode(TDisplayMode aDisplayMode);
	  void SetStrikethroughStyle(TFontStrikethrough aStrikethroughStyle);
	  void SetShadowMode(TBool aShadowMode = EFalse);
	inline void SetFadeMode(TBool aFadeMode = EFalse);			 
	inline void SetFadingParameters(TUint8 aBlackMap = 0);		 
	  void SetFaded(TBool aFaded);		 
	  void SetFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap);	 
	  TBool SetOrientation(TGraphicsOrientation aOrientation);
	  void ShadowArea(const TRegion* aRegion);
	  void FadeArea(const TRegion* aRegion);
	  void UpdateJustification(const TDesC& aText);
	  void UpdateJustificationVertical(const TDesC& aText,TBool aUp);
	  void UseBrushPattern(const CFbsBitmap* aBitmap);
	  TInt UseBrushPattern(TInt aFbsBitmapHandle);
	  void UseFont(const CFont* aFont);
	  TInt UseFont(TInt aFontHandle);
	  void UseFontNoDuplicate(const CFbsBitGcFont* aFont);
	  TBool IsBrushPatternUsed() const;
	  TBool IsFontUsed() const;
	inline static TInt16 Load16(const TUint8* aPtr) { return TInt16(aPtr[0]+(aPtr[1]<<8)); }
	  TInt AlphaBlendBitmaps(const TPoint& aDestPt,
									const CFbsBitmap* aSrcBmp1,
									const CFbsBitmap* aSrcBmp2,
									const TRect& aSrcRect1,
									const TPoint& aSrcPt2,
									const CFbsBitmap* aAlphaBmp,
									const TPoint& aAlphaPt);
	  TInt AlphaBlendBitmaps(const TPoint& aDestPt,
									const CFbsBitmap* aSrcBmp,
									const TRect& aSrcRect,
									const CFbsBitmap* aAlphaBmp,
									const TPoint& aAlphaPt);
	  void ExternalizeL(RWriteStream& aWriteStream);
	  void InternalizeL(RReadStream& aReadStream);
private:
	CFbsBitGc();
	void AddRect(const TRect& aRect);
	void AnalyseEllipse(const TRect& rc,TPoint& srad,TPoint& erad,TPoint& center,TInt& startq,TInt& endq,TBool* quads);
	void BitMultiply(TUint32* aBinaryDataPtr,TInt aBitLength,TInt aMultiplier);
	void CheckDevice() const;
	TBool CheckDevice(const TRect& aRect) const;
	TUint32* ClipBinaryArray(TUint32* aArray,TUint32* aArrayLimit,TInt aArrayWordWd,TInt& aDataWd,TInt& aDataHt,TPoint& aPos);
	void ClipFillLine(TPoint,TPoint);
	void CopyCharWord(TUint32* aBinaryDataPtr,const TUint8* aData,TInt aBitShift);
	void CopyCharLine(TUint32* aBinaryDataPtr,TInt aBufferWords,const TUint8* aData,TInt aBitShift,TInt aCharWidth);
	void DrawText(const TDesC& aText,const TPoint& aPosition,TTextAlign aAlignment,
				  CFont::TTextDirection aDirection,const TRect* aBox = 0L );
	void DoBitBlt(const TPoint& aDest,CFbsDevice* aDevice,const TRect& aSourceRect);
	void DoBitBlt(const TPoint& aDest,CBitwiseBitmap* aBitmap,TUint32* aBase,const TRect& aSourceRect);
	void DoBitBltMasked(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedFlicker(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedNonFlicker(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedNonFlickerSolid(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltMaskedNonFlickerPatterned(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,TBool aInvertMask,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltAlpha(const TPoint& aDest,CBitwiseBitmap* aSourceBitmap,TUint32* aSourceBase,const TRect& aSourceRect,CBitwiseBitmap* aMaskBitmap,TUint32* aMaskBase,const TPoint& aDitherOrigin,TInt aShadowMode);
	void DoBitBltAlpha(const TPoint& aDestPt,
					   const CBitwiseBitmap* aSrcBmp1,
					   TUint32* aSrcBmpDataAddr1,
					   const CBitwiseBitmap* aSrcBmp2,
					   TUint32* aSrcBmpDataAddr2,
					   const CBitwiseBitmap* aAlphaBmp,
					   TUint32* aAlphaBmpDataAddr,
					   const TRect& aSrcRect1,
					   const TPoint& aSrcPt2,
					   const TPoint& aAlphaPt,
					   TInt aShadowMode);
	void DoCopyRect(const TPoint&,const TRect&);
	void DoDrawBitmap(const TRect&,CBitwiseBitmap*,TUint32* aBase,const TRect&,const TPoint& aDitherOrigin);
	void DoDrawLine(TPoint aStart,TPoint aEnd,TBool aDrawStartPoint);
	void DoDrawDottedWideLine(const TPoint& pt1,const TPoint& pt2,TBool drawstart,const TRect& screenrect);
	void DoDrawSolidWideLine(const TPoint& pt1,const TPoint& pt2,TBool drawstart,const TRect& screenrect);
	void DoDrawText(CFont::TPositionParam& aParam);
	void DoDrawCharacter(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData);
	void DoDrawTextEx(CFont::TPositionParam& aParam,const CBitmapFont* font);
	void DoDrawCharacterEx(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent);
	void DoDrawCharacterAntiAliased(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData);
	void DoDrawTextLarge(CFont::TPositionParam& aParam,const CBitmapFont* font);
	void DoDrawCharacterLarge(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthFactor,TInt aHeightFactor);
	void DoDrawCharacterExLarge(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthFactor,TInt aHeightFactor);
	void DoDrawCharacterMultiplied(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthMultiplier,TInt aHeightMultiplier);
	void DoDrawTextVertical(CFont::TPositionParam& aParam,const CBitmapFont* font,TBool aUp);
	void DoDrawCharacterVertical(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,
		TBool aBold,TBool aItalic,TInt aSemiAscent,TInt aWidthFactor,TInt aHeightFactor,TBool aUp);
	void DoDrawCharacterVerticalAntiAliased(const TPoint& aTopLeft,const TSize& aDataSize,const TUint8* aData,TBool aUp);
	void DoPlot(const TPoint& pt);
	void EllipseFill(const TRect& aRect);
	void EllipseOutline(const TRect& aRect);
	void EllipseOutlineWide(const TRect& aRect);
	void GetUnderlineMetrics(TInt& aTop,TInt& aBottom);
	void GetStrikethroughMetrics(TInt& aTop,TInt& aBottom);
	void OutputCharLine(TPoint aPrintPos,TUint32* aBuffer,TInt aDataLength,TInt aNum,TBool aBold,TInt aWidthFactor,TInt aHeightFactor);
	void OutputCharLineMultiplied(TPoint aPrintPos,TUint32* aBuffer,TInt aDataLength,TInt aNum,TBool aBold,TInt aWidthMultiplier,TInt aHeightMultiplier);
	void OutputCharLineVertical(TPoint aPrintPos,TUint32* aBuffer,TInt aDataLength,TInt aNum,TBool aBold,TInt aWidthFactor,TInt aHeightFactor,TBool aUp);
	void PenAllocate();
	void PenDrawClipped(TPoint aPoint);
	void PenDrawDeferred(TPoint aPoint,TInt* aArray,TInt aFirstElement);
	void PieArcOutline(const TRect& aRect,const TPoint& aStartRadius,const TPoint& aEndRadius,TBool aDoPie);
	void PieFill(const TRect& aRect,const TPoint& aStartRadius,const TPoint& aEndRadius);
	void PieShell(const TRect& ellrect,const TPoint& startradius,const TPoint& endradius,TBool quads[5],TInt startquad,TInt endquad);
	void PieTriangles(TBool aInside,const TPoint& aStart,const TPoint& aEnd);
	void PieSliver(const TRect& ellrect,const TPoint& startradius,const TPoint& endradius,TInt quad);
	void PolyFill(const CArrayFix<TPoint>* aPointList,TFillRule aFillRule);
	void PolyFillLarge(const CArrayFix<TPoint>* aPointList,TFillRule aFillRule);
	void PolyFill(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule);
	void PolyFillLarge(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule);
	void PolyOutline(const CArrayFix<TPoint>* aPointList);
	void PolyOutline(const TPoint* aPointList,TInt aNumPoints);
	void RectFill(const TRect& aRect);
	void RoundRectFill(const TRect& aRect,TSize aSize);
	void RoundRectOutline(const TRect& aRect,TSize aSize);
	void SetupDevice() const;
	void ShadowFadeArea(const TRegion* aRegion,TInt8 aShadowMode);
	TBool UserClipRect(TRect& aRect);
	CGraphicsAccelerator* GraphicsAccelerator();
private:
	CFbsBitGcBitmap iBrushBitmap;
	TBool iBrushUsed;
	TRgb iBrushColor;
	TPoint iBrushOrigin;
	TBrushStyle iBrushStyle;
	TRect iClipRect;
	TRegionFix<1> iDefaultRegion;
	const TRegion* iDefaultRegionPtr;
	TRect iUserClipRect;
	CFbsDevice* iDevice;
	TPoint iDitherOrigin;
	TInt iDotLength;
	TInt iDotMask;
	TInt iDotParam;
	TInt iDotDirection;
	TDrawMode iDrawMode;
	TRect iDrawnTo;
	CFbsBitGcFont iFont;
	TInt iCharJustExcess;
	TInt iCharJustNum;
	TInt iWordJustExcess;
	TInt iWordJustNum;
	TPoint iLastPrintPosition;
	TPoint iLinePosition;
	TPoint iOrigin;
	TInt* iPenArray;
	TRgb iPenColor;
	TPenStyle iPenStyle;
	TSize iPenSize;
	TInt8 iShadowMode;
	TInt8 iAutoUpdateJustification;
	TUint8 iFadeBlackMap;
	TUint8 iFadeWhiteMap;
	TFontStrikethrough iStrikethrough;
	TFontUnderline iUnderline;
	TDisplayMode iUserDisplayMode;
	};

inline void CFbsBitGc::SetFadeMode(TBool aFadeMode  )
	{SetFaded(aFadeMode);}
inline void CFbsBitGc::SetFadingParameters(TUint8 aBlackMap  )
	{SetFadingParameters(aBlackMap,255);}		 



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/graphicsaccelerator.h" 1
 
 
 
 







 
 
 

 
class CFbsBitmap;
class TAcceleratedBitmapSpec;

 











class TAcceleratedBitmapInfo
	{
public:

     
	TDisplayMode	iDisplayMode;

	 
	TUint8*			iAddress;
	
	 
	TSize			iSize;
	
	 
	TInt			iLinePitch;
	
	 
	TInt			iPixelShift;
	
	 


	TUint8*			iPhysicalAddress;
	};

 











class RHardwareBitmap
	{
	friend class CBitwiseBitmap;
	friend class CFbsScreenDevice;
public:

     
	inline RHardwareBitmap();

     
	inline RHardwareBitmap(TInt aHandle);

	  TInt GetInfo(TAcceleratedBitmapInfo& aInfo) const;
private:
	  TInt SetAsScreenReference(TInt aScreen=-1);
	  TInt Create(TDisplayMode aDisplayMode, TSize aSize, TUid aCreatorUid);
	  void Destroy();
public:
	
	 

	TInt iHandle;	 
	};

	 
inline RHardwareBitmap::RHardwareBitmap()
	: iHandle(0)
	{}

	 

inline RHardwareBitmap::RHardwareBitmap(TInt aHandle)
	: iHandle(aHandle)
	{}

 









class TBitmapLockCount
	{
	friend class TAcceleratedBitmapSpec;
public:
	
	 
	inline TBitmapLockCount() : iCount(0) {}
private:
	inline TInt Inc() { return iCount++; }
	inline TInt Dec() { return --iCount; }
private:
	TInt iCount;
	};


 









class TAcceleratedBitmapSpec
	{
public:
	 
	inline TAcceleratedBitmapSpec();
	  TAcceleratedBitmapSpec(CFbsBitmap* aBitmap);
	  TAcceleratedBitmapSpec(RHardwareBitmap aBitmap);
	 
	
	  TInt GetInfo(TAcceleratedBitmapInfo& aInfo) const;
	inline void Lock(TBitmapLockCount& aCount);
	inline void Lock(TBitmapLockCount& aCount,TAcceleratedBitmapInfo& aInfo);
	inline void	Unlock(TBitmapLockCount& aCount);

	 
	 




	enum TAcceleratedBitmapType
		{
	 
		ENoBitmap,
	
	 


		EFbsBitmap,
	
	 


		EHardwareBitmap,
		};
	enum TAcceleratedBitmapLock
		{
		EBitmapIsStatic,
		EBitmapNeedsLocking,
		};
	 
	inline TAcceleratedBitmapType	Type() const;
	inline TInt						Handle() const;
private:
	  void DoLock(TBitmapLockCount& aCount);
	  void DoLock(TBitmapLockCount& aCount,TAcceleratedBitmapInfo& aInfo);
	  void DoUnlock(TBitmapLockCount& aCount);
private:
	TUint8	iType;			 
	TUint8	iLockStatus;	 
	TUint8	iSpare1;
	TUint8	iSpare2;
	TInt	iHandle;
	};

	 

inline TAcceleratedBitmapSpec::TAcceleratedBitmapSpec()
	: iType(ENoBitmap), iLockStatus(EBitmapIsStatic)
	{}

	 









inline void TAcceleratedBitmapSpec::Lock(TBitmapLockCount& aCount)
	{ if(iLockStatus==EBitmapNeedsLocking) DoLock(aCount); }

	 












inline void TAcceleratedBitmapSpec::Lock(TBitmapLockCount& aCount,TAcceleratedBitmapInfo& aInfo)
	{ if(iLockStatus==EBitmapNeedsLocking) DoLock(aCount,aInfo); }

	 







inline void	TAcceleratedBitmapSpec::Unlock(TBitmapLockCount& aCount)
	{ if(iLockStatus==EBitmapNeedsLocking) DoUnlock(aCount); }

	 


inline TAcceleratedBitmapSpec::TAcceleratedBitmapType TAcceleratedBitmapSpec::Type() const
	{ return (TAcceleratedBitmapSpec::TAcceleratedBitmapType)iType; }

	 


inline TInt TAcceleratedBitmapSpec::Handle() const
	{ return iHandle; }

 
 
 


 










enum TTransparencyType
	{
	
	 
	ETransparentPixelZero,
	
	 

	ETransparentPixel,
	
	 

	ETransparentColor,
	
	 


	ETransparent1555,
	};

 














class TGraphicsAcceleratorCaps
	{
public:
     


	enum TClipCaps	 
		{
		EClipToBitmap = 1,	 
	
	     



		EClipping = 2		 
		};

 


	enum TMaskBitmapCaps	 
		{
	 
		EMaskBitmapNone = 0,
	
	 
		EMaskBitmapAnyDisplayMode,
	
	 
		EMaskBitmapMatchingDisplayMode,
	
	 
		EMaskBitmapGray2,
		};

 


	enum TAlphaChannelCaps	 
    	{
	 

		EAlpha4444 = 1,	 
	
	 

		EAlpha8888 = 2,  
	
	 

		EAlpha1555 = 4,  
		};

 


	enum TAlphaBitmapCaps	 
    	{
	 

		EAlphaBitmapGray256 = 1,
	
	 


		EAlphaBitmapColor16M = 2,
	
	 
		EAlphaBitmapMatchingMode = 4,	 
		};

 





	enum TPatternSizeCaps	 
		{
	 
		EPatternSizeAny = 0xFFFFFFFF,
		};

 


	enum TPatternCaps	 
		{
	 
		EPatternAnyDisplayMode = 1,			 
	
	 
		EPatternMatchingDisplayMode = 2,	 
	
	 
		EPatternMustBeSquare = 4,			 
		};
		
 


	enum TPolygonCaps	 
		{
	 
		EPolygonFillAlternate = 1,
	
	 


		EPolygonFillWinding = 2,
		};

	 
	TInt			iStructureSize;	 
	
	 
	TInt			iVersion;		 
	
	 


	TUid			iVendorUid;		 
	
	 





	TUint			iDisplayModes;	 
	
	 



	TUint			iClipping;		 
	
	 



	TMaskBitmapCaps	iMaskType;		 
	
	 



	TUint			iTransparency;	 
	
	 



	TUint			iAlphaChannel;	 
	
	 



	TUint			iAlphaBitmap;	 
	
	 








	TUint			iPatternSizes;	 
	
	 



	TUint			iPattern;		 
	
	 



	TUint			iPolygon;		 
	
	 
	TUint			iReserved[4];	 
	};


 
 
 

 











class TGraphicsOperation
	{
public:
	enum TGopFunction
		{								 

		EFilledRect,					 
		EFilledRectUsingDrawMode,		 
		EFilledRectWithPattern,			 
		EInvertRect,					 
		EFadeRect,						 

		EBitBlt,						 
		EBitBltMasked,					 
		EBitBltTransparent,				 
		EBitBltAlphaChannel,			 
		EBitBltAlphaBitmap,				 

		EScaledBitBlt,					 
		EScaledBitBltMasked,			 
		EScaledBitBltTransparent,		 
		EScaledBitBltAlphaChannel,		 
		EScaledBitBltAlphaBitmap,		 

		EFilledPolygon,					 
		EFilledPolygonWithPattern,		 
		};
public:
	 
	inline TGopFunction Function() const	{ return iFunction; }
	inline TInt Size() const				{ return iSize; }
	 
	inline TGraphicsOperation* Next() const;
	inline void Append(TInt aNumBytes,TAny* aData);
protected:
	inline TGraphicsOperation(TGopFunction aFunction, TInt aArgSize);
	inline TGraphicsOperation() {}
protected:
	TGopFunction iFunction;
	TInt iSize;   
	};

inline TGraphicsOperation::TGraphicsOperation(TGopFunction aFunction, TInt aSize)
	: iFunction(aFunction) , iSize(aSize) {}

inline TGraphicsOperation* TGraphicsOperation::Next() const
	{ return (TGraphicsOperation*)((TUint8*)this+iSize); }

inline void TGraphicsOperation::Append(TInt aNumBytes,TAny* aData)
	{
	Mem::Copy(Next(),aData,aNumBytes);
	iSize += aNumBytes;
	}


 
 
 

 











class CGraphicsAccelerator : public CBase
	{
public:
	 
	
	 


	virtual const TGraphicsAcceleratorCaps* Capabilities() = 0;

	 
	
	 






	virtual TInt Operation(const TGraphicsOperation& aOperation) = 0;
	
	 










	virtual TInt Operation(const TGraphicsOperation& aOperation,TInt aNumClipRects,TRect* aClipRects) = 0;
	
	 
	 
	
	 

















	virtual TInt Operation(TDes8& aBuffer) = 0;
	
	 




















	virtual TInt Operation(TDes8& aBuffer,TInt aNumClipRects,TRect* aClipRects) = 0;
public:
	 
	virtual void Reserved_1() = 0;
	virtual void Reserved_2() = 0;
	virtual void Reserved_3() = 0;
	virtual void Reserved_4() = 0;
	};



 









class CSoftwareGraphicsAccelerator : public CGraphicsAccelerator
	{
public:
	 
	  static CSoftwareGraphicsAccelerator* NewL(CFbsBitmap* aBitmap);

	 
	  static const TGraphicsAcceleratorCaps* GenericCapabilities();
public:
	 
	virtual const TGraphicsAcceleratorCaps* Capabilities() = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation) = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation,TInt aNumClipRects,TRect* aClipRects) = 0;
	virtual TInt Operation(TDes8& aBuffer) = 0;
	virtual TInt Operation(TDes8& aBuffer,TInt aNumClipRects,TRect* aClipRects) = 0;
	 
	virtual void Reserved_1() = 0;
	virtual void Reserved_2() = 0;
	virtual void Reserved_3() = 0;
	virtual void Reserved_4() = 0;
	};


 











class CHardwareGraphicsAccelerator : public CGraphicsAccelerator
	{
public:
	  static CHardwareGraphicsAccelerator* NewL(RHardwareBitmap aBitmap);
	  static const TGraphicsAcceleratorCaps* GenericCapabilities();
public:
	 
	virtual const TGraphicsAcceleratorCaps* Capabilities() = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation) = 0;
	virtual TInt Operation(const TGraphicsOperation& aOperation,TInt aNumClipRects,TRect* aClipRects) = 0;
	virtual TInt Operation(TDes8& aBuffer) = 0;
	virtual TInt Operation(TDes8& aBuffer,TInt aNumClipRects,TRect* aClipRects) = 0;
	 
	virtual void Reserved_1() = 0;
	virtual void Reserved_2() = 0;
	virtual void Reserved_3() = 0;
	virtual void Reserved_4() = 0;
	};

 
 
 

 















class TGopFillPattern
	{
public:
	
	 
	TAcceleratedBitmapSpec	iBitmap;
	
	 




	TPoint					iOrigin;
	};

 





















class TGopFadeParams	 
	{
public:
	
	 
	TInt iScale;
	
	 
	TInt iOffset;
	};

 













class TGopTransparency
	{
public:
	
	 


	inline TGopTransparency(TTransparencyType aType)	: iType(aType), iParam(0) {}
	
	 




	inline TGopTransparency(TInt aPixelValue)			: iType(ETransparentPixel), iParam(aPixelValue) {}
	
	 



	inline TGopTransparency(TRgb aRgb)					: iType(ETransparentColor), iParam(aRgb.Value()) {}
	
	 



	inline TRgb Color()	const							{ return TRgb(iParam); }
	
	 




	inline TInt Pixel()	const							{ return iParam; }
public:
	
	 
	TTransparencyType	iType;
	
	 

	TUint32				iParam;
	};


 
 
 





 








class TGopFilledRect : public TGraphicsOperation
	{
public:
	 


	inline TGopFilledRect(const TRect& aRect,TRgb aColor)
			: TGraphicsOperation(EFilledRect,sizeof(*this)), iRect(aRect) , iColor(aColor) {}
public:
	
	 
	TRect	iRect;
	
	 
	TRgb	iColor;
	};

 











class TGopFilledRectUsingDrawMode : public TGraphicsOperation
	{
public:
	 



	inline TGopFilledRectUsingDrawMode(const TRect& aRect,TRgb aColor,CGraphicsContext::TDrawMode aDrawMode)
		: TGraphicsOperation(EFilledRectUsingDrawMode,sizeof(*this)), iRect(aRect) , iColor(aColor) , iDrawMode(aDrawMode) {}
public:
	
	 
	TRect						iRect;
	
	 
	TRgb						iColor;
	
	 
	CGraphicsContext::TDrawMode	iDrawMode;
	};

 








class TGopFilledRectWithPattern : public TGraphicsOperation
	{
public:
	 



	inline TGopFilledRectWithPattern(const TRect& aRect,TGopFillPattern aPattern)
		: TGraphicsOperation(EFilledRectWithPattern,sizeof(*this)), iRect(aRect) , iPattern(aPattern) {}
public:
	
	 
	TRect			iRect;
	
	 

	TGopFillPattern iPattern;
	};

 








class TGopInvertRect : public TGraphicsOperation
	{
public:
	 

	inline TGopInvertRect(const TRect& aRect)
		: TGraphicsOperation(EInvertRect,sizeof(*this)), iRect(aRect) {}
public:
	
	 
	TRect	iRect;
	};

 







class TGopFadeRect : public TGraphicsOperation
	{
public:
	 


	inline TGopFadeRect(const TRect& aRect, const TGopFadeParams aFade)
		: TGraphicsOperation(EFadeRect,sizeof(*this)), iRect(aRect), iFade(aFade) {}
public:
	
	 
	TRect			iRect;
	
	 
	TGopFadeParams	iFade;
	};

 









class TGopBitBlt : public TGraphicsOperation
	{
public:
	 






	inline TGopBitBlt(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EBitBlt,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 














class TGopBitBltMasked : public TGraphicsOperation
	{
public:
	 








	inline TGopBitBltMasked(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aMask)
		: TGraphicsOperation(EBitBltMasked,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iMask(aMask) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iMask;
	};

 











class TGopBitBltTransparent : public TGraphicsOperation
	{
public:
	 











	inline TGopBitBltTransparent(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TGopTransparency aTransparency)
		: TGraphicsOperation(EBitBltTransparent,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iTransparency(aTransparency) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TGopTransparency		iTransparency;
	};

 















class TGopBitBltAlphaChannel : public TGraphicsOperation
	{
public:
	 






	inline TGopBitBltAlphaChannel(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EBitBltAlphaChannel,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 
























class TGopBitBltAlphaBitmap : public TGraphicsOperation
	{
public:
	 








	inline TGopBitBltAlphaBitmap(const TPoint& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aAlphaBitmap)
		: TGraphicsOperation(EBitBltAlphaBitmap,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iAlphaBitmap(aAlphaBitmap) {}
public:
	
	 
	TPoint					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iAlphaBitmap;
	};

 









class TGopScaledBitBlt : public TGraphicsOperation
	{
public:
	 







	inline TGopScaledBitBlt(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EScaledBitBlt,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 














class TGopScaledBitBltMasked : public TGraphicsOperation
	{
public:
	 









	inline TGopScaledBitBltMasked(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aMask)
		: TGraphicsOperation(EScaledBitBltMasked,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iMask(aMask) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iMask;
	};

 












class TGopScaledBitBltTransparent : public TGraphicsOperation
	{
public:
	 











	inline TGopScaledBitBltTransparent(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TGopTransparency aTransparency)
		: TGraphicsOperation(EScaledBitBltTransparent,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iTransparency(aTransparency) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TGopTransparency		iTransparency;
	};

 












class TGopScaledBitBltAlphaChannel : public TGraphicsOperation
	{
public:
	 








	inline TGopScaledBitBltAlphaChannel(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect)
		: TGraphicsOperation(EScaledBitBltAlphaChannel,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	};

 












class TGopScaledBitBltAlphaBitmap : public TGraphicsOperation
	{
public:
	 








	inline TGopScaledBitBltAlphaBitmap(const TRect& aDestination, TAcceleratedBitmapSpec aSourceBitmap, TRect& aSourceRect, TAcceleratedBitmapSpec aAlphaBitmap)
		: TGraphicsOperation(EScaledBitBltAlphaBitmap,sizeof(*this)), iDestination(aDestination), iSourceBitmap(aSourceBitmap), iSourceRect(aSourceRect), iAlphaBitmap(aAlphaBitmap) {}
public:
	
	 
	TRect					iDestination;
	
	 
	TAcceleratedBitmapSpec	iSourceBitmap;
	
	 
	TRect					iSourceRect;
	
	 
	TAcceleratedBitmapSpec	iAlphaBitmap;
	};

 










class TGopFilledPolygon : public TGraphicsOperation
	{
public:
	 




	inline TGopFilledPolygon(TRgb aColor, CGraphicsContext::TFillRule aFillRule)
		: TGraphicsOperation(EFilledPolygon,sizeof(*this)), iColor(aColor), iFillRule(aFillRule), iNumPoints(0) {}
	inline void AddPoints(TInt aNumPoints, TPoint* aPoints);
public:
	
	 
	TRgb						iColor;
	
	 


	CGraphicsContext::TFillRule iFillRule;
	
	 
	TInt						iNumPoints;
	};

 



inline void TGopFilledPolygon::AddPoints(TInt aNumPoints, TPoint* aPoints)
	{ Append(aNumPoints*sizeof(TPoint),aPoints); iNumPoints += aNumPoints; }

 











class TGopFilledPolygonWithPattern : public TGraphicsOperation
	{
public:
	inline TGopFilledPolygonWithPattern(TGopFillPattern aPattern, CGraphicsContext::TFillRule aFillRule)
		: TGraphicsOperation(EFilledPolygonWithPattern,sizeof(*this)), iPattern(aPattern), iFillRule(aFillRule), iNumPoints(0) {}
	inline void AddPoints(TInt aNumPoints, TPoint* aPoints);
public:
	
	 
	TGopFillPattern				iPattern;
	
	 


	CGraphicsContext::TFillRule iFillRule;
	
	 
	TInt						iNumPoints;
	};

 



inline void TGopFilledPolygonWithPattern::AddPoints(TInt aNumPoints, TPoint* aPoints)
	{ Append(aNumPoints*sizeof(TPoint),aPoints); iNumPoints += aNumPoints; }




# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2


 



enum {EScanBufSize=0x80}; 

class CFbsDrawDevice;


 


















class CFbsDevice : public CBitmapDevice
	{
	friend class CFbsBitGc;
public:
	  ~CFbsDevice();
	  TInt CreateContext(CFbsBitGc*& aGc);
	inline TInt CreateContext(CGraphicsContext*& aGc);
	  TDisplayMode DisplayMode() const;
	  TSize SizeInPixels() const;
	  TBool RectCompare(const TRect& aSourceRect,const CFbsDevice& aDevice,const TRect& aDeviceRect) const;
	  TInt AddFile(const TDesC& aName,TInt& aId);
	  void RemoveFile(TInt aId=0);
	  TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt GetFontById(CFont*& aFont,TUid aFileId,const TAlgStyle& aStyle);
	inline TInt GetNearestFontInTwips(CFbsFont*& aFont,const TFontSpec& aFontSpec);
	inline TInt GetNearestFontInPixels(CFbsFont*& aFont,const TFontSpec& aFontSpec);
	inline TInt GetFontById(CFbsFont*& aFont,TUid aFileId,const TAlgStyle& aStyle);
	  void ReleaseFont(CFont* aFont);
	  TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  TInt NumTypefaces() const;
	  void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const;
	  TInt SetCustomPalette(const CPalette* aPalette);
	inline CGraphicsAccelerator* GraphicsAccelerator() const;
	inline CFbsBitGc::TGraphicsOrientation Orientation() const;
	  static TDisplayMode DisplayMode16M();
	  TInt SetScalingFactor(const TPoint& aOrigin,
								   TInt aFactorX, TInt aFactorY,
								   TInt aDivisorX, TInt aDivisorY);
	  void GetDrawRect(TRect& aRect) const;
protected:
	CFbsDevice();
	virtual void DrawingBegin(TBool=EFalse) {}
	virtual void DrawingEnd(TBool=EFalse) {}
	virtual void SetBits() {}
	virtual void CancelSprite() const {}
	virtual TSpriteBase* HideSprite() const {return(0L );}
	virtual TSpriteBase* HideSprite(const TRect&,const TRegion*) const {return(0L );}
	virtual void ShowSprite(TSpriteBase*) const {}
	virtual void ShowSprite(TSpriteBase*,const TRect&,const TRegion*) const {}
	TInt GetNearestFbsFont(CFbsFont*& aFont,const TFontSpec& aFontSpec);
	void DoGetScanLine(TDes8& aBuf,const TPoint& aPixel,TInt aLength,TDisplayMode aDispMode);
	void ReadLineDiffMode(TInt,TInt,TInt,TAny*,TDisplayMode) const;
	void TruncateRect(TRect& aRect);
	TBool SetOrientation(CFbsBitGc::TGraphicsOrientation aOrientation);
protected:
	CFbsDrawDevice* iDrawDevice;
	RFbsSession* iFbs;
	CFbsTypefaceStore* iTypefaceStore;
	TBool iLockHeap;
	TBool iScreenDevice;
	TUint8* iBitBltMaskedBuffer;
	CGraphicsAccelerator* iGraphicsAccelerator;
	CFbsBitGc::TGraphicsOrientation iOrientation;
	};

 






class CFbsScreenDevice : public CFbsDevice
	{
public:
	  static CFbsScreenDevice* NewL(const TDesC& aLibname,TDisplayMode aDispMode);
	  static CFbsScreenDevice* NewL(const TDesC& aLibname,TDisplayMode aDispMode, TRgb aWhite);
	  virtual ~CFbsScreenDevice();
	  void GetScanLine(TDes8& aBuf,const TPoint& aStartPixel,TInt aLength,TDisplayMode aDispMode) const;
	  void GetPixel(TRgb& aColor,const TPoint& aPixel) const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  void SetAutoUpdate(TBool aValue);
	  void DrawSpriteBegin();
	  void DrawSpriteEnd();
	  void CancelSprite() const;
	  TSpriteBase* HideSprite() const;
	  TSpriteBase* HideSprite(const TRect& aRect,const TRegion* aClippingRegion) const;
	  void ShowSprite(TSpriteBase* aSprite) const;
	  void ShowSprite(TSpriteBase* aSprite,const TRect& aRect,const TRegion* aClippingRegion) const;
	  void ChangeScreenDevice(CFbsScreenDevice* aOldDevice);
	  void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  void SetPalette(CPalette* aPalette);
	  TInt GetPalette(CPalette*& aPalette) const;
	  void Update();
	  void Update(const TRegion& aRegion);
	  TSize SizeInTwips() const;
	  RHardwareBitmap HardwareBitmap();
private:
	CFbsScreenDevice();
	void ConstructL(TDisplayMode aDispMode);
private:
	TSpriteBase* iSprite;
	TBool iSpriteDraw;
	};

 







class CFbsBitmapDevice : public CFbsDevice
	{
public:
	  static CFbsBitmapDevice* NewL(CFbsBitmap* aFbsBitmap);
	  static CFbsBitmapDevice* NewL(CFbsBitmap* aFbsBitmap,const TDesC& aLibname);
	  virtual ~CFbsBitmapDevice();
	  TInt Resize(const TSize& aSize);
	  virtual void GetScanLine(TDes8& aBuf,const TPoint& aStartPixel,TInt aLength,TDisplayMode iDispMode) const;
	  virtual void GetPixel(TRgb& aColor,const TPoint& aPixel) const;
	  virtual TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  virtual TInt VerticalPixelsToTwips(TInt aPixels) const;
	  virtual TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  virtual TInt VerticalTwipsToPixels(TInt aTwips) const;
	  virtual TSize SizeInTwips() const;
	  virtual void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  virtual void SetPalette(CPalette* aPalette);
	  virtual TInt GetPalette(CPalette*& aPalette) const;
	  virtual void DrawingBegin(TBool aAlways);
	  virtual void DrawingEnd(TBool aAlways);
	  TInt SwapWidthAndHeight();
private:
	CFbsBitmapDevice();
	virtual void SetBits();
	void ConstructL(CFbsBitmap* aFbsBitmap);
	void ConstructL(CFbsBitmap* aFbsBitmap,const TDesC& aLibname);
private:
	CFbsBitGcBitmap* iFbsBmp;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.inl" 1
 
 
 
 


 








TInt CFbsDevice::CreateContext(CGraphicsContext*& aGc)
	{
	return CreateContext((CFbsBitGc*&)aGc); 
	} 

 










TInt CFbsDevice::GetNearestFontInTwips(CFbsFont*& aFont,const TFontSpec& aFontSpec)
	{
	return GetNearestFontInTwips((CFont*&)aFont,aFontSpec); 
	} 

 










TInt CFbsDevice::GetNearestFontInPixels(CFbsFont*& aFont,const TFontSpec& aFontSpec)
	{
	return GetNearestFontInPixels((CFont*&)aFont,aFontSpec); 
	} 

 








TInt CFbsDevice::GetFontById(CFbsFont*& aFont,TUid aFileId,const TAlgStyle& aStyle)
	{
	return GetFontById((CFont*&)aFont,aFileId,aStyle); 
	} 

 




CGraphicsAccelerator* CFbsDevice::GraphicsAccelerator() const
	{
	return iGraphicsAccelerator;
	}


 


CFbsBitGc::TGraphicsOrientation CFbsDevice::Orientation() const
	{
	return iOrientation;
	}

# 179 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bitdev.h" 2


# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/w32std.h" 2






static const TLitC<sizeof(L"Wserv" )/2>  KWSERVThreadName ={sizeof(L"Wserv" )/2-1,L"Wserv" } ;

class RWindowBase;
class RWindow;
class RWsBuffer;

 




class TSizeMode
	{
public:
	inline TSizeMode(){}
	inline TSizeMode(TSize& aSize);
	static inline TInt ScaledCord(TInt aOrigin,TInt aScale);
	inline TPoint ScaledOrigin();
public:
	CFbsBitGc::TGraphicsOrientation iRotation;
	TPoint iOrigin;
	TSize iScreenSize;
	TSize iScreenTwipsSize;
	TUint iAlternativeRotations;
	TRect iPointerCursorArea;
	TSize iScreenScale;
	};

 












enum TScreenModeEnforcement
	{
	 





	ESizeEnforcementNone,
	 



	ESizeEnforcementPixelsAndRotation,
	 






	ESizeEnforcementPixelsTwipsAndRotation,
	};

struct TPixelsAndRotation
 







	{
	 
	TSize iPixelSize;
	 
	CFbsBitGc::TGraphicsOrientation iRotation;
	};

struct TPixelsTwipsAndRotation
 







	{
	 
	TSize iPixelSize;
	 
	TSize iTwipsSize;
	 
	CFbsBitGc::TGraphicsOrientation iRotation;
	};

 






enum {
	 
	KLogMessageLength=0x80
	};

 





typedef TBuf<KLogMessageLength> TLogMessageText;

 







enum
	{
	  
	KPasswordWindowGroupPriority=1000
	};

 













enum {
	 
	KOrdinalPositionSwitchToOwningWindow=0x80000000
	};

 










enum TCornerType
 
	{
	 
	EWindowCornerSquare,
	 
	EWindowCorner1,
	 


	EWindowCorner2,
	 



	EWindowCorner3,
	 




	EWindowCorner5,
	EWindowCornerRegion,		 
	 




	ECornerTypeMask=0xFFFF
	};

 







enum TCornerFlags
 
	{
	 
	EWindowCornerNotTL=0x10000,
	 
	EWindowCornerNotTR=0x20000,
	 
	EWindowCornerNotBL=0x40000,
	 
	EWindowCornerNotBR=0x80000,
	};

 




enum TWindowBackupType
	{
	 


	EWindowBackupAreaBehind=0x0001,
	 





	EWindowBackupFullScreen=0x0002,
	};

 







enum TEventCode
	{
	 


	EEventNull,
	 










	EEventKey,
	 



	EEventKeyUp,
	 



	EEventKeyDown,
	 






	EEventModifiersChanged,
	 







	EEventPointer,			 
	 





	EEventPointerEnter,
	 





	EEventPointerExit,
	 


	EEventPointerBufferReady,
	 

	EEventDragDrop,
	 


	EEventFocusLost,		 
	 


	EEventFocusGained,
	 




	EEventSwitchOn,
	 






	EEventPassword,
	 





	EEventWindowGroupsChanged,
	 







	EEventErrorMessage,		 
	 


	EEventMessageReady,
	EEventMarkInvalid,	 
	 








	EEventSwitchOff,
	 
	EEventKeySwitchOff,
	 



	EEventScreenDeviceChanged,  
	 


	EEventFocusGroupChanged,
	 




	EEventCaseOpened,
	 







	EEventCaseClosed,
	 






	EEventWindowGroupListChanged,
	 
	 





	EEventKeyRepeat=100,
	 
	 
	 






	EEventUser=1000,
	};


 




enum THotKey
	{
	 





	EHotKeyEnableLogging,
	 


	EHotKeyDisableLogging,
	 



	EHotKeyStateDump,
	 


	EHotKeyOfDeath,
	 




	EHotKeyShutDown,
	 






	EHotKeyHeapDump,
	 



	EHotKeyIncContrast,
	 



	EHotKeyDecContrast,
	 


	EHotKeyOff,
	 



	EHotKeyBacklightOn,
	 



	EHotKeyBacklightOff,
	 



	EHotKeyBacklightToggle,
	 



	EHotKeyScreenDimension0,
	 



	EHotKeyScreenDimension1,
	 
	EHotKeyScreenDimension2,
	 
	EHotKeyScreenDimension3,
	 








	EHotKeyCycleDisplaySize,
	 












	EHotKeyCycleOrientation,
	 



	EHotKeyIncBrightness,
	 


	EHotKeyDecBrightness,
	 



	EHotKeyFirstKeyType=EHotKeyEnableLogging,		 
	 



	EHotKeyLastKeyType=EHotKeyDecBrightness,		 
	};


 



enum TPasswordMode
	{
	 




	EPasswordCancel,
	 

	EPasswordNone,
	 



	EPasswordOnceADay,
	 
	EPasswordAlways,
	 

	EPasswordAlwaysTriggerNow,
	 

	EPasswordOnceADayTriggerNow,
	};

struct TTextCursor
 
















    {
	 
	 
	 
	 
	 
	 
	 





	enum ENamedCursors
		{
		 
		ETypeNone,
		 
		ETypeRectangle,
		 
		ETypeHollowRectangle,
		 



		ETypeFirst=ETypeRectangle,
		 



		ETypeLast=ETypeHollowRectangle,
		 


		ETypeLastBasic = 1000,
		};
	 
	typedef TInt EType;
	 


	enum EFlags
		{
		 
		EFlagNoFlash		= 0x00000001,
		 



		EFlagClipHorizontal	= 0x00000002,
		 





		EFlagClipVertical	= 0x00000004,
		 		
		EUserFlags			= 0x0000FFFF,
		 		
		EFlagClipped		= 0x00010000,
		 		
		EPrivateFlags		= 0xFFFF0000,
		};
	 


	TInt iType;
	 



    TInt iHeight;
	 
    TInt iAscent;
	 



    TInt iWidth;
	 


    TUint iFlags;
	 




	TRgb iColor;
    };

 







enum TSpriteFlags
	{
	 


	ESpriteFlash=0x1,
	 













	ESpriteNoChildClip=0x2,
	 




	ESpriteNoShadows=0x4,
	 
	ESpriteNonSystemFlags=0x0000FFFF,
	 
	ESpriteSystemFlags=	  0xFFFF0000,
	 
	ESpritePointer=0x10000,
	 
	ESpriteOOM=0x20000,
	 
	ESpriteDisabled=0x40000,
	 
	ESpriteActive=0x80000,
	};

struct TSpriteMember
 





	{
	 




	CFbsBitmap *iBitmap;
	 














	CFbsBitmap *iMaskBitmap;
	 

	TBool iInvertMask;
	 
	CGraphicsContext::TDrawMode iDrawMode;
	 



	TPoint iOffset;
	 



	TTimeIntervalMicroSeconds32 iInterval;
	};

 









enum TEventControl
	{
	 
	EEventControlAlways,
	 

	EEventControlOnlyWithKeyboardFocus,
	 

	EEventControlOnlyWhenVisible
	};

 









enum TPointerFilter
	{
	 
	 
	EPointerFilterEnterExit=0x1,
	 
	EPointerFilterMove=0x2,
	 
	EPointerFilterDrag=0x4,
	 



	EPointerGenerateSimulatedMove=0x8,
	 
	 









	EPointerMoveEvents=EPointerFilterMove|EPointerGenerateSimulatedMove,
	};

struct TPointerEvent
 






	{
 



	enum TType
		{
		 
		EButton1Down,
		 
		EButton1Up,
		 


		EButton2Down,
		 


		EButton2Up,
		 
		EButton3Down,
		 
		EButton3Up,
		 


		EDrag,
		 



		EMove,
		 
		EButtonRepeat,
		 
		ESwitchOn,
		};
	 
	TType iType;
	 
	TUint iModifiers;	 
	 





	TPoint iPosition;
	 




	TPoint iParentPosition;
	};

struct TKeyEvent
 













	{
	 


	TUint iCode;
	 


	TInt iScanCode;
	 
	TUint iModifiers;
	 



	TInt iRepeats;
	};

struct TModifiersChangedEvent
 




	{
	 

	TUint iChangedModifiers;
	 

	TUint iModifiers;
	};

struct TWsErrorMessage
 




	{
	 
	enum TErrorCategory
		{
		 





		EDrawingRegion,
		 


		EBackLight,
		 
		ELogging,
		 
		EContrast,
		};
	 
	TErrorCategory iErrorCategory;
	 
	TUint iError;
	};


class TWsRedrawEvent
 








	{
public:
	inline TUint Handle() const;
	inline TRect Rect() const;
public:
	void SetHandle(TUint aHandle);
	void SetRect(TRect aRect);
protected:
	 
	TUint iHandle;
	 
	TRect iRect;			 
	};


class TWsPriorityKeyEvent
 






	{
public:
	inline TKeyEvent *Key() const;
	inline TUint Handle() const;
	inline void SetHandle(TUint aHandle);
protected:
	 
	TUint iHandle;
	 
	TUint8 iEventData[sizeof(TKeyEvent)];
	};


class TWsEvent
 









	{
public:
	 
	enum
		{
		 



		EWsEventDataSize=sizeof(TPointerEvent)
		};
public:
	inline TPointerEvent *Pointer() const;
	inline TKeyEvent *Key() const;
	inline TModifiersChangedEvent *ModifiersChanged() const;
	inline TWsErrorMessage *ErrorMessage() const;
	inline TUint8 *EventData() const;
	inline TInt Type() const;
	inline TUint Handle() const;
	inline TTime Time() const;
	inline void SetType(TInt aType);
	inline void SetHandle(TUint aHandle);
	inline void SetTimeNow();
protected:
	 
	TInt iType;
	 
	TUint iHandle;
	 
	TTime iTime;
	 
	TUint8 iEventData[EWsEventDataSize];
	};


class RWsPointerCursor;

 








enum TPointerCursorMode
	{
	 
	EPointerCursorNone,
	 
	EPointerCursorFixed,
	 

	EPointerCursorNormal,
	 

	EPointerCursorWindow,
	 


	EPointerCursorFirstMode=EPointerCursorNone,
	 



	EPointerCursorLastMode=EPointerCursorWindow,
	};

 













enum TLongCaptureFlags
	{
	 



	ELongCaptureShortEventImmediately=0x01,
	 

	ELongCaptureRepeatEvents=0x02,
	 

	ELongCaptureNormal=ELongCaptureShortEventImmediately,
	 
	ELongCaptureWaitShort=0,
	};


class TIpcArgs;
class TReadDescriptorType;
class TWriteDescriptorType;
class CWindowGc;


class MWsClientClass
 



	{
	friend class CWindowGc;
public:
	MWsClientClass();
	MWsClientClass(RWsBuffer *aBuffer);
	inline TInt WsHandle() const;
protected:
	void Write(const TAny *aData, TInt aLength,const TAny *aData2, TInt aLength2,TUint aOpcode) const;
	void Write(const TAny *aBuf, TInt aBufLen,TUint aOpcode) const;
	void Write(TUint aOpcode) const;
	void WriteInt(TInt aInt, TUint aOpcode) const;
	void WriteRect(const TRect &aRect, TUint aOpcode) const;
	void WritePoint(const TPoint &aPoint, TUint aOpcode) const;
	void WriteSize(const TSize &aSize, TUint aOpcode) const;
	TInt WriteReply(TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReplyInt(TInt aInt, TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReply(const TAny *aBuf, TInt aBufLen,TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReply(const TAny *aBuf, TInt aBufLen,const TAny *aBuf2, TInt aBuflen2,TUint aOpcode,const TIpcArgs* aIpcArgs= 0L ) const;
	TInt WriteReplyP(const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyIntP(TInt aInt, const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyP(const TAny *aBuf, TInt aBufLen, const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyP(const TAny *aBuf, TInt aBufLen,const TAny *aBuf2, TInt aBuflen2, const TWriteDescriptorType& aReplyPackage,TUint aOpcode) const;
	TInt WriteReplyByProvidingRemoteReadAccess(const TAny* aBuf, TInt aBufLen,const TReadDescriptorType& aRemoteReadBuffer,TUint aOpcode) const;
protected:
	 
	TInt32 iWsHandle;
	 
	RWsBuffer *iBuffer;
	};

 
class RWindowTreeNode;
class CWsScreenDevice;
class CWsBitmap;
class RAnimDll;
class RWsSpriteBase;
class RDirectScreenAccess;
class RSoundPlugIn;


class RWsSession : public MWsClientClass, public RSessionBase
 






































	{
	friend class RWsBuffer;
	friend class RWindowTreeNode;
	friend class CWsScreenDevice;
	friend class CWsBitmap;
	friend class RAnimDll;
	friend class RWsSpriteBase;
	friend class RDirectScreenAccess;
	friend class RSoundPlugIn;
public:
	 







	enum TComputeMode
		{
		 




		EPriorityControlDisabled,
		 
		EPriorityControlComputeOn,
		 



		EPriorityControlComputeOff
		};
	enum {ESystemInfoArraySize=16};
	 


	enum TLoggingCommand
		{
		 
		ELoggingEnable,
		 
		ELoggingDisable,
		 

		ELoggingStatusDump,		 
		 

		ELoggingHeapDump,
		};
	struct SSystemInfo
	 
		{
		TInt iInfo[ESystemInfoArraySize];
		};
	 




	enum TCustomTextCursorAlignment
		{
		 
		ECustomTextCursorAlignTop,
		 

		ECustomTextCursorAlignBaseline,
		 

		ECustomTextCursorAlignBottom
		};
 
public:
	  RWsSession();
	  TInt Connect();
	  void Close();
	  TVersion Version();

	  TInt SetHotKey(THotKey aType, TUint aKeyCode, TUint aModifierMask, TUint aModifier);
	  TInt ClearHotKeys(THotKey aType);
	  TInt RestoreDefaultHotKey(THotKey aType);
 
	  void EventReady(TRequestStatus *aStat);
	  void EventReadyCancel();
	  void GetEvent(TWsEvent &aEvent);
	  void PurgePointerEvents();
 
	  void RedrawReady(TRequestStatus *aStat);
	  void RedrawReadyCancel();
	  void GetRedraw(TWsRedrawEvent &aEvent);
 
	  void PriorityKeyReady(TRequestStatus *aStat);
	  void PriorityKeyReadyCancel();
	  void GetPriorityKey(TWsPriorityKeyEvent &aEvent);
 
	  void Flush();
	  TBool SetAutoFlush(TBool aState);
	  void SetKeyboardRepeatRate(const TTimeIntervalMicroSeconds32 &aInitialTime, const TTimeIntervalMicroSeconds32 &aTime);
	  void GetKeyboardRepeatRate(TTimeIntervalMicroSeconds32 &aInitialTime, TTimeIntervalMicroSeconds32 &aTime);
	  void GetDoubleClickSettings(TTimeIntervalMicroSeconds32 &aInterval, TInt &aDistance);
	  void SetDoubleClick(const TTimeIntervalMicroSeconds32 &aInterval, TInt aDistance);
 
	  TInt NumWindowGroups() const;
	  TInt WindowGroupList(CArrayFixFlat<TInt> *aWindowList);
	  TInt NumWindowGroups(TInt aPriority) const;
	  TInt WindowGroupList(TInt aPriority, CArrayFixFlat<TInt> *aWindowList);
	  TInt GetFocusWindowGroup();
	  TInt GetDefaultOwningWindow();
	  TInt SetWindowGroupOrdinalPosition(TInt aIdentifier, TInt aPosition);
	  TInt GetWindowGroupClientThreadId(TInt aIdentifier, TThreadId &aThreadId);
	  TInt GetWindowGroupHandle(TInt aIdentifier);
	  TInt GetWindowGroupOrdinalPriority(TInt aIdentifier);
	  TInt SendEventToWindowGroup(TInt aIdentifier, const TWsEvent &aEvent);
	  TInt SendEventToAllWindowGroups(const TWsEvent &aEvent);
	  TInt SendEventToAllWindowGroups(TInt aPriority, const TWsEvent &aEvent);
	  TInt SendEventToOneWindowGroupsPerClient(const TWsEvent &aEvent);
	  TInt GetWindowGroupNameFromIdentifier(TInt aIdentifier, TDes &aWindowName);
	  TInt FindWindowGroupIdentifier(TInt aPreviousIdentifier,const TDesC& aMatch,TInt aOffset=0);
	  TInt FindWindowGroupIdentifier(TInt aPreviousIdentifier,TThreadId aThreadId);
	  TInt SendMessageToWindowGroup(TInt aIdentifier, TUid aUid, const TDesC8 &aParams);
	  TInt SendMessageToAllWindowGroups(TUid aUid, const TDesC8& aParams);
	  TInt SendMessageToAllWindowGroups(TInt aPriority, TUid aUid, const TDesC8& aParams);
	  TInt FetchMessage(TUid &aUid, TPtr8 &aParams, const TWsEvent& aMessageEvent);
 
	  void SetShadowVector(const TPoint &aVector);
	  TPoint ShadowVector() const;
 
	  void SetBackgroundColor(TRgb aColor);
	  TRgb GetBackgroundColor() const;
 
	  TInt SetSystemPointerCursor(const RWsPointerCursor &aPointerCursor,TInt aCursorNumber);
	  void ClearSystemPointerCursor(TInt aCursorNumber);
	  TInt ClaimSystemPointerCursorList();
	  void FreeSystemPointerCursorList();
 
	  TInt SetCustomTextCursor(TInt aIdentifier, const TArray<TSpriteMember>& aSpriteMemberArray, TUint aSpriteFlags, TCustomTextCursorAlignment aAlignment);
 
	  TInt ResourceCount();
	  void PasswordEntered();
	  void ComputeMode(TComputeMode aMode);
 
	  TInt HeapCount() const;
	  void MarkStart();
	  void CheckNum(TUint aCount);
	  void MarkEnd(TUint aCount);
	  void HeapSetFail(TInt aTAllocFail,TInt aValue);
	  void SetModifierState(TEventModifier aModifier,TModifierState aState);
	  TInt GetModifierState() const;
 
	  TInt RequestOffEvents(TBool aOn,RWindowTreeNode *aWin= 0L );
	  TDisplayMode GetDefModeMaxNumColors(TInt& aColor,TInt& aGray) const;
	  TInt GetColorModeList(CArrayFixFlat<TInt> *aModeList) const;
 
	  void SetPointerCursorArea(const TRect& aArea);
	  void SetPointerCursorArea(TInt aScreenSizeMode,const TRect& aArea);
	  TRect PointerCursorArea() const;
	  TRect PointerCursorArea(TInt aScreenSizeMode) const;
	  void SetPointerCursorMode(TPointerCursorMode aMode);
	  TPointerCursorMode PointerCursorMode() const;
	  void SetDefaultSystemPointerCursor(TInt aCursorNumber);
	  void ClearDefaultSystemPointerCursor();
	  void SetPointerCursorPosition(const TPoint& aPosition);
	  TPoint PointerCursorPosition() const;

	  void SetDefaultFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap);
	  void PrepareForSwitchOff();
	  void SetBufferSizeL(TInt aBufSize);
	  TInt SetSystemFaded(TBool aFaded);
	  TInt SetSystemFaded(TBool aFaded,TUint8 aBlackMap,TUint8 aWhiteMap);







 
	  void SimulateRawEvent(TRawEvent aEvent);
	  void SimulateKeyEvent(TKeyEvent aEvent);
	  void LogCommand(TLoggingCommand aCommand);
	  void LogMessage(const TLogMessageText &aMessage);
 
 
 
	  void SystemInfo(TInt &aSystemInfoNumber, SSystemInfo &aSystemInfo);
	  void TestWrite(TInt aHandle,TInt aOpcode,const TAny *aData, TInt aLength);
	  void TestWriteReply(TInt aHandle,TInt aOpcode,const TAny *aData, TInt aLength);
	  void TestWriteReplyP(TInt aHandle,TInt aOpcode,const TAny *aData,TInt aLength,TDes8 *aReplyPackage);
	  TInt TestWriteReplyByProvidingRemoteReadAccess(TInt aHandle,TInt aOpcode,const TDesC8& aData,const TDesC8& aRemoteReadBuffer);
	  TInt TestWriteReplyByProvidingRemoteReadAccess(TInt aHandle,TInt aOpcode,const TDesC8& aData,const TDesC16& aRemoteReadBuffer);
private:
	TInt doWindowGroupList(TInt aPriority, CArrayFixFlat<TInt> *aWindowList, TInt aNumOpcode, TInt aListOpcode);
	TInt doSetHotKey(TInt aOpcode, TInt aType, TUint aKeycode, TUint aModifierMask, TUint aModifiers);
	void doReadEvent(TRequestStatus *aStat, TInt aOpcode);
private:
	void connectL();
	TInt DoFlush(const TIpcArgs& aIpcArgs);
	void DirectAcessActivation(TBool aIsNowActive);
	};

class RWindowGroup;
class RWsSprite;

 	
typedef TInt (*AnimCommand)(TPtr8 *aBufPtr,TAny *aPackage);


class RWindowTreeNode : public MWsClientClass
 







	{
	friend class RWindowGroup;
	friend class RWindowBase;
	friend class CWindowGc;
	friend class RAnimDll;
	friend class RWsSprite;
public:
	 



	enum TFadeControl
		{
		 
		EFadeIncludeChildren=ETrue,
		 



		EFadeWindowOnly=EFalse,
		};
protected:
	RWindowTreeNode();
	RWindowTreeNode(RWsSession &aWs);
public:
	  void Close();
	  void Destroy();
	  TUint32 Parent() const;
	  TUint32 PrevSibling() const;
	  TUint32 NextSibling() const;
	  TUint32 Child() const;
	  TInt OrdinalPriority() const;
	  TInt OrdinalPosition() const;
	  TInt FullOrdinalPosition() const;
	  void SetOrdinalPosition(TInt aPos);
	  void SetOrdinalPosition(TInt aPos,TInt aOrdinalPriority);
	  TInt SetPointerCursor(TInt aCursorNumber);
	  void SetCustomPointerCursor(const RWsPointerCursor &aPointerCursor);
	  TInt EnableOnEvents(TEventControl aCircumstances=EEventControlOnlyWithKeyboardFocus);
	  void DisableOnEvents();
	  TInt EnableGroupChangeEvents();
	  void DisableGroupChangeEvents();
	  TInt EnableFocusChangeEvents();
	  void DisableFocusChangeEvents();
	  TInt EnableGroupListChangeEvents();
	  void DisableGroupListChangeEvents();
	  TInt EnableErrorMessages(TEventControl aCircumstances);
	  void DisableErrorMessages();
	  TInt EnableModifierChangedEvents(TUint aModifierMask, TEventControl aCircumstances);
	  void DisableModifierChangedEvents();
	  void SetNonFading(TBool aNonFading);
	  void SetFaded(TBool aFaded,TFadeControl aIncludeChildren);
	  void SetFaded(TBool aFaded,TFadeControl aIncludeChildren,TUint8 aBlackMap,TUint8 aWhiteMap);
	  void ClearPointerCursor();
protected:
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


class RWindowBase : public RWindowTreeNode
 









	{
public:
	 



	enum TCaptureFlags
		{
 
		 
		TCaptureFlagEnabled=0x01,
		 

		TCaptureFlagDragDrop=0x02,
		 

		TCaptureFlagAllGroups=0x04,
 
		 
		TCaptureDisabled=0,
		 
		TCaptureEnabled=TCaptureFlagEnabled,
		 
		TCaptureDragDrop=TCaptureFlagEnabled|TCaptureFlagDragDrop|TCaptureFlagAllGroups,
		};
protected:
	RWindowBase();
	RWindowBase(RWsSession &aWs);
public:
	  void Activate();
	  void SetPosition(const TPoint &point);
	  TInt SetSizeErr(const TSize &size);
	  TInt SetExtentErr(const TPoint &point,const TSize &size);
	  TSize Size() const;
	  TPoint InquireOffset(const RWindowTreeNode &aWindow) const;
	  void PointerFilter(TUint32 aFilterMask, TUint32 aFilter);
	  void SetPointerGrab(TBool aState);
	  void ClaimPointerGrab(TBool aSendUpEvent=ETrue);
	  void SetPointerCapture(TInt aFlags);
	  void SetVisible(TBool aState);
	  void SetShadowHeight(TInt aHeight);
	  void SetShadowDisabled(TBool aState);
	  TPoint Position() const;
	  TPoint AbsPosition() const;
	  TInt SetCornerType(TCornerType aCornerType, TInt aCornerFlags=0);
	  TInt SetShape(const TRegion &aRegion);
	  TInt SetRequiredDisplayMode(TDisplayMode aMode);
	  TDisplayMode DisplayMode();
	  void EnableBackup(TUint aBackupType=EWindowBackupAreaBehind);
	  void RequestPointerRepeatEvent(TTimeIntervalMicroSeconds32 aTime,const TRect &aRect);
	  void CancelPointerRepeatEventRequest();
	  TInt AllocPointerMoveBuffer(TInt aMaxPoints, TUint aFlags);
	  void FreePointerMoveBuffer();
	  void EnablePointerMoveBuffer();
	  void DisablePointerMoveBuffer();
	  TInt RetrievePointerMoveBuffer(TDes8 &aBuf);
	  void DiscardPointerMoveBuffer();
	  TInt AddKeyRect(const TRect &aRect, TInt aScanCode, TBool aActivatedByPointerSwitchOn);
	  void RemoveAllKeyRects();
	  TInt PasswordWindow(TPasswordMode aPasswordMode);
	  void FadeBehind(TBool aFade);
	  TBool IsFaded();
	  TBool IsNonFading();
	  TInt MoveToGroup(TInt aIdentifier);
protected:
	TInt construct(const RWindowTreeNode &parent,TUint32 aHandle, TInt aType, TDisplayMode aDisplayMode);
	};


class RBlankWindow : public RWindowBase
 








	{
public:
	  RBlankWindow();
	  RBlankWindow(RWsSession &aWs);
	  TInt Construct(const RWindowTreeNode &parent, TUint32 aHandle);
	  void SetColor(TRgb aColor);
	  void SetSize(const TSize &size);
	  void SetExtent(const TPoint &point,const TSize &size);
	};


class RDrawableWindow : public RWindowBase
 








	{
protected:
	RDrawableWindow();
	RDrawableWindow(RWsSession &aWs);
public:
	  void Scroll(const TPoint &aOffset);
	  void Scroll(const TRect &aClipRect, const TPoint &aOffset);
	  void Scroll(const TPoint &aOffset, const TRect &aRect);
	  void Scroll(const TRect &aClipRect, const TPoint &aOffset, const TRect &aRect);
private:
	void doScroll(const TRect &aClipRect, const TPoint &aOffset, const TRect &aRect, TInt aOpcode);
	};


class RWindow : public RDrawableWindow
 






	{
public:
	  RWindow();
	  RWindow(RWsSession &aWs);
	  TInt Construct(const RWindowTreeNode &parent,TUint32 aHandle);
	  void BeginRedraw();
	  void BeginRedraw(const TRect &aRect);
	  void EndRedraw();
	  void Invalidate();
	  void Invalidate(const TRect &aRect);
	  void GetInvalidRegion(RRegion &aRegion);
	  void SetBackgroundColor(TRgb aColor);
	  void SetBackgroundColor();
	  void SetSize(const TSize &size);
	  void SetExtent(const TPoint &point,const TSize &size);
	  void HandleTransparencyUpdate();
	  TInt SetTransparencyFactor(const TRgb& aTransparencyFactor);
	  TInt SetTransparencyBitmap(const CFbsBitmap& aTransparencyBitmap);
	  void SetNonTransparent();
	  void EnableRedrawStore(TBool aEnabled);
	};


class RBackedUpWindow : public RDrawableWindow
 











	{
public:
	  RBackedUpWindow();
	  RBackedUpWindow(RWsSession &aWs);
	  TInt Construct(const RWindowTreeNode &parent,TDisplayMode aDisplayMode, TUint32 aHandle);
	  TInt BitmapHandle();
	  void UpdateScreen();
	  void UpdateScreen(const TRegion &aRegion);
	  void UpdateBackupBitmap();
	  void MaintainBackup();
	};


class RWindowGroup : public RWindowTreeNode
 



	{
public:
	  RWindowGroup();
	  RWindowGroup(RWsSession &aWs);
	  TInt Construct(TUint32 aClientHandle);
	  TInt Construct(TUint32 aClientHandle, TBool aInitialFocusState);
	  void EnableReceiptOfFocus(TBool aState);
	  void AutoForeground(TBool aState);
	  void SetOrdinalPriorityAdjust(TInt aAdjust);
	  TInt32 CaptureKey(TUint aKeycode, TUint aModifierMask, TUint aModifier);
	  TInt32 CaptureKey(TUint aKeycode, TUint aModifierMask, TUint aModifier, TInt aPriority);
	  void CancelCaptureKey(TInt32 aCaptureKey);
	  TInt32 CaptureKeyUpAndDowns(TUint aScanCode, TUint aModifierMask, TUint aModifier);
	  TInt32 CaptureKeyUpAndDowns(TUint aScanCode, TUint aModifierMask, TUint aModifier, TInt aPriority);
	  void CancelCaptureKeyUpAndDowns(TInt32 aCaptureKey);
	  TInt32 CaptureLongKey(TUint aInputKeyCode,TUint aOutputKeyCode,TUint aModifierMask,TUint aModifier
																										,TInt aPriority,TUint aFlags);
	  TInt32 CaptureLongKey(TTimeIntervalMicroSeconds32 aRepeatTime,TUint aInputKeyCode,TUint aOutputKeyCode
																	,TUint aModifierMask,TUint aModifier,TInt aPriority,TUint aFlags);
	  void CancelCaptureLongKey(TInt32 aCaptureKey);
	  TInt AddPriorityKey(TUint aKeycode, TUint aModifierMask, TUint aModifier);
	  void RemovePriorityKey(TUint aKeycode, TUint aModifierMask, TUint aModifier);
	  void SetTextCursor(RWindowBase &aWin, const TPoint &aPos, const TTextCursor &aCursor);
	  void SetTextCursor(RWindowBase &aWin, const TPoint &aPos, const TTextCursor &aCursor, const TRect &aClipRect);
	  void CancelTextCursor();
	  void SetOwningWindowGroup(TInt aIdentifier);
	  void DefaultOwningWindow();
	  TInt SetName(const TDesC &aName);
	  TInt Name(TDes &aWindowName) const;
	  TInt Identifier() const;
	  void DisableKeyClick(TBool aState);
	  TInt EnableScreenChangeEvents();
	  void DisableScreenChangeEvents();
	  void SimulatePointerEvent(TRawEvent aEvent);
private:
	TInt32 doCaptureKey(TUint aKey, TUint aModifierMask, TUint aModifiers, TInt aPriority, TInt aOpcode);
	void doCancelCaptureKey(TInt32 aCaptureKeyHandle, TInt aOpcode);
	};


class CWsBitmap : public CFbsBitmap, public MWsClientClass
 







	{
public:
	  CWsBitmap();
	  CWsBitmap(RWsSession &aWs);
	  ~CWsBitmap();
	  TInt Create(const TSize& aSizeInPixels,TDisplayMode aDispMode);
	  TInt Duplicate(TInt aHandle);
	  TInt Load(const TDesC& aFileName,TInt32 aId,TBool aShareIfLoaded=ETrue);
	  void InternalizeL(RReadStream& aStream);
	  void Reset();
private:
	TInt createWsBitmap(TInt aErr);
	};


class CWindowGc : public CBitmapContext, public MWsClientClass
 























	{
	friend class CWsScreenDevice;
public:
	  CWindowGc(CWsScreenDevice *aDevice);
	  virtual ~CWindowGc();
	  virtual TInt Construct();
	  virtual void Activate(RDrawableWindow &aDevice);
	  virtual void Deactivate();
 
	  virtual CGraphicsDevice* Device() const;
	  virtual void SetOrigin(const TPoint &aPoint=TPoint(0,0));
	  virtual void SetDrawMode(TDrawMode aDrawingMode);
	  virtual void SetClippingRect(const TRect& aRect);
	  virtual void CancelClippingRect();
	  virtual void Reset();

	  virtual void UseFont(const CFont *aFont);
	  virtual void DiscardFont();
	  virtual void SetUnderlineStyle(TFontUnderline aUnderlineStyle);
	  virtual void SetStrikethroughStyle(TFontStrikethrough aStrikethroughStyle);
 
	  virtual void SetWordJustification(TInt aExcessWidth,TInt aNumGaps);
 
	  virtual void SetCharJustification(TInt aExcessWidth,TInt aNumChars);

	  virtual void SetPenColor(const TRgb &aColor);
	  virtual void SetPenStyle(TPenStyle aPenStyle);
	  virtual void SetPenSize(const TSize& aSize);

	  virtual void SetBrushColor(const TRgb &aColor);
	  virtual void SetBrushStyle(TBrushStyle aBrushStyle);
	  virtual void SetBrushOrigin(const TPoint &aOrigin);
	  virtual void UseBrushPattern(const CFbsBitmap *aDevice);
	  virtual void DiscardBrushPattern();
 
 
 
	  virtual void MoveTo(const TPoint &aPoint);
	  virtual void MoveBy(const TPoint &aPoint);
	  virtual void Plot(const TPoint &aPoint);
 
 
	  virtual void DrawArc(const TRect &aRect,const TPoint &aStart,const TPoint &aEnd);
	  virtual void DrawLine(const TPoint &aPoint1,const TPoint &aPoint2);
	  virtual void DrawLineTo(const TPoint &aPoint);
	  virtual void DrawLineBy(const TPoint &aPoint);
	  virtual void DrawPolyLine(const CArrayFix<TPoint> *aPointList);
	  virtual void DrawPolyLine(const TPoint* aPointList,TInt aNumPoints);
 
 
 
 
 
 
	  virtual void DrawPie(const TRect &aRect,const TPoint &aStart,const TPoint &aEnd);
	  virtual void DrawEllipse(const TRect &aRect);
	  virtual void DrawRect(const TRect &aRect);
	  virtual void DrawRoundRect(const TRect &aRect,const TSize &aEllipse);
	  virtual TInt DrawPolygon(const CArrayFix<TPoint> *aPointList,TFillRule aFillRule=EAlternate);
	  virtual TInt DrawPolygon(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule=EAlternate);
 
 
	  virtual void DrawBitmap(const TPoint &aTopLeft, const CFbsBitmap *aDevice);
	  virtual void DrawBitmap(const TRect &aDestRect, const CFbsBitmap *aDevice);
	  virtual void DrawBitmap(const TRect &aDestRect, const CFbsBitmap *aDevice, const TRect &aSourceRect);
 
 
 
 
	  virtual void DrawText(const TDesC &aBuf,const TPoint &aPos);
 
 
 
	  virtual void DrawText(const TDesC &aBuf,const TRect &aBox,TInt aBaselineOffset,TTextAlign aHoriz=ELeft,TInt aLeftMrg=0);
 
	  virtual void Clear();
	  virtual void Clear(const TRect &aRect);
	  virtual void CopyRect(const TPoint &anOffset,const TRect &aRect);
	  virtual void BitBlt(const TPoint &aPos, const CFbsBitmap *aBitmap);
	  virtual void BitBlt(const TPoint &aDestination, const CFbsBitmap *aBitmap, const TRect &aSource);
	  virtual void BitBltMasked(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aSourceRect,const CFbsBitmap* aMaskBitmap,TBool aInvertMask);
	  virtual void BitBlt(const TPoint &aPoint, const CWsBitmap *aBitmap);
	  virtual void BitBlt(const TPoint &aDestination, const CWsBitmap *aBitmap, const TRect &aSource);
	  virtual void BitBltMasked(const TPoint& aPoint,const CWsBitmap *aBitmap,const TRect& aSourceRect,const CWsBitmap *aMaskBitmap,TBool aInvertMask);
	  virtual void MapColors(const TRect& aRect,const TRgb* aColors,TInt aNumPairs=2,TBool aMapForwards=ETrue);

	  virtual void DrawTextVertical(const TDesC& aText,const TPoint& aPos,TBool aUp);
	  virtual void DrawTextVertical(const TDesC& aText,const TRect& aBox,TInt aBaselineOffset,TBool aUp,TTextAlign aVert=ELeft,TInt aMargin=0);
 
	  virtual void SetDitherOrigin(const TPoint& aPoint);
	  virtual TInt SetClippingRegion(const TRegion &aRegion);
	  virtual void CancelClippingRegion();
	  void SetOpaque(TBool aDrawOpaque=ETrue);
 
	  void SetFaded(TBool aFaded);
	  void SetFadingParameters(TUint8 aBlackMap,TUint8 aWhiteMap);
	  void AlphaBlendBitmaps(const TPoint& aDestPt, const CFbsBitmap* aSrcBmp, const TRect& aSrcRect, const CFbsBitmap* aAlphaBmp, const TPoint& aAlphaPt);
	  void AlphaBlendBitmaps(const TPoint& aDestPt, const CWsBitmap* aSrcBmp, const TRect& aSrcRect, const CWsBitmap* aAlphaBmp, const TPoint& aAlphaPt);
 
private:  
	TRgb Color(TInt aOpcode)const;
	void SetJustification(TInt aExcessWidth,TInt aNumGaps, TInt aOpcode);
	void DrawArcOrPie(const TRect &aRect,const TPoint &aStart,const TPoint &aEnd, TInt aOpcode);
	void doDrawPolyLine(const CArrayFix<TPoint> *aPointArray, const TPoint* aPointList,TInt aNumPoints);
	TInt doDrawPolygon(const CArrayFix<TPoint> *aPointArray,const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule);
	void WriteTextPos(TInt aOpcode,TInt aOpcodePtr,const TPoint &aPos,const TDesC &aBuf) const;
	void WriteTextCommand(TAny *aCmd, TInt aLen,const TDesC &aBuf,TInt aOpcode,TInt aOpcodePtr) const;
private:  
	CFbsFont *iFont;
	CWsScreenDevice *iDevice;
	};


class CWsScreenDevice : public CBitmapDevice, public MWsClientClass
 












	{
public:
	 
	enum TSpriteInCompare
		{
		 






		ERemoveSprite=0,
		 



		EIncludeSprite=1,
		};
public:
	  CWsScreenDevice();
	  CWsScreenDevice(RWsSession &aWs);
	  ~CWsScreenDevice();
	  TInt Construct();
 
	  TDisplayMode DisplayMode() const;
	  TSize SizeInPixels() const;
	  TSize SizeInTwips() const;
	  TInt HorizontalTwipsToPixels(TInt aTwips) const;
	  TInt VerticalTwipsToPixels(TInt aTwips) const;
	  TInt HorizontalPixelsToTwips(TInt aPixels) const;
	  TInt VerticalPixelsToTwips(TInt aPixels) const;
	  TRect PointerRect() const;
	  TInt CreateContext(CGraphicsContext *&aGc);
    inline TInt CreateContext(CWindowGc *&aGc);
	  TInt GetNearestFontInTwips(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt NumTypefaces() const;
	  void TypefaceSupport(TTypefaceSupport& aTypefaceSupport,TInt aTypefaceIndex) const;
	  TInt FontHeightInTwips(TInt aTypefaceIndex,TInt aHeightIndex) const;
 
      void GetPixel(TRgb &aColor,const TPoint &aPixel) const;
      void GetScanLine(TDes8 &aScanLine,const TPoint &aStartPixel,TInt aPixelLength, TDisplayMode aDispMode) const;
	  TInt AddFile(const TDesC& aName,TInt& aId);
	  void RemoveFile(TInt aId=0);
	  TInt GetNearestFontInPixels(CFont*& aFont,const TFontSpec& aFontSpec);
	  TInt FontHeightInPixels(TInt aTypefaceIndex,TInt aHeightIndex) const;
	  void ReleaseFont(CFont* aFont);
 
	  void PaletteAttributes(TBool& aModifiable,TInt& aNumEntries) const;
	  void SetPalette(CPalette* aPalette);
	  TInt GetPalette(CPalette*& aPalette) const;
 
	  TInt SetCustomPalette(const CPalette* aPalette);
 	  TInt GetFontById(CFont *&aFont,TUid aUid,const TAlgStyle& aAlgStyle);
	  TBool RectCompare(const TRect &aRect1,const TRect &aRect2);
	  TBool RectCompare(const TRect& aRect1,const TRect &aRect2,TUint aFlags) const;
	  TInt CopyScreenToBitmap(const CFbsBitmap *aBitmap) const;
	  TInt CopyScreenToBitmap(const CFbsBitmap *aBitmap, const TRect &aRect) const;
 
	  void SetScreenSizeAndRotation(const TPixelsTwipsAndRotation &aSizeAndRotation);
	  void GetDefaultScreenSizeAndRotation(TPixelsTwipsAndRotation &aSizeAndRotation) const;
	  void SetScreenSizeAndRotation(const TPixelsAndRotation &aSizeAndRotation);
	  void GetDefaultScreenSizeAndRotation(TPixelsAndRotation &aSizeAndRotation) const;
	  TScreenModeEnforcement ScreenModeEnforcement() const;
	  void SetScreenModeEnforcement(TScreenModeEnforcement aMode) const;
	  void GetScreenModeSizeAndRotation(TInt aMode, TPixelsTwipsAndRotation &aSizeAndRotation) const;
	  void GetScreenModeSizeAndRotation(TInt aMode, TPixelsAndRotation &aSizeAndRotation) const;
	  void SetCurrentRotations(TInt aMode, CFbsBitGc::TGraphicsOrientation aRotation) const;
	  TInt GetRotationsList(TInt aMode, CArrayFixFlat<TInt> *aRotationList) const;
	  TInt NumScreenModes() const;
	  void SetScreenMode(TInt aMode);
	  TInt CurrentScreenMode() const;
	  void SetAppScreenMode(TInt aMode);
	  TPoint GetDefaultScreenModeOrigin() const;
	  TPoint GetScreenModeOrigin(TInt aMode) const;
	  TSize GetCurrentScreenModeScale() const;
	  TSize GetScreenModeScale(TInt aMode) const;
	  TPoint GetCurrentScreenModeScaledOrigin() const;
	  TPoint GetScreenModeScaledOrigin(TInt aMode) const;
 
	  TSizeMode GetCurrentScreenModeAttributes() const;
	  void SetCurrentScreenModeAttributes(const TSizeMode &aModeAtt);
private:  
	CFbsTypefaceStore* iTypefaceStore;
	TSize iPhysicalScreenSizeInTwips;
	TSize iDisplaySizeInPixels;
	friend class CWindowGc;
	};


class RWsSpriteBase : public MWsClientClass
 
 








	{
protected:
	  RWsSpriteBase();
	  RWsSpriteBase(RWsSession &aWs);
public:
	  TInt Activate();
	  TInt AppendMember(const TSpriteMember &aMemberData);
	  void UpdateMember(TInt aIndex);
	  TInt UpdateMember(TInt aIndex, const TSpriteMember &aMemberData);
	  void Close();
	};


class RWsSprite : public RWsSpriteBase
 






	{
public:
	  RWsSprite();
	  RWsSprite(RWsSession &aWs);
	  TInt Construct(RWindowTreeNode &aWindow, const TPoint &aPos, TInt aFlags);
	  void SetPosition(const TPoint &aPos);
	};


class RWsPointerCursor : public RWsSpriteBase
 




















	{
	friend class RWindowTreeNode;
	friend class RWsSession;
public:
	  RWsPointerCursor();
	  RWsPointerCursor(RWsSession &aWs);
	  TInt Construct(TInt aFlags);
	};


class RAnim;


class RAnimDll : public MWsClientClass
 









	{
public:
	  RAnimDll();
	  virtual ~RAnimDll();
	  RAnimDll(RWsSession &aWs);
	  TInt Load(const TDesC &aFileName);
	  void Destroy();
	  virtual void Close();
private:
	TInt CommandReply(TInt aHandle, TInt aOpcode, const TIpcArgs* aIpcArgs= 0L );
	TInt CommandReply(TInt aHandle, TInt aOpcode, const TDesC8& aArgs, const TIpcArgs* aIpcArgs= 0L );
	void Command(TInt aHandle, TInt aOpcode, const TPtrC8 &aArgs);
	void Command(TInt aHandle, TInt aOpcode);
	void AsyncCommandReply(TRequestStatus& aStatus, TInt aOpcode, TIpcArgs& aIpcArgs);
	TInt CreateInstance(TInt32& aHandle, const MWsClientClass &aDevice, TInt aType, const TDesC8 &aArgs, TInt aOpcode, const TIpcArgs* aIpcArgs);
	void DestroyInstance(TInt aHandle);
private:
	friend class RAnim;
	};


class RAnim
 






	{
public:
	  virtual ~RAnim();
	  virtual void Close();
	  void Destroy();
protected:
	  RAnim();
	  RAnim(RAnimDll &aDll);
	  TInt Construct(const RWindowBase &aDevice, TInt aType, const TDesC8 &aParams);
	  TInt Construct(const RWindowBase &aDevice, TInt aType, const TDesC8 &aParams, const TIpcArgs& aIpcArgs);
	  TInt Construct(const RWsSprite &aDevice, TInt aType, const TDesC8 &aParams);
	  TInt Construct(const RWsSprite &aDevice, TInt aType, const TDesC8 &aParams, const TIpcArgs& aIpcArgs);
	  TInt CommandReply(TInt aOpcode);
	  TInt CommandReply(TInt aOpcode, const TPtrC8 &aArgs);
	  TInt CommandReply(TInt aOpcode, const TDesC8& aArgs, const TIpcArgs& aIpcArgs);
	  void Command(TInt aOpcode, const TPtrC8 &aArgs);
	  void Command(TInt aOpcode);
	  void AsyncCommandReply(TRequestStatus& aRequestStatus,TInt aOpcode, const TIpcArgs& aIpcArgs);
private:
	TInt32 iHandle;
	RAnimDll *iAnimDll;
	};


class RDirectScreenAccess : public MWsClientClass
 








	{
public:
	 








	enum TTerminationReasons
		{
		 
		ETerminateCancel,
		 

		ETerminateRegion,
		 
		ETerminateScreenMode,
		 

		ETerminateRotation,
		};
	 

	enum TPriority
		{
		 


		EPriorityVeryHigh=100,
		};
public:
	  RDirectScreenAccess();
	  RDirectScreenAccess(RWsSession& aWs);
	  TInt Construct();
	  TInt Request(RRegion*& aRegion,TRequestStatus& aStatus,const RWindowBase& aWindow); 
	  void Completed();
	  void Cancel();
	  void Close();
private:
	RWsSession* iWs;
	RThread iWsThread;
	TRequestStatus* iAborted;
	TRequestStatus* iAbortedBackup;
	};


class MAbortDirectScreenAccess
 






	{
public:
	 













	virtual void AbortNow(RDirectScreenAccess::TTerminationReasons aReason)=0;
	};


class MDirectScreenAccess : public MAbortDirectScreenAccess
 









	{
public:
	 











	virtual void Restart(RDirectScreenAccess::TTerminationReasons aReason)=0;
	};


class CDirectScreenAccess : public CActive
 















	{
public:
	  static CDirectScreenAccess* NewL(RWsSession& aWs,CWsScreenDevice& aScreenDevice,RWindowBase& aWin,MDirectScreenAccess& aAbort);
	~CDirectScreenAccess();
	  void StartL();
	inline CFbsBitGc* Gc();
	inline CFbsScreenDevice*& ScreenDevice();
	inline RRegion* DrawingRegion();
private:
	enum TFlags
		{
		EDirectCheckModeChange=0x1,
		EDirectCheckSizeModeChange=0x2,
		};
private:
	inline CDirectScreenAccess(RWsSession& aWs,CWsScreenDevice* aScreenDevice,RWindowBase& aWindow,MDirectScreenAccess& aAbort);
	void ConstructL(RWsSession& aWs);
	void CreateScreenObjectsL(TDisplayMode aCurrentMode);
	void UpdateSizeAndRotation(CFbsBitGc* aGc);
	static TInt Restart(TAny* aDirect);
	void Restart();
	 
	void DoCancel();
	void RunL();
private:
	CFbsBitGc* iGc;
	CFbsScreenDevice* iScreenDevice;
	RRegion* iDrawingRegion;
	RWindowBase& iWindow;
	CWsScreenDevice* iWsScreenDevice;
	MDirectScreenAccess& iAbort;
	RDirectScreenAccess iDirectAccess;
	RDirectScreenAccess::TTerminationReasons iReason;
	CIdle* iRestart;
	TSize iScreenSize;
	TBool iAborting;
	TUint iFlags;
	};


class RSoundPlugIn : public MWsClientClass
 






	{
public:
	 
	enum 
		{
		 



		ESoundWrongPlugIn=KMinTInt
		};
public:
	  RSoundPlugIn();
	  RSoundPlugIn(RWsSession &aWs);
	  TInt Construct(TUid aUid= TUid::Null() );
	  void Close();
	  void Destroy();
	  TBool IsLoaded(TBool& aIsChangeable);
	  TInt Unload();
	  TInt Load(const TDesC &aFileName);
	  void SetKeyClick(TBool aEnabled);
	  void SetPenClick(TBool aEnabled);
	  TBool KeyClickEnabled();
	  TBool PenClickEnabled();
	  TInt CommandReply(TInt aOpcode, const TPtrC8 &aArgs);
	};

inline TInt MWsClientClass::WsHandle() const
	 


	{return(iWsHandle);}

inline TInt CWsScreenDevice::CreateContext(CWindowGc *&aGc)
	 







	{return(CreateContext((CGraphicsContext *&)aGc));}

inline TUint TWsRedrawEvent::Handle() const
	 






	{return(iHandle);}

inline TRect TWsRedrawEvent::Rect() const
	 



	{return(iRect);}

inline TPointerEvent *TWsEvent::Pointer() const
	 





	{return((TPointerEvent *)&iEventData);}

inline TKeyEvent *TWsEvent::Key() const
	 





	{return((TKeyEvent *)&iEventData);}

inline TModifiersChangedEvent *TWsEvent::ModifiersChanged() const
	 





	{return((TModifiersChangedEvent *)&iEventData);}

inline TWsErrorMessage *TWsEvent::ErrorMessage() const
	 





	{return((TWsErrorMessage *)&iEventData);}

inline TUint8 *TWsEvent::EventData() const
	 







	{return((TUint8 *)&iEventData);}

inline TInt TWsEvent::Type() const
	 


	{return(iType);}

inline TUint TWsEvent::Handle() const
	 






	{return(iHandle);}

inline TTime TWsEvent::Time() const
	 


	{return(iTime);}

inline void TWsEvent::SetType(TInt aType)
	 


	{iType=aType;}

inline void TWsEvent::SetHandle(TUint aHandle)
	 




	{iHandle=aHandle;}

inline void TWsEvent::SetTimeNow()
	 
	{iTime.HomeTime();}

inline TUint TWsPriorityKeyEvent::Handle() const
	 






	{return(iHandle);}

inline TKeyEvent *TWsPriorityKeyEvent::Key() const
	 


	{return((TKeyEvent *)&iEventData);}

inline void TWsPriorityKeyEvent::SetHandle(TUint aHandle)
	 




	{iHandle=aHandle;}

inline CDirectScreenAccess::CDirectScreenAccess(RWsSession& aWs,CWsScreenDevice* aScreenDevice,RWindowBase& aWindow,MDirectScreenAccess& aAbort)
		:CActive(RDirectScreenAccess::EPriorityVeryHigh), iWindow(aWindow), iAbort(aAbort), iDirectAccess(aWs)
		{iWsScreenDevice=aScreenDevice;}

inline CFbsBitGc* CDirectScreenAccess::Gc()
	 










	{ return iGc; }

inline CFbsScreenDevice*& CDirectScreenAccess::ScreenDevice()
	 






	{ return iScreenDevice; }

inline RRegion* CDirectScreenAccess::DrawingRegion()
	 










	{ return iDrawingRegion; }

inline TSizeMode::TSizeMode(TSize& aSize) :
	iOrigin(0, 0), iScreenSize(aSize)
	{}

inline TInt TSizeMode::ScaledCord(TInt aOrigin,TInt aScale)
	{return (aOrigin+aScale-1)/aScale;}

inline TPoint TSizeMode::ScaledOrigin()
	{return TPoint(ScaledCord(iOrigin.iX,iScreenScale.iWidth),ScaledCord(iOrigin.iY,iScreenScale.iHeight));}


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/barsc.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/barsc.h" 2


 
class RResourceFileImpl;

 



















class RResourceFile
	{
public:
	  RResourceFile();
	  void Close();
	  void OpenL(RFs &aFs,const TDesC &aName);
	  TUidType UidType() const;
	  void ReadL(TDes8 &aDes,TInt aResourceId) const;
	  HBufC8 *AllocReadL(TInt aResourceId) const;
	  HBufC8 *AllocReadLC(TInt aResourceId) const;
	  void ConfirmSignatureL(TInt aSignature);
	  void ConfirmSignatureL();
	  TInt SignatureL() const;  
	  TBool OwnsResourceId(TInt aResourceId) const;
	  TBool OwnsResourceIdL(TInt aResourceId) const;
	  void OpenL(RFs& aFs, const TDesC& aName, TUint aFileOffset, TInt aFileSize);
	inline TInt Offset() const;
private:
	void DoOpenL(RFs& aFs, const TDesC& aName, TUint aFileOffset, TInt aFileSize);
	  TInt Offset2() const;
	RResourceFileImpl* Impl();
	const RResourceFileImpl* Impl() const;
private:
	enum
		{
		KRscFileSize = 24
		};
	TUint8 iImpl[KRscFileSize];
	};

 







inline TInt RResourceFile::Offset() const 
	{ 
	return Offset2(); 
	}


# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h" 1
 
 
 
 

 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bamdesca.h" 1
 
 
 
 

 
 
 










class MDesC8Array
 







    {
public:
	 
    virtual ~MDesC8Array() {}
	 




    virtual TInt MdcaCount() const =0;

	 








    virtual TPtrC8 MdcaPoint(TInt aIndex) const =0;
    };


class MDesC16Array
 







    {
public:
	 
    virtual ~MDesC16Array() {}

	 




    virtual TInt MdcaCount() const =0;
	 








    virtual TPtrC16 MdcaPoint(TInt aIndex) const =0;
    };


 
 
 


 














 
# 123 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/bamdesca.h"





# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h" 2








class CDesC8Array : public CArrayFixBase, public MDesC8Array
 






	{
protected:
	  CDesC8Array(TBufRep aRep,TInt aGranularity);
public:
      ~CDesC8Array();
	  void AppendL(const TDesC8& aPtr);
	  void InsertL(TInt aPos,const TDesC8& aPtr);
	  TInt InsertIsqL(const TDesC8& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt InsertIsqAllowDuplicatesL(const TDesC8& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  void Sort(TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt Find(const TDesC8& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  TInt FindIsq(const TDesC8& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  void Delete(TInt aPos);
	  void Delete(TInt aIndex,TInt aCount);
	  void Reset();
	inline TPtrC8 operator[](TInt aIndex) const;
 
      TInt MdcaCount() const;
	  TPtrC8 MdcaPoint(TInt aIndex) const;
	};

inline TPtrC8 CDesC8Array::operator[](TInt aIndex) const
	{ return(MdcaPoint(aIndex)); }


class CDesC8ArrayFlat : public CDesC8Array
 





	{
public:
	  CDesC8ArrayFlat(TInt aGranularity);
      ~CDesC8ArrayFlat();
	};


class CDesC8ArraySeg : public CDesC8Array
 





	{
public:
	  CDesC8ArraySeg(TInt aGranularity);
      ~CDesC8ArraySeg();
	};


class CDesC16Array : public CArrayFixBase, public MDesC16Array
 








	{
protected:
	  CDesC16Array(TBufRep aRep,TInt aGranularity);
public:
      ~CDesC16Array();
	  void AppendL(const TDesC16& aPtr);
	  void InsertL(TInt aPos,const TDesC16& aPtr);
	  TInt InsertIsqL(const TDesC16& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt InsertIsqAllowDuplicatesL(const TDesC16& aPtr,TKeyCmpText aTextComparisonType=ECmpFolded);
	  void Sort(TKeyCmpText aTextComparisonType=ECmpFolded);
	  TInt Find(const TDesC16& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  TInt FindIsq(const TDesC16& aPtr,TInt& aPos,TKeyCmpText aTextComparisonType=ECmpFolded) const;
	  void Delete(TInt aPos);
	  void Delete(TInt aIndex,TInt aCount);
	  void Reset();
	inline TPtrC16 operator[](TInt aIndex) const;
 
      TInt MdcaCount() const;
		  TPtrC16 MdcaPoint(TInt aIndex) const;
	};



inline TPtrC16 CDesC16Array::operator[](TInt aIndex) const
 








 { return(MdcaPoint(aIndex)); }


class CDesC16ArrayFlat : public CDesC16Array
 





	{
public:
	  CDesC16ArrayFlat(TInt aGranularity);
      ~CDesC16ArrayFlat();
	};


class CDesC16ArraySeg : public CDesC16Array
 





	{
public:
	  CDesC16ArraySeg(TInt aGranularity);
      ~CDesC16ArraySeg();
	};


class CPtrC8Array : public CArrayFixFlat<TPtrC8>, public MDesC8Array
 






	{
public:
	  CPtrC8Array(TInt aGranularity);
	  ~CPtrC8Array();
 
	  void CopyL(const MDesC8Array& aArray);
    inline void operator=(const MDesC8Array& aArray);
 
      TInt MdcaCount() const;
      TPtrC8 MdcaPoint(TInt aIndex) const;
	};


class CPtrC16Array : public CArrayFixFlat<TPtrC16>, public MDesC16Array
 






	{
public:
	  CPtrC16Array(TInt aGranularity);
	  ~CPtrC16Array();
 
	  void CopyL(const MDesC16Array& aArray);
    inline void operator=(const MDesC16Array& aArray);
 
      TInt MdcaCount() const;
      TPtrC16 MdcaPoint(TInt aIndex) const;
	};


inline void CPtrC8Array::operator=(const MDesC8Array& aArray)
 








	{CopyL(aArray);}


inline void CPtrC16Array::operator=(const MDesC16Array& aArray)
 








	{CopyL(aArray);}

 


 






typedef CDesC16Array     CDesCArray;

 






typedef CDesC16ArrayFlat CDesCArrayFlat;

 






typedef CDesC16ArraySeg  CDesCArraySeg;

 












typedef CPtrC16Array CPtrCArray;
# 307 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h"








# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/basched.h" 1
 
 
 
 

 
 
 












 



const TInt KErrExtended=(-1000);
const TInt KErrExtendedWithText=(-1001);
const TInt KLeaveWithoutAlert=(-1002);
const TInt KLeaveExit=(-1003);

 


struct SExtendedError
	{
	TUid iComponent;
	TInt iErrorNumber;
	TBool iInformation;
	};

class CBaErrorHandler;

class CBaActiveScheduler : public CActiveScheduler
 



	{
public:
	  static void LeaveNoAlert();
public:  
	  static void Exit();
	  static void LeaveForAlert(TUid aComponent,TInt aErrorNumber);
	  static void LeaveForInfoPrint(TUid aComponent,TInt aErrorNumber);
	  static void LeaveForErrorHandler(const CBaErrorHandler *aHandler);
	  static const SExtendedError& ExtendedError();
	  static void DisplayExtendedError(TUid aComponent,TInt aErrorNumber);
	  virtual void DisplayError(TInt aError) const;
public: 
	  void Error(TInt aError) const;
private:
 
	  virtual void Reserved_1();
	  virtual void Reserved_2();
 
	static void ExtendedLeave(TUid aComponent,TInt aErrorNumber,TBool aLeaveForInfoPrint);
protected:
	SExtendedError iExtendedError;
	};


# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 2



class CVwsSessionWrapper;
class MVwsSessionWrapperObserver;

class CCoeAppUiBase;
class CCoeEnv;
class TResourceReader;
class RGenericPointerArray;

 




enum TActivePriority
	{
	 
	EActivePriorityClockTimer=300,
	 
	EActivePriorityIpcEventsHigh=200,
	 
	EActivePriorityFepLoader=150,
	 
	EActivePriorityWsEvents=100,
	 
	EActivePriorityRedrawEvents=50,
	 
	EActivePriorityDefault=0,
	 
	EActivePriorityLogonA=-10
	};

class CCoeEnvExtra;
class CCoeStatic;


class MCoeObserverOfLoadedFep
 











	{
public:
	 


	virtual void HandleChangeInLoadedFep()=0;
private:
	  virtual void MCoeObserverOfLoadedFep_Reserved_1();
	  virtual void MCoeObserverOfLoadedFep_Reserved_2();
	};

class TCoeInputCapabilities;  


class MCoeFocusObserver
 














	{
public:
	 

	virtual void HandleChangeInFocus()=0;
	 

	virtual void HandleDestructionOfFocusedItem()=0;
private:
	  virtual void MCoeFocusObserver_Reserved_1();
	  virtual void MCoeFocusObserver_Reserved_2();
	};

class MCoeResourceChangeObserver
 






	{
public:
	 
	virtual void HandleResourceChange()=0;
private:
	  virtual void MCoeResourceChangeObserver_Reserved_1();
	  virtual void MCoeResourceChangeObserver_Reserved_2();
	};

class MCoeForegroundObserver
 














	{
public:
	 
	virtual void HandleGainingForeground()=0;
	 
	virtual void HandleLosingForeground()=0;
private:
	  virtual void MCoeForegroundObserver_Reserved_1();
	  virtual void MCoeForegroundObserver_Reserved_2();
	};


class MCoeMessageObserver
 













	{
public:
	 
	enum TMessageResponse
		{
		 
		EMessageNotHandled,
		 
		EMessageHandled
		};
public:
	 










	virtual TMessageResponse HandleMessageL(TUint32 aClientHandleOfTargetWindowGroup, TUid aMessageUid, const TDesC8& aMessageParameters)=0;
private:
	  virtual void MCoeMessageObserver_Reserved_1();
	  virtual void MCoeMessageObserver_Reserved_2();
	};

 
class MCoeFepObserver;

 



typedef void (*TCoeFepObserverFunction)(MCoeFepObserver& aFepObserver);
class CCoeFepParameters;  
class CCoeFep;  

class CCoeScheduler : public CBaActiveScheduler
 




	{
public:
	  CCoeScheduler(CCoeEnv* aCoeEnv);
	  virtual void WaitForAnyRequest();
	  virtual void DisplayError(TInt aError) const;
	 


	inline CCoeEnv* CoeEnv() {return iCoeEnv;}
	TBool Flush() const;  
	void SetFlush(TBool aFlush);  
private:
	 
	  virtual void Reserved_1();
	  virtual void Reserved_2();
private:
	CCoeEnv* iCoeEnv;
	TBool iFlush;
	};


class CCoeEnv : public CActive
 














	{
public:
	  ~CCoeEnv();
	  CCoeEnv();
	  virtual void DestroyEnvironment();
	  CCoeAppUiBase* SetAppUi(CCoeAppUiBase* aAppUi);
	  void ExecuteD();
	  void RunL();
	  void DoCancel();
	  virtual void HandleError(TInt aError);
	  void ConstructL();
	  void ConstructL(TBool aInitialFocusState);
	inline const TWsEvent& LastEvent() const;
	inline CCoeAppUiBase* AppUi() const;
	inline RFs& FsSession() const;
	inline RWsSession& WsSession() const;
	inline RWindowGroup& RootWin() const;
	inline CWindowGc& SystemGc() const;
	inline const CFont* NormalFont() const;
	inline CWsScreenDevice* ScreenDevice() const;
	inline TBool IsSchedulerRunning() const;

	  CWindowGc* CreateGcL();
	  void Flush(TTimeIntervalMicroSeconds32 aDelay=0);
	  CFbsFont* CreateDeviceFontL(CGraphicsDevice* aDevice,const TFontSpec& aFontSpec);
	  CFbsFont* CreateScreenFontL(const TFontSpec& aFontSpec);
	  void ReleaseScreenFont(CFont* aFont) const;
	  void CreateResourceReaderLC(TResourceReader& aReader,TInt aResourceId) const;
	inline void ReadResource(TDes& aDes,TInt aResourceId) const; 
	inline void ReadResourceL(TDes& aDes,TInt aResourceId) const; 
	inline  HBufC* AllocReadResourceL(TInt aResourceId) const;
	inline HBufC* AllocReadResourceLC(TInt aResourceId) const;
	  TInt AddResourceFileL(const TDesC& aFileName);
	  void DeleteResourceFile(TInt aOffset);
	inline CDesCArrayFlat* ReadDesCArrayResourceL(TInt aResourceId);
	  void LeaveWithErrorText(const TDesC& aMsg,const TDesC* aContextText= 0L );
	  void Format128(TDes& aDes,TInt aResourceId,...);
	  void Format256(TDes& aDes,TInt aResourceId,...);
	  static TVersion Version();
	  static CCoeEnv* Static();
	  void SimulateKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  TBool IsWservEventPending() const;
	  TBool IsRedrawEventPending() const;
	  void PrepareToExit();
	  void BringOwnerToFront();
	  void ReadResourceAsDes8(TDes8& aDes,TInt aResourceId) const;  
	  void ReadResourceAsDes8L(TDes8& aDes,TInt aResourceId) const;
	  HBufC8* AllocReadResourceAsDes8L(TInt aResourceId) const;
	  HBufC8* AllocReadResourceAsDes8LC(TInt aResourceId) const;
	  CDesC8ArrayFlat* ReadDesC8ArrayResourceL(TInt aResourceId);
	  void SuppressNextFlush();
	  void ReadResourceAsDes16(TDes16& aDes,TInt aResourceId) const;  
	  void ReadResourceAsDes16L(TDes16& aDes,TInt aResourceId) const; 
	  HBufC16* AllocReadResourceAsDes16L(TInt aResourceId) const;  
	  HBufC16* AllocReadResourceAsDes16LC(TInt aResourceId) const;  
	  CDesC16ArrayFlat* ReadDesC16ArrayResourceL(TInt aResourceId);  
	  void AddObserverOfLoadedFepL(MCoeObserverOfLoadedFep& aObserverOfLoadedFep);  
	  void RemoveObserverOfLoadedFep(MCoeObserverOfLoadedFep& aObserverOfLoadedFep);  
	  void AddFocusObserverL(MCoeFocusObserver& aFocusObserver);  
	  void RemoveFocusObserver(MCoeFocusObserver& aFocusObserver);  
	  void SyncNotifyFocusObserversOfChangeInFocus();
	void NotifyFocusObserversOfDestructionOfFocusedItem();  
	  void AddForegroundObserverL(MCoeForegroundObserver& aForegroundObserver);  
	  void RemoveForegroundObserver(MCoeForegroundObserver& aForegroundObserver);  
	void NotifyForegroundObserversOfGainingForeground();  
	void NotifyForegroundObserversOfLosingForeground();  
	  void AddResourceChangeObserverL(MCoeResourceChangeObserver& aResourceChangeObserver); 
	  void RemoveResourceChangeObserver(MCoeResourceChangeObserver& aResourceChangeObserver); 
	void NotifyResourceObserversOfChangeInResource(); 
	  void AddMessageObserverL(MCoeMessageObserver& aMessageObserver);  
	  void RemoveMessageObserver(MCoeMessageObserver& aMessageObserver);  
	  void AddFepObserverL(MCoeFepObserver& aFepObserver);  
	  void RemoveFepObserver(MCoeFepObserver& aFepObserver);  
	  void ForEachFepObserverCall(TCoeFepObserverFunction aFepObserverFunction);  
	void LoadFepL();  
	void LoadFepL(const TDesC& aFileNameOfFepDll);  
	  void InstallFepL(const TDesC& aFileNameOfFepDll);  
	  void InstallFepL(const TDesC& aFileNameOfFepDll, const TBool aLeave);
	  HBufC* NameOfInstalledFepL();  
	  MDesC16Array * FileNamesOfAvailableFepsL();  
	  void ExecuteFepSettingsDialogL(const TDesC& aFileNameOfFepDll);  
	  CCoeFep* Fep() const;  
	  TUid FepUid() const;  
	  CWindowGc* SwapSystemGc(CWindowGc* aGc);  
	  static CCoeStatic* Static(TUid aUid);
	  CCoeStatic* FindStatic(TUid aUid);
	  void DisableExitChecks(TBool aDisable);
	  void InputCapabilitiesChanged();  
public:  
	  CCoeFepParameters* FepParameters();
public:  
	  void GetMessageNotifyingObserversLC(TUint32 aClientHandleOfTargetWindowGroup, TUid& aMessageUid, TPtr8& aMessageParameters, const TWsEvent& aMessageEvent);
protected:  
	  void SetUpFepL(CCoeFepParameters* aFepParameters, const TDesC& aFileNameOfDefaultFepDll);
private:  
	  virtual void Reserved_1();
	  virtual void Reserved_2();
public:  
	void ReadEvent();
	CVwsSessionWrapper* InitViewServerSessionL(MVwsSessionWrapperObserver& aObserver);
	void AddStatic(CCoeStatic* aStatic);
	void QueueNotificationToFocusObserversOfChangeInFocus();
	TInt FocusObserverNotificationIdentifier() const;
	TBool FocusObserverNotificationIsStillPending(TInt aFocusObserverNotificationIdentifier) const;
protected:
	  virtual void DestroyScreen();
	inline TDes& ErrorText();
	inline TDes& ErrorContextText();
private:
	  virtual void InitSystemFontsL();
	  virtual TInt ResourceFileVersionNumber() const;
	void CreateActiveSchedulerL();
	void ConnectToFileServerL();
	void ConnectToWindowServerL();
	void InitScreenL();
	void InitRootWindowL(TBool aInitialFocusState);
	void InitSystemGcL();
	RResourceFile& ResourceFileForId(TInt aResourceId) const;
	void DestroyAllResourceFiles();
	void AddObserverL(TAny* aObserver, RGenericPointerArray& aArray);
	void RemoveObserver(TAny* aObserver, RGenericPointerArray& aArray);
	inline TBool DisableShutdownChecks() const;
	void UpdateStatic(CCoeAppUiBase* aNewAppUi);
	void SetInitialHandleCount();
	inline TUint InitialHandleCount() const;
protected:
	CCoeAppUiBase* iAppUi;
	RFs iFsSession;
	RWsSession iWsSession;
	RWindowGroup iRootWin;
	CWindowGc* iSystemGc;
	const CFont* iNormalFont;
	CWsScreenDevice* iScreen;
	TWsEvent iLastEvent;
	CArrayFix<RResourceFile>* iResourceFileArray;

private:
	enum TFlags  
		{
		ENoShutdownChecks			=0x0001,
		EExtraPointerIsErrorCode	=0x0002,
		ESchedulerIsRunning			=0x0004
		};
private:
	TDes* iErrorText;
	TDes* iErrorContextText;
	CCoeEnvExtra* iExtra;
	CTrapCleanup* iCleanup;
	TUint iEnvFlags;
	};

class CCoeStatic : public CBase
 











	{
public:
	 
	enum TScope
		{
		 
		EThread,
		 
		EApp,
		};
	 
	enum {EDefaultDestructionPriority=100};
public:
	  ~CCoeStatic();
protected:
	  CCoeStatic(TUid aUid,TScope=EThread);
	  CCoeStatic(TUid aUid,TInt aDestructionPriority,TScope aScope=EThread);
private:
	void DoConstruction(TUid aUid,TInt aDestructionPriority,TScope aScope);
	void SetCsAppUi(CCoeAppUiBase* aAppUi);
	CCoeAppUiBase* CsAppUi() const;
	TScope CsScope() const;
	inline TInt DestructionPriority() const {return iCsLink.iPriority;}
private:
	TPriQueLink iCsLink;
	TUid iCsUid;
	TUint iCsAppUiAndScope;
private:
	friend class CCoeEnv;
	friend class CCoeEnvExtra;
	};

inline const TWsEvent& CCoeEnv::LastEvent() const
 




	{ return(iLastEvent); }

inline CCoeAppUiBase* CCoeEnv::AppUi() const
 


	{ return(iAppUi); }

inline RFs& CCoeEnv::FsSession() const
 





	{ return((RFs&)iFsSession); }

inline RWsSession& CCoeEnv::WsSession() const
 





	{ return((RWsSession&)iWsSession); }

inline RWindowGroup& CCoeEnv::RootWin() const
 






	{ return((RWindowGroup&)iRootWin); }

inline CWindowGc& CCoeEnv::SystemGc() const
 





	{ return((CWindowGc&)*iSystemGc); }

inline const CFont* CCoeEnv::NormalFont() const
 





	{ return(iNormalFont); }

inline CWsScreenDevice* CCoeEnv::ScreenDevice() const
 




	{ return(iScreen); }

inline TDes& CCoeEnv::ErrorText() 
 


	{ return *iErrorText; }

inline TDes& CCoeEnv::ErrorContextText() 
 


	{ return *iErrorContextText; }


inline void CCoeEnv::ReadResource(TDes& aDes,TInt aResourceId) const
 













	{ ReadResourceAsDes16(aDes,aResourceId); }

inline void CCoeEnv::ReadResourceL(TDes& aDes,TInt aResourceId) const
 







	{ ReadResourceAsDes16L(aDes,aResourceId); }

inline  HBufC* CCoeEnv::AllocReadResourceL(TInt aResourceId) const
 







	{ return AllocReadResourceAsDes16L(aResourceId); }

inline HBufC* CCoeEnv::AllocReadResourceLC(TInt aResourceId) const
 








	{ return AllocReadResourceAsDes16LC(aResourceId); }

inline CDesCArrayFlat* CCoeEnv::ReadDesCArrayResourceL(TInt aResourceId)
 




	{ return ReadDesC16ArrayResourceL(aResourceId); }
# 613 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h"


 
 
 
 
 
 
 
 
 
inline TBool CCoeEnv::IsSchedulerRunning() const
	{return iEnvFlags&ESchedulerIsRunning;}


# 72 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 1
 
 
 
 




 


 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 1
 
 
 
 

 




 





 

 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.hrh" 1
 
 
 
 




 












 






































 




# 20 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 2













 







 


 





const TInt KUidMediaServerLibraryValue = 268450111 ;
# 60 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h"


 





const TUid KUidMediaServerLibrary = {KUidMediaServerLibraryValue};

const TUint  KUidMdaTimerFactoryValue =  268441660 ; const TUid  KUidMdaTimerFactory  = { KUidMdaTimerFactoryValue}; 

 





const TInt KMdaServerDefaultMessageSlots=-1;	 

 





const TInt KMdaUnknown = -1;

 

 







class TMdaRawPackage
	{
public:
	inline TPtr8& Package();
	inline const TPtr8& Package() const;
protected:
	TMdaRawPackage(TInt aDerivedSize);
	inline void SetSize(TInt aDerivedSize);
protected:
	TPtr8 iThis;
	friend class RDummyMdaObject;
	};


class TMdaOpenPackage : public TMdaRawPackage
 






	{
public:
	inline void SetHandleAddress(TPckgBuf<TInt>* aHandle);
	inline TPckgBuf<TInt>* GetHandleAddress() const;
	inline TMdaOpenPackage(TInt aDerivedSize);
private:
	TPckgBuf<TInt>* iHandle;
	};

 












class TMdaPackage : public TMdaRawPackage
	{
public:
	inline TUid Type() const;
	inline TUid Uid() const;
	inline void SetUid(TUid aUid);
	inline TBool operator==(const TMdaPackage& aPackage);  
protected:
	inline TMdaPackage(TUid aType, TUid aUid, TInt aDerivedSize);
private:
	TUid iType;
	TUid iUid;
	};


 






class TMdaReturnPackage : public TMdaPackage
	{
public:
	inline TInt ReturnSize() const;
protected:
	inline TMdaReturnPackage(TUid aType, TUid aUid, TInt aDerivedSize);
	inline void SetReturnSize(TInt aReturnSize);
private:
	TInt iRetSize;
	friend class RDummyMdaObject;
	};


 






class TMdaEvent
	{
public:
	TInt32 iId;
	TInt32 iArg[3];
	};


 






class TMdaObjectEvent
	{
public:
	TInt iHandle;
	TMdaEvent iEvent;
	};

 






class TMdaEventPackage : public TMdaRawPackage
	{
public:
	inline TMdaEventPackage();  
	 
	inline TInt EventCount() const;
	inline TInt MaxEvents() const;
	inline const TMdaEvent& Event();  
	inline const TMdaEvent& Event(TInt aIndex);
	inline TInt EventFrom();  
	inline TInt EventFrom(TInt aIndex);
protected:
	inline TMdaEventPackage(TInt aMaxEvents);
protected:
	TInt iMaxEvents;
	TInt iValidEvents;
	TMdaObjectEvent iFirstEvent;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.inl" 1
 
 
 
 

 

inline TPtr8& TMdaRawPackage::Package()
	{ 
	((TMdaRawPackage*)this)->iThis.Set((TUint8*)this,iThis.Length(),iThis.MaxLength()); 
	return iThis; 
	}

inline const TPtr8& TMdaRawPackage::Package() const
	{ 
	((TMdaRawPackage*)this)->iThis.Set((TUint8*)this,iThis.Length(),iThis.MaxLength()); 
	return iThis; 
	}

inline void TMdaRawPackage::SetSize(TInt aDerivedSize)
	{ 
	iThis.Set((TUint8*)this,aDerivedSize,aDerivedSize);
	}

inline void TMdaOpenPackage::SetHandleAddress(TPckgBuf<TInt>* aHandle)
	{
	iHandle = aHandle;
	}

inline TPckgBuf<TInt>* TMdaOpenPackage::GetHandleAddress() const
	{
	return iHandle;
	}

 




inline TUid TMdaPackage::Type() const
	{
	return iType; 
	}

 




inline TUid TMdaPackage::Uid() const
	{ 
	return iUid;
	}

 







inline TBool TMdaPackage::operator==(const TMdaPackage& aPackage)
	{
	return ((aPackage.Type()==Type())&&(aPackage.Uid()==Uid()));
	}

inline void TMdaPackage::SetUid(TUid aUid)
	{
	iUid = aUid;
	}

inline TInt TMdaReturnPackage::ReturnSize() const
	{ 
	return iRetSize;
	}

inline void TMdaReturnPackage::SetReturnSize(TInt aReturnSize)
	{
	iRetSize = aReturnSize;
	}

inline TMdaRawPackage::TMdaRawPackage(TInt aDerivedSize)
#pragma warning( disable : 4355 )	
: iThis((TUint8*)this,aDerivedSize,aDerivedSize) 
#pragma warning( default : 4355 )
	{ 
	}

 









inline TMdaPackage::TMdaPackage(TUid aType, TUid aUid, TInt aDerivedSize)
: TMdaRawPackage(aDerivedSize),iType(aType),iUid(aUid)
	{
	}

inline TMdaOpenPackage::TMdaOpenPackage(TInt aDerivedSize) :
TMdaRawPackage(aDerivedSize)
	{
	}

inline TMdaReturnPackage::TMdaReturnPackage(TUid aType, TUid aUid, TInt aDerivedSize)
: TMdaPackage(aType,aUid,aDerivedSize)
	{  
	iRetSize = 0;
	}	

# 232 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfbase.h" 1
 
 
 
 




 



 













enum TMdaPriority
	{
  	 



    EMdaPriorityMin = -100,
	 


    EMdaPriorityNormal = 0,
	 


    EMdaPriorityMax = 100
	};

 






enum TMdaPriorityPreference
	{
	 


    EMdaPriorityPreferenceNone =	0x00000000,
	 



    EMdaPriorityPreferenceTime =	0x00000001,
	 



    EMdaPriorityPreferenceQuality = 0x00000002,
	 



    EMdaPriorityPreferenceTimeAndQuality = EMdaPriorityPreferenceTime|EMdaPriorityPreferenceQuality
	};

 





enum TMMFState
{
	 

	EMMFStateIdle,
	 

	EMMFStatePlaying,
	 

	EMMFStateTonePlaying,
	 

	EMMFStateRecording,
	 

	EMMFStatePlayingRecording,
	 

	EMMFStateConverting
};

 






class TMMFPrioritySettings
	{
public:
	 






	TInt iPriority;

	 














	TMdaPriorityPreference iPref;

	 


	TMMFState iState;
	};

 





typedef TPckgBuf<TMMFPrioritySettings> TMMFPrioritySettingsPckg;



# 234 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/base.h" 2



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 1
 
 
 
 




 


 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/port.h" 1
 
 
 
 




 


 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/port.hrh" 1
 
 
 
 








# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/port.h" 2



const TUint  KUidMdaSourcePortValue =  268450134 ; const TUid  KUidMdaSourcePort  = { KUidMdaSourcePortValue};  
const TUint  KUidMdaDestinationPortValue =  268450135 ; const TUid  KUidMdaDestinationPort  = { KUidMdaDestinationPortValue};  

 

 





enum
	{
	EMLbIoFactoryNewIO=0
	};

 





enum
	{
	EMLbPortNewBuffer=EMLbIoFactoryNewIO+1,
	EMLbPortConfig,
	EMLbPortNegotiate
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/controller.h" 1
 
 
 
 

 


# 15 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.hrh" 1
 
 
 
 






enum TMdaResourceStringType
	{
	EMdaResStringText=0x01,
	EMdaResStringData=0x02
	};

enum TMdaResourceUsage
	{
	EMdaResUsageSrc=0x01,
	EMdaResUsageDst=0x02,
	EMdaResUsageSrcAndDst=0x03  
	};

enum TMdaResourceConfigDefType
	{
	EMdaResConfigDefChoiceList=0x01,
	EMdaResConfigDefInteger=0x02,
	EMdaResConfigDefText=0x03,
	 
	EMdaResConfigDefChoiceListReadOnly=0x81,
	EMdaResConfigDefIntegerReadOnly=0x82,
	EMdaResConfigDefTextReadOnly=0x83
	};

enum TMdaResourceSigType
	{
	EMdaResSigTypeData=0,
	EMdaResSigTypeNamePattern=1,
	EMdaResSigTypeMime=2
	};






















# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/resource.h" 2


 
const TUint  KUidMdaResourceManagerValue =  268450122 ; const TUid  KUidMdaResourceManager  = { KUidMdaResourceManagerValue};   
const TUint  KUidMdaSourceClipValue =  268450126 ; const TUid  KUidMdaSourceClip  = { KUidMdaSourceClipValue};   
const TUint  KUidMdaDestinationClipValue =  268450127 ; const TUid  KUidMdaDestinationClip  = { KUidMdaDestinationClipValue};  
const TUint  KUidMdaClipLocationValue =  268450128 ; const TUid  KUidMdaClipLocation  = { KUidMdaClipLocationValue};   
const TUint  KUidMdaClipFormatValue =  268450129 ; const TUid  KUidMdaClipFormat  = { KUidMdaClipFormatValue};  
const TUint  KUidMdaSourceStreamValue =  268450130 ; const TUid  KUidMdaSourceStream  = { KUidMdaSourceStreamValue};   
const TUint  KUidMdaDestinationStreamValue =  268450131 ; const TUid  KUidMdaDestinationStream  = { KUidMdaDestinationStreamValue};  
const TUint  KUidMdaStreamDeviceValue =  268450132 ; const TUid  KUidMdaStreamDevice  = { KUidMdaStreamDeviceValue};   
const TUint  KUidMdaFileResLocValue =  268450124 ; const TUid  KUidMdaFileResLoc  = { KUidMdaFileResLocValue};   
const TUint  KUidMdaDesResLocValue =  268450125 ; const TUid  KUidMdaDesResLoc  = { KUidMdaDesResLocValue};  
const TUint  KUidMdaUrlResLocValue =  268450134 ; const TUid  KUidMdaUrlResLoc  = { KUidMdaUrlResLocValue};  
const TUint  KUidMdaClipDurationValue =  268450133 ; const TUid  KUidMdaClipDuration  = { KUidMdaClipDurationValue};   
const TUint  KUidMdaClipPrimeWindowValue =  268450166 ; const TUid  KUidMdaClipPrimeWindow  = { KUidMdaClipPrimeWindowValue};  
const TUint  KUidMdaClipCropValue =  268450197 ; const TUid  KUidMdaClipCrop  = { KUidMdaClipCropValue};  


 





const TInt KMdaResourceSizeUnknown = KMdaUnknown;

 



const TInt KMdaRepeatForever = -2;

 

 





enum
	{
	EMLbResourceHandleConfig=EMLbPortNegotiate+1
	};

 





enum
	{
	EMLbResourceObjectConfig=0,
	EMLbResourceObjectCreatePort=1
	};

 





enum
	{
	EMLbClipFunctionBase=EMLbResourceObjectCreatePort,
	EMLbClipLocRead,
	EMLbClipLocWrite
	};

 





enum
	{
	EMdaResourceEventIdConfigComplete,
	EMdaResourceEventIdConfigFailed,
	EMdaResourceEventIdSizeChanged,
	EMdaResourceEventIdDataChanged
	};

 

 





class TMdaResourceQuery : public TMdaPackage
	{
public:
	TMdaResourceQuery(TUid aType);
	};

 













class TMdaClipLocation : public TMdaPackage
	{
protected:
	inline TMdaClipLocation(TUid aUid, TInt aDerivedSize);
public:

	 


	TInt iSize;  

	 



	TInt iVisible;  
	};

 










class TMdaClipFormat : public TMdaPackage
	{
public:
	inline TMdaClipFormat();
protected:
	inline TMdaClipFormat(TUid aUid, TInt aDerivedSize);
	};

 





class TMdaClipFormatQuery : public TMdaClipFormat
	{
public:
	inline TMdaClipFormatQuery(TUid aUid, TInt aAdditionalSize);
	};

 





class TMdaStreamDevice : public TMdaPackage
	{
protected:
	inline TMdaStreamDevice(TUid aUid, TInt aDerivedSize);
	};

 

 







class TMdaFileClipLocation : public TMdaClipLocation
	{
public:
	inline TMdaFileClipLocation();
	inline TMdaFileClipLocation(const TDesC& aName);
public:
	 


	TBuf<256> iName;
	};

 







class TMdaDesClipLocation : public TMdaClipLocation
	{
public:
	inline TMdaDesClipLocation();
	inline TMdaDesClipLocation(TDes8& aWriteableDes);
	inline TMdaDesClipLocation(const TDesC8& aReadOnlyDes);
public:
	 


	TThreadId iThreadId;
	 


	TDesC8* iDes;
	};

 





class TMdaUrlClipLocation : public TMdaClipLocation
	{
public:
	inline TMdaUrlClipLocation();
	inline TMdaUrlClipLocation(const TDesC& aUrl, TInt aIapId, const TDesC8& aMimeType = KNullDesC8);
public:
	TBuf<256> iUrl;
	TBuf8<256> iMimeType;
	TInt iIapId;
	};


 

inline TMdaResourceQuery::TMdaResourceQuery(TUid aType) :
TMdaPackage(aType,TUid::Null() ,sizeof(TMdaResourceQuery)) {}
	
 








inline TMdaClipLocation::TMdaClipLocation(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaClipLocation,aUid,aDerivedSize) {}

 


inline TMdaClipFormat::TMdaClipFormat(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaClipFormat,aUid,aDerivedSize) {}

inline TMdaClipFormatQuery::TMdaClipFormatQuery(TUid aUid, TInt aAdditionalSize) :
TMdaClipFormat(aUid,sizeof(TMdaClipFormat)+aAdditionalSize) {}
	
inline TMdaClipFormat::TMdaClipFormat() : 
TMdaPackage(KUidMdaClipFormat,TUid::Null() ,sizeof(TMdaClipFormat)) {}

inline TMdaStreamDevice::TMdaStreamDevice(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaStreamDevice,aUid,aDerivedSize) {}

 


inline TMdaFileClipLocation::TMdaFileClipLocation() :
TMdaClipLocation(KUidMdaFileResLoc,sizeof(TMdaFileClipLocation)) {}

 





inline TMdaFileClipLocation::TMdaFileClipLocation(const TDesC& aName) :
TMdaClipLocation(KUidMdaFileResLoc,sizeof(TMdaFileClipLocation)),
iName(aName) {}

inline TMdaUrlClipLocation::TMdaUrlClipLocation() :
TMdaClipLocation(KUidMdaUrlResLoc,sizeof(TMdaUrlClipLocation)) {}

inline TMdaUrlClipLocation::TMdaUrlClipLocation(const TDesC& aUrl, TInt aIapId, const TDesC8& aMimeType) :
TMdaClipLocation(KUidMdaUrlResLoc,sizeof(TMdaUrlClipLocation)),
iUrl(aUrl),iMimeType(aMimeType), iIapId(aIapId) {}


 



inline TMdaDesClipLocation::TMdaDesClipLocation() :
TMdaClipLocation(KUidMdaDesResLoc,sizeof(TMdaDesClipLocation)),
iThreadId(RThread().Id()) {}

 





inline TMdaDesClipLocation::TMdaDesClipLocation(const TDesC8& aReadOnlyDes) :
TMdaClipLocation(KUidMdaDesResLoc,sizeof(TMdaDesClipLocation)),
iThreadId(RThread().Id()),
iDes(&(TDesC8&)aReadOnlyDes) {}

 





inline TMdaDesClipLocation::TMdaDesClipLocation(TDes8& aWriteableDes) :
TMdaClipLocation(KUidMdaDesResLoc,sizeof(TMdaDesClipLocation)),
iThreadId(RThread().Id()),
iDes(&aWriteableDes) {}


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2

 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.hrh" 1
 
 
 






 
 








































































# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audiostream.hrh" 1
 
 
 
 




 
 
 






# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/common/audio.h" 2


const TUint  KUidMdaPrioritySettingsValue =  268457514 ; const TUid  KUidMdaPrioritySettings  = { KUidMdaPrioritySettingsValue}; 
const TUint  KUidMdaMediaTypeAudioValue =  268450136 ; const TUid  KUidMdaMediaTypeAudio  = { KUidMdaMediaTypeAudioValue};   
const TUint  KUidMdaLocalSoundDeviceValue =  268450137 ; const TUid  KUidMdaLocalSoundDevice  = { KUidMdaLocalSoundDeviceValue};   
const TUint  KUidMdaClipLocationMaxWriteLengthValue =  268457517 ; const TUid  KUidMdaClipLocationMaxWriteLength  = { KUidMdaClipLocationMaxWriteLengthValue}; 
const TUint  KUidMdaTelephonySoundDeviceValue =  268450187 ; const TUid  KUidMdaTelephonySoundDevice  = { KUidMdaTelephonySoundDeviceValue};   
const TUint  KUidMdaClientPCMSoundDeviceValue =  268450188 ; const TUid  KUidMdaClientPCMSoundDevice  = { KUidMdaClientPCMSoundDeviceValue};   
const TUint  KUidMdaToneGeneratorDeviceValue =  268457494 ; const TUid  KUidMdaToneGeneratorDevice  = { KUidMdaToneGeneratorDeviceValue};   
const TUint  KUidMdaClipFormatWavValue =  268450138 ; const TUid  KUidMdaClipFormatWav  = { KUidMdaClipFormatWavValue};   

const TUint  KUidMdaAudioOutputStreamDeviceValue =  268457516 ; const TUid  KUidMdaAudioOutputStreamDevice  = { KUidMdaAudioOutputStreamDeviceValue};   

const TUint  KUidMdaWavCodecValue =  268450146 ; const TUid  KUidMdaWavCodec  = { KUidMdaWavCodecValue};   
const TUint  KUidMdaWavPcmCodecValue =  268450147 ; const TUid  KUidMdaWavPcmCodec  = { KUidMdaWavPcmCodecValue};   
const TUint  KUidMdaWavAlawCodecValue =  268450148 ; const TUid  KUidMdaWavAlawCodec  = { KUidMdaWavAlawCodecValue};  
const TUint  KUidMdaWavMulawCodecValue =  268450149 ; const TUid  KUidMdaWavMulawCodec  = { KUidMdaWavMulawCodecValue};  
const TUint  KUidMdaWavImaAdpcmCodecValue =  268450150 ; const TUid  KUidMdaWavImaAdpcmCodec  = { KUidMdaWavImaAdpcmCodecValue};  


const TUint  KUidMdaClipFormatAuValue =  268450141 ; const TUid  KUidMdaClipFormatAu  = { KUidMdaClipFormatAuValue};   
const TUint  KUidMdaAuCodecValue =  268450151 ; const TUid  KUidMdaAuCodec  = { KUidMdaAuCodecValue};   
const TUint  KUidMdaAuMulawCodecValue =  268450152 ; const TUid  KUidMdaAuMulawCodec  = { KUidMdaAuMulawCodecValue};   
const TUint  KUidMdaAu8PcmCodecValue =  268450153 ; const TUid  KUidMdaAu8PcmCodec  = { KUidMdaAu8PcmCodecValue};   
const TUint  KUidMdaAu16PcmCodecValue =  268450154 ; const TUid  KUidMdaAu16PcmCodec  = { KUidMdaAu16PcmCodecValue};  
const TUint  KUidMdaAuAlawCodecValue =  268450155 ; const TUid  KUidMdaAuAlawCodec  = { KUidMdaAuAlawCodecValue}; 

const TUint  KUidMdaClipFormatRawAudioValue =  268450142 ; const TUid  KUidMdaClipFormatRawAudio  = { KUidMdaClipFormatRawAudioValue};   
const TUint  KUidMdaRawAudioCodecValue =  268450156 ; const TUid  KUidMdaRawAudioCodec  = { KUidMdaRawAudioCodecValue};   
const TUint  KUidMdaRawAudioMulawCodecValue =  268450157 ; const TUid  KUidMdaRawAudioMulawCodec  = { KUidMdaRawAudioMulawCodecValue}; 
const TUint  KUidMdaRawAudioAlawCodecValue =  268450158 ; const TUid  KUidMdaRawAudioAlawCodec  = { KUidMdaRawAudioAlawCodecValue};  
const TUint  KUidMdaRawAudioS8PcmCodecValue =  268450159 ; const TUid  KUidMdaRawAudioS8PcmCodec  = { KUidMdaRawAudioS8PcmCodecValue};   
const TUint  KUidMdaRawAudioU8PcmCodecValue =  268450160 ; const TUid  KUidMdaRawAudioU8PcmCodec  = { KUidMdaRawAudioU8PcmCodecValue};   
const TUint  KUidMdaRawAudioSL16PcmCodecValue =  268450161 ; const TUid  KUidMdaRawAudioSL16PcmCodec  = { KUidMdaRawAudioSL16PcmCodecValue};   
const TUint  KUidMdaRawAudioSB16PcmCodecValue =  268450162 ; const TUid  KUidMdaRawAudioSB16PcmCodec  = { KUidMdaRawAudioSB16PcmCodecValue};   
const TUint  KUidMdaRawAudioUL16PcmCodecValue =  268450163 ; const TUid  KUidMdaRawAudioUL16PcmCodec  = { KUidMdaRawAudioUL16PcmCodecValue};   
const TUint  KUidMdaRawAudioUB16PcmCodecValue =  268450164 ; const TUid  KUidMdaRawAudioUB16PcmCodec  = { KUidMdaRawAudioUB16PcmCodecValue};   

const TUint  KUidMdaTelephonyStateQueryValue =  268450205 ; const TUid  KUidMdaTelephonyStateQuery  = { KUidMdaTelephonyStateQueryValue};   
const TUint  KUidMdaAudioStreamVolumeRampValue =  268457498 ; const TUid  KUidMdaAudioStreamVolumeRamp  = { KUidMdaAudioStreamVolumeRampValue};   

const TUint  KUidMdaDataTypeSettingsValue =  268450121 ; const TUid  KUidMdaDataTypeSettings  = { KUidMdaDataTypeSettingsValue}; 

const TUint  KUidMdaClipFormatRawAmrValue =  268437992 ; const TUid  KUidMdaClipFormatRawAmr  = { KUidMdaClipFormatRawAmrValue};   
const TUint  KUidMdaRawAmrCodecValue =  268437991 ; const TUid  KUidMdaRawAmrCodec  = { KUidMdaRawAmrCodecValue};   

 


const TInt KMdaClipLocationMaxWriteLengthNone = -1;

 




enum TMdaAudioBufferSettings
	{
	 
	 

	EMdaAudioBufferAtPlay =		0x0000000,
	 

	EMdaAudioBufferAtPrime =	0x0000001,
	 

	EMdaAudioBufferDouble =		0x0000002,
	 

	EMdaAudioBufferSupply =		0x0000004
	};

 

 





class TMdaPrioritySettings : public TMdaPackage
	{
public:
	inline TMdaPrioritySettings();
public:
	 






	TInt iPriority;
	 














	TMdaPriorityPreference iPref;
	};

 





class TMdaClipLocationMaxWriteLength : public TMdaPackage
 	{
public:
 	inline TMdaClipLocationMaxWriteLength ();
public:
 	TInt iLength;
	};


 







class TMdaDatatypeSettings : public TMdaPackage
	{
protected:
	inline TMdaDatatypeSettings(TUid aUid,TInt aDerivedSize);
	};

inline TMdaDatatypeSettings::TMdaDatatypeSettings(TUid aUid,TInt aDerivedSize) :
TMdaPackage(KUidMdaDataTypeSettings,aUid,aDerivedSize) {}

 















class TMdaAudioDataSettings : public TMdaDatatypeSettings
	{
public:
	 



	enum TAudioCaps
		{

		 

		 


		ESampleRateFixed =		0x00000001,

		 

		ESampleRateAnyInRange = 0x00000002,

		 

		ESampleRate8000Hz =		0x00000010,

		 

		ESampleRate11025Hz =	0x00000040,

		 

		ESampleRate12000Hz =	0x00000080,

		 

		ESampleRate16000Hz =	0x00000100,

		 

		ESampleRate22050Hz =	0x00000400,

		 

		ESampleRate24000Hz =	0x00000800,

		 

		ESampleRate32000Hz =	0x00001000,

		 

		ESampleRate44100Hz =	0x00004000,

		 

		ESampleRate48000Hz =	0x00010000,

		 

		ESampleRate96000Hz =	0x00020000,

		 

		ESampleRate64000Hz =	0x00040000,

		 

		 

		EChannelsMono =			0x02000000,

		 

		EChannelsStereo =		0x04000000,

		 

		ERoutingControl =		0x08000000,

		 

		ERealTime =				0x10000000
		};

	 


	enum TAudioFlags
		{

		 

		ENoLocalRouting =		0x00000001,

		 

		ENoNetworkRouting =		0x00000002
		};
public:
	inline TMdaAudioDataSettings();
	inline void Query();  
public:
	 

	 



	TInt iCaps;

	 


	TInt iMaxVolume;  

	 
	 


	TInt iSampleRate;

	 


	TInt iChannels;

	 


	TInt iVolume;

	 


	TInt iFlags;
	};

 

 







class TMdaWavClipFormat : public TMdaClipFormat
	{
public:
	inline TMdaWavClipFormat();
	};

 









class TMdaWavCodec : public TMdaPackage
	{
public:
	inline TMdaWavCodec();  
protected:
	inline TMdaWavCodec(TUid aUid,TInt aDerivedSize);
	};

 





class TMdaCodecQuery : public TMdaPackage
	{
public:
	inline TMdaCodecQuery(TUid aType, TUid aUid,TInt aAdditionalSize);
	};

 







class TMdaPcmWavCodec : public TMdaWavCodec
	{
public:

	 


	enum TBits
		{
   		 

		E8BitPcm=0,

   		 

		E16BitPcm=1
		};
public:
	inline TMdaPcmWavCodec(TBits aBits=E16BitPcm);
public:
	 


	TBits iBits;
	};

 





class TMdaAlawWavCodec : public TMdaWavCodec
	{
public:
	inline TMdaAlawWavCodec();
	};

 





class TMdaMulawWavCodec : public TMdaWavCodec
	{
public:
	inline TMdaMulawWavCodec();
	};

 





class TMdaImaAdpcmWavCodec : public TMdaWavCodec
	{
public:
	inline TMdaImaAdpcmWavCodec();
	};


 
 







class TMdaAuClipFormat : public TMdaClipFormat
	{
public:
	inline TMdaAuClipFormat();
	};

 









class TMdaAuCodec : public TMdaPackage
	{
public:
	inline TMdaAuCodec();  
protected:
	inline TMdaAuCodec(TUid aUid,TInt aDerivedSize);
	};

 





class TMdaPcm8BitAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaPcm8BitAuCodec();
	};

 





class TMdaPcm16BitAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaPcm16BitAuCodec();
	};

 





class TMdaAlawAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaAlawAuCodec();
	};

 





class TMdaMulawAuCodec : public TMdaAuCodec
	{
public:
	inline TMdaMulawAuCodec();
	};

 
 







class TMdaRawAudioClipFormat : public TMdaClipFormat
	{
public:
	inline TMdaRawAudioClipFormat();
	};

 















class TMdaRawAudioCodec : public TMdaPackage
	{
public:
	inline TMdaRawAudioCodec();  
protected:
	inline TMdaRawAudioCodec(TUid aUid,TInt aDerivedSize);
	};

 





class TMdaMulawRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaMulawRawAudioCodec();
	};

 





class TMdaAlawRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaAlawRawAudioCodec();
	};

 





class TMdaS8PcmRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaS8PcmRawAudioCodec();
	};

 





class TMdaU8PcmRawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaU8PcmRawAudioCodec();
	};

 





class TMdaSL16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaSL16RawAudioCodec();
	};

 





class TMdaSB16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaSB16RawAudioCodec();
	};

 





class TMdaUL16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaUL16RawAudioCodec();
	};

 





class TMdaUB16RawAudioCodec : public TMdaRawAudioCodec
	{
public:
	inline TMdaUB16RawAudioCodec();
	};

 







class TMdaLocalAudioDevice : public TMdaStreamDevice
	{
public:
	inline TMdaLocalAudioDevice();
	};

 







class TMdaTelephonyAudioDevice : public TMdaStreamDevice
	{
public:
	inline TMdaTelephonyAudioDevice();
	};

 






class TMdaTelephonyStateQuery : public TMdaPackage
	{
public:
	inline TMdaTelephonyStateQuery();
public:
	TBool iIsTelephonyActive;
	};

 






class TMdaClientPCMAudioDevice : public TMdaStreamDevice
	{
public:
	inline TMdaClientPCMAudioDevice();
	};


 





class TMdaAudioStreamVolumeRamp : public TMdaPackage
	{
public:
	inline TMdaAudioStreamVolumeRamp();
public:
	TTimeIntervalMicroSeconds iDuration;
	};

 





enum TMdaToneGeneratorFunction
	{
	EMdaToneGeneratorConfig=0,
	EMdaToneGeneratorGetFixedNames=1,
	EMdaToneGeneratorPlay=2
	};

 





enum TMdaToneType  
	{
	EMdaToneTypeSimple,
	EMdaToneTypeDTMF,
	EMdaToneTypeDesSeq,
	EMdaToneTypeFileSeq,
	EMdaToneTypeFixedSeq
	};

 





class TMdaToneGeneratorConfig : public TMdaReturnPackage
	{
public:
	inline TMdaToneGeneratorConfig();
	inline void SetReturnSize(TInt aReturnSize);
public:
	enum TMask
		{
		EPrepare		= 0x1,
		EVolumeChange	= 0x2,
		EPriorityChange = 0x4,
		EDTMFLengths    = 0x8,
		ESetRepeat		= 0x10,
		EVolumeRamp		= 0x20
		};
public:
	TUint32 iMask;
	TInt iVolume;
	TInt iMaxVolume;
	TInt iPriority;
	TMdaPriorityPreference iPref;
	TTimeIntervalMicroSeconds32 iDtmfToneOnLength;
	TTimeIntervalMicroSeconds32 iDtmfToneOffLength;
	TTimeIntervalMicroSeconds32 iDtmfPauseLength;
	TMdaToneType iType;
	TInt iFrequency;
	TTimeIntervalMicroSeconds iDuration;
	const TDesC8* iDes;
	TInt iDesLength;
	TInt iFixedSequenceNumber;
	TTimeIntervalMicroSeconds iRepeatTrailingSilence;
	TInt iRepeatCount;
	TTimeIntervalMicroSeconds iRampDuration;
	};

enum TMdaAudioOutputFunction
	{
	EMdaAudioOutputPrepare=0,
	EMdaAudioOutputConfig=1,
	EMdaAudioOutputWrite=2,
	EMdaAudioOutputStop=3,
	EMdaAudioOutputPlay=4
	};

 





class TMdaAudioOutputConfig : public TMdaReturnPackage
	{
public:
	inline TMdaAudioOutputConfig();
	inline void SetReturnSize(TInt aReturnSize);
public:
	enum TMask
		{
		ENull = 0x0,
		EQuery	= 0x1,
		EVolumeChange		= 0x2,
		EPriorityChange		= 0x4,
		EChannelsChange		= 0x8,
		ESampleRateChange	= 0x10
		};
public:
	TUint32 iMask;
	TInt						iPriority;
	TTimeIntervalMicroSeconds	iPosition;
	TInt						iMaxVolume;
	TInt						iVolume;
	TInt						iNumChannels;
	TInt						iSampleRate;
	TMdaPriorityPreference		iPref;
	};

 





class TMdaToneFixedSequenceNames : public TMdaRawPackage
	{
public:
	inline TMdaToneFixedSequenceNames();
public:
	TInt iCount;
	};

 

 


inline TMdaAudioDataSettings::TMdaAudioDataSettings() :
TMdaDatatypeSettings(KUidMdaMediaTypeAudio,sizeof(TMdaAudioDataSettings)) 
	{
	Mem::FillZ(&iSampleRate,sizeof(TInt)*4);
	}

 



inline void TMdaAudioDataSettings::Query()
	{
	iChannels = KMdaUnknown;
	iSampleRate = KMdaUnknown;
	iVolume = KMdaUnknown;
	} 

 


inline TMdaWavClipFormat::TMdaWavClipFormat() :
TMdaClipFormat(KUidMdaClipFormatWav,sizeof(TMdaWavClipFormat)) {}

 


inline TMdaWavCodec::TMdaWavCodec() :
TMdaPackage(KUidMdaWavCodec,TUid::Null() ,sizeof(TMdaWavCodec)) {}

inline TMdaCodecQuery::TMdaCodecQuery(TUid aType, TUid aUid,TInt aAdditionalSize) :
TMdaPackage(aType,aUid,sizeof(TMdaCodecQuery)+aAdditionalSize) {}

inline TMdaWavCodec::TMdaWavCodec(TUid aUid, TInt aDerivedSize) :
TMdaPackage(KUidMdaWavCodec,aUid,aDerivedSize) {}

 





inline TMdaPcmWavCodec::TMdaPcmWavCodec(TBits aBits) :
TMdaWavCodec(KUidMdaWavPcmCodec,sizeof(TMdaPcmWavCodec)), iBits(aBits) {}

 


inline TMdaAlawWavCodec::TMdaAlawWavCodec() :
TMdaWavCodec(KUidMdaWavAlawCodec,sizeof(TMdaAlawWavCodec)) {}

 


inline TMdaMulawWavCodec::TMdaMulawWavCodec() :
TMdaWavCodec(KUidMdaWavMulawCodec,sizeof(TMdaMulawWavCodec)) {}

 


inline TMdaImaAdpcmWavCodec::TMdaImaAdpcmWavCodec() :
TMdaWavCodec(KUidMdaWavImaAdpcmCodec,sizeof(TMdaImaAdpcmWavCodec)) {}

 


inline TMdaAuClipFormat::TMdaAuClipFormat() :
TMdaClipFormat(KUidMdaClipFormatAu,sizeof(TMdaAuClipFormat)) {}

 


inline TMdaAuCodec::TMdaAuCodec() :
TMdaPackage(KUidMdaAuCodec,TUid::Null() ,sizeof(TMdaAuCodec)) {}

inline TMdaAuCodec::TMdaAuCodec(TUid aUid,TInt aDerivedSize) :
TMdaPackage(KUidMdaAuCodec,aUid,aDerivedSize) {}

 


inline TMdaPcm16BitAuCodec::TMdaPcm16BitAuCodec() :
TMdaAuCodec(KUidMdaAu16PcmCodec,sizeof(TMdaPcm16BitAuCodec)) {}

 


inline TMdaPcm8BitAuCodec::TMdaPcm8BitAuCodec() :
TMdaAuCodec(KUidMdaAu8PcmCodec,sizeof(TMdaPcm8BitAuCodec)) {}

 


inline TMdaAlawAuCodec::TMdaAlawAuCodec() :
TMdaAuCodec(KUidMdaAuAlawCodec,sizeof(TMdaAlawAuCodec)) {}

 


inline TMdaMulawAuCodec::TMdaMulawAuCodec() :
TMdaAuCodec(KUidMdaAuMulawCodec,sizeof(TMdaMulawAuCodec)) {}

 


inline TMdaRawAudioClipFormat::TMdaRawAudioClipFormat() :
TMdaClipFormat(KUidMdaClipFormatRawAudio,sizeof(TMdaRawAudioClipFormat)) {}

 


inline TMdaRawAudioCodec::TMdaRawAudioCodec() :
TMdaPackage(KUidMdaRawAudioCodec,TUid::Null() ,sizeof(TMdaRawAudioCodec)) {}

inline TMdaRawAudioCodec::TMdaRawAudioCodec(TUid aUid,TInt aDerivedSize) :
TMdaPackage(KUidMdaRawAudioCodec,aUid,aDerivedSize) {}

 


inline TMdaMulawRawAudioCodec::TMdaMulawRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioMulawCodec,sizeof(TMdaMulawRawAudioCodec)) {}

 


inline TMdaAlawRawAudioCodec::TMdaAlawRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioAlawCodec,sizeof(TMdaAlawRawAudioCodec)) {}

 


inline TMdaS8PcmRawAudioCodec::TMdaS8PcmRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioS8PcmCodec,sizeof(TMdaS8PcmRawAudioCodec)) {}

 


inline TMdaU8PcmRawAudioCodec::TMdaU8PcmRawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioU8PcmCodec,sizeof(TMdaU8PcmRawAudioCodec)) {}

 


inline TMdaSL16RawAudioCodec::TMdaSL16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioSL16PcmCodec,sizeof(TMdaSL16RawAudioCodec)) {}

 


inline TMdaSB16RawAudioCodec::TMdaSB16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioSB16PcmCodec,sizeof(TMdaSB16RawAudioCodec)) {}

 


inline TMdaUL16RawAudioCodec::TMdaUL16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioUL16PcmCodec,sizeof(TMdaUL16RawAudioCodec)) {}

 


inline TMdaUB16RawAudioCodec::TMdaUB16RawAudioCodec() :
TMdaRawAudioCodec(KUidMdaRawAudioUB16PcmCodec,sizeof(TMdaUB16RawAudioCodec)) {}

inline TMdaLocalAudioDevice::TMdaLocalAudioDevice() : 
TMdaStreamDevice(KUidMdaLocalSoundDevice,sizeof(TMdaLocalAudioDevice)) {}

inline TMdaTelephonyAudioDevice::TMdaTelephonyAudioDevice() : 
TMdaStreamDevice(KUidMdaTelephonySoundDevice,sizeof(TMdaTelephonyAudioDevice)) {}

inline TMdaClientPCMAudioDevice::TMdaClientPCMAudioDevice() : 
TMdaStreamDevice(KUidMdaClientPCMSoundDevice,sizeof(TMdaClientPCMAudioDevice)) {}

inline TMdaAudioStreamVolumeRamp::TMdaAudioStreamVolumeRamp() :
TMdaPackage(KUidMdaAudioStreamVolumeRamp,KUidMdaAudioStreamVolumeRamp,sizeof(TMdaAudioStreamVolumeRamp)) {}

inline TMdaTelephonyStateQuery::TMdaTelephonyStateQuery() :
TMdaPackage(KUidMdaTelephonySoundDevice,KUidMdaTelephonyStateQuery,sizeof(TMdaTelephonyStateQuery)) {}
 
inline TMdaToneGeneratorConfig::TMdaToneGeneratorConfig() :
TMdaReturnPackage(KUidMdaToneGeneratorDevice,KUidMdaToneGeneratorDevice,sizeof(TMdaToneGeneratorConfig)) {}

inline void TMdaToneGeneratorConfig::SetReturnSize(TInt aReturnSize)
	{ TMdaReturnPackage::SetReturnSize(aReturnSize); }

inline TMdaAudioOutputConfig::TMdaAudioOutputConfig() : 
TMdaReturnPackage(KUidMdaAudioOutputStreamDevice,KUidMdaAudioOutputStreamDevice,sizeof(TMdaAudioOutputConfig)) {}

inline void TMdaAudioOutputConfig::SetReturnSize(TInt aReturnSize)
	{ TMdaReturnPackage::SetReturnSize(aReturnSize); }


inline TMdaToneFixedSequenceNames::TMdaToneFixedSequenceNames() :
TMdaRawPackage(sizeof(TMdaToneFixedSequenceNames)) {}


inline TMdaPrioritySettings::TMdaPrioritySettings() :
TMdaPackage(KUidMdaPrioritySettings,KUidMdaPrioritySettings,sizeof(TMdaPrioritySettings)) {}

inline TMdaClipLocationMaxWriteLength::TMdaClipLocationMaxWriteLength() :
 TMdaPackage(KUidMdaClipLocationMaxWriteLength,KUidMdaClipLocationMaxWriteLength,sizeof(TMdaClipLocationMaxWriteLength)) {}


# 73 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mdaaudiooutputstream.h" 1
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 1
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasourcesink.hrh" 1
 
 
 





 
 

const TUid KUidMmfDataPath		= {0x101F5D06}; 
const TUid KUidMmfFormatDecode	= {0x101F5D04}; 
const TUid KUidMmfFormatEncode	= {0x101F5D05};
const TUid KUidMmfAudioOutput	= {0x101F53B9};  
const TUid KUidMmfAudioInput	= {0x101F53BB}; 

 
const TUint KMmfUidFileSource		= 0x101F53B1;
const TUint KMmfUidFileSink			= 0x101F53B3;
const TUint KMmfUidDescriptorSource = 0x101F53B2;
const TUint KMmfUidDescriptorSink	= 0x101F53B4; 
const TUint KMmfUidUrlSource		= 0x101F6068;
const TUint KMmfUidUrlSink		= 0x101F6069;

const TUid KUidMmfFileSource		= {KMmfUidFileSource}; 
const TUid KUidMmfFileSink			= {KMmfUidFileSink}; 
const TUid KUidMmfDescriptorSource	= {KMmfUidDescriptorSource};
const TUid KUidMmfDescriptorSink	= {KMmfUidDescriptorSink}; 
const TUid KUidMmfUrlSource		= {KMmfUidUrlSource};
const TUid KUidMmfUrlSink		= {KMmfUidUrlSink};

 
static const TUid KUidMediaTypeAudio	= {0x101F5D07};
static const TUid KUidMediaTypeVideo	= {0x101F5D08};
static const TUid KUidMediaTypeMidi	= {0x101F7D02};




# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatabuffer.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/e32transbuf.h" 1
 
 
 
 
 











enum TTransferBufferType
	{
	ETransferBufferFixedContiguous,
	ETransferBufferContiguous,
	ETransferBufferNonContiguous
	};

class RTransferWindow;

 





class RTransferBuffer : public RHandleBase
	{
	public:
		  TInt Create(TInt aBufferSize);
		  TInt GetBufferSize() const;
	};

 





class RTransferWindow : public RHandleBase
	{
	public:
		  TInt Create(TInt aMaxBufferSize);
		  TInt Open(RTransferBuffer& aBuffer);
		  TInt MapInBuffer(const RTransferBuffer& aBuffer) const;
		  void WaitForBuffer() const;
		  void WaitForBuffer(TRequestStatus& aStatus) const;
		  void CancelWaitForBuffer() const;
		  void MapOutBuffer() const;
		  void WaitForBufferFree() const;
		  void WaitForBufferFree(TRequestStatus& aStatus) const;
		  void CancelWaitForBufferFree() const;
		  TUint8* GetBufferAddress() const;
		  TInt GetBufferSize() const;
	};



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatabuffer.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfbuffer.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfbuffer.hrh" 1
 
 
 




static const TUid KUidMmfDataBuffer			= {0x101F5D09}; 
static const TUid KUidMmfDescriptorBuffer 		= {0x101F5D09};
static const TUid KUidMmfTransferBuffer			= {0x101F5E66};
static const TUid KUidMmfAudioBuffer			= {0x101F72A9};
static const TUid KUidMmfYUVBuffer			= {0x101F5D0A};
static const TUid KUidMmfBitmapFrameBuffer		= {0x101F5D0B};
static const TUid KUidMmfPtrBuffer			= {0x101FD90B};




# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfbuffer.h" 2



 





enum TBufferStatus
	{
	 
	EAvailable,

	 
	EBeingFilled,

	 
	EFull,

	 
	EBeingEmptied,

	 
	EUnAvailable
	};


 





class CMMFBuffer : public CBase
	{
public:
	  static TBool IsSupportedDataBuffer(TUid aUid);
	  static TBool IsFileServerSafe(TUid aUid);
	 




	TUid Type() const {return iType;};
	 





	virtual void SetStatus(TBufferStatus aStatus) 
			{iStatus = aStatus; if (iStatus == EAvailable) iPosition = 0;}
	 




	TBufferStatus Status() {return iStatus;};

	 






	virtual TUint BufferSize() const = 0;

	 


	virtual ~CMMFBuffer() {};
	inline TTimeIntervalMicroSeconds TimeToPlay() const;
	inline void SetTimeToPlay (TTimeIntervalMicroSeconds aTime);
	inline TUint FrameNumber() const;
	inline void SetFrameNumber(TUint aFrame);
	inline void NextFrame();
	inline virtual void SetPosition (TUint aPosition);
	inline virtual TUint Position() const;
	inline virtual TInt RequestSize() const;
	inline void SetLastBuffer(TBool aLastBuffer);
	inline TBool LastBuffer() const;
protected:
	CMMFBuffer(TUid aType): iType(aType), iStatus(EAvailable) {};	

protected:
	 


	TUid iType;

	 




	TBufferStatus iStatus;

	 


	TTimeIntervalMicroSeconds iTimeToPlay;

	 



	TUint iPosition;

	 


	TUint iFrameNumber;

	 


	TInt iRequestSize;

	 


	TBool iLastBuffer; 
	};

 




inline TTimeIntervalMicroSeconds CMMFBuffer::TimeToPlay() const
	{
	return iTimeToPlay;
	}

 





inline void CMMFBuffer::SetTimeToPlay (TTimeIntervalMicroSeconds aTime)
	{
	iTimeToPlay = aTime;
	}

 




inline TUint CMMFBuffer::FrameNumber() const
	{
	return iFrameNumber;
	}

 





inline void CMMFBuffer::SetFrameNumber (TUint aFrameNumber)
	{
	iFrameNumber = aFrameNumber;
	}

 


inline void CMMFBuffer::NextFrame()
	{
	iFrameNumber++;
	}


 







inline void CMMFBuffer::SetPosition (TUint aPosition)
	{
	iPosition = aPosition;
	}

 






inline TUint CMMFBuffer::Position() const
	{
	return iPosition;
	}

 





inline TBool CMMFBuffer::LastBuffer() const
	{
	return iLastBuffer;
	}

 






inline void CMMFBuffer::SetLastBuffer(TBool aLastBuffer)
	{
	iLastBuffer = aLastBuffer;
	}

 




inline TInt CMMFBuffer::RequestSize() const
	{
	return iRequestSize;
	}


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatabuffer.h" 2


 





static const TInt KMMFDataBufferDefaultBufferSize = 32;

 








class CMMFDataBuffer : public CMMFBuffer
	{
public:
	  static CMMFDataBuffer* NewL();
	  static CMMFDataBuffer* NewL(TInt aMaxBufferSize);
	 


	virtual ~CMMFDataBuffer() {};

	 






	virtual TDes8& Data() = 0;

	 






	virtual const TDesC8& Data() const = 0;

	 






	virtual TUint BufferSize() const = 0;

	 











	virtual void SetRequestSizeL(TInt aSize) = 0;
protected:
	 


	CMMFDataBuffer(TUid aType): CMMFBuffer(aType) {};
	};


 









class CMMFDescriptorBuffer : public CMMFDataBuffer
	{
public:
	  static CMMFDescriptorBuffer* NewL();
	  static CMMFDescriptorBuffer* NewL(TInt aMaxBufferSize);
	  ~CMMFDescriptorBuffer();
	  void ReAllocBufferL(TInt aMaxBufferSize);
	virtual TDes8& Data();
	virtual const TDesC8& Data() const;
	virtual void SetStatus(TBufferStatus aStatus);
	virtual void SetRequestSizeL(TInt aSize);
	virtual TUint BufferSize() const;
	virtual void SetPosition (TUint aPosition);
private:
	CMMFDescriptorBuffer() : CMMFDataBuffer(KUidMmfDescriptorBuffer), iPtr(0,0,0) {};
	void ConstructL(TInt aMaxBufferSize);
private:
	TUint8* iData;
	TPtr8 iPtr;
	};


 













class CMMFTransferBuffer : public CMMFDataBuffer
	{
public:
	  static CMMFTransferBuffer* NewL(RTransferWindow& aTransferWindow, TUint aDataLength = 0);
	  ~CMMFTransferBuffer();
	virtual TDes8& Data();
	virtual const TDesC8& Data() const;
	virtual TUint BufferSize() const;
	virtual void SetRequestSizeL(TInt aSize);
	virtual void SetPosition (TUint aPosition);
	  RTransferWindow& TransferWindow();
	  void MapOutBuffer();
	  TInt UpdateTransferWindow(RTransferWindow& aTransferWindow, TUint aDataLength = 0);
private:
	 


	CMMFTransferBuffer() : CMMFDataBuffer(KUidMmfTransferBuffer), iPtr(0,0,0){};
	void ConstructL(RTransferWindow& aTransferWindow, TUint aDataLength);
private:
	RTransferWindow iTransferWindow;
	TBool iTransferWindowMappedInOK;
	TPtr8 iPtr;
	};

 











class CMMFPtrBuffer : public CMMFDataBuffer
	{
public:
	  static CMMFPtrBuffer* NewL();		 
	  static CMMFPtrBuffer* NewL(const TPtr8& aPtr);
	  ~CMMFPtrBuffer();
	  void SetPtr(const TPtr8& aPtr);
	virtual TDes8& Data();
	virtual const TDesC8& Data() const;
	virtual void SetStatus(TBufferStatus aStatus);	
	virtual void SetRequestSizeL(TInt aSize);
	virtual TUint BufferSize() const;
	virtual void SetPosition (TUint aPosition);
private:
	CMMFPtrBuffer() : CMMFDataBuffer(KUidMmfPtrBuffer), iPtr(0,0,0) {};
	void ConstructL(const TPtr8& aPtr);
private:
	TPtr8 iPtr;
	};


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmffourcc.h" 1
 





 
 
 
 




 

 

const TUint32 KMMFFourCCCodePCM8 = 0x38502020;		 

 

const TUint32 KMMFFourCCCodePCMU8 = 0x38555020;		 

 

const TUint32 KMMFFourCCCodePCM16 = 0x36315020;		 

 

const TUint32 KMMFFourCCCodePCMU16 = 0x36315550;	 

 

const TUint32 KMMFFourCCCodePCM16B = 0x42363150;	 

 

const TUint32 KMMFFourCCCodePCMU16B = 0x42365550;	 

 

const TUint32 KMMFFourCCCodeIMAD = 0x44414d49;		 

 

const TUint32 KMMFFourCCCodeIMAS = 0x53414d49;		 

 

const TUint32 KMMFFourCCCodeALAW = 0x57414c41;		 

 

const TUint32 KMMFFourCCCodeMuLAW = 0x57414c75;		 

 

const TUint32 KMMFFourCCCodeGSM610 = 0x364d5347;	 

 

const TUint32 KMMFFourCCCodeNULL = 0x4c4c554e;		 

 

const TUint32 KMMFFourCCCodeAMR = 0x524d4120;		 

 

const TUint32 KMMFFourCCCodeAAC = 0x43414120;		 

 

const TUint32 KMMFFourCCCodeAWB = 0x42574120;		 

 

const TUint32 KMMFFourCCCodeMP3 = 0x33504d20;		 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 1
 
 
 
 
# 369 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h"


# 81 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmffourcc.h" 2




# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfutilities.h" 2



 





class TMediaId
	{
public:

	 











	TMediaId(TUid aMediaType, TUint aStreamId) : iMediaType(aMediaType), iStreamId(aStreamId) {};

	 








	TMediaId(TUid aMediaType) : iMediaType(aMediaType), iStreamId(0) {};

	 


	TMediaId() : iMediaType(TUid::Null() ), iStreamId(0) {};
public:
	 


	TUid iMediaType;

	 



	TUint iStreamId;
	};

 





const TInt KFourCCNULL = KMMFFourCCCodeNULL;

 









class TFourCC
{
public:

	 


	TFourCC() {iFourCC = KMMFFourCCCodeNULL;}  

	 















	TFourCC(TUint8 aChar1, TUint8 aChar2, TUint8 aChar3, TUint8 aChar4) {iFourCC =(aChar4<<24)+(aChar3<<16)+(aChar2<<8)+aChar1;}

	 






	TFourCC(const TDesC8& aDes) {iFourCC =(aDes[3]<<24)+(aDes[2]<<16)+(aDes[1]<<8)+aDes[0];}

	 





	TFourCC(TInt32 aFourCC) {iFourCC = aFourCC;}

	 




	TUint32 FourCC() {return iFourCC;}
	inline void FourCC( TPtr8* aDes ) const ;

	 





	void Set(TFourCC aFourCC) {iFourCC = aFourCC.iFourCC;}

	 





	void Set(TUint32 aFourCC) {iFourCC = aFourCC;}

	 








	TBool operator==(const TFourCC& aA) const {return (iFourCC == aA.iFourCC);}

	 








	TBool operator==(const TUint32& aUint) const {return (iFourCC == aUint);}

	 








	TBool operator!=(const TFourCC& aA) const {return (iFourCC != aA.iFourCC);}

	 





	TBool operator!=(const TUint32& aUint) const {return (iFourCC != aUint);}

private:
	TUint32 iFourCC;
};

 







inline void TFourCC::FourCC( TPtr8* aDes ) const
	{
	TUint8 char1 = TUint8( iFourCC ) ;
	TUint8 char2 = TUint8( iFourCC >> 8 ) ;
	TUint8 char3 = TUint8( iFourCC >> 16 ) ;
	TUint8 char4 = TUint8( iFourCC >> 24 ) ;

	aDes->Format( (TPtrC8((const TText8 *)( "%1c%1c%1c%1c" ))) , char1, char2, char3, char4 ) ;
	}

 




class CMMFChannelAndSampleRateConverter : public CBase
	{
public:
	 











	virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer) =0;
	virtual void Reset() {};

	 


	virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize) {return aSrcBufferSize;}

	void SetRates(TInt aSrcRate,TInt aSrcChannels,TInt aDstRate,TInt aDstChannels);
public:
	 


	TInt iFromRate;
	 


	TInt iToRate;
	 


	TInt iFromChannels;
	 


	TInt iToChannels;
protected:
	TReal iRatio;
	TInt iFraction;
	TInt iIndex;
	};

 


class CMMFStereoToMonoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);

	};

 


class CMMFStereoToMonoConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);
	};

 


class CMMFStereoToStereoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
	};

 


class CMMFMonoToMonoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
	};

 


class CMMFMonoToStereoConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);
	};

 


class CMMFMonoToStereoRateConverter : public CMMFChannelAndSampleRateConverter
	{
	public:
		virtual TInt Convert(const CMMFDataBuffer& aSrcBuffer, CMMFDataBuffer& aDstBuffer);
		virtual TUint MaxConvertBufferSize(TUint aSrcBufferSize);
	};

 





class CMMFChannelAndSampleRateConverterFactory : public CBase
	{





public:
	  CMMFChannelAndSampleRateConverter* CreateConverterL(TInt aFromRate,TInt aFromChannels,
												 TInt aToRate,TInt aToChannels);
	  CMMFChannelAndSampleRateConverter* CreateConverterL();
	CMMFChannelAndSampleRateConverter* Converter() {return iConverter;}
	  ~CMMFChannelAndSampleRateConverterFactory();
	TInt Rate() {return iToRate;}
	TInt Channels() {return iToChannels;}
public:
	 


	TInt iFromRate;
	 


	TInt iToRate;
	 


	TInt iFromChannels;
	 


	TInt iToChannels;
private:
	CMMFChannelAndSampleRateConverter* iConverter;
	};





# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 1
 
 
 
 

 






 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 19 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 20 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomerrorcodes.h" 1
 
 
 
 

 




 




 
 
const TInt KEComErrBase								= -17000;

 
 
const TInt KEComErrLast								= -17030;

 
 
 
 




const TInt KEComErrNoInterfaceIdentified			= -17004;

 




const TInt KEComErrNoResolver						= -17014;

 




const TInt KEComErrTooManyNotificationsOutstanding	= -17026;

 





const TInt KEComErrMissingParameter					= -17028;

 



const TInt KEComErrListInvalidAwaitNotification		= -17029;

 




const TInt KEComErrListCurrentlyUnavailable			= -17030;


 
 
 
 



const TInt KEComErrInvalidUnloadPolicy				= -17003;

 




const TInt KEComErrInvalidIIC						= -17008;

 




const TInt KEComErrDriveNotFound					= -17019;


 
 
 
 



const TInt KEComErrUnknownService					= -17002;

 



const TInt KEComErrReferenceCountInvalid			= -17013;

 



const TInt KEComErrDestructionFailed				= -17017;

 




const TInt KEComErrInvalidRegistryData				= -17022;

 





const TInt KEComErrDestroyingWithNullDtorKey		= -17027;


 
 
 
 


const TInt KEComErrAlreadyReceiving					= -17001;

 



const TInt KEComErrEnableFailed						= -17005;

 



const TInt KEComErrDisableFailed					= -17006;

 




const TInt KEComErrNoRegistrationsFound				= -17007;

 



const TInt KEComErrUninstallFailed					= -17009;

 



const TInt KEComErrReinstallFailed					= -17010;

 



const TInt KEComErrRegistrationFailed				= -17011;

 



const TInt KEComErrNotConnected						= -17012;

 



const TInt KEComErrSuspendFailed					= -17015;

 



const TInt KEComErrResumeFailed						= -17016;

 




const TInt KEComErrDriveAlreadyInstalled			= -17018;

 


const TInt KEComErrIndexEntryNotFound				= -17020;

 




const TInt KEComErrNoRegistrationData				= -17021;

 


const TInt KEComErrMismatchedTags					= -17023;

 


const TInt KEComErrInstantiationPointerNotFound		= -17024;

 


const TInt KEComErrInstantiationPointerNotAvailable = -17025;


# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomresolverparams.h" 1
 
 
 
 

 





 






 
 















 
class TEComResolverParams
	{
public:
	 
	inline TEComResolverParams();
	
	 
	inline const TDesC8& DataType() const;
	 
	inline void SetDataType(const TDesC8& aDataType);
	
	inline TBool IsGenericMatch() const;
	inline void SetGenericMatch(TBool aGenericMatch);

	 
	 
	inline TBool IsWildcardMatch() const;
	 
	inline void SetWildcardMatch(TBool aWildcardMatch);

private:
	 
	 
	TPtrC8 iDataType;
	 
	TBool iGenericMatch;
	};


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomresolverparams.inl" 1
 
 
 
 

 





 


 
 
 
 
 

 




TEComResolverParams::TEComResolverParams()
:	iDataType(0L ,0),
	iGenericMatch(EFalse)
	{
	 
	}


 






 
const TDesC8& TEComResolverParams::DataType() const
	{
	return iDataType;
	}


 







 
void TEComResolverParams::SetDataType(const TDesC8& aDataType)
	{
	iDataType.Set(aDataType);
	}

 






TBool TEComResolverParams::IsGenericMatch() const
	{
	return iGenericMatch;
	}

 


























void TEComResolverParams::SetGenericMatch(TBool aGenericMatch)
	{
	iGenericMatch=aGenericMatch;
	}
	

 






 
TBool TEComResolverParams::IsWildcardMatch() const
	{
	return iGenericMatch;
	}


 







 
void TEComResolverParams::SetWildcardMatch(TBool aWildcardMatch)
	{
	iGenericMatch=aWildcardMatch;
	}




# 66 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecomresolverparams.h" 2



# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 1
 
 
 
 

 



 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 15 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 2


 
 
 

































 
class CImplementationInformation : public CBase
	{
public:
	 
	static CImplementationInformation* NewLC(RReadStream& aStream);
	 
	static CImplementationInformation* NewL(TUid	aUid, 
											TInt	aVersion, 
											HBufC*  aName,
											HBufC8* aDataType,
											HBufC8* aOpaqueData,
											TDriveUnit aDrive,
											TBool aRomOnly,
											TBool aRomBased);
	 
	static CImplementationInformation* NewL(const CImplementationInformation& aImplInfo);
	 
	~CImplementationInformation();
	 
	inline const TDesC& DisplayName() const;
	 
	inline const TDesC8& DataType() const;
	 
	inline const TDesC8& OpaqueData() const;
	 
	inline TUid ImplementationUid() const;
	 
	inline TInt Version() const;
	 
	inline TBool Disabled() const;
	 
	inline void SetDisabled(TBool aDisabled);
	 
	void ExternalizeL(RWriteStream& aStream) const;
	 
	void InternalizeL(RReadStream& aStream);
	inline TDriveUnit Drive() const;
	inline TBool RomOnly() const;
	inline TBool RomBased() const;
	void SetRomBased(TBool aRomBased);

private:
	 
	CImplementationInformation();
	 
	CImplementationInformation(TUid aUid, 
							   TInt aVersion, 
							   HBufC*  aName, 
							   HBufC8* aDataType,
							   HBufC8* aOpaqueData,
							   TDriveUnit aDrive,
							   TBool aRomOnly,
							   TBool aRomBased);

private:
	 
	 
	TUid		iImplementationUid;
	 
	 
	TInt		iVersion;
	 
	 
	HBufC*		iDisplayName;
	 




	 
	HBufC8*		iData;
	 



	 
	HBufC8*		iOpaqueData;
	  
	 
	TBool		iDisabled;
	  
	TDriveUnit		iDrive;
	 
	TBool iRomOnly;
	 
	TBool iRomBased;
	};	 

 



typedef RArray<CImplementationInformation*> RImplInfoArray;

 



typedef RPointerArray<CImplementationInformation> RImplInfoPtrArray;


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.inl" 1
 
 
 
 

 



 

 
 
 
 

 





const TDesC& CImplementationInformation::DisplayName() const
	{
	if(iDisplayName == 0L )
		return KNullDesC();
	else
		return *iDisplayName;
	}


 





const TDesC8& CImplementationInformation::DataType() const
	{
	if(iData == 0L )
		return KNullDesC8();
	else
		return *iData;
	}


 





const TDesC8& CImplementationInformation::OpaqueData() const
	{
	if(iOpaqueData == 0L )
		return KNullDesC8();
	else
		return *iOpaqueData;
	}


 





TUid CImplementationInformation::ImplementationUid() const
	{
	return iImplementationUid;
	}


 





TInt CImplementationInformation::Version() const
	{
	return iVersion;
	}


 






TBool CImplementationInformation::Disabled() const
	{
	return iDisabled;
	}


 






void CImplementationInformation::SetDisabled(TBool aDisabled)
	{
	iDisabled = aDisabled;
	}

 






TDriveUnit CImplementationInformation::Drive() const
	{
	return iDrive;
	}


 





TBool CImplementationInformation::RomOnly() const
	{
	return iRomOnly;
	}

 





TBool CImplementationInformation::RomBased() const
	{
	return iRomBased;
	}
# 156 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/implementationinformation.h" 2



# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/ecom/ecom.h" 2


 
 
 


const TInt KMaxServiceArgs = 4;

 





const TUid KRomOnlyResolverUid = {0x10009D92};

 













 
class REComSession  : public RSessionBase
	{
public:
	 
	  REComSession();
	 
	  static REComSession& OpenL();
	 
	  void Close();
	 
	  void NotifyOnChange(TRequestStatus& aStatus);
	 
	  void CancelNotifyOnChange(TRequestStatus& aStatus);
	 
	  static void ListImplementationsL(TUid aInterfaceUid, 
											  const TEComResolverParams& aResolutionParameters,
											  RImplInfoPtrArray& aImplInfoArray);
	 
	  static void ListImplementationsL(TUid aInterfaceUid,
											  RImplInfoPtrArray& aImplInfoArray);
	 
	  static void ListImplementationsL(TUid aInterfaceUid, 
											  const TEComResolverParams& aResolutionParameters, 
											  TUid aResolverUid,
											  RImplInfoPtrArray& aImplInfoArray);

	 
	 
	 
	 
	 
	 
	 

	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TUid& aDtorIDKey);
	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TInt32 aKeyOffset);
	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TUid& aDtorIDKey, 
												TAny* aConstructionParameters);
	 
	  static TAny* CreateImplementationL(TUid aImplementationUid, 
												TInt32 aKeyOffset,
												TAny* aConstructionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey,
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset, 
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey, 
												TAny* aConstructionParameters, 
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset, 
												TAny* aConstructionParameters, 
												const TEComResolverParams& aResolutionParameters);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey, 
												const TEComResolverParams& aResolutionParameters,
												TUid aResolverUid);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset,
												const TEComResolverParams& aResolutionParameters, 
												TUid aResolverUid);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TUid& aDtorIDKey, 
												TAny* aConstructionParameters,
												const TEComResolverParams& aResolutionParameters, 
												TUid aResolverUid);
	 
	  static TAny* CreateImplementationL(TUid aInterfaceUid, 
												TInt32 aKeyOffset, 
												TAny* aConstructionParameters,
												const TEComResolverParams& aResolutionParameters,
												TUid aResolverUid);
	 
	  static void DestroyedImplementation(TUid aDtorIDKey);
	  static void FinalClose();

private:
	 
	void ConstructL();
	 
	void ReallyClose();
	 
	static void ListImplementationsL(TInt aServiceId, 
									 TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid aResolverUid,
									 RImplInfoPtrArray& aImplInfoArray);
	 
	TAny* GetResolvedCreationMethodL(TUid aImplementationUid, 
									 TUid& aDtorIDKey);
	 
	TAny* GetResolvedCreationMethodL(TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid& aDtorIDKey);
	 
	TAny* GetResolvedCreationMethodL(TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid aResolverUid, 
									 TUid& aDtorIDKey);
	 
	TAny* GetResolvedCreationMethodL(TInt aServiceId,
									 TUid aInterfaceUid, 
									 const TEComResolverParams& aResolutionParameters, 
									 TUid aResolverUid, 
									 TUid& aDtorIDKey);
	 
	TAny* CreateL(TAny* aCreationMethodPtr);
	 
	TAny* CreateL(TAny* aCreationMethodPtr, TAny* aCreationParameters);

private:
	 
	TInt iReserved2;


 

	 
	TBool iDoNotCloseThis;

	 
	TAny* iReserved;

	};



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframework.h" 1
 
 
 
 








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframeworkbase.h" 1
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32mem.h" 1
 
 
 
 









 












class TMemBuf : public TStreamBuf
	{
public:
	  TMemBuf();
	  void Set(TUint8* aPtr,TUint8* anEnd,TInt aMode=ERead|EWrite);
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline TUint8* Base() const;
	inline TUint8* End() const;
private:
	TUint8* iBase;
	};

 


















class TDesBuf : public TStreamBuf
	{
public:
	  TDesBuf();
	  void Set(TDes8& aDes,TInt aMode=ERead|EWrite);
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  void DoSynchL();
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline TDes8& Des() const;
	inline TUint8* Base() const;
 	void Consolidate();
private:
	TDes8* iDes;
	};

 































class TBufBuf : public TStreamBuf
	{
public:
	enum {ETruncate=0x10,EInsert=0x20};
public:
	  TBufBuf();
	  void Set(CBufBase& aBuf,TInt aPos,TInt aMode=ERead|EWrite);
protected:
	  TInt UnderflowL(TInt aMaxLength);
	  void OverflowL();
	  void DoSynchL();
	  void DoWriteL(const TAny* aPtr,TInt aLength);
	  TStreamPos DoSeekL(TMark aMark,TStreamLocation aLocation,TInt anOffset);
private:
	inline CBufBase& Buf() const;
 	void Consolidate();
 
	void SetPos(TMark aMark,TInt aPos);
	inline void SetPos(TRead,TInt aPos);
	inline void SetPos(TWrite,TInt aPos);
	TInt Pos(TMark aMark) const;
	inline TInt Pos(TRead) const;
	inline TInt Pos(TWrite) const;
	inline TInt MovePos(TRead,TInt anOffset);
	inline TInt MovePos(TWrite,TInt anOffset);
	inline TInt Mark(TRead) const;
	inline TInt Mark(TWrite) const;
private:
	CBufBase* iBuf;
	TInt iRPos;
	TInt iWPos;
	TInt iMode;
	};

 



class RMemReadStream : public RReadStream
	{
public:
	RMemReadStream() {}
	  RMemReadStream(const TAny* aPtr,TInt aLength);
	  void Open(const TAny* aPtr,TInt aLength);
private:
	TMemBuf iSource;
	};

 



class RMemWriteStream : public RWriteStream
	{
public:
	RMemWriteStream() {}
	inline RMemWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RMemWriteStream(TAny* aPtr,TInt aMaxLength);
	  void Open(TAny* aPtr,TInt aMaxLength);
private:
	TMemBuf iSink;
	};

 



class RDesReadStream : public RReadStream
	{
public:
	RDesReadStream() {}
	  RDesReadStream(const TDesC8& aDes);
	  void Open(const TDesC8& aDes);
private:
	TMemBuf iSource;
	};

 



class RDesWriteStream : public RWriteStream
	{
public:
	RDesWriteStream() {}
	inline RDesWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RDesWriteStream(TDes8& aDes);
	  void Open(TDes8& aDes);
private:
	TDesBuf iSink;
	};

 



class RBufReadStream : public RReadStream
	{
public:
	RBufReadStream() {}
	  RBufReadStream(const CBufBase& aBuf,TInt aPos=0);
	  void Open(const CBufBase& aBuf,TInt aPos=0);
private:
	TBufBuf iSource;
	};

 



class RBufWriteStream : public RWriteStream
	{
public:
	RBufWriteStream() {}
	inline RBufWriteStream(const MExternalizer<TStreamRef>& anExter);
	  RBufWriteStream(CBufBase& aBuf,TInt aPos=0);
	  void Open(CBufBase& aBuf,TInt aPos=0);
	  void Truncate(CBufBase& aBuf,TInt aPos=0);
	  void Insert(CBufBase& aBuf,TInt aPos);
	inline void Append(CBufBase& aBuf);
private:
	TBufBuf iSink;
	};

 
















class CBufStore : public CStreamStore
	{
public:
	  static CBufStore* NewL(TInt anExpandSize);
	  static CBufStore* NewLC(TInt anExpandSize);
	  CBufStore(TInt anExpandSize);
	  ~CBufStore();
protected:
	  TStreamId DoExtendL();
	  void DoDeleteL(TStreamId anId);
	  MStreamBuf* DoReadL(TStreamId anId) const;
	  MStreamBuf* DoCreateL(TStreamId& anId);
	  MStreamBuf* DoWriteL(TStreamId anId);
	  MStreamBuf* DoReplaceL(TStreamId anId);
private:
	CBufSeg& BufL(TStreamId anId) const;
private:
	CArrayFixFlat<CBufSeg*> iBufArray;
	TInt iExpandSize;
	};		

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32mem.inl" 1
 
 
 
 

 
inline RMemWriteStream::RMemWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

 
inline RDesWriteStream::RDesWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}

 
inline RBufWriteStream::RBufWriteStream(const MExternalizer<TStreamRef>& anExter)
	: RWriteStream(anExter)
	{}
inline void RBufWriteStream::Append(CBufBase& aBuf)
	{Insert(aBuf,aBuf.Size());}

# 274 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32mem.h" 2


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframeworkbase.h" 2


 






const TInt KUseDefaultIap = -1;


 













class TMMFEvent
	{
public:

	 









	  TMMFEvent(TUid aEventType, TInt aErrorCode);

	 





	  TMMFEvent();

	 


	TUid iEventType;

	 


	TInt iErrorCode;

	};

 





typedef TPckgBuf<TMMFEvent> TMMFEventPckg;

 





typedef TPckgBuf<TUid> TMMFUidPckg;

 





typedef TPckgBuf<TTimeIntervalMicroSeconds> TMMFTimeIntervalMicroSecondsPckg;


 












class CMMFMetaDataEntry : public CBase
	{
public:

	 























	  static CMMFMetaDataEntry* NewL(const TDesC& aName, const TDesC& aValue);

	 











	  static CMMFMetaDataEntry* NewL(const CMMFMetaDataEntry& aOther);

	 









	  static CMMFMetaDataEntry* NewL();

	 




	  ~CMMFMetaDataEntry();

	 






	  const TDesC& Name() const;

	 






	  const TDesC& Value() const;

	 









	  void SetNameL(const TDesC& aName);

	 









	  void SetValueL(const TDesC& aValue);

	 










	  void ExternalizeL(RWriteStream& aStream) const;

	 










	  void InternalizeL(RReadStream& aStream);
private:

	 




	CMMFMetaDataEntry();

	 





















	void ConstructL(const TDesC& aName, const TDesC& aValue);
private:
	 


	HBufC* iName;

	 


	HBufC* iValue;
	};




 










class CMMFUrlParams : public CBase
	{
public:

	 















	  static CMMFUrlParams* NewL(const TDesC& aUrl, TInt aIAPId=KUseDefaultIap);

	 














	  static CMMFUrlParams* NewLC(const TDesC& aUrl, TInt aIAPId=KUseDefaultIap);

	 











	  static CMMFUrlParams* NewLC(RReadStream& aStream);

	 









	  void ExternalizeL(RWriteStream& aStream) const;

	 









	  CBufFlat* ExternalizeToCBufFlatLC() const;

	 


	~CMMFUrlParams();


	 





	  const TDesC& Url() const;

	 






	  TInt IAPId() const;

	 








	  TBool UseIAPId() const;
private:
	CMMFUrlParams();
	void ConstructL(const TDesC& aUrl, TInt aIAPId);
	void ConstructL(RReadStream& aStream);
private:
	HBufC* iUrl;
	TInt iIAPId;
	};



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframework.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.h" 1
 
 
 
 

 







 




 
 
 
 
 



typedef RMessage2 RMmfIpcMessage;

class CMmfIpcServer;  

 




 
class CMmfIpcSession : public CSession2
	{
protected:
	virtual void CreateL(const CMmfIpcServer& aServer);
	CMmfIpcSession() {}
	 
	void CreateL();
	};

 




 
class CMmfIpcServer : public CServer2
	{
protected:
	virtual CMmfIpcSession* NewSessionL(const TVersion& aVersion) const=0;
	CMmfIpcServer(TInt aPriority,TServerType aType=EUnsharableSessions);
private:
	 
	CSession2* NewSessionL(const TVersion& aVersion,const RMessage2& aMessage) const;
	};















 






class RMmfSessionBase : public RSessionBase
	{
protected:
	 
	TInt SendReceive(TInt aFunction) const;
	void SendReceive(TInt aFunction, TRequestStatus& aStatus) const;
	 
	TInt SendReceive(TInt aFunction, TInt aParam0) const;
	TInt SendReceive(TInt aFunction, TInt aParam0, TInt aParam1) const;
	void SendReceive(TInt aFunction, TInt aParam0, TRequestStatus& aStatus) const;
	void SendReceive(TInt aFunction, TInt aParam0, TInt aParam1, TRequestStatus& aStatus) const;
	TInt SendReceive(TInt aFunction, const TDesC8& aParam0) const;
	TInt SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1) const;
	TInt SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2) const;
	void SendReceive(TInt aFunction, const TDesC8& aParam0, TRequestStatus& aStatus) const;
	void SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TRequestStatus& aStatus) const;
	void SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TRequestStatus& aStatus) const;
	 
	TInt SendReceiveResult(TInt aFunction, TDes8& aResult) const;
	TInt SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult) const;
	TInt SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult) const;
	void SendReceiveResult(TInt aFunction, TDes8& aResult, TRequestStatus& aStatus) const;
	void SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult, TRequestStatus& aStatus) const;
	void SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult, TRequestStatus& aStatus) const;
	};


 





class MmfMessageUtil 
	{
public:
	static TInt Read(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult);
	static TInt Write(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue);
	static void ReadL(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult);
	static void WriteL(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue);
	};
	
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.inl" 1
 
 
 
 



 
 
 

inline void CMmfIpcSession::CreateL(const CMmfIpcServer&  )
	{
	 
	} 
	
inline void CMmfIpcSession::CreateL() 
	{ 
	const CMmfIpcServer* server = static_cast<const CMmfIpcServer*>(Server());
	CreateL(*server);  
	}

 
 
 

inline CMmfIpcServer::CMmfIpcServer(TInt aPriority,TServerType aType):
	CServer2(aPriority,aType)
	{
	}

inline CSession2* CMmfIpcServer::NewSessionL(const TVersion& aVersion, const RMessage2&  ) const
	{
	return NewSessionL(aVersion);
	}



 
 
 

inline TInt RMmfSessionBase::SendReceive(TInt aFunction) const
	{
	return RSessionBase::SendReceive(aFunction);
	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, TRequestStatus& aStatus) const
	{
	RSessionBase::SendReceive(aFunction,aStatus);
	}

 

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0));








	}

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0, TInt aParam1) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0,aParam1));








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0), aStatus);








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, TInt aParam0, TInt aParam1, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(aParam0,aParam1), aStatus);








	}

 

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0));








	}

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1));








	}

inline TInt RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2));








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0), aStatus);








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1), aStatus);








	}

inline void RMmfSessionBase::SendReceive(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2), aStatus);








	}

 

inline TInt RMmfSessionBase::SendReceiveResult(TInt aFunction, TDes8& aResult) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aResult));








	}

inline TInt RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aResult));








	}

inline TInt RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult) const
	{

	return RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2,&aResult));








	}

inline void RMmfSessionBase::SendReceiveResult(TInt aFunction, TDes8& aResult, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aResult), aStatus);








	}

inline void RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, TDes8& aResult, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aResult), aStatus);








	}

inline void RMmfSessionBase::SendReceiveResult(TInt aFunction, const TDesC8& aParam0, const TDesC8& aParam1, const TDesC8& aParam2, TDes8& aResult, TRequestStatus& aStatus) const
	{

	RSessionBase::SendReceive(aFunction, TIpcArgs(&aParam0,&aParam1,&aParam2,&aResult), aStatus);








	}
	
 
 
 

inline void MmfMessageUtil::ReadL(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult)
	{

	User::LeaveIfError(aMessage.Read(aParam, aResult));
# 303 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.inl"

	}

inline void MmfMessageUtil::WriteL(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue)
	{

	User::LeaveIfError(aMessage.Write(aParam, aValue));
# 322 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.inl"

	}

inline TInt MmfMessageUtil::Read(const RMmfIpcMessage& aMessage, TInt aParam, TDes8& aResult)
	{

	return aMessage.Read(aParam, aResult);




	}

inline TInt MmfMessageUtil::Write(const RMmfIpcMessage& aMessage, TInt aParam, const TDesC8& aValue)
	{

	return aMessage.Write(aParam, aValue);




	}
# 125 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfipc.h" 2



# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerframework.h" 2


 
class CMMFControllerImplementationInformation;

static const TLitC<sizeof(L"MMFControllerProxyServer" )/2>  KMMFControllerProxyServerName ={sizeof(L"MMFControllerProxyServer" )/2-1,L"MMFControllerProxyServer" } ;

 




 


const TInt KMMFControllerProxyMaxHeapSize = 0x1000000; 

 


const TInt KMMFControllerProxyMaxCachedMessages = 10;

 




const TInt KMMFObjectHandleControllerProxy = -1;

 





const TInt KMMFObjectHandleController = -2;

 





const TInt KMMFObjectHandleNull = 0;
 





const TInt KMMFObjectHandleFirstValid = 1;

 


const TInt KMmfControllerThreadShutdownTimeout = 20000000;	 

 




const TUid KUidInterfaceMMFControllerProxy = {0x101F77E7};

 


enum TMMFControllerProxyMessages
	{
	EMMFControllerProxyLoadControllerPluginByUid,
	EMMFControllerProxyReceiveEvents,
	EMMFControllerProxyCancelReceiveEvents
	};


 















class TMMFMessageDestination
	{
public:

	 






	  TMMFMessageDestination();

	 









	  TMMFMessageDestination(TUid aInterfaceId);

	 









	  TMMFMessageDestination(TUid aInterfaceId, TInt aDestinationHandle);

	 







	  TMMFMessageDestination(const TMMFMessageDestination& aOther);

	 






	  TUid InterfaceId() const;

	 






	  TInt DestinationHandle() const;

	 










	  TBool operator==(const TMMFMessageDestination& aOther) const;

private:
	TUid iInterfaceId;
	TInt iDestinationHandle;
	};

 





typedef TPckgBuf<TMMFMessageDestination> TMMFMessageDestinationPckg;


 


















class TMMFMessage
	{
friend class CMMFControllerProxySession;
public:

	 










	  TMMFMessage(const TMMFMessage& aMessage);

	 







	  const TMMFMessageDestination& Destination();

	 









	  TInt Function();

	 







	  TInt SizeOfData1FromClient();

	 











	  TInt ReadData1FromClient(TDes8& aDes);

	 











	  void ReadData1FromClientL(TDes8& aDes);


	 








	  TInt SizeOfData2FromClient();

	 











	  TInt ReadData2FromClient(TDes8& aDes);

	 











	  void ReadData2FromClientL(TDes8& aDes);

	 












	  TInt WriteDataToClient(const TDesC8& aDes);

	 











	  void WriteDataToClientL(const TDesC8& aDes);

	 









	  void Complete(TInt aReason);

	 







	  TBool IsCompleted();
private:
	 






	TMMFMessage(const RMmfIpcMessage& aMessage);

	 






	void FetchDestinationL();
private:

	 


	RMessagePtr2 iMessage;
	 


	TInt iFunction;
	 


	TInt iDummyPadding[6];







	 


	TMMFMessageDestination iDestination;

	 


	TBool iAmCompleted;
	};


 











class RMMFControllerProxy : public RMmfSessionBase
	{
public:

	 




	  RMMFControllerProxy();

	 









	  TInt LoadController(TUid aControllerUid);

	 










	  TInt LoadController(const CMMFControllerImplementationInformation& aControllerInfo);

	 







	  void Close();

	 




























	  TInt SendSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom) const;

	 

























	  TInt SendSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2) const;

	 

































	  void SendAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction,  const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom, TRequestStatus& aStatus) const;

	 






























	  void SendAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction,  const TDesC8& aDataTo1, const TDesC8& aDataTo2, TRequestStatus& aStatus) const;

	 


















	  void ReceiveEvents(TMMFEventPckg& aEvent, TRequestStatus& aStatus);

	 











	  TInt CancelReceiveEvents();
private:
	 


	TInt DoCreateSubThread(const TDesC& aName, TUint aMaxHeapSize);

	 


	TUint ControllersMaxHeapSizeL(TUid aControllerUid);

	 




	TInt LoadController(TUid aControllerUid, const CMMFControllerImplementationInformation* aControllerInfo);

private:
	 


	RThread iSubThread;
	 



	TMMFMessageDestinationPckg iDestinationPckg;
	};

 








class TMMFControllerProxyStartParams
	{
public:

	 







	TMMFControllerProxyStartParams(TRequestStatus& aStatus) : iStatus(&aStatus), iThreadId(RThread().Id())
		{aStatus=KRequestPending;};

	 






	void SignalL()
		{
		RThread starter;
		User::LeaveIfError(starter.Open(iThreadId));
		starter.RequestComplete(iStatus,KErrNone);
		starter.Close();
		};
public:
	TRequestStatus* iStatus;
	TThreadId iThreadId;
	};

 





class CMMFControllerProxyShutdown : public CTimer
	{
	enum {EMMFControllerProxyShutdownDelay=1000000};	 
public:

	 






	static CMMFControllerProxyShutdown* NewL();

	 





	void Start();

	 






	void ShutdownNow();
private:
	CMMFControllerProxyShutdown();
	void ConstructL();

	 




	void RunL();
	};


 





class MAsyncEventHandler
	{
public:

	 







	virtual TInt SendEventToClient(const TMMFEvent& aEvent) = 0;
	};

 








class CMMFEventReceiver : public CBase
	{
public:

	 











	static CMMFEventReceiver* NewL(const TMMFMessage& aMessage);

	 






	~CMMFEventReceiver();

	 







	void SendEvent(const TMMFEvent& aEvent);
private:

	 







	CMMFEventReceiver(const TMMFMessage& aMessage);
private:
	 


	TMMFMessage iMessage;
	};



 











class CMMFControllerProxyServer : public CMmfIpcServer
	{
public:
	 








	static CMMFControllerProxyServer* NewL();

	 




	~CMMFControllerProxyServer();

	 













	static TInt StartThread(TAny* aAny);

	 









	TInt RunError(TInt aError);

	 






	void SessionCreated();

	 





	void SessionDestroyed();
private:

	 












	static void DoStartThreadL(TMMFControllerProxyStartParams* aParams);

	 











	CMmfIpcSession* NewSessionL(const TVersion& aVersion) const;

	 




	CMMFControllerProxyServer();

	 




	void ConstructL();
private:
	 


	CMMFControllerProxyShutdown* iShutdownTimer;
	 


	TBool iHaveSession;
	};

class CMMFController;

 








class CMMFControllerProxySession : public CMmfIpcSession, public MAsyncEventHandler
	{
public:

	 








	static CMMFControllerProxySession* NewL();

	 









	void CreateL(const CMmfIpcServer& aServer);

	 


	~CMMFControllerProxySession();

	 













	void ServiceL(const RMmfIpcMessage& aMessage);

	 






	TInt SendEventToClient(const TMMFEvent& aEvent);
private:
	 


	CMMFControllerProxySession();

	 










	TBool ReceiveEventsL(TMMFMessage& aMessage);

	 









	TBool CancelReceiveEvents(TMMFMessage& aMessage);

	 









	TBool LoadControllerL(TMMFMessage& aMessage);
private:
	 


	CMMFController* iController;
	 


	CMMFControllerProxyServer* iServer;
	 


	CMMFEventReceiver* iEventReceiver;
	 


	RArray<TMMFEvent> iEvents;
	};



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasource.h" 2


 
 
 

class CMMFBuffer;
class MDataSink;
class MAsyncEventHandler;

 





class MDataSource
	{
public:
	static inline MDataSource* NewSourceL( TUid aImplementationUid,  const TDesC8& aInitData ) ;

	 


	virtual ~MDataSource() {REComSession::DestroyedImplementation(iDtor_ID_Key);};

	 




	virtual TUid DataSourceType() const {return iDataSourceType;};

	 











	virtual TFourCC SourceDataTypeCode(TMediaId aMediaId) = 0;

	inline virtual TInt SetSourceDataTypeCode(TFourCC aSourceFourCC, TMediaId aMediaId);

	 







































	virtual void FillBufferL(CMMFBuffer* aBuffer, MDataSink* aConsumer,TMediaId aMediaId)=0;

	 











	virtual void BufferEmptiedL(CMMFBuffer* aBuffer)=0;

	 









	virtual TBool CanCreateSourceBuffer()=0;

	 


















	virtual CMMFBuffer* CreateSourceBufferL(TMediaId aMediaId, TBool &aReference) = 0;

	inline virtual CMMFBuffer* CreateSourceBufferL(TMediaId aMediaId, CMMFBuffer& aSinkBuffer, TBool &aReference);

	inline virtual TInt SourceThreadLogon(MAsyncEventHandler& aEventHandler);

	 










	virtual void SourceThreadLogoff() {};

	inline virtual void NegotiateSourceL(MDataSink& aDataSink);  

	 







	virtual TBool SourceSampleConvert() {return EFalse;};
	
	 





	virtual void SourcePrimeL() {};
	
	 





	virtual void SourcePlayL() {};

	 





	virtual void SourcePauseL() {};

	 





	virtual void SourceStopL() {};

	inline virtual void SetSourcePrioritySettings(const TMMFPrioritySettings& aPrioritySettings);

	 








	virtual void SourceCustomCommand(TMMFMessage& aMessage) {aMessage.Complete(KErrNotSupported);};
protected:

	 








	virtual void ConstructSourceL(  const TDesC8& aInitData ) = 0 ;

	 


	MDataSource(TUid aType): iDataSourceType(aType) {}
private:
	TUid iDataSourceType;
	TUid iDtor_ID_Key;

	};

 









inline MDataSource* MDataSource::NewSourceL( TUid aImplementationUid, const TDesC8& aInitData )
	{
	MDataSource* retPtr = (reinterpret_cast<  MDataSource* >(  REComSession::CreateImplementationL( aImplementationUid,
																			((TInt)(&(( MDataSource  *)0)->  iDtor_ID_Key ))  )  ))  ;
	CleanupDeletePushL(retPtr);
	retPtr->ConstructSourceL( aInitData ) ;

	CleanupStack::Pop(retPtr);
	return retPtr ;
	}

 















inline TInt MDataSource::SetSourceDataTypeCode(TFourCC  , TMediaId  )
{
	return KErrNotSupported;
}

 






















inline CMMFBuffer* MDataSource::CreateSourceBufferL(TMediaId aMediaId, CMMFBuffer&  , TBool &aReference)
{
	return CreateSourceBufferL(aMediaId, aReference);
}

 


















inline TInt MDataSource::SourceThreadLogon(MAsyncEventHandler&  )
{
	return KErrNone;
}

 








inline void MDataSource::NegotiateSourceL(MDataSink&  )
{
}

 













inline void MDataSource::SetSourcePrioritySettings(const TMMFPrioritySettings&  )
{
}

 






inline static void DoDataSourceStop(TAny* aSource)
	{
	MDataSource* source = (static_cast< MDataSource* >(  aSource )) ;
	 
	 
	 
	TInt  error ;{TTrap __t;if (__t.Trap( error )==0){  source->SourceStopL() ;TTrap::UnTrap();}} ;
	}

 





inline static void DoDataSourceThreadLogoff(TAny* aSource)
	{
	MDataSource* source = (static_cast< MDataSource* >(  aSource )) ;
	source->SourceThreadLogoff();
	}


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/server/mmfdatasink.h" 1
 
 
 











 
 
 

class TFourCC;
class TMediaId;
class CMMFBuffer;
class MDataSource;
class MAsyncEventHandler;

 





class MDataSink
	{
public:

	static inline MDataSink* NewSinkL( TUid aImplementationUid,  const TDesC8& aInitData ) ;

	 


	virtual ~MDataSink() {REComSession::DestroyedImplementation(iDtor_ID_Key);};

	 




	virtual TUid DataSinkType() const {return iDataSinkType;};

	 











	virtual TFourCC SinkDataTypeCode(TMediaId aMediaId) = 0;

	inline virtual TInt SetSinkDataTypeCode(TFourCC aSinkFourCC, TMediaId aMediaId);

	 



















	virtual void EmptyBufferL(CMMFBuffer* aBuffer, MDataSource* aSupplier, TMediaId aMediaId)=0;

	 










	virtual void BufferFilledL(CMMFBuffer* aBuffer)=0;
	
	 









	virtual TBool CanCreateSinkBuffer()=0;
	
	 

















	virtual CMMFBuffer* CreateSinkBufferL(TMediaId aMediaId, TBool &aReference)=0;

	inline virtual TInt SinkThreadLogon(MAsyncEventHandler& aEventHandler);

	 










	virtual void SinkThreadLogoff() {};

	inline virtual void NegotiateL(MDataSource& aDataSource);

	 





	virtual void SinkPrimeL() {};

	 





	virtual void SinkPlayL() {};

	 





	virtual void SinkPauseL() {};

	 





	virtual void SinkStopL() {};

	inline virtual void SetSinkPrioritySettings(const TMMFPrioritySettings& aPrioritySettings);

	 








	virtual void SinkCustomCommand(TMMFMessage& aMessage) {aMessage.Complete(KErrNotSupported);};

protected:
	 








	virtual void ConstructSinkL( const TDesC8& aInitData ) = 0;

	 





	MDataSink(TUid aType): iDataSinkType(aType) {}
private:
	TUid iDataSinkType;
	TUid iDtor_ID_Key;
	};

 









inline MDataSink* MDataSink::NewSinkL( TUid aImplementationUid,  const TDesC8& aInitData )
	{
	MDataSink* retPtr = (reinterpret_cast<  MDataSink* >(  REComSession::CreateImplementationL( aImplementationUid,
																			((TInt)(&(( MDataSink  *)0)->  iDtor_ID_Key ))  )  ))  ;
	CleanupDeletePushL(retPtr);
	retPtr->ConstructSinkL( aInitData ) ;

	CleanupStack::Pop(retPtr);
	return retPtr ;
	}

 















inline TInt MDataSink::SetSinkDataTypeCode(TFourCC  , TMediaId  )
{
	return KErrNotSupported;
}

 



















inline TInt MDataSink::SinkThreadLogon(MAsyncEventHandler&  )
{
	return KErrNone;
}

 










inline void MDataSink::NegotiateL(MDataSource&  )
{
}

 













inline void MDataSink::SetSinkPrioritySettings(const TMMFPrioritySettings&  )
{
}

 






inline static void DoDataSinkStop(TAny* aSink)
	{
	MDataSink* sink = (static_cast< MDataSink* >(  aSink )) ;
	 
	 
	 
	TInt  error ;{TTrap __t;if (__t.Trap( error )==0){  sink->SinkStopL() ;TTrap::UnTrap();}} ;
	}

 





inline static void DoDataSinkThreadLogoff(TAny* aSink)
	{
	MDataSink* sink = (static_cast< MDataSink* >(  aSink )) ;
	sink->SinkThreadLogoff();
	}



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerpluginresolver.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apmstd.h" 1
 
 
 
 








 



const TInt KMaxDataTypeLength=256;

 
class RReadStream;
class RWriteStream;

 







typedef TInt16 TDataTypePriority;

 



const TInt16 KDataTypePriorityUserSpecified=KMaxTInt16;

 






const TInt16 KDataTypePriorityHigh=10000;

 






const TInt16 KDataTypePriorityNormal=0;

 






const TInt16 KDataTypePriorityLow=-10000;

 






const TInt16 KDataTypePriorityLastResort=-20000;

 



const TInt16 KDataTypePriorityNotSupported=KMinTInt16;


class TDataType
 








	{
public:
	  TDataType();
	  TDataType(const TDataType& aDataType);
	  TDataType(const TDesC8& aDataType);
	  TDataType(TUid aUid);
	 
	  TInt operator==(const TDataType& aDataType) const;
	  TInt operator!=(const TDataType& aDataType) const;
	  TBool IsNative() const;
	 
	  TBuf<KMaxDataTypeLength> Des() const;
	  TPtrC8 Des8() const;
	  TUid Uid() const;
	 
	  void InternalizeL(RReadStream& aReadStream);
	  void ExternalizeL(RWriteStream& aWriteStream) const;
private:
	void ParseDes();
private:
	TBuf8<KMaxDataTypeLength> iDataType;
	TUid iUid;
	};

 




 


static const TLitC8<sizeof(  "X-Epoc-Url/" )>  KEpocUrlDataTypeHeader ={sizeof(  "X-Epoc-Url/" )-1,  "X-Epoc-Url/" } ;



class TDataTypeWithPriority
 











	{
public:
	  TDataTypeWithPriority(const TDataType& aDataType, TDataTypePriority aPriority);
public:
	 
	TDataType iDataType;
	 
	TDataTypePriority iPriority;
	};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontrollerpluginresolver.h" 2



 





const TUint KMMFDefaultControllerThreadHeapSize = 0x100000;  


class CMMFFormatImplementationInformation;

 





typedef RPointerArray<CMMFFormatImplementationInformation> RMMFFormatImplInfoArray;

class CMMFControllerImplementationInformation;

 





typedef RPointerArray<CMMFControllerImplementationInformation> RMMFControllerImplInfoArray;

 




class MTaggedDataParserClient
	{
public:
	virtual void ProcessTaggedDataL(const TDesC8& aTag, const TDesC8& aData) = 0;
	};

 




class TaggedDataParser
	{
public:

	 


	static void ParseTaggedDataL(const TDesC8& aData, MTaggedDataParserClient& aClient);

	 


	static void ConvertTextToUidL(const TDesC8& aData, TUid& aUid);

	 



	static void ConvertTextToTUintL(const TDesC8& aData, TUint& aUid);

	};

class CDesC8Array;

 







class CMMFPluginImplementationInformation : public CBase
	{
public:

	 







	  TUid Uid() const;

	 






	  const TDesC& DisplayName() const;

	 






	  const TDesC& Supplier() const;

	 






	  TInt Version() const;

	 









	  const RArray<TUid>& SupportedMediaIds() const;

	 










	  TBool SupportsSupplier(const TDesC& aSupplier) const;

	 









	  TBool SupportsMediaId(TUid aMediaId) const;

	 


	virtual ~CMMFPluginImplementationInformation();

protected:

	 


	CMMFPluginImplementationInformation();

	 


	void SetSupplierL(const TDesC8& aData);

	 


	void AddMediaIdL(const TDesC8& aData);
protected:

	 


	TUid iUid;

	 


	HBufC* iDisplayName;

	 


	HBufC* iSupplier;

	 


	TInt iVersion;

	 


	RArray<TUid> iMediaIds;
	};

 
































class CMMFFormatImplementationInformation : public CMMFPluginImplementationInformation, MTaggedDataParserClient
	{
public:

	 









	static CMMFFormatImplementationInformation* NewL(const CImplementationInformation& aImplInfo);

	 









	static CMMFFormatImplementationInformation* NewLC(const CImplementationInformation& aImplInfo);

	 


	virtual ~CMMFFormatImplementationInformation();

	 





	  const CDesC8Array& SupportedFileExtensions() const;

	 






	  const CDesC8Array& SupportedMimeTypes() const;

	 





	  const CDesC8Array& SupportedHeaderData() const;

	 










	  TBool SupportsFileExtension(const TDesC8& aFileExtension) const;

	 









	  TBool SupportsMimeType(const TDesC8& aMimeType) const;

	 










	  TBool SupportsHeaderDataL(const TDesC8& aHeaderData) const;
protected:

	 


	CMMFFormatImplementationInformation();

	 


	void ConstructL(const CImplementationInformation& aImplInfo);

	 


	void AddFileExtensionL(const TDesC8& aData);

	 


	void AddMimeTypeL(const TDesC8& aData);

	 


	void AddHeaderDataL(const TDesC8& aData);

	 


	void ProcessTaggedDataL(const TDesC8& aTag, const TDesC8& aData);

private:
	 


	CDesC8Array* iFileExtensions;

	 


	CDesC8Array* iMimeTypes;

	 


	CDesC8Array* iHeaderData;
	};


 






































class CMMFControllerImplementationInformation : public CMMFPluginImplementationInformation, MTaggedDataParserClient
	{
public:

	 









	static CMMFControllerImplementationInformation* NewL(const CImplementationInformation& aImplInfo);

	 












	static CMMFControllerImplementationInformation* NewLC(const CImplementationInformation& aImplInfo);

	 









	  static CMMFControllerImplementationInformation* NewL(TUid aUid);

	 


	~CMMFControllerImplementationInformation();

	 






	  const RMMFFormatImplInfoArray& PlayFormats() const;

	 






	  const RMMFFormatImplInfoArray& RecordFormats() const;

	 






	  TUint HeapSpaceRequired() const;

	 


	void GetPlayFormatsL();

	 


	void GetRecordFormatsL();
protected:

	 


	CMMFControllerImplementationInformation();

	 


	void ConstructL(const CImplementationInformation& aImplInfo);

	 


	void SetPlayFormatCollectionUidL(const TDesC8& aData);

	 


	void SetRecordFormatCollectionUidL(const TDesC8& aData);

	 


	void SetHeapSizeL(const TDesC8& aData);

	 


	void ProcessTaggedDataL(const TDesC8& aTag, const TDesC8& aData);

	 


















	void GetFormatsL(TUid aFormatCollectionUid, TUid aFormatPluginCollectionUid, RMMFFormatImplInfoArray& aFormatArray);

	 










	void AddFormatsSwallowCorruptL(RImplInfoPtrArray& aEcomArray, RMMFFormatImplInfoArray& aFormatArray);

private:

	 


	RMMFFormatImplInfoArray iPlayFormats;

	 


	RMMFFormatImplInfoArray iRecordFormats;

	 


	TUid iPlayFormatCollectionUid;

	 


	TUid iRecordFormatCollectionUid;
	
	 


	TUint iHeapSpaceRequired;
	};


 







class CMMFPluginSelectionParameters : public CBase
	{
public:

 



enum TPreferredSupplierMatchType
	{

	 

	ENoPreferredSupplierMatch,

	 

	EPreferredSupplierPluginsFirstInList,

	 

	EOnlyPreferredSupplierPluginsReturned
	};
 



enum TMediaIdMatchType
	{

	 

	ENoMediaIdMatch,

	 



	EAllowOtherMediaIds,

	 



	EAllowOnlySuppliedMediaIds
	};

public:

	 




	virtual ~CMMFPluginSelectionParameters();


	 









	  void SetPreferredSupplierL(const TDesC& aPreferredSupplier, TPreferredSupplierMatchType aMatchType);

	 









	  void SetMediaIdsL(const RArray<TUid>& aMediaIds, TMediaIdMatchType aMatchType);

	 






	  const TDesC& PreferredSupplier() const;

	 





	  TPreferredSupplierMatchType PreferredSupplierMatchType() const;

	 






	  const RArray<TUid>& MediaIds() const;

	 






	  TMediaIdMatchType MediaIdMatchType() const;

	 






	  TUid InterfaceUid() const;

protected:

	 








	CMMFPluginSelectionParameters(TUid aPluginInterfaceUid);

	 








	TBool CheckMediaIdSupportL(const CMMFPluginImplementationInformation& aPlugin) const;
private:
	TUid iPluginInterfaceUid;
	HBufC* iPreferredSupplier;
	TPreferredSupplierMatchType iPreferredSupplierMatchType;
	RArray<TUid> iMediaIds;
	TMediaIdMatchType iMediaIdMatchType;
	};







 









class CMMFFormatSelectionParameters : public CBase
	{
public:
 



enum TMatchDataType
	{

	 

	EMatchAny,

	 

	EMatchFileExtension,

	 

	EMatchMimeType,

	 

	EMatchHeaderData
	};

public:
	
	 






	  static CMMFFormatSelectionParameters* NewL();

	 





	  static CMMFFormatSelectionParameters* NewLC();

	 






	static CMMFFormatSelectionParameters* NewL(const CMMFFormatSelectionParameters& aParams);

	 















	  void SetMatchToFileNameL(const TDesC& aFileName);

	 










	  void SetMatchToUriL(const TDesC& aUri);

	 







	  void SetMatchToMimeTypeL(const TDesC8& aMimeType);

	 








	  void SetMatchToHeaderDataL(const TDesC8& aHeaderData);

	 






	  const TDesC8& MatchData() const;

	 






	  TMatchDataType MatchDataType() const;

	 


	virtual ~CMMFFormatSelectionParameters();
protected:

	 


	CMMFFormatSelectionParameters();
	void ConstructL(const CMMFFormatSelectionParameters& aParams);
private:
	HBufC8* iMatchData;
	TMatchDataType iMatchDataType;
	};



 







class CMMFControllerPluginSelectionParameters : public CMMFPluginSelectionParameters
	{
public:

	 






	  static CMMFControllerPluginSelectionParameters* NewL();

	 






	  static CMMFControllerPluginSelectionParameters* NewLC();

	 












	  void SetRequiredPlayFormatSupportL(const CMMFFormatSelectionParameters& aRequiredSupport);

	 














	  void SetRequiredRecordFormatSupportL(const CMMFFormatSelectionParameters& aRequiredSupport);

	 









	  virtual void ListImplementationsL(RMMFControllerImplInfoArray& aImplementations) const;

	 


	virtual ~CMMFControllerPluginSelectionParameters();
protected:
	CMMFControllerPluginSelectionParameters();
	void MatchImplementationToSelectParamsL(RMMFControllerImplInfoArray& aImplementations, const CMMFControllerImplementationInformation& aPlugin, TInt& aArrayPos) const;
	TInt CheckPreferredSupplierL(RMMFControllerImplInfoArray& aImplementations, const CMMFControllerImplementationInformation& aPlugin) const;
	TBool CheckFormatSupportL(CMMFFormatSelectionParameters* aSelectParams, const RMMFFormatImplInfoArray& aFormats) const;
protected:
	 


	CMMFFormatSelectionParameters* iRequiredPlayFormatSupport;
	
	 


	CMMFFormatSelectionParameters* iRequiredRecordFormatSupport;
	};

 








class CMmfRecognizerUtil : public CBase
	{
public:
	enum TMatchLevel
		{
		EMatchNone,  
		EMatchData,  
		EMatchName   
		};
public:
	  static void GetMimeTypesL(CDesC8Array* aMimeTypes);

	  static CMmfRecognizerUtil* CMmfRecognizerUtil::NewL();
	~CMmfRecognizerUtil();
	  TMatchLevel GetMimeTypeL(const TDesC& aFileName, const TDesC8& aImageData, TDes8& aMimeType);

private:
	CMmfRecognizerUtil();
	void ConstructL();

private:
	class CBody;
	CBody* iBody;
	};





 











class CMMFFormatPluginSelectionParameters : public CMMFPluginSelectionParameters
	{
public:

	 









	  void ListImplementationsL(RMMFFormatImplInfoArray& aImplementations) const;

	 







	  void SetRequiredFormatSupportL(const CMMFFormatSelectionParameters& aRequiredSupport);

	 


	virtual ~CMMFFormatPluginSelectionParameters();
protected:
	 


	CMMFFormatPluginSelectionParameters(TUid aInterfaceUid);

	void MatchImplementationToSelectParamsL(RMMFFormatImplInfoArray& aImplementations, const CMMFFormatImplementationInformation& aPlugin, TInt& aArrayPos) const;
	TInt CheckPreferredSupplierL(RMMFFormatImplInfoArray& aImplementations, const CMMFFormatImplementationInformation& aPlugin) const;
	TBool CheckFormatSupportL(const CMMFFormatImplementationInformation& aPlugin) const;
protected:
	 


	CMMFFormatSelectionParameters* iRequiredFormatSupport;
	};

 







class CMMFFormatEncodePluginSelectionParameters : public CMMFFormatPluginSelectionParameters
	{
public:

	 






	  static CMMFFormatEncodePluginSelectionParameters* NewL();

	 






	  static CMMFFormatEncodePluginSelectionParameters* NewLC();
protected:
	 


	CMMFFormatEncodePluginSelectionParameters();
	};


 







class CMMFFormatDecodePluginSelectionParameters : public CMMFFormatPluginSelectionParameters
	{
public:

	 






	  static CMMFFormatDecodePluginSelectionParameters* NewL();

	 






	  static CMMFFormatDecodePluginSelectionParameters* NewLC();
protected:
	 


	CMMFFormatDecodePluginSelectionParameters();
	};



 







template <class T>
class CleanupResetAndDestroy
	{
public:
	 





	inline static void PushL(T& aRef);
private:
	static void ResetAndDestroy(TAny *aPtr);
	};
template <class T>
inline void CleanupResetAndDestroyPushL(T& aRef);
template <class T>
inline void CleanupResetAndDestroy<T>::PushL(T& aRef)
	{CleanupStack::PushL(TCleanupItem(&ResetAndDestroy,&aRef));}
template <class T>
void CleanupResetAndDestroy<T>::ResetAndDestroy(TAny *aPtr)
	{((static_cast< T* >( aPtr )) )->ResetAndDestroy();}
template <class T>
inline void CleanupResetAndDestroyPushL(T& aRef)
	{CleanupResetAndDestroy<T>::PushL(aRef);}



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmfplugininterfaceuids.hrh" 1
 
 
 
 





 











# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfcontroller.h" 2



 








const TUid KMMFErrorCategoryControllerGeneralError = {0x101F76D3};

 








const TUid KMMFEventCategoryPlaybackComplete = {0x101f7ea0};

 


const TUid KUidInterfaceMMFDataSinkHolder = {0x101F76D4};
 


const TUid KUidInterfaceMMFDataSourceHolder = {0x101F76D5};

 





const TUid KUidInterfaceMMFController = {0x101F4F47 };

 




enum TMMFControllerMessages
	{
	EMMFControllerAddDataSource,
	EMMFControllerAddDataSink,
	EMMFControllerRemoveDataSource,
	EMMFControllerRemoveDataSink,
	EMMFControllerReset,
	EMMFControllerPrime,
	EMMFControllerPlay,
	EMMFControllerPause,
	EMMFControllerStop,
	EMMFControllerGetPosition,
	EMMFControllerSetPosition,
	EMMFControllerGetDuration,
	EMMFControllerGetNumberOfMetaDataEntries,
	EMMFControllerGetSizeOfMetaDataEntry, 
	EMMFControllerGetMetaDataEntry,
	EMMFControllerSetPrioritySettings,
	EMMFControllerCancelAddDataSource,
	EMMFControllerCancelAddDataSink
	};



 










class RMMFController
	{
public:

	  RMMFController();

	  TInt Open(TUid aControllerUid, const TMMFPrioritySettings& aPrioritySettings);

	  TInt Open(const CMMFControllerImplementationInformation& aControllerInfo, const TMMFPrioritySettings& aPrioritySettings);

	  void Close();

	  TInt SetPrioritySettings(const TMMFPrioritySettings& aPrioritySettings) const;

	  TInt AddDataSource(TUid aSourceUid, const TDesC8& aSourceInitData);

	  TInt AddDataSink(TUid aSinkUid, const TDesC8& aSinkInitData);

	  TInt AddDataSource(TUid aSourceUid, const TDesC8& aSourceInitData, TMMFMessageDestination& aHandleInfo);

	  TInt AddDataSink(TUid aSinkUid, const TDesC8& aSinkInitData, TMMFMessageDestination& aHandleInfo);

	  void AddDataSource(const TMMFUidPckg& aSourceUid, const TDesC8& aSourceInitData, TMMFMessageDestinationPckg& aHandleInfoPckg, TRequestStatus& aStatus);

	  void CancelAddDataSource();
	
	  void AddDataSink(const TMMFUidPckg& aSinkUid, const TDesC8& aSinkInitData, TMMFMessageDestinationPckg& aHandleInfoPckg, TRequestStatus& aStatus);
	
	  void CancelAddDataSink();

	  TInt RemoveDataSource(const TMMFMessageDestination& aSourceHandleInfo);

	  TInt RemoveDataSink(const TMMFMessageDestination& aSinkHandleInfo);

	  TInt Reset();

	  TInt Prime();

	  TInt Play();

	  TInt Pause();

	  TInt Stop();

	  TInt GetPosition(TTimeIntervalMicroSeconds& aPosition) const;

	  TInt SetPosition(const TTimeIntervalMicroSeconds& aPosition) const;

	  TInt GetDuration(TTimeIntervalMicroSeconds& aDuration) const;

	  TInt GetNumberOfMetaDataEntries(TInt& aNumberOfEntries) const;

	  CMMFMetaDataEntry* GetMetaDataEntryL(TInt aIndex) const;

	  TInt CustomCommandSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom);

	  TInt CustomCommandSync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2);

	  void CustomCommandAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TDes8& aDataFrom, TRequestStatus& aStatus);

	  void CustomCommandAsync(const TMMFMessageDestinationPckg& aDestination, TInt aFunction, const TDesC8& aDataTo1, const TDesC8& aDataTo2, TRequestStatus& aStatus);

	  void ReceiveEvents(TMMFEventPckg& aEventPckg, TRequestStatus& aStatus);

	  TInt CancelReceiveEvents();

private:
	 


	RMMFControllerProxy iControllerProxy;

	 


	TMMFMessageDestinationPckg iDestinationPckg;
	};


 










class CMMFObject : public CBase
	{
friend class CMMFObjectContainer; 
public:
	  ~CMMFObject();

	  CMMFObject(TUid aInterfaceId);

	  const TMMFMessageDestination& Handle();

	  TBool operator==(const CMMFObject& aOther);

	 












	virtual void HandleRequest(TMMFMessage& aMessage) = 0;
private:
	void SetHandle(const TMMFMessageDestination& aNewHandle);
private:
	TMMFMessageDestination iHandle;
	};


 







class CMMFObjectContainer : public CBase
	{
public:

	  CMMFObjectContainer();

	  ~CMMFObjectContainer();

	  TInt AddMMFObject(CMMFObject& aObject);

	  void RemoveAndDestroyMMFObject(CMMFObject& aObject);

	  TInt FindMMFObject(const TMMFMessageDestination& aObjectHandle, CMMFObject*& aObjectFound);

	  void DeleteAllObjects();
private:
	 


	TInt FindMMFObject(const CMMFObject& aObject, TInt& aPositionInArray);

	 


	TInt GenerateObjectHandle();
private:
	 


	RPointerArray<CMMFObject> iObjects;

	 


	TInt iNextObjectHandle;
	};


 










class CMMFDataSourceHolder : public CMMFObject
	{
public:

	  CMMFDataSourceHolder(MDataSource& aDataSource);

	  ~CMMFDataSourceHolder();

	  MDataSource& DataSource();

	 
	  void HandleRequest(TMMFMessage& aMessage);
private:
	 


	MDataSource* iDataSource;
	};

 










class CMMFDataSinkHolder : public CMMFObject
	{
public:
	  CMMFDataSinkHolder(MDataSink& aDataSink);

	  ~CMMFDataSinkHolder();

	  MDataSink& DataSink();

	 
	  void HandleRequest(TMMFMessage& aMessage);

private:
	 


	MDataSink* iDataSink;
	};


 











class RMMFCustomCommandsBase
	{
public:

	  RMMFCustomCommandsBase(RMMFController& aController, TUid aInterfaceId);
protected:
	 






	RMMFController& iController;

	 





	TMMFMessageDestinationPckg iDestinationPckg;
	};

 















class CMMFCustomCommandParserBase : public CBase
	{
public:

	 









	virtual void HandleRequest(TMMFMessage& aMessage) = 0;

	 






	  TUid InterfaceId();

	 




	  ~CMMFCustomCommandParserBase();
protected:

	 









	  CMMFCustomCommandParserBase(TUid aInterfaceId);

private:

	 


	TUid iInterfaceId;
	};

 










class CMMFCustomCommandParserManager : public CBase
	{
public:
	 






	static CMMFCustomCommandParserManager* NewL();

	 






	~CMMFCustomCommandParserManager();

	 










	TBool HandleRequest(TMMFMessage& aMessage);

	 











	void AddCustomCommandParserL(CMMFCustomCommandParserBase& aParser);
private:
	CMMFCustomCommandParserManager();
private:
	 


	RPointerArray<CMMFCustomCommandParserBase> iParsers;
	};



 
















class CMMFController : public CBase
	{
public:

	 














	static CMMFController* NewL(TUid aControllerUid, MAsyncEventHandler& aEventHandler);

	 









	  virtual void HandleRequestL(TMMFMessage& aMessage);

	 


	  virtual ~CMMFController();
protected:

	 


	CMMFController(){};

	 

	 















	virtual void AddDataSourceL(MDataSource& aDataSource) = 0;

	 















	virtual void AddDataSinkL(MDataSink& aDataSink) = 0;

	 


















	virtual void RemoveDataSourceL(MDataSource& aDataSource) = 0;

	 


















	virtual void RemoveDataSinkL(MDataSink& aDataSink) = 0;

	 











	virtual void ResetL() = 0;

	 







	virtual void PrimeL() = 0;

	 







	  virtual void PrimeL(TMMFMessage& aMessage);

	 










	virtual void PlayL()= 0;

	 







	  virtual void PlayL(TMMFMessage& aMessage);


	 











	virtual void PauseL()= 0;

	 







	  virtual void PauseL(TMMFMessage& aMessage);

	 







	virtual void StopL()= 0;

	 







	  virtual void StopL(TMMFMessage& aMessage);

	 








	virtual TTimeIntervalMicroSeconds PositionL() const = 0;

	 









	virtual void SetPositionL(const TTimeIntervalMicroSeconds& aPosition) = 0;

	 








	virtual TTimeIntervalMicroSeconds DurationL() const = 0;

	 














	virtual void SetPrioritySettings(const TMMFPrioritySettings& aPrioritySettings) = 0;

	 




















	virtual void CustomCommand(TMMFMessage& aMessage)
		{aMessage.Complete(KErrNotSupported);}; 

	 








	virtual void GetNumberOfMetaDataEntriesL(TInt& aNumberOfEntries) = 0;

	 










	virtual CMMFMetaDataEntry* GetMetaDataEntryL(TInt aIndex) = 0;

	 

	 










	  TInt DoSendEventToClient(const TMMFEvent& aEvent);

	 









	  CMMFObjectContainer& MMFObjectContainerL();

	 















	  void AddCustomCommandParserL(CMMFCustomCommandParserBase& aParser);

private:
	 


	void ConstructL(MAsyncEventHandler& aEventHandler);
	 
	TBool DoAddDataSourceL(TMMFMessage& aMessage);
	TBool DoAddDataSinkL(TMMFMessage& aMessage);
	TBool DoRemoveDataSourceL(TMMFMessage& aMessage);
	TBool DoRemoveDataSinkL(TMMFMessage& aMessage);
	TBool DoResetL(TMMFMessage& aMessage);
	TBool DoPrimeL(TMMFMessage& aMessage);
	TBool DoPlayL(TMMFMessage& aMessage);
	TBool DoPauseL(TMMFMessage& aMessage);
	TBool DoStopL(TMMFMessage& aMessage);
	TBool DoGetPositionL(TMMFMessage& aMessage);
	TBool DoSetPositionL(TMMFMessage& aMessage);
	TBool DoGetDurationL(TMMFMessage& aMessage);
	TBool DoSetPrioritySettingsL(TMMFMessage& aMessage);
	void DoCustomCommand(TMMFMessage& aMessage);
	TBool DoGetNumberOfMetaDataEntriesL(TMMFMessage& aMessage);
	TBool DoGetSizeOfMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoGetMetaDataEntryL(TMMFMessage& aMessage);
private:
	 


	CBufFlat* iMetaDataBuffer;

	 


	TUid iDtor_ID_Key;

	 


	MAsyncEventHandler* iAsyncEventHandler;

	 


	CMMFObjectContainer* iMMFObjectContainer;

	 


	CMMFCustomCommandParserManager* iCustomCommandParserManager;
	};



 







class MMMFControllerEventMonitorObserver
	{
public:

	 







	virtual void HandleEvent(const TMMFEvent& aEvent) = 0;
	};

 








class CMMFControllerEventMonitor : public CActive
	{
public:

	 












	  static CMMFControllerEventMonitor* NewL(MMMFControllerEventMonitorObserver& aObserver,
		RMMFController& aMMFController);
	 


	~CMMFControllerEventMonitor();

	 






	  void Start();

private:
	 






	void RunL();

	 




	void DoCancel();

	 










	CMMFControllerEventMonitor(MMMFControllerEventMonitorObserver& aObserver,
		RMMFController& aMMFController);
private:
	MMMFControllerEventMonitorObserver& iObserver;
	RMMFController& iMMFController;
	TMMFEventPckg iEventPckg;
	};

 





class MMMFAddDataSourceSinkAsyncObserver
	{
public:
 








	virtual void MadssaoAddDataSourceSinkAsyncComplete(TInt aError, const TMMFMessageDestination& aHandle) = 0;
	};


 








class CMMFAddDataSourceSinkAsync : public CActive
	{
public:
 








	  static CMMFAddDataSourceSinkAsync* NewL(MMMFAddDataSourceSinkAsyncObserver& aObs);

 














	  void AddDataSource(RMMFController& aController, TUid aSourceUid, const TDesC8& aSourceInitData);

 














	  void AddDataSink(RMMFController& aController, TUid aSinkUid, const TDesC8& aSinkInitData);

 


	~CMMFAddDataSourceSinkAsync();

private:
	void RunL();
	void DoCancel();
	CMMFAddDataSourceSinkAsync(MMMFAddDataSourceSinkAsyncObserver& aObserver);
private:
	enum TCurrentAction {EIdle, EAddingDataSource, EAddingDataSink};
private:
	MMMFAddDataSourceSinkAsyncObserver& iObserver;
	TMMFMessageDestinationPckg iHandleInfoPckg;
	TCurrentAction iCurrentAction;
	RMMFController* iMMFController;
	HBufC8* iSourceSinkInitData;
	TMMFUidPckg iSourceSinkUidPckg;
	};


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfvideo.h" 1
 
 
 
 






class CFbsBitmap;

 








const TInt KMMFVariableVideoBitRate = -1;

 







const TInt KMMFNoMaxClipSize = -1;

 






const TUid KMMFEventCategoryVideoOpenComplete = {0x101F7F85};

 





const TUid KMMFEventCategoryVideoPrepareComplete = {0x101F7F86};

 



const TUid KMMFEventCategoryVideoLoadingStarted = {0x101F7F87};

 



const TUid KMMFEventCategoryVideoLoadingComplete = {0x101F7F88};

 



const TUid KMMFEventCategoryVideoPlayerGeneralError = {0x101F8000};

 



const TUid KMMFEventCategoryVideoRecorderGeneralError = {0x101F8001};


 







enum TVideoRotation
	{
	EVideoRotationNone,
	EVideoRotationClockwise90,
	EVideoRotationClockwise180,
	EVideoRotationClockwise270
	};

 






class TMMFVideoConfig
	{
public:
	inline TMMFVideoConfig();

public:
	 



	TBool						iAudioEnabled;
	 


	TPoint						iTopLeftPt;
	 


	TRect						iClipRect;
	 


	TInt						iBitmapHandle;
	 


	TInt						iFrameNumber;
	 


	TReal32						iFramesPerSecond;
	 


	TSize						iVideoFrameSize;
	 




	TInt						iVolume;
	 





	TInt						iMaxVolume;
	 


	TInt						iBalance;
	 



	TInt						iGain;
	 


	TInt						iMaxGain;
	 





	TInt						iMetaData;
	 


	TInt						iMaxFileSize;
	 


	TUint						iChannels;
	 


	TInt						iVideoBitRate;
	 


	TInt						iAudioBitRate;
	 


	TUid						iFormatUid;
	 


	TFourCC						iVideoCodec;
	 


	TFourCC						iAudioCodec;
	 


	TTimeIntervalMicroSeconds	iRampDuration;
	 


	TTimeIntervalMicroSeconds	iStartPosition;
	 


	TTimeIntervalMicroSeconds	iEndPosition;
	 


	TTimeIntervalMicroSeconds	iRecordTimeAvailable;
	 





	TInt						iFrameBitmapServerHandle;
	 


	TRect						iWindowRect;
	 


	TInt						iCameraHandle;
	 


	TInt						iDSAEvent;
	 


	TInt						iLoadingCompletePercentage;
	 


	TVideoRotation				iVideoRotation;
	 


	TReal32						iWidthScalePercentage;
	 


	TReal32						iHeightScalePercentage;
	 


	TBool						iAntiAliasFiltering;
	 


	TRect						iCropRectangle;
	};

 


inline TMMFVideoConfig::TMMFVideoConfig() {};

 











class MMMFVideoFrameMessage 
	{
public:
	 





	virtual void FrameReady(TInt aError) = 0;
	 




	virtual CFbsBitmap& GetBitmap() = 0;
	};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/caf/caf.h" 1
 








 






 
const TInt KErrCANotSupported  =(-17450);

 




const TInt KErrCANoPermission  =(-17451); 

 




const TInt KErrCANoRights      =(-17452); 

 




const TInt KErrCANoAgent       =(-17453);

 
const TInt KErrCAOutOfRange    =(-17454);

 



const TInt KErrCAPendingRights =(-17455);

 




const TInt KErrCASizeNotDetermined = (-17456);

 
const TInt KErrCAF32AgentAlreadyFound  =(-17457);


namespace ContentAccess
	{
	 
	enum TQosAttribute
		{
		 
		EQosBufferSize   = 0,
		 
		EQosAttrTop  
		};

	 


	enum TContentShareMode
		{
		EContentShareReadOnly      = 0,   
		EContentShareReadWrite     = 1,   
		EContentShareExclusive     = 2    
		};
		
		 



	enum TIntent
		{
		EPeek		= 0,	 
		EPlay		= 1,	 
		EView		= 2,	 
		EExecute	= 3,	 
		EPrint		= 4		 
		};

	 



	enum TAttribute
		{
		EIsProtected   = 0,  
		EIsForwardable = 1,
		EIsModifyable  = 2,
		EIsCopyable    = 3,
		ECanPlay       = 4,  
		ECanPrint      = 5,  
		ECanExecute    = 6,  
		ECanView       = 7,  
		ERightsNone    = 8,  
		ERightsPending = 9,  
		
		EAttrTop			 
		}; 

	 



	enum TOutputType
		{
		EContent					= 0,	 
		EReceipt					= 1      
		}; 

	 



	enum TMimeFields
		{
		EContentType				= 0,	 
		EContentLength				= 1,	 
		EContentId					= 2,     
		EContentTransferEncoding	= 3,     
		EBoundary					= 4,     
		EMimeMax				    		 
		}; 
	}


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mmf/common/mmfstandardcustomcommands.h" 2


class CMMFVideoFrameMessage;
class CFbsBitmap;
class CDesC8Array;

 



const TInt KPlaybackRateNormal = 1;

 





const TInt KMMFBalanceCenter = 0;

 





const TInt KMMFBalanceMaxLeft = -100;

 





const TInt KMMFBalanceMaxRight = 100;

 



const TInt KMMFVideoCurrentFrame = -1;

 



enum TMMFDSAEvent
	{
	EAbortDSA,
	EResumeDSA
	};

 





const TUid KUidInterfaceMMFAudioPlayDevice = {0x101F76D6};

 


enum TMMFAudioPlayDeviceMessages
	{
	EMMFAudioPlayDeviceSetVolume,
	EMMFAudioPlayDeviceGetMaxVolume,
	EMMFAudioPlayDeviceGetVolume,
	EMMFAudioPlayDeviceSetVolumeRamp,
	EMMFAudioPlayDeviceSetBalance,
	EMMFAudioPlayDeviceGetBalance
	};

 





const TUid KUidInterfaceMMFAudioRecordDevice = {0x101F76D7};

 


enum TMMFAudioRecordDeviceMessage
	{
	EMMFAudioRecordDeviceSetGain,
	EMMFAudioRecordDeviceGetMaxGain,
	EMMFAudioRecordDeviceGetGain,
	EMMFAudioRecordDeviceSetBalance,
	EMMFAudioRecordDeviceGetBalance
	};

 





const TUid KUidInterfaceMMFAudioPlayController = {0x101F76D8};

 


enum TMMFAudioPlayControllerMessages
	{
	EMMFAudioPlayControllerSetPlaybackWindow,
	EMMFAudioPlayControllerDeletePlaybackWindow,
	EMMFAudioPlayControllerGetLoadingProgress
	};

 





const TUid KUidInterfaceMMFAudioRecordController = {0x101F76D9};

 


enum TMMFAudioRecordControllerMessages
	{
	EMMFAudioRecordControllerGetRecordTimeAvailable,
	EMMFAudioRecordControllerSetMaxDuration,
	EMMFAudioRecordControllerSetMaxFileSize,
	EMMFAudioRecordControllerCrop,
	EMMFAudioRecordControllerAddMetaDataEntry,
	EMMFAudioRecordControllerRemoveMetaDataEntry,
	EMMFAudioRecordControllerReplaceMetaDataEntry
	};

 





const TUid KUidInterfaceMMFAudioController = {0x101F76DA};

 


enum TMMFAudioControllerMessages
	{
	EMMFAudioControllerSetSourceSampleRate,
	EMMFAudioControllerSetSourceNumChannels,
	EMMFAudioControllerSetSourceFormat,
	EMMFAudioControllerSetSourceBitRate,
	EMMFAudioControllerSetSourceDataType,
	EMMFAudioControllerSetSinkSampleRate,
	EMMFAudioControllerSetSinkNumChannels,
	EMMFAudioControllerSetSinkFormat,
	EMMFAudioControllerSetSinkBitRate,
	EMMFAudioControllerSetSinkDataType,
	EMMFAudioControllerGetSourceSampleRate,
	EMMFAudioControllerGetSourceBitRate,
	EMMFAudioControllerGetSourceNumChannels,
	EMMFAudioControllerGetSourceFormat,
	EMMFAudioControllerGetSourceDataType,
	EMMFAudioControllerGetSinkSampleRate,
	EMMFAudioControllerGetSinkBitRate,
	EMMFAudioControllerGetSinkNumChannels,
	EMMFAudioControllerGetSinkFormat,
	EMMFAudioControllerGetSinkDataType,
	EMMFAudioControllerGetSupportedSourceSampleRates,
	EMMFAudioControllerGetSupportedSourceBitRates,
	EMMFAudioControllerGetSupportedSourceNumChannels,
	EMMFAudioControllerGetSupportedSourceDataTypes,
	EMMFAudioControllerGetSupportedSinkSampleRates,
	EMMFAudioControllerGetSupportedSinkBitRates,
	EMMFAudioControllerGetSupportedSinkNumChannels,
	EMMFAudioControllerGetSupportedSinkDataTypes,
	EMMFAudioControllerCopyArrayData,
	EMMFAudioControllerSetCodec
	};


 



const TUid KUidInterfaceMMFVideoController = {0x101F76DB};

 


enum TMMFVideoControllerMessages
	{
	EMMFVideoControllerGetAudioCodec,
	EMMFVideoControllerGetVideoBitRate,
	EMMFVideoControllerGetAudioBitRate,
	EMMFVideoControllerGetVideoFrameSize,
	EMMFVideoControllerSetFrameRate,
	EMMFVideoControllerGetFrameRate,
	EMMFVideoControllerGetVideoMimeType
	};

 



const TUid KUidInterfaceMMFVideoPlayController = {0x101F7B73};

 


enum TMMFVideoPlayControllerMessages
	{
	EMMFVideoPlayControllerPrepare,
	EMMFVideoPlayControllerGetFrame,
	EMMFVideoPlayControllerSetDisplayWindow,
	EMMFVideoPlayControllerGetAudioEnabled,
	EMMFVideoPlayControllerUpdateDisplayRegion,
	EMMFVideoPlayControllerDSAEvent,
	EMMFVideoPlayControllerPlay,
	EMMFVideoPlayControllerRefreshFrame,
	EMMFVideoPlayControllerGetLoadingProgress,
	EMMFVideoPlayControllerSetRotation,
	EMMFVideoPlayControllerGetRotation,
	EMMFVideoPlayControllerSetScaleFactor,
	EMMFVideoPlayControllerGetScaleFactor,
	EMMFVideoPlayControllerSetCropRegion,
	EMMFVideoPlayControllerGetCropRegion
	};

 



const TUid KUidInterfaceMMFVideoRecordController = {0x101F7B74};

 


enum TMMFVideoRecordControllerMessages
	{
	EMMFVideoRecordControllerSetVideoFormat,
	EMMFVideoRecordControllerSetVideoCodec,
	EMMFVideoRecordControllerSetAudioCodec,
	EMMFVideoRecordControllerSetVideoBitRate,
	EMMFVideoRecordControllerSetAudioBitRate,
	EMMFVideoRecordControllerSetVideoFrameSize,
	EMMFVideoRecordControllerSetMaxFileSize,
	EMMFVideoRecordControllerAddMetaDataEntry,
	EMMFVideoRecordControllerRemoveMetaDataEntry,
	EMMFVideoRecordControllerReplaceMetaDataEntry,
	EMMFVideoRecordControllerSetAudioEnabled,
	EMMFVideoRecordControllerPrepare,
	EMMFVideoRecordControllerSetCameraHandle,
	EMMFVideoRecordControllerGetRecordTimeAvailable,
	EMMFVideoRecordControllerGetSupportedSinkAudioTypes,
	EMMFVideoRecordControllerGetSupportedSinkVideoTypes,
	EMMFVideoRecordControllerCopyDescriptorArrayData,
	EMMFVideoRecordControllerCopyFourCCArrayData,
	EMMFVideoRecordControllerGetAudioEnabled  
	};


 



const TUid KUidInterfaceMMFVideoDRMExt = {0x101F7C23};

 


enum TMMFDRMIntentMessages
	{
	EMMFVideoDRMExtGetFrame
	};



 









class RMMFAudioPlayDeviceCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFAudioPlayDeviceCustomCommands(RMMFController& aController);

	 









	  TInt SetVolume(TInt aVolume) const;

	 









	  TInt GetMaxVolume(TInt& aMaxVolume) const;

	 









	  TInt GetVolume(TInt& aVolume) const;

	 














	  TInt SetVolumeRamp(const TTimeIntervalMicroSeconds& aRampDuration) const;

	 










	  TInt SetBalance(TInt aBalance) const;

	 









	  TInt GetBalance(TInt& aBalance) const;
	};

 






class MMMFAudioPlayDeviceCustomCommandImplementor
	{
public:

	 










	virtual void MapdSetVolumeL(TInt aVolume) = 0;

	 










	virtual void MapdGetMaxVolumeL(TInt& aMaxVolume) = 0;

	 










	virtual void MapdGetVolumeL(TInt& aVolume) = 0;

	 















	virtual void MapdSetVolumeRampL(const TTimeIntervalMicroSeconds& aRampDuration) = 0;

	 











	virtual void MapdSetBalanceL(TInt aBalance) = 0;

	 










	virtual void MapdGetBalanceL(TInt& aBalance) = 0;
	};

 
































class CMMFAudioPlayDeviceCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 











	  static CMMFAudioPlayDeviceCustomCommandParser* NewL(MMMFAudioPlayDeviceCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioPlayDeviceCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioPlayDeviceCustomCommandParser(MMMFAudioPlayDeviceCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetVolumeL(TMMFMessage& aMessage);
	TBool DoGetMaxVolumeL(TMMFMessage& aMessage);
	TBool DoGetVolumeL(TMMFMessage& aMessage);
	TBool DoSetVolumeRampL(TMMFMessage& aMessage);
	TBool DoSetBalanceL(TMMFMessage& aMessage);
	TBool DoGetBalanceL(TMMFMessage& aMessage);
private:
	 
	MMMFAudioPlayDeviceCustomCommandImplementor& iImplementor;
	};

 










class RMMFAudioRecordDeviceCustomCommands : public RMMFCustomCommandsBase
	{
public:
	
	 







	  RMMFAudioRecordDeviceCustomCommands(RMMFController& aController);

	 









	  TInt SetGain(TInt aGain) const;

	 









	  TInt GetMaxGain(TInt& aMaxGain) const;

	 









	  TInt GetGain(TInt& aGain) const;

	 










	  TInt SetBalance(TInt aBalance) const;

	 









	  TInt GetBalance(TInt& aBalance) const;
	};

 






class MMMFAudioRecordDeviceCustomCommandImplementor
	{
public:

	 










	virtual void MardSetGainL(TInt aGain) = 0;

	 










	virtual void MardGetMaxGainL(TInt& aMaxGain) = 0;

	 










	virtual void MardGetGainL(TInt& aGain) = 0;

	 











	virtual void MardSetBalanceL(TInt aBalance) = 0;

	 










	virtual void MardGetBalanceL(TInt& aBalance) = 0;
	};

 
































class CMMFAudioRecordDeviceCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 











	  static CMMFAudioRecordDeviceCustomCommandParser* NewL(MMMFAudioRecordDeviceCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioRecordDeviceCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioRecordDeviceCustomCommandParser(MMMFAudioRecordDeviceCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetGainL(TMMFMessage& aMessage);
	TBool DoGetMaxGainL(TMMFMessage& aMessage);
	TBool DoGetGainL(TMMFMessage& aMessage);
	TBool DoSetBalanceL(TMMFMessage& aMessage);
	TBool DoGetBalanceL(TMMFMessage& aMessage);
private:
	 
	MMMFAudioRecordDeviceCustomCommandImplementor& iImplementor;
	};


 










class RMMFAudioPlayControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:
	
	 







	  RMMFAudioPlayControllerCustomCommands(RMMFController& aController);

	 












	  TInt SetPlaybackWindow(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) const;

	 





	  TInt DeletePlaybackWindow();

	 









	  TInt GetLoadingProgress(TInt& aPercentageProgress) const;
	};


 






class MMMFAudioPlayControllerCustomCommandImplementor
	{
public:

	 













	virtual void MapcSetPlaybackWindowL(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) = 0;

	 







	virtual void MapcDeletePlaybackWindowL() = 0;

	 










	virtual void MapcGetLoadingProgressL(TInt& aPercentageComplete) = 0;
	};

 
































class CMMFAudioPlayControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFAudioPlayControllerCustomCommandParser* NewL(MMMFAudioPlayControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioPlayControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioPlayControllerCustomCommandParser(MMMFAudioPlayControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetPlaybackWindowL(TMMFMessage& aMessage);
	TBool DoDeletePlaybackWindowL(TMMFMessage& aMessage);
	TBool DoGetLoadingProgressL(TMMFMessage& aMessage);
private:
	 


	MMMFAudioPlayControllerCustomCommandImplementor& iImplementor;
	};




 










class RMMFAudioRecordControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFAudioRecordControllerCustomCommands(RMMFController& aController);

	 









	  TInt GetRecordTimeAvailable(TTimeIntervalMicroSeconds& aTime) const;

	 









	  TInt SetMaxDuration(const TTimeIntervalMicroSeconds& aMaxDuration) const;

	 









	  TInt SetMaxFileSize(TInt aMaxSize) const;

	 











	  TInt Crop(TBool aToEnd);

	 







	  void AddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry);

	 









	  TInt RemoveMetaDataEntry(TInt aIndex);

	 









	  void ReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry);
	};

 






class MMMFAudioRecordControllerCustomCommandImplementor
	{
public:

	 










	virtual void MarcGetRecordTimeAvailableL(TTimeIntervalMicroSeconds& aTime) = 0;

	 










	virtual void MarcSetMaxDurationL(const TTimeIntervalMicroSeconds& aMaxDuration) = 0;

	 










	virtual void MarcSetMaxFileSizeL(TInt aMaxSize) = 0;

	 












	virtual void MarcCropL(TBool aToEnd) = 0;

	 







	virtual void MarcAddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry) = 0;

	 







	virtual void MarcRemoveMetaDataEntryL(TInt aIndex) = 0;

	 









	virtual void MarcReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry) = 0;
	};

 
































class CMMFAudioRecordControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFAudioRecordControllerCustomCommandParser* NewL(MMMFAudioRecordControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioRecordControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFAudioRecordControllerCustomCommandParser(MMMFAudioRecordControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoGetRecordTimeAvailableL(TMMFMessage& aMessage);
	TBool DoSetMaxDurationL(TMMFMessage& aMessage);
	TBool DoSetMaxFileSizeL(TMMFMessage& aMessage);
	TBool DoCropL(TMMFMessage& aMessage);
	TBool DoAddMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoRemoveMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoReplaceMetaDataEntryL(TMMFMessage& aMessage);
private:
	 


	MMMFAudioRecordControllerCustomCommandImplementor& iImplementor;
	};


 










class RMMFAudioControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 








	  RMMFAudioControllerCustomCommands(RMMFController& aController);

	 









	  TInt SetSourceSampleRate(TUint aSampleRate) const;

	 









	  TInt SetSourceBitRate(TUint aRate) const;

	 










	  TInt SetSourceNumChannels(TUint aNumChannels) const;

	 











	  TInt SetSourceFormat(TUid aFormatUid) const;

	 









	  TInt SetSourceDataType(TFourCC aDataType) const;

	 









	  TInt SetSinkSampleRate(TUint aSampleRate) const;

	 









	  TInt SetSinkBitRate(TUint aRate) const;

	 










	  TInt SetSinkNumChannels(TUint aNumChannels) const;

	 











	  TInt SetSinkFormat(TUid aFormatUid) const;

	 









	  TInt SetSinkDataType(TFourCC aDataType) const;

	 











	  TInt SetCodec(TFourCC aSourceDataType, TFourCC aSinkDataType) const;

	 









	  TInt GetSourceSampleRate(TUint& aRate) const;

	 









	  TInt GetSourceBitRate(TUint& aRate) const;

	 










	  TInt GetSourceNumChannels(TUint& aNumChannels) const;

	 











	  TInt GetSourceFormat(TUid& aFormat) const;

	 









	  TInt GetSourceDataType(TFourCC& aDataType) const;

	 









	  TInt GetSinkSampleRate(TUint& aRate) const;

	 









	  TInt GetSinkBitRate(TUint& aRate) const;

	 










	  TInt GetSinkNumChannels(TUint& aNumChannels) const;

	 











	  TInt GetSinkFormat(TUid& aFormat) const;

	 









	  TInt GetSinkDataType(TFourCC& aDataType) const;

	 











	  void GetSupportedSourceSampleRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSourceBitRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSourceNumChannelsL(RArray<TUint>& aSupportedChannels) const;

	 











	  void GetSupportedSourceDataTypesL(RArray<TFourCC>& aSupportedDataTypes) const;

	 











	  void GetSupportedSinkSampleRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSinkBitRatesL(RArray<TUint>& aSupportedRates) const;

	 











	  void GetSupportedSinkNumChannelsL(RArray<TUint>& aSupportedChannels) const;

	 











	  void GetSupportedSinkDataTypesL(RArray<TFourCC>& aSupportedDataTypes) const;

private:
	void DoGetUintArrayL(RArray<TUint>& aArray, TMMFAudioControllerMessages aIpc) const;
	void DoGetFourCCArrayL(RArray<TFourCC>& aArray, TMMFAudioControllerMessages aIpc) const;
	};


 






class MMMFAudioControllerCustomCommandImplementor
	{
public:

	 







	virtual void MacSetSourceSampleRateL(TUint aSampleRate) = 0;

	 







	virtual void MacSetSourceBitRateL(TUint aBitRate) = 0;

	 








	virtual void MacSetSourceNumChannelsL(TUint aNumChannels) = 0;

	 








	virtual void MacSetSourceFormatL(TUid aFormatUid) = 0;

	 







	virtual void MacSetSourceDataTypeL(TFourCC aDataType) = 0;

	 







	virtual void MacSetSinkSampleRateL(TUint aSampleRate) = 0;

	 







	virtual void MacSetSinkBitRateL(TUint aRate) = 0;

	 








	virtual void MacSetSinkNumChannelsL(TUint aNumChannels) = 0;

	 








	virtual void MacSetSinkFormatL(TUid aFormatUid) = 0;

	 







	virtual void MacSetSinkDataTypeL(TFourCC aDataType) = 0;

	 









	virtual void MacSetCodecL(TFourCC aSourceDataType, TFourCC aSinkDataType) = 0;


	 







	virtual void MacGetSourceSampleRateL(TUint& aRate) = 0;

	 







	virtual void MacGetSourceBitRateL(TUint& aRate) = 0;

	 








	virtual void MacGetSourceNumChannelsL(TUint& aNumChannels) = 0;

	 








	virtual void MacGetSourceFormatL(TUid& aFormat) = 0;

	 







	virtual void MacGetSourceDataTypeL(TFourCC& aDataType) = 0;

	 







	virtual void MacGetSinkSampleRateL(TUint& aRate) = 0;

	 







	virtual void MacGetSinkBitRateL(TUint& aRate) = 0;

	 








	virtual void MacGetSinkNumChannelsL(TUint& aNumChannels) = 0;

	 








	virtual void MacGetSinkFormatL(TUid& aFormat) = 0;

	 







	virtual void MacGetSinkDataTypeL(TFourCC& aDataType) = 0;

	 







	virtual void MacGetSupportedSourceSampleRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSourceBitRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSourceNumChannelsL(RArray<TUint>& aSupportedChannels) = 0;

	 









	virtual void MacGetSupportedSourceDataTypesL(RArray<TFourCC>& aSupportedDataTypes) = 0;

	 









	virtual void MacGetSupportedSinkSampleRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSinkBitRatesL(RArray<TUint>& aSupportedRates) = 0;

	 









	virtual void MacGetSupportedSinkNumChannelsL(RArray<TUint>& aSupportedChannels) = 0;

	 









	virtual void MacGetSupportedSinkDataTypesL(RArray<TFourCC>& aSupportedDataTypes) = 0;
	};

 
































class CMMFAudioControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFAudioControllerCustomCommandParser* NewL(MMMFAudioControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFAudioControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:
	 







	CMMFAudioControllerCustomCommandParser(MMMFAudioControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);

	TBool DoSetSourceSampleRateL(TMMFMessage& aMessage);
	TBool DoSetSourceNumChannelsL(TMMFMessage& aMessage);
	TBool DoSetSourceFormatL(TMMFMessage& aMessage);
	TBool DoSetSinkSampleRateL(TMMFMessage& aMessage);
	TBool DoSetSinkNumChannelsL(TMMFMessage& aMessage);
	TBool DoSetSinkFormatL(TMMFMessage& aMessage);
	TBool DoSetCodecL(TMMFMessage& aMessage);
	TBool DoSetSourceBitRateL(TMMFMessage& aMessage);
	TBool DoSetSourceDataTypeL(TMMFMessage& aMessage);
	TBool DoSetSinkBitRateL(TMMFMessage& aMessage);
	TBool DoSetSinkDataTypeL(TMMFMessage& aMessage);
	TBool DoGetSourceSampleRateL(TMMFMessage& aMessage);
	TBool DoGetSourceBitRateL(TMMFMessage& aMessage);
	TBool DoGetSourceNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSourceFormatL(TMMFMessage& aMessage);
	TBool DoGetSourceDataTypeL(TMMFMessage& aMessage);
	TBool DoGetSinkSampleRateL(TMMFMessage& aMessage);
	TBool DoGetSinkBitRateL(TMMFMessage& aMessage);
	TBool DoGetSinkNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSinkFormatL(TMMFMessage& aMessage);
	TBool DoGetSinkDataTypeL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceSampleRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceBitRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSupportedSourceDataTypesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkSampleRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkBitRatesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkNumChannelsL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkDataTypesL(TMMFMessage& aMessage);
	TBool DoCopyArrayDataL(TMMFMessage& aMessage);

	void DoCreateBufFromUintArrayL(RArray<TUint>& aArray);
	void DoCreateBufFromFourCCArrayL(RArray<TFourCC>& aArray);
private:
	 


	MMMFAudioControllerCustomCommandImplementor& iImplementor;

	CBufFlat* iDataCopyBuffer;
	};


class RWindow;

 










class RMMFVideoControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoControllerCustomCommands(RMMFController& aController);

	 









	  TInt GetVideoFrameSize(TSize& aVideoFrameSize) const;

	 









	  TInt GetAudioCodec(TFourCC& aCodec) const;

	 










	  TInt GetVideoBitRate(TInt& aBitRate) const;

	 









	  TInt GetAudioBitRate(TInt& aBitRate) const;

	 









	  TInt SetFrameRate(TReal32 aFramesPerSecond) const;

	 









	  TInt GetFrameRate(TReal32& aFramesPerSecond) const;

	 







	  TInt GetVideoMimeType(TDes8& aMimeType) const;
	};

 










class RMMFVideoPlayControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoPlayControllerCustomCommands(RMMFController& aController);

	 










	  TInt Prepare();

	 













	  void GetFrame(CFbsBitmap& aBitmap, TRequestStatus& aStatus);

	 











	  TInt SetDisplayWindow(const TRect& aWindowRect, const TRect& aClipRect) const;

	 









	  TInt UpdateDisplayRegion(const TRegion& aRegion) const;

	 









	  TInt GetAudioEnabled(TBool& aEnabled) const;

	 









	  TInt DirectScreenAccessEvent(const TMMFDSAEvent aDSAEvent) const;

	 











	  TInt Play(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) const;

	 






	  TInt RefreshFrame() const;

	 









	  TInt GetLoadingProgress(TInt& aPercentageProgress) const;

	 









	  TInt SetRotation(TVideoRotation aRotation) const;

	 









	  TInt GetRotation(TVideoRotation& aRotation) const;

	 















	  TInt SetScaleFactor(TReal32 aWidthPercentage, TReal32 aHeightPercentage, TBool aAntiAliasFiltering) const;

	 















	  TInt GetScaleFactor(TReal32& aWidthPercentage, TReal32& aHeightPercentage, TBool& aAntiAliasFiltering) const;

	 









	  TInt SetCropRegion(const TRect& aCropRegion) const;

	 










	  TInt GetCropRegion(TRect& aCropRegion) const;


private:
	TPckgBuf<TMMFVideoConfig> iConfigPackage;
	};

 










class RMMFVideoRecordControllerCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoRecordControllerCustomCommands(RMMFController& aController);

	 









	  TInt SetVideoFormat(TUid aVideoFormatUid) const;

	 









	  TInt SetVideoCodec(const TDesC8& aVideoCodec) const;

	 









	  TInt SetVideoBitRate(TInt aBitRate) const;

	 









	  TInt SetAudioBitRate(TInt aBitRate) const;

	 









	  TInt SetAudioCodec(TFourCC aAudioCodec) const;

	 









	  TInt SetVideoFrameSize(TSize aVideoFrameSize) const;

	 










	  TInt SetMaxFileSize(TInt aMaxSize) const;

	 









	  void AddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry)const;

	 









	  TInt RemoveMetaDataEntry(TInt aIndex)const;

	 









	  void ReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry)const;

	 









	  TInt SetAudioEnabled(TBool aEnable) const;

	 







	  TInt Prepare() const;

	 









	  TInt SetCameraHandle(TInt aCameraHandle) const;

	 









	  TInt GetRecordTimeAvailable(TTimeIntervalMicroSeconds& aTime) const;

	 







	  TInt GetSupportedSinkAudioTypes(RArray<TFourCC>& aSupportedDataTypes) const;

	 







	  TInt GetSupportedSinkVideoTypes(CDesC8Array& aDataTypes) const;

	 
	 









	  TInt GetAudioEnabled(TBool& aEnabled) const;

private:
	void DoGetCDesC8ArrayL(CDesC8Array& aArray, TMMFVideoRecordControllerMessages aIpc) const;
	void DoGetFourCCArrayL(RArray<TFourCC>& aArray) const;
	};



 






class MMMFVideoRecordControllerCustomCommandImplementor
	{
public:

	 









	virtual void MvrcSetVideoFormatL(TUid aVideoFormatUid)=0;

	 









	virtual void MvrcSetVideoCodecL(const TDesC8& aVideoCodec)=0;

	 









	virtual void MvrcSetAudioCodecL(TFourCC aAudioCodec)=0;

	 










	virtual void MvrcSetVideoBitRateL(TInt& aBitRate)=0;

	 









	virtual void MvrcSetAudioBitRateL(TInt& aBitRate)=0;

	 







	virtual void MvrcAddMetaDataEntryL(const CMMFMetaDataEntry& aNewEntry)=0;

	 







	virtual void MvrcRemoveMetaDataEntryL(TInt aIndex)=0;

	 









	virtual void MvrcReplaceMetaDataEntryL(TInt aIndex, const CMMFMetaDataEntry& aNewEntry)=0;

	 








	virtual void MvrcSetMaxFileSizeL(TInt aMaxFileSize)=0;

	 







	virtual void MvrcSetAudioEnabledL(TBool aEnable)=0;

	 







	virtual void MvrcSetVideoFrameSizeL(TSize aFrameSize)=0;

	 





	virtual void MvrcPrepareL()=0;

	 




	virtual void MvrcSetCameraHandleL(TInt aCameraHandle)=0;

	 







	virtual void MvrcGetRecordTimeAvailableL(TTimeIntervalMicroSeconds& aTime) = 0;

	 









	virtual void MvrcGetSupportedSinkAudioTypesL(RArray<TFourCC>& aDataTypes)=0;

	 









	virtual void MvrcGetSupportedSinkVideoTypesL(CDesC8Array& aDataTypes)=0;

	 
	 







	virtual void MvrcGetAudioEnabledL(TBool& aEnabled)=0;
	};


 










class MMMFVideoPlayControllerCustomCommandImplementor
	{
public:

	 










	virtual void MvpcPrepare()=0;

	 







	virtual void MvpcGetFrameL(MMMFVideoFrameMessage& aVideoFrame)=0;

	 







	virtual void MvpcGetAudioEnabledL(TBool& aEnabled)=0;

	 







	virtual void MvpcSetDisplayWindowL(const TRect& aWindowRect, const TRect& aClipRect) = 0;

	 








	virtual void MvpcUpdateDisplayRegionL(const TRegion& aRegion) = 0;

	 









	virtual void MvpcDirectScreenAccessEventL(const TMMFDSAEvent aDSAEvent) = 0;

	 









	virtual void MvpcPlayL(const TTimeIntervalMicroSeconds& aStart, const TTimeIntervalMicroSeconds& aEnd) = 0;
	
	 




	virtual void MvpcRefreshFrameL() = 0;

	 







	virtual void MvpcGetLoadingProgressL(TInt& aPercentageComplete) = 0;

	 







	virtual void MvpcSetRotationL(TVideoRotation aRotation) = 0;

	 







	virtual void MvpcGetRotationL(TVideoRotation& aRotation) = 0;

	 














	virtual void MvpcSetScaleFactorL(TReal32 aWidthPercentage, TReal32 aHeightPercentage, TBool aAntiAliasFiltering) = 0;

	 














	virtual void MvpcGetScaleFactorL(TReal32& aWidthPercentage, TReal32& aHeightPercentage, TBool& aAntiAliasFiltering) = 0;

	 







	virtual void MvpcSetCropRegionL(const TRect& aCropRegion) = 0;

	 








	virtual void MvpcGetCropRegionL(TRect& aCropRegion) = 0;
	};



 






class MMMFVideoControllerCustomCommandImplementor
	{
public:

	 







	virtual void MvcGetVideoFrameSizeL(TSize& aVideoFrameSize)=0;

	 







	virtual void MvcGetAudioCodecL(TFourCC& aCodec)=0;

	 








	virtual void MvcGetVideoBitRateL(TInt& aBitRate)=0;

	 







	virtual void MvcGetAudioBitRateL(TInt& aBitRate)=0;

	 







	virtual void MvcSetFrameRateL(TReal32 aFramesPerSecond)=0;

	 







	virtual void MvcGetFrameRateL(TReal32& aFramesPerSecond)=0;

	 







	virtual void MvcGetVideoMimeTypeL(TDes8& aMimeType)=0;
	};


 

































class CMMFVideoControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoControllerCustomCommandParser* NewL(MMMFVideoControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:

	 







	CMMFVideoControllerCustomCommandParser(MMMFVideoControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoGetAudioCodecL(TMMFMessage& aMessage);

	TBool DoGetAudioBitRateL(TMMFMessage& aMessage);
	TBool DoGetVideoBitRateL(TMMFMessage& aMessage);
	TBool DoGetVideoFrameSizeL(TMMFMessage& aMessage);
	TBool DoSetFrameRateL(TMMFMessage& aMessage);
	TBool DoGetFrameRateL(TMMFMessage& aMessage);
	TBool DoGetVideoMimeTypeL(TMMFMessage& aMessage);
private:
	 


	MMMFVideoControllerCustomCommandImplementor& iImplementor;
	};

 










class CMMFVideoPlayControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoPlayControllerCustomCommandParser* NewL(MMMFVideoPlayControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoPlayControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:
	 







	CMMFVideoPlayControllerCustomCommandParser(MMMFVideoPlayControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoRequestFrameL(TMMFMessage& aMessage);
	TBool DoGetFrameL(TMMFMessage& aMessage);
	TBool DoSetDisplayWindowL(TMMFMessage& aMessage);
	TBool DoUpdateDisplayRegionL(TMMFMessage& aMessage);
	TBool DoGetAudioEnabledL(TMMFMessage& aMessage);
	TBool DoDirectScreenAccessEventL(TMMFMessage& aMessage);
	TBool DoPlayL(TMMFMessage& aMessage);
	TBool DoRefreshFrameL(TMMFMessage& aMessage);
	TBool DoGetLoadingProgressL(TMMFMessage& aMessage);
	TBool DoPrepareL(TMMFMessage& aMessage);
	TBool DoSetRotationL(TMMFMessage& aMessage);
	TBool DoGetRotationL(TMMFMessage& aMessage);
	TBool DoSetScaleFactorL(TMMFMessage& aMessage);
	TBool DoGetScaleFactorL(TMMFMessage& aMessage);
	TBool DoSetCropRegionL(TMMFMessage& aMessage);
	TBool DoGetCropRegionL(TMMFMessage& aMessage);


private:
	 


	MMMFVideoPlayControllerCustomCommandImplementor& iImplementor;
	CMMFVideoFrameMessage* iVideoFrameMessage;
	};

 










class CMMFVideoRecordControllerCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoRecordControllerCustomCommandParser* NewL(MMMFVideoRecordControllerCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoRecordControllerCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);
private:
	 







	CMMFVideoRecordControllerCustomCommandParser(MMMFVideoRecordControllerCustomCommandImplementor& aImplementor);
	 
	void DoHandleRequestL(TMMFMessage& aMessage);
	TBool DoSetVideoFormatL(TMMFMessage& aMessage);
	TBool DoSetAudioBitRateL(TMMFMessage& aMessage);
	TBool DoSetVideoBitRateL(TMMFMessage& aMessage);
	TBool DoSetVideoCodecL(TMMFMessage& aMessage);
	TBool DoSetAudioCodecL(TMMFMessage& aMessage);
	TBool DoAddMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoRemoveMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoReplaceMetaDataEntryL(TMMFMessage& aMessage);
	TBool DoSetMaxFileSizeL(TMMFMessage& aMessage);
	TBool DoSetAudioEnabledL(TMMFMessage& aMessage);
	TBool DoSetVideoFrameSizeL(TMMFMessage& aMessage);
	TBool DoPrepareL(TMMFMessage& aMessage);
	TBool DoSetCameraHandleL(TMMFMessage& aMessage);
	TBool DoGetRecordTimeAvailableL(TMMFMessage& aMessage);

	TBool DoGetSupportedSinkAudioTypesL(TMMFMessage& aMessage);
	TBool DoGetSupportedSinkVideoTypesL(TMMFMessage& aMessage);

	TInt32 DoCreateBufFromCDesC8ArrayL(CDesC8Array& aArray);
	TBool DoCopyCDesC8ArrayDataL(TMMFMessage& aMessage);

	TBool DoCopyFourCCArrayDataL(TMMFMessage& aMessage);
	void DoCreateBufFromFourCCArrayL(RArray<TFourCC>& aArray);
	TBool DoGetAudioEnabledL(TMMFMessage& aMessage);  

private:
	 


	MMMFVideoRecordControllerCustomCommandImplementor& iImplementor;
	CBufFlat* iDataCopyBuffer;
	};



 










class RMMFVideoDRMExtCustomCommands : public RMMFCustomCommandsBase
	{
public:

	 







	  RMMFVideoDRMExtCustomCommands(RMMFController& aController);

	 









	  void GetFrame(CFbsBitmap& aBitmap, ContentAccess::TIntent aIntent, TRequestStatus& aStatus);

private:
	TPckgBuf<TMMFVideoConfig> iConfigPackage;
	TPckgBuf<ContentAccess::TIntent> iIntentPackage;
	};



 






class MMMFVideoDRMExtCustomCommandImplementor
	{
public:

	 







	virtual void MvdeGetFrameL(MMMFVideoFrameMessage& aVideoFrame, ContentAccess::TIntent aIntent)=0;
	};


 








class CMMFVideoDRMExtCustomCommandParser : public CMMFCustomCommandParserBase
	{
public:

	 









	  static CMMFVideoDRMExtCustomCommandParser* NewL(MMMFVideoDRMExtCustomCommandImplementor& aImplementor);

	 




	  ~CMMFVideoDRMExtCustomCommandParser();

	 







	void HandleRequest(TMMFMessage& aMessage);

private:
	 






	CMMFVideoDRMExtCustomCommandParser(MMMFVideoDRMExtCustomCommandImplementor& aImplementor);
	 

	void DoGetFrameL(TMMFMessage& aMessage);

private:
	MMMFVideoDRMExtCustomCommandImplementor& iImplementor;
	CMMFVideoFrameMessage* iVideoFrameMessage;
	};




# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mdaaudiooutputstream.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/utility.h" 1
 
 
 
 
 





 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/port.h" 1
 
 
 
 




 


 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/base.h" 1
 
 
 
 




 


 


 



enum { KDummyMdaSessionNotImplemented = 0 };

 



enum { KMediaServerNotImplemented = 0 };

 



enum { KDummyMdaObjectNotImplemented = 0 };

 





  TInt StartMediaServer();
  void StartMediaServerL();
  void StartMediaServer(TRequestStatus& aStatus);

class RDummyMdaObject;

 






class RDummyMdaSession : public RSessionBase
	{
public:
	  TInt Connect(TInt aSlots=KMdaServerDefaultMessageSlots);
	  void ConnectL(TInt aSlots=KMdaServerDefaultMessageSlots);
	  void ConnectLC(TInt aSlots=KMdaServerDefaultMessageSlots);
	 
	  void Close();
	 
	  TInt ListenTo(const RDummyMdaObject& aObject);
	  void ListenToL(const RDummyMdaObject& aObject);
	  void StopListeningTo(const RDummyMdaObject& aObject);
	 
	  TInt SetListenerParameters(TMdaEventPackage& aPackage,TInt aMaxPackages);
	  void SetListenerParametersL(TMdaEventPackage& aPackage,TInt aMaxPackages);
	 
	  void GetListenerEvents(TMdaEventPackage& aEvents, TRequestStatus& aStatus);
	  void CancelGetListenerEvents();
private:
	friend class RDummyMdaObject;
	};

class RMdaRegistry;

 






class RDummyMdaObject
	{
public:
      void Close();
protected:
	 
	  TInt SynchCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TAny* aArg= 0L );
	  void SynchCreateMessageL(const RDummyMdaObject& aParent,TInt16 aFunction,TAny* aArg= 0L );
	  void SynchCreateMessageLC(const RDummyMdaObject& aParent,TInt16 aFunction,TAny* aArg= 0L );
	  void AsynchCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TRequestStatus &aStatus,TAny* aArg= 0L );
	  TInt SynchPackageCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TMdaOpenPackage& aPackage);
	  void SynchPackageCreateMessageL(const RDummyMdaObject& aParent,TInt16 aFunction,TMdaOpenPackage& aPackage);
	  void SynchPackageCreateMessageLC(const RDummyMdaObject& aParent,TInt16 aFunction,TMdaOpenPackage& aPackage);
	  void AsynchPackageCreateMessage(const RDummyMdaObject& aParent,TInt16 aFunction,TRequestStatus &aStatus,TMdaOpenPackage& aPackage);
	  void CancelCreateMessage( TRequestStatus &aStatus);
	 
	  TInt BlindMessage(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  void BlindMessageL(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  TInt SynchMessage(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  void SynchMessageL(TInt16 aFunction,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ,const TAny* aArg3= 0L ) const;
	  void AsynchMessage(TInt16 aFunction,TRequestStatus &aStatus,const TAny* aArg1= 0L ,const TAny* aArg2= 0L ) const;
	  void CancelMessage( TRequestStatus &aStatus) const;
	 
	  TInt SynchPackage(TInt16 aFunction,const TMdaRawPackage& aPackage) const;
	  void SynchPackageL(TInt16 aFunction,const TMdaRawPackage& aPackage) const;
	  void AsynchPackage(TInt16 aFunction,TRequestStatus &aStatus,const TMdaRawPackage& aPackage) const;
	  TInt SynchPackageReturn(TInt16 aFunction,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
	  void SynchPackageReturnL(TInt16 aFunction,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
	  void SynchPackageReturnLC(TInt16 aFunction,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
	  void AsynchPackageReturn(TInt16 aFunction,TRequestStatus &aStatus,const TMdaReturnPackage& aArgPackage,TMdaRawPackage*& aReturn) const;
private:
	RDummyMdaSession iSession;
	TPckgBuf<TInt> iObjectHandle;
	friend class RMdaRegistry;
	friend class RMdaTimer;
	friend class RMdaTimerFactory;
	};


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/port.h" 2



 





class RMdaPort : public RDummyMdaObject
	{
	};

 





class RMdaSrcPort : public RMdaPort
	{  
	};

 





class RMdaDstPort : public RMdaPort
	{  
	};


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mda/client/utility.h" 2


 



enum {
	KDummyMdaControllerNotImplemented = 0,
	KDummyMdaServerNotImplemented,
	KDummyMdaResourceNotImplemented
	};

 
 

 





class MMdaObjectEventListener
	{
public:

	 




	virtual const RDummyMdaObject& MoelObject() const =0;

	 







	virtual void MoelEvent(const TMdaEvent& aEvent) =0;

	 



	virtual void MoelEventMissed() =0;
	friend class CMdaServer;
	};

 





class CMdaServer : public CBase
	{
public:
	  static CMdaServer* NewL();
	  ~CMdaServer();
	  void AddListenerL(MMdaObjectEventListener& aListener);
	  void RemoveListener(MMdaObjectEventListener& aListener);
	};

 













class MMdaObjectStateChangeObserver
	{
public:
	virtual void MoscoStateChangeEvent(CBase* aObject, TInt aPreviousState, TInt aCurrentState, TInt aErrorCode)=0;
	};

 




class MDummyMdaSrcPort
	{
public:
	virtual const RMdaSrcPort& MspSrcPort()=0;
	};

 




class MDummyMdaDstPort
	{
public:
	virtual const RMdaDstPort& MdpDstPort()=0;
	};

 




class CDummyMdaResource : public CActive, public MDummyMdaSrcPort, public MDummyMdaDstPort
	{
protected:
	  CDummyMdaResource(TInt aPriority);
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/mdaaudiooutputstream.h" 2



 









class MMdaAudioOutputStreamCallback 
	{
public:

	 






	virtual void MaoscOpenComplete(TInt aError) = 0;

	 














	virtual void MaoscBufferCopied(TInt aError, const TDesC8& aBuffer) = 0;

	 









	virtual void MaoscPlayComplete(TInt aError) = 0;
	};


class CMMFMdaAudioOutputStream;

 
































class CMdaAudioOutputStream : public CBase
	{
public:

	 












	  static CMdaAudioOutputStream* NewL(MMdaAudioOutputStreamCallback& aCallBack,
												CMdaServer* aServer = 0L );

	 




















	  static CMdaAudioOutputStream* NewL(MMdaAudioOutputStreamCallback& aCallBack,
												TInt aPriority,
												TMdaPriorityPreference aPref = EMdaPriorityPreferenceTimeAndQuality);


	 




	~CMdaAudioOutputStream();

	 







	virtual void SetAudioPropertiesL(TInt aSampleRate, TInt aChannels);

	 










	virtual void Open(TMdaPackage* aSettings);

	 




	virtual TInt MaxVolume();

	 




	virtual TInt Volume();

	 







	virtual void SetVolume(const TInt aNewVolume);

	 

















	virtual void SetPriority(TInt aPriority, TMdaPriorityPreference aPref);
	
	 











	virtual void WriteL(const TDesC8& aData);

	 


	virtual void Stop();

	 




	virtual const TTimeIntervalMicroSeconds& Position();

	 





	  void SetBalanceL(TInt aBalance = KMMFBalanceCenter);
	
	 




	  TInt GetBalanceL() const;

	 




	  TInt GetBytes();

	 









      void SetDataTypeL(TFourCC aAudioType);

	 




	  TFourCC DataType() const;


private:
	CMdaAudioOutputStream();
private:
	 


	CMMFMdaAudioOutputStream* iProperties;
	};


# 74 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2




# 1 "/home/andrew/Projects/ayfly/src/libayfly/z80ex/include/z80ex.h" 1
 











# 1 "/home/andrew/Projects/ayfly/src/libayfly/z80ex/include/z80ex_common.h" 1
 











 
 









# 44 "/home/andrew/Projects/ayfly/src/libayfly/z80ex/include/z80ex_common.h"

typedef unsigned char Z80EX_BYTE;
typedef signed char Z80EX_SIGNED_BYTE;
typedef unsigned short Z80EX_WORD;
typedef unsigned int Z80EX_DWORD;



# 13 "/home/andrew/Projects/ayfly/src/libayfly/z80ex/include/z80ex.h" 2


typedef
enum {regAF,regBC,regDE,regHL,regAF_,regBC_,regDE_,regHL_,regIX,regIY,regPC,regSP,regI,regR,regR7,regIM ,regIFF1,regIFF2}
Z80_REG_T;



struct _z80_cpu_context;
typedef struct _z80_cpu_context Z80EX_CONTEXT;



 

 
typedef void (*z80ex_tstate_cb)(Z80EX_CONTEXT *cpu, void *user_data);

 

typedef Z80EX_BYTE (*z80ex_mread_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD addr, int m1_state, void *user_data);

 
typedef void (*z80ex_mwrite_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD addr, Z80EX_BYTE value, void *user_data);

 
typedef Z80EX_BYTE (*z80ex_pread_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD port, void *user_data);

 
typedef void (*z80ex_pwrite_cb)(Z80EX_CONTEXT *cpu, Z80EX_WORD port, Z80EX_BYTE value, void *user_data);

 
typedef Z80EX_BYTE (*z80ex_intread_cb)(Z80EX_CONTEXT *cpu, void *user_data);




 
extern Z80EX_CONTEXT *z80ex_create(z80ex_mread_cb mrcb_fn, void *mrcb_data,
	z80ex_mwrite_cb mwcb_fn, void *mwcb_data,
	z80ex_pread_cb prcb_fn, void *prcb_data,
	z80ex_pwrite_cb pwcb_fn, void *pwcb_data,
	z80ex_intread_cb ircb_fn, void *ircb_data);

 
extern void z80ex_destroy(Z80EX_CONTEXT *cpu);

 
extern int z80ex_step(Z80EX_CONTEXT *cpu);

 

extern Z80EX_BYTE z80ex_last_op_type(Z80EX_CONTEXT *cpu);

 
extern void z80ex_set_tstate_callback(Z80EX_CONTEXT *cpu, z80ex_tstate_cb cb_fn, void *user_data);

 
 
extern int z80ex_int(Z80EX_CONTEXT *cpu);

 
 

extern int z80ex_nmi(Z80EX_CONTEXT *cpu);

 
extern void z80ex_reset(Z80EX_CONTEXT *cpu);

 
extern Z80EX_WORD z80ex_get_reg(Z80EX_CONTEXT *cpu, Z80_REG_T reg);

 
extern void z80ex_set_reg(Z80EX_CONTEXT *cpu, Z80_REG_T reg, Z80EX_WORD value);

 
extern int z80ex_doing_halt(Z80EX_CONTEXT *cpu);

 

extern int z80ex_op_tstate(Z80EX_CONTEXT *cpu);

 

extern void z80ex_w_states(Z80EX_CONTEXT *cpu, unsigned w_states);

 


extern void z80ex_next_t_state(Z80EX_CONTEXT *cpu);





# 78 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 90 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h"

















struct AYSongInfo;

typedef void (*ELAPSED_CALLBACK)(void *arg);
typedef void (*PLAYER_INIT_PROC)(AYSongInfo &info);
typedef void (*PLAYER_PLAY_PROC)(AYSongInfo &info);
typedef void (*PLAYER_CLEANUP_PROC)(AYSongInfo &info);

# 1 "/home/andrew/Projects/ayfly/src/libayfly/ay.h" 1
 






















enum
{
    AY_CHNL_A_FINE = 0,
    AY_CHNL_A_COARSE,
    AY_CHNL_B_FINE,
    AY_CHNL_B_COARSE,
    AY_CHNL_C_FINE,
    AY_CHNL_C_COARSE,
    AY_NOISE_PERIOD,
    AY_MIXER,
    AY_CHNL_A_VOL,
    AY_CHNL_B_VOL,
    AY_CHNL_C_VOL,
    AY_ENV_FINE,
    AY_ENV_COARSE,
    AY_ENV_SHAPE,
    AY_GPIO_A,
    AY_GPIO_B
};

class ay
{
public:
    ay(AYSongInfo *info);
    ~ay();
    void ayReset();
    void ayWrite(unsigned char reg, unsigned char val);
    unsigned char ayRead(unsigned char reg);
    void ayProcess(unsigned char *stream, unsigned long len);
    void ayProcessMono(unsigned char *stream, unsigned long len);
    inline void chnlMute(unsigned long chnl, bool mute)
    {
        chnl_mute[chnl] = !mute;
    }
    ;
    inline bool chnlMuted(unsigned long chnl)
    {
        return chnl_mute[chnl];
    }
    ;
    inline float GetVolume(unsigned long chnl)
    {
        return volume[chnl];
    }
    ;
    inline void SetVolume(unsigned long chnl, float new_volume)
    {
        volume[chnl] = new_volume;
    }
    ;
    inline const unsigned char *GetRegs()
    {
        return regs;
    };

    void SetParameters();
private:
    static const float init_levels[16];
    float levels[16];
    unsigned char regs[16];
    long noise_period;
    long chnl_period[3];
    float chnl_vol[3];
    bool chnl_enable[3];
    long tone_period_init[3];
    long noise_period_init;
    long chnl_trigger[3];
    bool noise_enable[3];
    unsigned long noise_trigger;
    unsigned long noise_reg;
    long env_period_init;
    long env_period;
    unsigned long env_type;
    unsigned long env_tick;
    unsigned long env_vol;
    long env_trigger;
    bool chnl_mute[3];
    unsigned long ay_tacts;
    void setEnvelope();
    void updateEnvelope();
    float volume[3];
    unsigned long int_counter;
    unsigned long int_limit;
    AYSongInfo *songinfo;
};



# 114 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2

# 1 "/home/andrew/Projects/ayfly/src/libayfly/AbstractAudio.h" 1
 






















class AbstractAudio
{
public:
    AbstractAudio(unsigned long _sr, AYSongInfo *info);
    virtual ~AbstractAudio();
    virtual bool Start(void) = 0;
    virtual void Stop() = 0;
    virtual void WriteAy(unsigned char reg, unsigned char val)
    {
        ay8910->ayWrite(reg, val);
    }
    ;
    unsigned char ReadAy(unsigned char reg)
    {
        return ay8910->ayRead(reg);
    }
    ;
    void ResetAy()
    {
        ay8910->ayReset();
    }
    ;
    inline virtual void ChnlMute(unsigned long chnl, bool mute)
    {
        if(ay8910)
            ay8910->chnlMute(chnl, mute);
    }
    ;
    inline virtual bool ChnlMuted(unsigned long chnl)
    {
        return ay8910 ? ay8910->chnlMuted(chnl) : true;
    }
    ;
    bool Started()
    {
        return started;
    }
    ;
    inline float GetVolume(unsigned long chnl)
    {
        return ay8910 ? ay8910->GetVolume(chnl) : 0;
    }
    ;
    inline void SetVolume(unsigned long chnl, float new_volume)
    {
        if(ay8910)
        {
            ay8910->SetVolume(chnl, new_volume);
        }
    }
    ;
    inline const unsigned char *GetAYRegs(unsigned long chip_num = 0)
    {
        return ay8910 ? ay8910->GetRegs() : 0;
    }
    ;
    inline void GetAYBuffer(unsigned char *buffer, unsigned long buffer_length, unsigned long chip_num = 0)
    {
        ay8910->ayProcess(buffer, buffer_length);
    }
    ;
    inline void GetAYBufferMono(unsigned char *buffer, unsigned long buffer_length, unsigned long chip_num = 0)
    {
        ay8910->ayProcessMono(buffer, buffer_length);
    }
    ;
    inline void SetAYParameters()
    {
        ay8910->SetParameters();
    }
    ;
protected:
    unsigned long sr;
    bool started;
    AYSongInfo *songinfo;
    ay *ay8910;
};


# 115 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2


struct AYSongInfo
{





    TFileName Author;
    TFileName Name;
    TFileName FilePath;

    unsigned long Length;  
    unsigned long Loop;  
    bool bEmul;  
    PLAYER_INIT_PROC init_proc;  
    PLAYER_PLAY_PROC play_proc;  
    PLAYER_CLEANUP_PROC cleanup_proc;  
    void *data;  
    unsigned char *module;  
    unsigned char *file_data;  
    unsigned char z80IO [65536];  
    unsigned long file_len;  
    AbstractAudio *player;  
    Z80EX_CONTEXT *z80ctx;  
    unsigned long timeElapsed;  
    ELAPSED_CALLBACK callback;  
    void *callback_arg;  
    unsigned short ay_reg;  
    unsigned long z80_freq;  
    unsigned long ay_freq;  
    unsigned long int_freq;  
    unsigned long sr;  
    ~AYSongInfo();
};









# 1 "/home/andrew/Projects/ayfly/src/libayfly/s60/ayfly_s60Audio.h" 1
















class Cayfly_s60Sound;

class CCommandHandler: public CActive
{
public:
      static CCommandHandler* NewL();
      ~CCommandHandler();
    void Start(Cayfly_s60Sound *aSound);
    void DoCancel();
      CCommandHandler();
      void RunL();
private:
    Cayfly_s60Sound *iSound;
};

class Cayfly_s60Sound: public CBase, MMdaAudioOutputStreamCallback
{
public:
    enum
    {
        EStopped = 0, EStarting, EPlaying, EStopping
    };
public:
    static Cayfly_s60Sound* NewL(AYSongInfo *info);
    virtual ~Cayfly_s60Sound();

    void StartPlay();
    void StopPlay();
    void SetDeviceVolume(TInt aVolume);
    TInt GetDeviceVolume();

    virtual void MaoscOpenComplete(TInt aError);
    virtual void MaoscBufferCopied(TInt aError, const TDesC8 &aBuffer);
    virtual void MaoscPlayComplete(TInt aError);

    bool StartL();
    void StopL();

    void PrivateWaitRequestOK();
    void PrivateStart();
    void PrivateStop();
    void PrivateSetVolume();
    TInt State();
    void Exit();
    unsigned char *iBuffer1;
    unsigned char *iBuffer2;
    TPtr8 iDesc1;
    TPtr8 iDesc2;
    RThread iPlayerThread;
    TRequestStatus *iRequestPtr;
    TBool iKilling;
    TInt iBufferToMix;
    TInt iMixStep;
    CIdle *iIdle;
    TBool iIdleActive;
    TBool iStartOnNext;
    CMdaAudioOutputStream *iStream;
    TMdaAudioDataSettings iSettings;
    TInt iState;
    TInt iVolume;
    CCommandHandler *iHandler;
    bool stereo;
private:
    void ConstructL();
    Cayfly_s60Sound(AYSongInfo *info);
    AYSongInfo *songinfo;
    static TInt MixLoop(TAny *t);
};

 
class Cayfly_s60Audio : public AbstractAudio
{
public:
    Cayfly_s60Audio(AYSongInfo *info);
    virtual ~Cayfly_s60Audio();
    virtual bool Start();
    virtual void Stop();
    void SetDeviceVolume(TInt aVolume);
    TInt GetDeviceVolume();
private:
    Cayfly_s60Sound *sound;
};


# 160 "/home/andrew/Projects/ayfly/src/libayfly/ayfly.h" 2




 
bool ay_sys_readfromfile(AYSongInfo &info);
bool ay_sys_getsonginfo(AYSongInfo &info);
bool ay_sys_getsonginfoindirect(AYSongInfo &info);
void ay_sys_rewindsong(AYSongInfo &info, long new_position);
bool ay_sys_initz80(AYSongInfo &info);
void ay_sys_z80exec(AYSongInfo &info);
void ay_sys_resetz80(AYSongInfo &info);
void ay_sys_shutdownz80(AYSongInfo &info);
bool ay_sys_initsong(AYSongInfo &info);


extern "C" {

 



  void *ay_initsong(TFileName FilePath, unsigned long sr);




  void *ay_initsongindirect(unsigned char *module, unsigned long sr, TFileName type, unsigned long size);




  void *ay_getsonginfo(TFileName FilePath);




  void *ay_getsonginfoindirect(unsigned char *module, TFileName type, unsigned long size);




  TFileName ay_getsongname(void *info);




  TFileName ay_getsongauthor(void *info);




  TFileName ay_getsongpath(void *info);

  void ay_z80xec(void *info);
  void ay_seeksong(void *info, long new_position);
  void ay_resetsong(void *info);
  void ay_closesong(void **info);
  bool ay_songstarted(void *info);
  void ay_startsong(void *info);
  void ay_stopsong(void *info);
  void ay_setvolume(void *info, unsigned long chnl, float volume);
  float ay_getvolume(void *info, unsigned long chnl);
  void ay_chnlmute(void *info, unsigned long chnl, bool mute);
  bool ay_chnlmuted(void *info, unsigned long chnl);
  void ay_setcallback(void *info, ELAPSED_CALLBACK callback, void *callback_arg);
  unsigned long ay_getsonglength(void *info);
  unsigned long ay_getelapsedtime(void *info);
  unsigned long ay_getsongloop(void *info);
  const unsigned char *ay_getregs(void *info, unsigned long chip_num);
  void ay_rendersongbuffer(void *info, unsigned char *buffer, unsigned long buffer_length, unsigned long chip_num);
  unsigned long ay_getz80freq(void *info);
  void ay_setz80freq(void *info, unsigned long z80_freq);
  unsigned long ay_getayfreq(void *info);
  void ay_setayfreq(void *info, unsigned long ay_freq);
  unsigned long ay_getintfreq(void *info);
  void ay_setintfreq(void *info, unsigned long int_freq);
  void ay_setsongplayer(void *info, void *   player);
  void *ay_getsongplayer(void *info);





}














# 36 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h" 1
 
 
 
 
 





# 650 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/f32file.h"

# 42 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 43 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h" 1
 
 
 
 
# 441 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32file.h"

# 44 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/avkon.hrh" 1
 























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh" 1



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcolor.hrh" 1
 
 
 
 





















































































# 4 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh" 2



 







 
 
 
 






 
 
 
 

 


 





























 

 
 
 
 
 
 
 
 
 
 
 
 
 
enum TAknEditorNumericKeymap
    {
                                             
    EAknEditorStandardNumberModeKeymap,      
    EAknEditorPlainNumberModeKeymap,         
    EAknEditorCalculatorNumberModeKeymap,    
    EAknEditorConverterNumberModeKeymap,     
    EAknEditorToFieldNumberModeKeymap,       
    EAknEditorFixedDiallingNumberModeKeymap, 
    EAknEditorSATNumberModeKeymap,           
    EAknEditorSATHiddenNumberModeKeymap,     
    EAknEditorAlphanumericNumberModeKeymap,  
    EAknEditorReservedInternalUseKeymap = 100    
    };

 
 





 
 

 



 










 


 

 
 







 
 

 
 
 
 

 

 

 
 
 


 

 
 
 
 











enum EEikLabelStandardFont
    {
    EEikLabelFontNormal,
    EEikLabelFontLegend,
    EEikLabelFontAnnotation
    };
    
 
 
 
 





 
 
 
 









 
 
 
 










 
 



 





 


 
 
 
 

 






 




 













 
 
 
 





















 





 
 
 
 




 
 
 
 






















enum TEikAppResourceFileStandardOffset
    {
    ESignatureResourceOffset=1,
    EDefaultNameResourceOffset,
    EAppInfoResourceOffset
    };

 
 





































 
 
 
 






































































 
 
 
 

enum TEikStockControls
    {
    EEikCtCommandButton,
    EEikCtLabeledButton,
    EEikCtEdwin,
    EEikCtRichTextEditor,
    EEikCtSecretEd,
    EEikCtCheckBox,
    EEikCtChoiceList,
    EEikCtOptionButton,
    EEikCtHorOptionButList,
    EEikCtFileNameSel,
    EEikCtFileNameEd,
    EEikCtFolderNameSel,
    EEikCtFolderNameEd,
    EEikCtDriveNameSel,
    EEikCtListBox,
    EEikCtCharMap,
    EEikCtCharEd,
    EEikCtImage,
    EEikCtImageArray,
    EEikCtLabel,
    EEikCtComboBox,
    EEikCtProgInfo,
    EEikCtFlPtEd,
    EEikCtFxPtEd,
    EEikCtTwipsEd,
    EEikCtNumberEditor,
    EEikCtRangeEditor,
    EEikCtTimeEditor,
    EEikCtDateEditor,
    EEikCtTimeAndDateEditor,
    EEikCtDurationEditor,
    EEikCtTimeOffsetEditor,
    EEikCtLatitudeEditor_Not_Supported,
    EEikCtLongitudeEditor_Not_Supported,
    EEikCtBorderPreview,
    EEikCtFontPreview,
    EEikCtGraySelector,
    EEikCtWorldSelector,
    EEikCtGlobalTextEditor,
    EEikCtSoundSelector,
    EEikCtClock,
    EEikCtPrintPreview,
    EEikCtMenuButton,
    EEikCtDirContentsListBox,
    EAknCtIpFieldEditor,
    EEikCtCalendar,
    EEikCtSpacer,
    EEikCtColListBox,
    EEikCtRangeRefEditor,
    EEikCtTextButton,
    EEikCtBitmapButton,
    EEikCtDialogToolBar,
    EEikCtFileBrowser,
    EEikCtFileNameLabel,
    EEikCtUnifiedFileSel,
    EEikCtTelephoneNumberEditor,
    EEikCtTwoPictureCommandButton,
    EEikCtInverterCommandButton,
    EEikCtScrollBar,
    EEikCtArrowHeadScrollBar
    };

 
enum TEikStockButtonGroupControls
    {
    EEikBgToolBar,
    EEikBgButtonPanel,
    EEikBgCba
    };

 
 
 
 















































































 







 






 






 











 







 
                                     



 




 














































































































 
 
 
 
 
















 

 





 





































 
 
 
 

 




 










 



 



 




















# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/avkon.hrh" 2


 
 
 
 
 
 
 
 

 






 


 



 





 


 
 
 
 
 
 















 
 
 


 
 
 








 









 





 
 
 










 
 
 






 
 
 
 
 
 
 

 
 
 

enum
    {
    EAknApplicationIconWidth = 42,
    EAknApplicationIconHeight = 29
    };

 
 
 
 
 


 
 
 

 





 
 
 




 
enum 
    {
    EAknDummyForProcessCommands=4000,
    EAknMarkAll,  
    EAknUnmarkAll,  
    EAknCmdHelp,
    EAknCmdAddToPinboard,
    EAknCmdFindPopupActivated,
    EAknCmdEditModeT9,
    EAknCmdEditModeMultitap,
    EAknCmdEditModeNumber,
    EAknCmdEditInsertNumber,
    EAknCmdEditInsertSymbol,
    EAknCmdInputLanguage,
    EAknCmdPredictiveTextCascade,
    EAknCmdT9PredictiveMatches,
    EAknCmdT9PredictiveInsertWord,
    EAknCmdT9PredictiveEditWord,
    EAknCmdT9PredictiveT9Off,
    EAknCmdMultitapPredictiveT9On,
    EAknCmdExit,
    EAknCmdEditTextMenu,
    EAknCmdEditListMenu,  
    EAknCmdMark,  
    EAknCmdUnmark,  
    EAknCmdOpen,     

     
    EChinFepCmdInstructions,
    EChinFepCmdModePinyin,
    EChinFepCmdModeZhuyin,
    EChinFepCmdModeStroke,
    EChinFepCmdModeLatinUpper,
    EChinFepCmdModeLatinLower,
    EChinFepCmdModeNumber,
    EChinFepCmdModeZhuyinFind,
    EChinFepCmdModeStrokeFind,

    EAknCmdEditModeArabicIndicNumber,
    EAknCmdEditModeAlpha,
    EAknCmdEditModeLatinText,

     
    EJapanFepCmdModeHiragana,
    EJapanFepCmdModeKatakana,
    EJapanFepCmdModePictographs,
    EJapanFepCmdModeFullWidth,
    EJapanFepCmdModeHalfWidth,
    EJapanFepCmdModePredictiveOn,
    EJapanFepCmdModePredictiveOff,
    EJapanFepCmdModeUserDic,
    EJapanFepCmdModeKutenCodeInput,
    EAknCmdEditInsertPictograph,
    EJapanFepCmdPredictiveTextCascade,
    EJapanFepCmdMultitapPredictiveT9On,
    EJapanFepCmdEditModeAlpha,
    EJapanFepCmdEditModeNumber,

    EAknCmdEnd
};

 




enum         
    {
    EAknSoftkeyOk = -2 ,
    EAknSoftkeyCancel = -1 ,
    EAknSoftkeySelect = -6 ,
    EAknSoftkeyOptions= 3000,
    EAknSoftkeyBack,
    EAknSoftkeyMark,
    EAknSoftkeyUnmark,
    EAknSoftkeyInsert,
    EAknSoftkeyYes,
    EAknSoftkeyNo,
    EAknSoftkeyDone,
    EAknSoftkeyClose,
    EAknSoftkeyExit,
    EAknSoftkeyClear,
    EAknSoftkeyUnlock,
    EAknSoftkeySave,
    EAknSoftkeyShow,
    EAknSoftkeyListen,
    EAknSoftkeyRead,
    EAknSoftkeySearch,
    EAknSoftkeyEmpty,
    EAknSoftkeyLock,
    EAknSoftkeyCall,
    EAknSoftkeyAgain,
    EAknSoftkeyQuit,
    EAknSoftkeyDetails,
    EAknSoftkeyNext
    };

enum    {
    EAknSoftkeyDummyUsedWithShortcuts = 3200
    };

enum
    {
    EAknCBAFlagRespondWhenInvisible = 0x02    
    };


 
 
 
 
 






 
 
 


 
 
 
 

 
 
 



enum
    {
    EAknCtTest = 5699 ,
    EAknControlIdBase = 5700,

    EAknCtFormattedListBox,  

     
    EAknCtSingleListBox,
    EAknCtSingleNumberListBox,
    EAknCtSingleHeadingListBox,
    EAknCtSingleGraphicListBox,
    EAknCtSingleGraphicHeadingListBox,
    EAknCtSingleNumberHeadingListBox,
    EAknCtSingleLargeListBox,
    EAknCtDoubleListBox,
    EAknCtDoubleNumberListBox,    
    EAknCtDoubleTimeListBox,
    EAknCtDoubleLargeListBox,   
    EAknCtDoubleGraphicListBox,
    EAknCtSettingListBox,      
    EAknCtSettingNumberListBox,   

     
    EAknCtSinglePopupMenuListBox,
    EAknCtSingleGraphicPopupMenuListBox,
    EAknCtSingleGraphicHeadingPopupMenuListBox,
    EAknCtMenuDoublePopupMenuListBox,
    EAknCtSinglePopupSubmenuListBox,
    EAknCtDoubleLargeGraphicPopupMenuListBox,
    EAknCtSingleHeadingPopupMenuListBox,

     
    EAknSetListBox,

     
    EAknFormGraphicListBox,

     
    EAknCtAppGrid,
    EAknCtPinbGrid,       
    EAknCtQdialGrid,      
    EAknCtCaleMonthGrid,  

     
    EAknCtTitlePane,
    EAknCtContextPane,
    EAknCtNaviPane,
    EAknCtSignalPane,
    EAknCtBatteryPane,
    EAknCtIndicatorPane,
    EAknCtIdleContextPane,
 
 
 
    EAknCtNote,
    EAknCtQuery,
    EAknCtMultilineQuery,
 
 
 
    EAknCtPopupField,
    EAknCtPopupFieldText,
 
    EAknCtFormLabelEditor,

 
    EAknCtLAF,
    EAknCtPopupHeadingPane,
    EAknCtSearchField,

 
    EAknCtSettingPage,

 
    EAknCtVolumeControl,
    EAknCtSlider,
    EAknCtListQueryControl,
    EAknCtSpecialCharacterMap,

 
    EAknPhoneNumberEditor,

 
    EAknCtNumericSecretEditor,

 
    EAknCtPopupSettingList,
 
    EAknCtMessageQuery,

 
    EAknCtIntegerEdwin,
    EAknCtFloatingPointEdwin,
    EAknCtSelectionListFixedFind,
    EAknCtSelectionListPopupFind,
    EAknCtEmptyList,
    EAknCtDouble2GraphicListBox,
    EAknCtDouble2LargeListBox,
    EAknCtDouble2PopupMenuListBox,

 
    EAknCtSingle2GraphicListBox,
    EAknCtDouble2GraphicLargeListBox,
 

 
    EAknCtColourSelectionDialogNoneField,
    EAknCtColourSelectionDialogGrid,

 
    EAknCtListQuerySearchControl,

 
    EAknExtCtQuery,

 
    EAknExtCtMultilineQuery,

   EAknCtBitmapAnimation,

 
    EAknCtLastControlId = 0x2000  

 
 
 
 
 
 
 
 
 
 

 

    };

 
enum
    {
    ENaviDecoratorControlNone,
    ENaviDecoratorControlTabGroup,
    ENaviDecoratorLabel,
    ENaviDecoratorImage,
    ENaviDecoratorToolTip  
    };

 


enum
    {
    EAknTabWidthWithTwoTabs = 36,
    EAknTabWidthWithTwoLongTabs = 74,
    EAknTabWidthWithThreeTabs = 22,
    EAknTabWidthWithThreeLongTabs = 67,
    EAknTabWidthWithFourTabs = 18,
    EAknTabWidthWithOneTab = 107
    };

 
enum 
    {
    EGeneralLayout = 1,
    EConfirmationLayout,
    EProgressLayout,
    ENoteWithImageLayout,
    ETextualNotificationLayout,
    ENotificationWithGraphicsLayout,
    EAknNoteControlAnimationCreationFailed,
    EWaitLayout
    };

enum 
    {
    EAknInvalidBorderCount = 1,
    EAknInvalidDimensionArrayOutOfBounds,
    EAknNoNoteControlDimensionDefined,
    EAknNoteControlNullArgumentUsed
    };

enum EAknNoteItemType {
    EAknNoteNoType = 1,
    EAknNoteBitmap,
    EAknNoteNumberTypeIndication,
    EAknNoteProgressBar,
    EAknNoteLabel,
    EAknNoteAnimation
};

enum TNoteCtrlIds
    {
    EGeneralNote = 1
    };


 



 

 
 
 
 
 
 
enum 
    {
    EDataLayout=1,
    EConfirmationQueryLayout,
    ECodeLayout,
    ETimeLayout,
    EDateLayout,
    EListLayout,
    EMultiListLayout,
    EMultiLineDataLayout,
    EDurationLayout,
    ETextSoftNotification,
    ENumberLayout,
    EPinLayout,
    EPhoneLayout,
    EMessageQueryLayout,
    EStaticSizeDataLayout,
    EFloatingPointLayout,
    EIpLayout,                          
    EFixedPointLayout                   
    };

enum
    {
    ETextEditor=1,
    ESecretEditor,
    ETimeEditor,
    EDateEditor,
    ENumberEditor,
    EDurationEditor,
    EIpEditor,                          
    EFixedPointEditor                   
    };

enum EAknMultilineDataLayout
{
    EMultiDataFirstEdwin = 1,
    EMultiDataSecondEdwin,
    EMultiDataFirstSecEd,
    EMultiDataSecondSecEd,
    EMultiDataFirstTimeEd,
    EMultiDataSecondTimeEd,
    EMultiDataFirstDateEd,
    EMultiDataSecondDateEd,
    EMultiDataFirstDurEd,
    EMultiDataSecondDurEd,
    EMultiDataFirstPhoneEd,
    EMultiDataSecondPhoneEd,
    EMultiDataFirstNumEd,
    EMultiDataSecondNumEd,
    EMultiDataFirstPinEd,
    EMultiDataSecondPinEd,
    EMultiDataFirstIpEd,                
    EMultiDataSecondIpEd                
    };

enum TQueryCtrlIds
    {
    EGeneralQuery = 0x500,
    EMultilineFirstLine,
    EMultilineSecondLine
    };

enum TListQueryCtrlIds
    {
    EListQueryMainInboxList = 1,
    EListQueryMainDraftList,
    EListQueryMainOutboxList,
    EListQueryAppViewLabel,
    EListQueryMsgEditField,
    EListQueryHeading,
    EListQueryControl
    };
   
enum TSelectionListCtrlIds
    {
    ESelectionListControl = 1,
    EFindControl,
    EAknEmptyListControl,
    EAknListQueryMessageBox   
    };
   

 
enum
    {
    ELayoutNoCmd =1,
    ELayoutOptional,  
    ELayoutRightSeparator,  
    ELayoutTransparentCell,   
    ELayoutItemMark,          

    ELayoutNotFilled,
    ELayoutNotAlwaysDrawn
    };

enum {
    ELayoutAlignNone,
    ELayoutAlignCenter,
    ELayoutAlignLeft,
    ELayoutAlignRight,
    ELayoutAlignBidi
     };

 
enum 
    {
    EAknEditorAlignNone = ELayoutAlignNone,
    EAknEditorAlignCenter = ELayoutAlignCenter,
    EAknEditorAlignLeft = ELayoutAlignLeft,
    EAknEditorAlignRight = ELayoutAlignRight,
    EAknEditorAlignBidi = ELayoutAlignBidi
     };

 
enum 
    {
    EAknEditorCharactersUpperCase = 0x1 ,
    EAknEditorCharactersLowerCase = 0x2 ,
    EAknEditorCharactersTextCase = 0x4 
    };

 


enum {
    EFontNone = 0,
    ELatinPlain12,
    ELatinBold12,
    ELatinBold13,
    ELatinBold17,
    ELatinBold19,
    ENumberPlain5,
    EClockBold30,
    ELatinClock14,
    EFontCustom,
    EPlain12,
    EPlain16, 
    EApacPlain12 = EPlain12,
    EApacPlain16 = EPlain16,
    EBold18,
    EBold24,
    ELatinBold16,
	EHighestFixedLayoutFont = (0x100-1) 
    };

 





enum TAknLogicalFontId
	{
	EAknLogicalFontPrimaryFont = (0x100-1)  + 1,
	EAknLogicalFontSecondaryFont,
	EAknLogicalFontTitleFont
	};



 
enum
{
    EAknLayoutFindPaneIconId = 1,
    EAknLayoutFindPaneEditorId,
    EAknLayoutMainPaneListGenPane,
    EAknLayoutMainPaneListGenPaneWithFindBox,
    EAknLayoutMainPaneFindPane,

    EAknListSinglePane,
    EAknListSingleNumberPane,
    EAknListSingleHeadingPane,
    EAknListSingleGraphicPane,
    EAknListSingleGraphicHeadingPane,
    EAknListSingleNumberHeadingPane,
    EAknListSingleLargeGraphicPane,
    EAknListDoubleNumberPane,
    EAknListDoubleTimePane,
    EAknListDoubleLargeGraphicPane,
    EAknListDoubleGraphicPane,
    EAknListSettingNumberPane,


    EAknLayoutFindPaneVShadow,
    EAknLayoutFindPaneHShadow,
    EAknLayoutFindPaneOutlineRect,


    EAknLayoutEmptyList1stLine,
    EAknLayoutEmptyList2ndLine
};


 










 





enum
    {
    EAknDialogQueryValueTextEditor1 = 1,
    EAknDialogQueryValueNumberEditor1,
    EAknDialogQueryValuePhoneEditor1,
    EAknDialogQueryValueTimeEditor1,
    EAknDialogQueryValueDateEditor1,
    EAknDialogQueryValueDurationEditor1,
    EAknFormQueryControl,
    EAknPopupFieldEmptyListNote
    };

 
enum
    {
    EAknPopupSettingListFlagAllowsUserDefinedEntry = 0x001,
    EAknPopupSettingListFlagInitialised = 0x002
    };

 
enum
    {
    EAknFormCmdEdit = 950,
    EAknFormCmdAdd,
    EAknFormCmdSave,
    EAknFormCmdLabel,
    EAknFormCmdDelete,
    EAknFormMaxDefault
    };

 
enum
    {
    EAknFormSliderLayout1 =1,
    EAknFormSliderLayout2,
    EAknFormSliderLayout3,
    EAknSettingsItemSliderLayout, 
    EAknSettingsItemSliderLayoutWithGraphics
    };

 
enum
    {
    EAknSliderValueNone,
    EAknSliderValueBareFigure,
    EAknSliderValuePercentage,
    EAknSliderValueFraction,
    EAknSliderValueDecimal
    };

 
enum
    {
    ESettingsVolumeControl,
    ENaviPaneVolumeControl,
    EPopupVolumeControl
    };

 
enum
    {
     
    EAknIndicatorIrActive,
    EAknIndicatorEnvelope,
    EAknIndicatorEmailMessage,
    EAknIndicatorDataMessage,
    EAknIndicatorFaxMessage,
    EAknIndicatorOtherMessage,
    EAknIndicatorSecuredConnection,
    EAknIndicatorVoiceMailWaiting,
    EAknIndicatorVoiceMailWaitingOnLine1,
    EAknIndicatorVoiceMailWaitingOnLine2,  
    EAknIndicatorVoiceMailWaitingOnBothLines,  
    EAknIndicatorHomeZone,
    EAknIndicatorBluetooth,
    EAknIndicatorBluetoothModuleOn,
    EAknIndicatorOutbox,
    EAknIndicatorKeyguard,
    EAknIndicatorAllCallsForwarded,
    EAknIndicatorCallsForwardedOnLine1,
    EAknIndicatorCallsForwardedOnLine2, 
    EAknIndicatorCallsForwardedOnBothLines,
    EAknIndicatorCallsForwardedToVoiceMailbox,
    EAknIndicatorSelectedLine,
    EAknIndicatorAlarmClock,     
    EAknIndicatorHeadset,
    EAknIndicatorLoopset,
    EAknIndicatorIHFActive,
    EAknIndicatorInstantMessage,
    EAknIndicatorTTY,
    EAknIndicatorUSBConnection,
    EAknIndicatorMissedCalls,
    EAknIndicatorRemoteMailboxEmailMessage,
    EAknIndicatorLocation,
    EAknIndicatorHeadsetUnavailable,
    EAknIndicatorRoaming,
    EAknIndicatorLocationOn,
    EAknIndicatorLocationOff,

     
    EAknNaviPaneEditorIndicatorT9 = 100,
    EAknNaviPaneEditorIndicatorUpperCase,
    EAknNaviPaneEditorIndicatorLowerCase,
    EAknNaviPaneEditorIndicatorTextCase,
    EAknNaviPaneEditorIndicatorNumberCase,
    EAknNaviPaneEditorIndicatorQuery,
    EAknNaviPaneEditorIndicatorQwertyShift,

    EAknNaviPaneEditorIndicatorArabicCase = 130,
    EAknNaviPaneEditorIndicatorHebrewCase,
    EAknNaviPaneEditorIndicatorArabicIndicNumberCase,

     
    EAknNaviPaneEditorIndicatorPinyin = 150,
    EAknNaviPaneEditorIndicatorZhuyin,
    EAknNaviPaneEditorIndicatorStroke,  

    EAknNaviPaneEditorIndicatorZhuyinFind,
    EAknNaviPaneEditorIndicatorStrokeFind,

     
    EAknNaviPaneEditorIndicatorThai = 170,


    EAknNaviPaneEditorIndicatorStrokeTrad,   

     
    EAknNaviPaneEditorIndicatorAudioAttached = 200,
    EAknNaviPaneEditorIndicatorImageAttached,
    EAknNaviPaneEditorIndicatorObjects,
    EAknNaviPaneEditorIndicatorAttachment,
    EAknNaviPaneEditorIndicatorMessageLength,
    EAknNaviPaneEditorIndicatorMessageInfo,

     
    EAknNaviPaneEditorIndicatorWaitBar,
    EAknNaviPaneEditorIndicatorProgressBar,
    EAknNaviPaneEditorIndicatorSecuredConnection,
    EAknNaviPaneEditorIndicatorWmlWaitGlobe,
    EAknNaviPaneEditorIndicatorGprs, 
    EAknNaviPaneEditorIndicatorFileSize,

     
    EAknNaviPaneEditorIndicatorJapaneseHiraganaKanji = 300,  
    EAknNaviPaneEditorIndicatorJapaneseHiragana,             
    EAknNaviPaneEditorIndicatorJapaneseFullKatakana,         
    EAknNaviPaneEditorIndicatorJapaneseHalfKatakana,         
    EAknNaviPaneEditorIndicatorJapaneseFullUpperAlphabet,    
    EAknNaviPaneEditorIndicatorJapaneseFullLowerAlphabet,    
    EAknNaviPaneEditorIndicatorJapaneseFullTextAlphabet,     
    EAknNaviPaneEditorIndicatorJapaneseFullNumeric           
    };


enum   
    {
    EAknIndicatorStateOff,
    EAknIndicatorStateOn,
    EAknIndicatorStateAnimate
    };

enum  
    {
     
    EAknSignalGprsIndicatorOff = 0,
    EAknSignalGprsIndicatorAvailable,   
    EAknSignalGprsIndicatorAttached,
    EAknSignalGprsIndicatorEstablishingContext,
    EAknSignalGprsIndicatorContext,
    EAknSignalGprsIndicatorSuspended,
    EAknSignalGprsIndicatorMultipdp,

      
    EAknSignalCommonPacketDataIndicatorOff = 0x100,
    EAknSignalCommonPacketDataIndicatorAvailable,   
    EAknSignalCommonPacketDataIndicatorAttached,
    EAknSignalCommonPacketDataIndicatorEstablishingContext,
    EAknSignalCommonPacketDataIndicatorContext,
    EAknSignalCommonPacketDataIndicatorSuspended,
    EAknSignalCommonPacketDataIndicatorMultipdp,

      
    EAknSignalWcdmaIndicatorOff = 0x200,  
    EAknSignalWcdmaIndicatorAvailable,  
    EAknSignalWcdmaIndicatorAttached,
    EAknSignalWcdmaIndicatorEstablishingContext, 
    EAknSignalWcdmaIndicatorContext,
    EAknSignalWcdmaIndicatorMultipdp,

     
    EAknSignalCdmaIndicatorOff = 0x300,
    EAknSignalCdmaIndicatorNoService,
    EAknSignalCdmaIndicatorAvailable,
    EAknSignalCdmaIndicatorNotAvailable,
    EAknSignalCdmaIndicatorActive,
    EAknSignalCdmaIndicatorDormant,
    EAknSignalCdmaIndicatorSending,
    EAknSignalCdmaIndicatorReceiving
    };



 






 
 
 









 





 

    

 



 
 
 
 
 
 
 
 
 







 
enum   
    {
    EAknSCTLowerCase,
    EAknSCTUpperCase,
    EAknSCTNumeric,
    EAknSCTFullCase,
    EAknSCTHalfCase,
    EAknSCTChiChineseInputModes = EAknSCTUpperCase,
    EAknSCTChiLatinInputModes = EAknSCTLowerCase
    };

 


 




enum TSCTQueryCtrlIds
    {
    EAknSCTQueryHeadingId = 1,
    EAknSCTQueryContentId
    };

 

enum TAvkonSKeyRepeatType
    {
    ESKeyTypeShort,
    ESKeyTypeLong,
    ESKeyTypeRepeat
    };

 
 
 
enum TAvkonSystemSID
    {
    EAvkonSIDNoSound = 1000,
    EAvkonSIDDefaultSound = 1001,
    EAvkonSIDStandardKeyClick = 1002,
    EAvkonSIDConfirmationTone = 1003,
    EAvkonSIDInformationTone = 1003,    
    EAvkonSIDWarningTone = 1004,
    EAvkonSIDErrorTone = 1005,
    EAvkonSIDVolumeMaxTone = 1006,
    EAvkonSIDVolumeMinTone = 1007,
    EAvkonSIDReadialCompleteTone = 1008,
    EAvkonSIDBatteryLowTone = 1009, 
    EAvkonSIDChargingBatteryTone  = 1010,
    EAvkonSIDConnectionStartTone  = 1011,
    EAvkonSIDConnectionStopTone  = 1012,
    EAvkonSIDOperationReadyTone  = 1013,
    EAvkonSIDNameDiallerStartTone  = 1014,
    EAvkonSIDNameDiallerErrorTone  = 1015,
    EAvkonSIDNameDiallerAbortTone  = 1016,
    EAvkonSIDPowerOffTone  = 1017,
    EAvkonSIDPowerOnTone  = 1018,
    EAvkonSIDRechargeBatteryTone = 1019,
    EAvkonSIDVoiceRecordingTone  = 1020,
    EAvkonSIDVoiceRecordingStartTone  = 1021,
    EAvkonSIDVoiceRecordingStopTone  = 1022,
    EAvkonSIDWrongCharger  = 1023,
    EAvkonSIDNetBusy = 1024,                
    EAvkonSIDNetCallWaiting = 1025,     
    EAvkonSIDNetReorder = 1026, 
    EAvkonSIDNetCongestion = 1027,      
    EAvkonSIDNetSpecialInformation = 1028,  
    EAvkonSIDNetRadioNotAvailable = 1029,
    EAvkonSIDIHFActive = 1030,
    EAvkonSIDRadioPathAcknowledge = 1031,
    EAvkonSIDDial = 1032,
    EAvkonSIDRingGoing = 1033,
    EAvkonSIDLocationRequest = 1034
    };

 
enum TAvkonSoundsPriority
    {
    EAvkonKeyClickPriority = 45,  
    EAvkonPoweringTonesPriority = 50,
    EAvkonLowLevelNotesPriority = 55,
    EAvkonConfirmationNotePriority = 55,
    EAvkonVolumeSettingTonesPriority = 60,
    EAvkonConnectionTonesPriority = 65,
    EAvkonHighLevelNotesPriority = 70,
    EAvkonErrorNotePriority = 70,
    EAvkonWarningNotePriority = 70,
    EAvkonVoiceDiallingTonesPriority = 73,
    EAvkonNetworkingTonesPriority = 75,
    EAvkonRecordingTonesPriority = 80,
    EAvkonChargingTonesPriority = 85,
    EAvkonNewMessageTonesPriority = 90,
    EAvkonAlarmTonesPriority = 95,  
    EAvkonRingingTonesPriority = 100
    };

 
enum TAvkonSoundsPreference
    {
    EAknAudioPrefIncomingCall       =0x01340001,
    EAknAudioPrefIncomingCallLine2  =0x01330001,
    EAknAudioPrefIncomingDataCall       =0x01320001,
    EAknAudioPrefAutoRedialCompleted    =0x01310001,

    EAknAudioPrefAlarmClock         =0x01220001,
    EAknAudioPrefCalendarAlarm      =0x01210001,

 
    EAknAudioPrefNewSMS         =0x01120001,
    EAknAudioPrefNewSpecialMessage  =0x01110001,

 
    EAknAudioPrefBatteryLow         =0x01030001,
    EAknAudioPrefRechargeBattery        =0x01020001,
    EAknAudioPrefWrongCharger       =0x01010001,

 
    EAknAudioPrefVoiceRecStart      =0x00930001,
    EAknAudioPrefVoiceRecRecording  =0x00920001,
    EAknAudioPrefVoiceRecStop       =0x00910001,

 
    EAknAudioPrefRadioPathAck       =0x00890001,
    EAknAudioPrefDial               =0x00880001,
    EAknAudioPrefRingGoing          =0x00870001,                    
    EAknAudioPrefBusy               =0x00860001,
    EAknAudioPrefCallWaiting        =0x00850001,
    EAknAudioPrefReorder            =0x00840001,
    EAknAudioPrefCongestion         =0x00830001,
    EAknAudioPrefSpecialInformation =0x00820001,
    EAknAudioPrefRadioNotAvailable  =0x00810001,

 
    EAknAudioPrefError      =0x00720001,
    EAknAudioPrefWarning        =0x00710001,

 
    EAknAudioPrefVoiceStarting  =0x00630001,
    EAknAudioPrefVoiceError     =0x00620001,
    EAknAudioPrefVoiceAbort     =0x00610001,

 
    EAknAudioPrefConnectionStart    =0x00530001,
    EAknAudioPrefConnectionStop =0x00520001,
    EAknAudioPrefOperationReady =0x00510001,

 
    EAknAudioPrefFilePreview    =0x00440001,
    EAknAudioPrefAudioVolumeMin =0x00430001,
    EAknAudioPrefAudioVolumeMax =0x00420001,
    EAknAudioPrefIHFActive      =0x00410001,

 
    EAknAudioPrefCharging       =0x00330001,
    EAknAudioPrefConfirmation   =0x00320001,
    EAknAudioPrefDefaultTone    =0x00310001,

 
    EAknAudioPrefPowerOn        =0x00220001,
    EAknAudioPrefPowerOff       =0x00210001,

 
    EAknAudioPrefKeyPressNonDTMF    =0x00140001,
    EAknAudioPrefKeyDownDTMF    =0x00130001,
    EAknAudioPrefKeyUpDTMF      =0x00120001,
    EAknAudioPrefCamera     =0x00110001,

 
    EAknAudioPrefVoiceRec       =0x00060001,
    EAknAudioPrefComposer       =0x00050001,
    EAknAudioPrefRingFilePreview    =0x00040001,
    EAknAudioPrefVocosPlayback  =0x00030001,
    EAknAudioPrefVocosTrain     =0x00020001,
    EAknAudioPrefVocosRecog     =0x00010001,
    
    EAvkonKeyClickPreference = 0x00140001,
    EAvkonConfirmationNotePreference = 0x00320001,
    EAvkonErrorNotePreference = 0x00720001,
    EAvkonWarningNotePreference = 0x00710001
    };

 


enum TMessageQueryCtrlIds
    {
    EAknMessageQueryHeaderId = 1,
    EAknMessageQueryContentId
    };

 
     












enum TAvkonIncallStatusBubbleFlags 
    {
    EAknStatusBubbleAlerting     = 0x00,  
    EAknStatusBubbleActive       = 0x01,  
    EAknStatusBubbleOnHold       = 0x02,  
    EAknStatusBubbleDisconnected = 0x03,  
    EAknStatusBubbleNoCiphering  = 0x04,        
    EAknStatusBubbleMuted        = 0x08,
    EAknStatusBubbleVisible      = 0x10,
    EAknStatusBubbleFax      = 0x20,
    EAknStatusBubbleData      = 0x40,
    EAknStatusBubbleDataHscsd      = 0x80,
    EAknStatusBubbleLine2      = 0x100,
    EAknStatusBubbleVideo      = 0x200,
    EAknStatusBubbleEmergency  = 0x400
    };


 



enum TAknNoteDialogTimeout
    {
    EAknNoteDialogUndefinedTimeout = 0,
    EAknNoteDialogShortTimeout = 1500000,
    EAknNoteDialogLongTimeout = 3000000,
    
     
    EAknConfirmationNoteTimeout = EAknNoteDialogShortTimeout,
    EAknInformationNoteTimeout = EAknNoteDialogLongTimeout,
    EAknErrorNoteTimeout = EAknNoteDialogLongTimeout,
    EAknWarningNoteTimeout = EAknNoteDialogLongTimeout
    };

 



enum TAknNoteDialogTone 
    {
    EAknNoteDialogNoTone = 0,
    EAknNoteDialogConfirmationTone = EAvkonSIDConfirmationTone,
    EAknNoteDialogWarningTone = EAvkonSIDWarningTone,
    EAknNoteDialogErrorTone  = EAvkonSIDErrorTone
    };


enum TAknSelectionListDialogFlags
    {
    EAknFlagFind = 0x0001
    };

enum TAknIconArrayType
    {
    EAknIconArrayNone,
    EAknIconArraySimple,
    EAknIconArrayComplex
    };

 
 
enum EVariantFlag
   {
   EEuropeanVariant=0,
   EApacVariant
   };

 
 
 
 
 
enum ESubVariantFlag
   {
   ENoSubVariant = 0,
   EPrcSubVariant,
   EHongKongSubVariant,
   ETaiwanSubVariant
   };


 


 



 
 






enum TAknKeyBlockMode
    {
    EDefaultBlockMode=0,
    ENoKeyBlock
    };

 
enum TAknSeparatorLinePosition
    {
    ENoLine,
    EAColumn,
    EABColumn,
    EBCColumn
    };
enum TAknColourSelectionDialogIds {
    ECtrlGridType = 100,
    EColourGridPopup,
    EColourGridPopupNone
};


 

enum TAknCustomTextCursorIds
    {
    KAknCustomTextCursorIdLeftToRight = 0x101fdf03,
    KAknCustomTextCursorIdRightToLeft = 0x101fdf04,
    KAknCustomTextCursorIdLeftToRightThin = 0x101fe51c,
    KAknCustomTextCursorIdRightToLeftThin = 0x101fe51d
    };

enum TAknNaviPaneBackgroundTypes
    {
    EAknNaviPaneBackgroundTypeNotDefined  = 0,
    EAknNaviPaneBackgroundTypeWipe        = 1,
    EAknNaviPaneBackgroundTypeSolid       = 2     
    };




# 45 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 1
 
 
 
 

# 627 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h"

# 46 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknmessagequerydialog.h" 1
 























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 1
 























 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecobs.h" 1
 
 
 
 




class CCoeControl;

class MCoeControlObserver
 



	{
public:
	 
	enum TCoeEvent
		{
		 





		EEventRequestExit,
		 




		EEventRequestCancel,
		 


		EEventRequestFocus,
		 


		EEventPrepareFocusTransition,
		 



		EEventStateChanged,
		 


		EEventInteractionRefused
		};
public:
	 







	virtual void HandleControlEventL(CCoeControl* aControl,TCoeEvent aEventType)=0;
	};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeccntx.h" 1
 
 
 
 








class MCoeControlContext
 















	{
public:
	  virtual void ActivateContext(CWindowGc& aGc,RDrawableWindow& aWindow) const;
	  virtual void ResetContext(CWindowGc& aGc) const;
	  virtual void PrepareContext(CWindowGc& aGc) const;
	};

class CCoeBrushAndPenContext : public CBase, public MCoeControlContext
 






	{
public:
	  static CCoeBrushAndPenContext* NewL();
	 
	  void SetBrushStyle(CWindowGc::TBrushStyle aBrushStyle);
	  void SetBrushColor(TRgb aColor);
	  void SetBrushBitmap(const CFbsBitmap& aBitmap);
	  void SetPenColor(TRgb aColor);
	 
	  CWindowGc::TBrushStyle BrushStyle() const;
	  TRgb BrushColor() const;
	  const CFbsBitmap& BrushBitmap() const;
	  TRgb PenColor() const;
protected:  
	  void PrepareContext(CWindowGc& aGc) const;
private:
	CCoeBrushAndPenContext();
private:
	CWindowGc::TBrushStyle iBrushStyle;
	TRgb iBrushColor;
	const CFbsBitmap* iBitmap;
	TRgb iPenColor;
	};


class MCoeControlBrushContext : public MCoeControlContext
 










	{





protected:  
	  void PrepareContext(CWindowGc& aGc) const;
public:
	 
	CWindowGc::TBrushStyle iBrushStyle;
	 
	TRgb iBrushColor;
	 
	const CFbsBitmap* iBitmap;
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbctrl.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h" 1
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/guldef.h" 1
 
 
 
 




 



enum TGulAdjacent
	{
	 
	EGulAdjNone		=0x00,
	 
	EGulAdjTop		=0x01,
	 
	EGulAdjBottom	=0x02,
	 
	EGulAdjLeft		=0x04,
	 
	EGulAdjRight	=0x08
	};
	
 





 





 





 





 





 





 






# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h" 2








class TGulBorder
 














    {
public:
	class TColors
	 











		{
	public:
		  TColors();
	public:	
		 



		TRgb iLine;
		 




		TRgb iBack;
		 


		TRgb iLight;
		 


		TRgb iMidlight;
		 


		TRgb iMid;
		 


		TRgb iDark;
		 
		TRgb iInternalBack;
		};

public:
	 


	enum TOutlineStyle
		{
		 
		EWithOutline=0x01,
		 
		EDottedOutline=0x02
		};

	 


	enum TInlineStyle
		{
		 
		EWithInline=0x04
		};

	 
	enum T3DStyle
		{
		 
		EFlat=0x10,
		 
		ESunken=0x20,
		 
		ERaised=0x40
		};

	 
	enum TConstructionStyle
		{
		 



		EOneStep=0x100,
		 




		ETwoStep=0x200,
		 



		EThreeStep=0x400,
		 



		EInvertedTwoStep=0x800
		};

	 






	enum TThickness
		{
		 
		EAddOnePixel=0x1000,
		 
		EAddTwoPixels=0x2000,
		 
		EAddFourPixels=0x4000
		};

	 
	enum TRounding
		{
		 
		EAddOneRoundingPixel=0x10000,
		 
		EAddTwoRoundingPixels=0x20000,
		 
		EAddFourRoundingPixels=0x40000
		};
private:
	enum TNull
		{
		ENoBorder=0x00
		};

	enum TLegacyStyle
		{
		EShallow=EAddOnePixel,
		EDeep=EAddTwoPixels,
		EThick=EAddFourPixels,
		EHorizontal=0x100000,
		EWithOverlap=0x200000,
		EGray=0x400000,
		EBlack=0x80000
		};

	enum TLogicalStyle
		{
		ELogical=0x800000
		};
public:
	 

	enum TLogicalFamily
		{
		 
		EWindowFamily=ELogical|0x1,
		 
		EContainerFamily=ELogical|0x2,
		 
		EControlFamily=ELogical|0x3
		};
public:
	 
	enum TBorderType
		{
		 
		ENone=ENoBorder,
		 
		ESingleGray=EWithOutline|EGray,
		 
		ESingleBlack=EWithOutline|EBlack,
		 
		ESingleDotted=EWithOutline|EDottedOutline,
		 
		EShallowRaised=ERaised|EOneStep|EAddOnePixel,
		 
		EShallowSunken=ESunken|EOneStep|EAddOnePixel,
		 
		EDeepRaised=EWithOutline|ERaised|EOneStep|EAddTwoPixels,
		 
		EDeepRaisedWithOutline=EWithOutline|ERaised|EOneStep|EAddTwoPixels,
		 
		EDeepSunken=EWithOutline|ESunken|EOneStep|EAddTwoPixels,
		 
		EDeepSunkenWithOutline=EWithOutline|ESunken|EOneStep|EAddTwoPixels,
		 
		EThickDeepRaisedWithOutline=EWithOutline|ERaised|EOneStep|EAddOnePixel|EAddTwoPixels, 
		 

		EVerticalBar=ERaised|EOneStep|EAddTwoPixels|EWithOverlap,
		 
		EHorizontalBar=ERaised|EOneStep|EAddTwoPixels|EHorizontal|EWithOverlap
		};

	 
	enum TLogicalType
		{
		 
		 
		EWindow=EWindowFamily|ERaised,
		 
		 
		EFlatContainer=EContainerFamily|EFlat,
		 
		ERaisedContainer=EContainerFamily|ERaised,
		 
		ESunkenContainer=EContainerFamily|ESunken,
		 
		 
		EFlatControl=EControlFamily|EFlat,
		 
		ERaisedControl=EControlFamily|ERaised,
		 
		ESunkenControl=EControlFamily|ESunken,
		 
		EFocusedRaisedControl=EControlFamily|ERaised|0x100,
		 
		EFocusedSunkenControl=EControlFamily|ESunken|0x100
		};

public:
      TGulBorder();
      TGulBorder(TBorderType aType);
      TGulBorder(TBorderType aType,TGulAdjacent aAdjacent);
	  TGulBorder(TInt aType);
      TGulBorder(TInt aType,TGulAdjacent aAdjacent);
	  void Draw(CGraphicsContext& aGc,const TRect& aRect,const TColors& aBorderColors) const;
   	  void Draw(CGraphicsContext& aGc,const TRect& aRect) const;
	  TRect InnerRect(const TRect& aOuterRect) const;
   	  TRect OuterRect(const TRect& aInnerRect) const;
	  void SetType(TInt aType);
	  void SetAdjacent(TInt aAdjacent);
	  TSize SizeDelta() const;
   	  TMargins Margins() const;
	  TBool HasBorder() const;
	  TInt Adjacent() const;	
	  TInt Type() const;
public:	 
	  TInt Thickness() const;
	  TInt Rounding() const;
private:
	TBool IsSunken() const;
	TInt Depth() const;
	void DrawOutline(CGraphicsContext& aGc,const TRect& aRect,TRgb aColor) const;
	void DrawRectOutline(CGraphicsContext& aGc,const TRect& aRect) const;
	void DrawInline(CGraphicsContext& aGc,const TRect& aRect,TRgb aColor) const;
	TMargins OutlineMargins() const;
	TMargins BorderMargins() const;
	TMargins InlineMargins() const;
	TRect OutlineInnerRect(const TRect& aOuterRect) const;
	TRect BorderInnerRect(const TRect& aOuterRect) const;
	TInt BorderRounding() const;
	TInt InlineRounding() const;
	void DrawOneStep(CGraphicsContext& aGc,const TRect& aRect,TRgb aMidlight,TRgb aMid) const;
	void DrawTwoStep(CGraphicsContext& aGc,const TRect& aRect,TRgb aLight,TRgb aMidlight,TRgb aMid,TRgb aDark) const;
	void DrawInvertedTwoStep(CGraphicsContext& aGc,const TRect& aRect,TRgb aLight,TRgb aMidlight,TRgb aMid,TRgb aDark) const;
	void DrawThreeStep(CGraphicsContext& aGc,const TRect& aRect,TRgb aBack,TRgb aLight,TRgb aMidlight,TRgb aMid,TRgb aDark) const;
	void DrawTopLeft(CGraphicsContext& aGc,const TRect& aRect,TRgb aColor,const TInt aRounding) const;
	void DrawRoundedTopLeft(CGraphicsContext& aGc,const TRect& aRect,const TInt aRounding) const;
	void DrawBottomRight(CGraphicsContext& aGc,const TRect& aRect,TRgb aColor,const TInt aRounding) const;
	void DrawRoundedBottomRight(CGraphicsContext& aGc,const TRect& aRect,const TInt aRounding) const;
	void DrawRoundedCorner(CGraphicsContext& aGc,const TPoint& aStart,const TInt aRoundedLength, const TBool aUp, const TBool aRight) const;
	TInt RoundingMargin(const TInt aRoundedLength) const;
	inline TInt InternalType() const;
	void TranslateLegacyTypes();
private:
    TInt iType;
    };

 



class MGulLogicalBorder
	{
public:
	virtual void Draw(const TGulBorder& aBorder,CGraphicsContext& aGc, const TRect& aRect, const TGulBorder::TColors& aBorderColors) const=0;
	virtual TMargins Margins(const TGulBorder& aBorder) const=0;
private:
	  virtual void MGulLogicalBorderReserved();
	};

 



class GulTls
	{
public:
	  static void SetLogicalBorder(MGulLogicalBorder* aLogicalBorder);
	  static const MGulLogicalBorder* LogicalBorder();
	};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbctrl.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulalign.h" 1
 
 
 
 
















 



enum TGulHAlignment
	{
	 
	EHLeft=CGraphicsContext::ELeft,
	 
	EHCenter=CGraphicsContext::ECenter,
	 
	EHRight=CGraphicsContext::ERight
	};

 



enum TGulVAlignment
	{
	 
	EVTop=0x00,
	 
	EVCenter=0x10,
	 
	EVBottom=0x20
	};

 



enum TGulAlignmentValue
	{
	 
	EHLeftVTop=EHLeft|EVTop,
	 
	EHLeftVCenter=EHLeft|EVCenter,
	 
	EHLeftVBottom=EHLeft|EVBottom,
	 
	EHCenterVTop=EHCenter|EVTop,
	 
	EHCenterVCenter=EHCenter|EVCenter,
	 
	EHCenterVBottom=EHCenter|EVBottom,
	 
	EHRightVTop=EHRight|EVTop,
	 
	EHRightVCenter=EHRight|EVCenter,
	 
	EHRightVBottom=EHRight|EVBottom
	};


class TGulAlignment
 




	{
private:
	enum {EHMask=0x03, EVMask=0x30};
public:
	inline TGulAlignment();
	inline TGulAlignment(TGulAlignmentValue aValue);
	inline operator TGulAlignmentValue() const;
	inline TGulVAlignment VAlignment() const;
	inline TGulHAlignment HAlignment() const;

	 
	inline CGraphicsContext::TTextAlign TextAlign() const;

	  void SetVAlignment(TGulVAlignment aVAlign);
	  void SetHAlignment(TGulHAlignment aHAlign);
	  TPoint InnerTopLeft(const TRect& aOuter,const TSize& aInnerSize) const;
	  TRect InnerRect(const TRect& aOuter,const TSize& aInnerSize) const;
private:
	TGulAlignmentValue iValue;
	};

inline TGulAlignment::TGulAlignment()
 
	{};
inline TGulAlignment::TGulAlignment(TGulAlignmentValue aValue)
 


	{iValue=aValue;}
inline TGulAlignment::operator TGulAlignmentValue() const
 
	{return(iValue);}
inline TGulVAlignment TGulAlignment::VAlignment() const
 


	{return((TGulVAlignment)(iValue&EVMask));}
inline TGulHAlignment TGulAlignment::HAlignment() const
 


	{return((TGulHAlignment)(iValue&EHMask));}
inline CGraphicsContext::TTextAlign TGulAlignment::TextAlign() const
 


	{return((CGraphicsContext::TTextAlign)(HAlignment()));}


# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coedef.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/guldef.h" 1
 
 
 
 

# 69 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/guldef.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coedef.h" 2


 






enum TKeyResponse
	{
	 
	EKeyWasNotConsumed,
	 
	EKeyWasConsumed
	};

 






enum TDrawNow
	{
	 
	ENoDrawNow,
	 
	EDrawNow
	};

 





enum TCoeWinPriority
	{
	 
	ECoeWinPriorityNeverAtFront		=-1000,
	 
	ECoeWinPriorityLow				=-750,
	 
	ECoeWinPriorityNormal			=0,
	 
	ECoeWinPriorityMedium			=500,
	 
	ECoeWinPriorityHigh				=750,
	 
	ECoeWinPriorityFep				=900,
	 
	ECoeWinPriorityAlwaysAtFront	=1000
	};

 


const TInt KUidValueCoeColorSchemeChangeEvent	=0x100056C4;

 






 











 






# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 2








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coehelp.h" 1
 
 
 
 








 



typedef TBuf<30> TCoeContextName;


class TCoeHelpContext
 








	{
public:
	  TCoeHelpContext();
	  TCoeHelpContext(TUid aMajor,const TDesC& aContext);
	  TBool IsNull() const;
	  TBool operator==(const TCoeHelpContext& aContext) const;
	  TBool operator!=(const TCoeHelpContext& aContext) const;
public:
	 
	TUid iMajor;
	 

	TCoeContextName iContext;
	};


# 34 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeinput.h" 1
 
 
 
 








 
class MCoeFepAwareTextEditor;
class MCoeCaptionRetrieverForFep;

class MObjectProvider;

class TCoeInputCapabilities
 



	{
public:
	 

	enum
		{
		 
		ENone							=0,
		 
		EWesternNumericIntegerPositive	=0x00000001,
		 
		EWesternNumericIntegerNegative	=0x00000002,
		 
		EWesternNumericReal				=0x00000004,
		 
		EWesternAlphabetic				=0x00000008,
		 
		EJapaneseHiragana				=0x00000010,
		 
		EJapaneseKatakanaHalfWidth		=0x00000020,
		 
		EJapaneseKatakanaFullWidth		=0x00000040,
		 
		EDialableCharacters				=0x00000080,
		 

		ESecretText						=0x00000100,
		 


		EAutoSentenceCase				=0x00000200,
		 
		EAllText						=0x01000000,
		 

		ENavigation						=0x02000000
		};
	class MCoeFepSpecificExtensions;  
public:
	 
	  TCoeInputCapabilities(TUint aCapabilities);
	  TCoeInputCapabilities(TUint aCapabilities, MCoeFepAwareTextEditor* aFepAwareTextEditor, MCoeCaptionRetrieverForFep* aCaptionRetrieverForFep);
	  TCoeInputCapabilities(TUint aCapabilities, MCoeFepAwareTextEditor* aFepAwareTextEditor, MCoeCaptionRetrieverForFep* aCaptionRetrieverForFep, TUid aFepUid, MCoeFepSpecificExtensions* aFepSpecificExtensions);
	  TCoeInputCapabilities(const TCoeInputCapabilities& aAnother);  
	  TCoeInputCapabilities& operator=(const TCoeInputCapabilities& aAnother);  
	  TBool operator==(const TCoeInputCapabilities& aAnother) const;  
	  TBool operator!=(const TCoeInputCapabilities& aAnother) const;  
	  void MergeWith(const TCoeInputCapabilities& aAnother);
	  void SetCapabilities(TUint aCapabilities);
	  TUint Capabilities() const;
	  TBool IsNone() const;
	  TBool SupportsWesternNumericIntegerPositive() const;
	  TBool SupportsWesternNumericIntegerNegative() const;
	  TBool SupportsWesternNumericReal() const;
	  TBool SupportsWesternAlphabetic() const;
	  TBool SupportsJapaneseHiragana() const;
	  TBool SupportsJapaneseKatakanaHalfWidth() const;
	  TBool SupportsJapaneseKatakanaFullWidth() const;
	  TBool SupportsDialableCharacters() const;
	  TBool SupportsSecretText() const;
	  TBool SupportsAutoSentenceCase() const;
	  TBool SupportsAllText() const;
	  TBool SupportsNavigation() const;
	  MCoeFepAwareTextEditor* FepAwareTextEditor() const;
	  MCoeCaptionRetrieverForFep* CaptionRetrieverForFep() const;
	  MCoeFepSpecificExtensions* FepSpecificExtensions(TUid aFepUid) const;
      MObjectProvider* ObjectProvider() const;
      void SetObjectProvider(MObjectProvider* aObjectProvider);

private:
	TUint iCapabilities;
	MCoeFepAwareTextEditor* iFepAwareTextEditor;
	MCoeCaptionRetrieverForFep* iCaptionRetrieverForFep;
	TUint iFepUid;
	MCoeFepSpecificExtensions* iFepSpecificExtensions;
    MObjectProvider* iObjectProvider;
    TAny* iSpareForFutureUse[5];
	};


# 38 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemop.h" 1
 
 






 







 
 
 
 
 
class TTypeUid : public TUid
 

















	{
public:
	class Ptr
	 



		{
		friend class TTypeUid;
	private:
		explicit inline Ptr(TAny* aPtr)
			: iPtr(aPtr)
			{}
	public:
		inline TAny* Pointer() const
		 


			{return iPtr;}
	private:
		TAny* iPtr;
		};
public:
	inline TTypeUid(TInt aUid)
	 



		{ iUid = aUid; }
	inline static Ptr Null()
	 


		{ return Ptr(0L ); }
	template <class T> inline Ptr MakePtr(T* aT) const
	 



		{  ; return Ptr(aT); }
	};


class MObjectProvider
 


















	{
public:
	template<class T>
	T* MopGetObject(T*& aPtr) 
	 








		{ return (aPtr=static_cast<T*>(MopGetById(T::ETypeId))); }

private:  
	 







	virtual TTypeUid::Ptr MopSupplyObject(TTypeUid aId) = 0;

private:  
	 


	  virtual MObjectProvider* MopNext();

private: 
	  TAny* MopGetById(TTypeUid aId);
	};


# 42 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 2



class TResourceReader;
class CCoeEnv;
class MCoeControlContext;
class CCoeControlExtension;


class TCoeColorUse
 








    {
public:
	 
	enum TGround
		{
		 
		EFore=0x01,
		 
		EBack=0x02
		};

	 
	enum TAreas
		{
		 
		EContents=0x10,
		 
		EHighlights=0x20,
		 
		ESurrounds=0x40,
		 
		EBorders=0x80
		};

	 
	enum TFocus
		{
		 

		EActive=0x100,
		 

		EDimmed=0x200,
		 
		EShadowed=0x400,	
		 
		EPressed=0x800
		};

	 
	enum TState
		{
		 
		ENormal=0x1000,
		 
		ESet=0x2000,
		 
		EChecked=0x4000
		};

	 
	enum TTones
		{
		 
		ENeutral=0x10000,
		 
		ELight=0x20000,
		 
		EMidLight=0x40000,
		 
		EMid=0x80000,
		 
		EDark=0x100000
		};
public:
	  TCoeColorUse();
	 
	  void SetUse(TInt aUse);
	  void SetLogicalColor(TInt aLogicalColor);
	  TInt LogicalColor() const;
	  TInt Use() const;
	 
	  TBool IsForeground() const;
	  TBool IsBackground() const;
	 
	  TBool IsContents() const;
	  TBool IsHighlights() const;
	  TBool IsSurrounds() const;
	  TBool IsBorders() const;
	  TBool IsActive() const;
	  TBool IsDimmed() const;
	  TBool IsPressed() const;
	  TBool IsNormal() const;
	  TBool IsSet() const;
private:
    TInt iLogicalColor;
	TInt iUse;
    };


class RCoeExtensionStorage
 
	{
public:
	RCoeExtensionStorage();
	void Close();
	TInt& Flags();
	TInt Flags() const;
	void SetExtension(CCoeControlExtension* aExtension);
	CCoeControlExtension* Extension() const;
private:
	inline TBool IsFlags() const;
private:
	union
		{
		TInt iFlags;
		CCoeControlExtension* iExtension;
		};
	};


class CCoeControl : public CBase

								, public MObjectProvider

 



	{
public:
	  CCoeControl();
	  ~CCoeControl();
	 
	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  virtual void MakeVisible(TBool aVisible);
	  virtual void SetDimmed(TBool aDimmed);
	  virtual void SetContainerWindowL(const CCoeControl& aContainer);
	  void SetContainerWindowL(RWindow& aWindow); 
	  void SetContainerWindowL(RBackedUpWindow& aWindow);
	  virtual void ConstructFromResourceL(TResourceReader& aReader);
	  virtual void ActivateL();
	  virtual void PrepareForFocusLossL();
	  virtual void PrepareForFocusGainL();
	  virtual void SetAdjacent(TInt aAdjacent);
	  virtual void SetNeighbor(CCoeControl* aNeighbor);
	  virtual TBool HasBorder() const;
	  virtual TSize MinimumSize();
	  virtual void HandleResourceChange(TInt aType);			 
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void GetHelpContext(TCoeHelpContext& aContext) const;
	  virtual TCoeInputCapabilities InputCapabilities() const;
	  TCoeInputCapabilities RecursivelyMergedInputCapabilities() const;  
	  void DrawNow() const;
	  void DrawDeferred() const;
	  void SetFocus(TBool aFocus,TDrawNow aDrawNow=ENoDrawNow);
	  void SetExtent(const TPoint& aPosition,const TSize& aSize);
	  void SetSize(const TSize& aSize);
	  void SetPosition(const TPoint& aPosition);
	  void SetRect(const TRect& aRect);
	  void SetExtentToWholeScreen();
	  TBool IsFocused() const;
	  TBool IsVisible() const;
	  TBool IsDimmed() const;
	  RDrawableWindow* DrawableWindow() const;
	  TSize Size() const;
	  TPoint Position() const;
	  TRect Rect() const;
	  TPoint PositionRelativeToScreen() const;
	  void SetObserver(MCoeControlObserver* aObserver);
	  MCoeControlObserver* Observer() const;
	inline CCoeEnv* ControlEnv() const;
	  TInt Index(const CCoeControl* aControl) const;
	  void SetNonFocusing();
	  void SetFocusing(TBool aFocusing);  
	  TBool IsNonFocusing() const;
	  void SetControlContext(MCoeControlContext* aContext);
	  void CopyControlContextFrom(const CCoeControl* aControl);
	  MCoeControlContext* ControlContext() const;
	  TBool OwnsWindow() const;
	  TBool IsBackedUp() const;
	  void SetPointerCapture(TBool aCapture=ETrue);
	  void ClaimPointerGrab(TBool aSendUpEvent=ETrue);
	  void IgnoreEventsUntilNextPointerUp();
	  void SetComponentsToInheritVisibility(TBool aInherit=ETrue);
	  void SetGloballyCapturing(TBool aGlobal);
	  void OverrideColorL(TInt aLogicalColor,TRgb aColor);  
	  TBool GetColor(TInt aLogicalColor,TRgb& aColor) const;  

	 
	  void SetMopParent(MObjectProvider* aParent);

public:  
	void ProcessPointerEventL(const TPointerEvent& aPointerEvent);
	void ProcessPointerBufferReadyL();
	void RecursivelyMergeInputCapabilities(TCoeInputCapabilities& aInputCapabilities) const;
	void WriteInternalStateNowL(RWriteStream& aWriteStream) const;
protected:
	  virtual void HandlePointerEventL(const TPointerEvent& aPointerEvent);
	  virtual void HandlePointerBufferReadyL();
	  virtual void FocusChanged(TDrawNow aDrawNow);
	  virtual void SizeChanged();
	  virtual void PositionChanged();
public:
	  virtual TInt CountComponentControls() const;
	  virtual CCoeControl* ComponentControl(TInt aIndex) const;
protected:
	  void EnableDragEvents();
	  void HandleRedrawEvent(const TRect& aRect) const;
	  RWindow& Window() const;
	  RBackedUpWindow& BackedUpWindow() const;
	  void CloseWindow();
	  void CreateWindowL();
	  void CreateWindowL(const CCoeControl* aParent);
	  void CreateWindowL(RWindowTreeNode& aParent);
	  void CreateWindowL(RWindowGroup* aParent);
	  void CreateBackedUpWindowL(RWindowTreeNode& aParent);  
	  void CreateBackedUpWindowL(RWindowTreeNode& aParent,TDisplayMode aDisplayMode);
	  void SetAllowStrayPointers();
	  void SetCanDrawOutsideRect();
	  void SetBlank();
	  void ReportEventL(MCoeControlObserver::TCoeEvent aEvent);
	  void SetCornerAndSize(TGulAlignment aCorner,const TSize& aSize);
	  void SetSizeWithoutNotification(const TSize& aSize);
	  CWindowGc& SystemGc() const;
	  void ActivateGc() const;
	  void ResetGc() const;
	  void DeactivateGc() const;
	  TBool IsReadyToDraw() const;
	  TBool IsActivated() const;
	  TBool IsBlank() const;
	  TBool IsBeingDestroyed() const;
	  CCoeControl* GrabbingComponent() const;
	  TBool CapturesPointer() const;
	  void HandleComponentControlsResourceChange(TInt aType);  

protected:  
	  virtual TTypeUid::Ptr MopSupplyObject(TTypeUid aId);

private:  
	  virtual MObjectProvider* MopNext();

private:
	friend class CCoeRedrawer;
	  virtual void Draw(const TRect& aRect) const;
	void DrawComponents(const TRect& aRect) const;
	void DrawWindowOwningComponentsNow() const;
	void SetGrabbed(TBool aGrabbed);
	TBool IsGrabbed() const;
	void DoMakeVisible(TBool aVisible);
	void CheckPointerEventPurge() const;
	inline TInt Flags() const;
	inline TInt& Flags();
protected:  
	  virtual void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:
 
	  virtual void Reserved_2();
protected:
	CCoeEnv* iCoeEnv;
	MCoeControlContext* iContext;
	TPoint iPosition;
	TSize iSize;
private:
	RDrawableWindow* iWin;
	MCoeControlObserver* iObserver;
	RCoeExtensionStorage iExt;

	MObjectProvider* iMopParent;

	};


inline CCoeEnv* CCoeControl::ControlEnv() const
 


	{return(iCoeEnv);}


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbctrl.h" 2



class CEikBorderedControl : public CCoeControl
	{
public:
	  CEikBorderedControl();
	  CEikBorderedControl(const TGulBorder& aBorder);
public:  
	  TBool HasBorder() const;
	  void SetAdjacent(TInt aAdjacent);
	  void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;
	  void HandleResourceChange(TInt aType);
public:  
	  void SetBorder(TGulBorder::TBorderType aBorderType);
	  void SetBorder(TInt aBorderType);
	  TGulBorder Border() const;
protected:  
	  void Draw(const TRect& aRect) const;
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
protected:
	TGulBorder iBorder;
	};




# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdpobs.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikfctry.h" 1
 
 
 
 








class CCoeControl;

enum
	{
	EEikControlHasEars=0x01,
	EEikControlIsNonFocusing=0x02,
	EEikControlHasExtraAscent=0x04
	};

struct SEikControlInfo
    {
    CCoeControl* iControl;
	TInt iTrailerTextId;
    TInt iFlags;
    };

class EikControlFactory
	{
public:
      static SEikControlInfo CreateByTypeL(TInt aControlType);
	};


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdpobs.h" 2



 





class MEikDialogPageObserver
	{
 




	public:
		enum TFormControlTypes
		{
		EUnknownType,
		EEdwinDerived,
		EMfneDerived,
		EPopfieldDerived,
		ESecretEditorDerived,
		ESliderDerived
		};
public:
	 



	virtual void PrepareForFocusTransitionL()=0;

	 


	virtual void PageChangedL(TInt aPageId)=0;

	 


	virtual void LineChangedL(TInt aControlId)=0;

	 




	virtual SEikControlInfo CreateCustomControlL(TInt aControlType)=0;

	 





	virtual TFormControlTypes ConvertCustomControlTypeToBaseControlType(TInt aControlType)const =0 ;

	 



	virtual void GetCustomAutoValue(TAny* aReturnValue,TInt aControlType,const CCoeControl* aControl)=0;
	};


# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulftflg.hrh" 1
 
 
 
 

 





 





 





 





 





 





 





 





 





 





 





 





 





 





 





 




# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2





 
 
 


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbutb.h" 1
 
 
 
 











# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/lafpublc.h" 1
 
 
 
 






const TInt KLafScrollBarButtonPositionMask = 0x00C0;	 

struct SLafScrollButton
	{
	enum TType
		{
		ENudgeLeft,
		ENudgeUp,
		ENudgeRight,
		ENudgeDown,
		EPageLeft,
		EPageUp,
		EPageRight,
		EPageDown,
		EHome,
		ETop,
		EEnd,
		EBottom
		};
	};

struct SLafScrollBar
	{
	enum TEikScrollBarFlags
		{
		EEikScrollBarDefaultBehaviour	=0x0000,
		EEikScrollBarNoNudgeButtons		=0x0001,
		EEikScrollBarHasPageButtons		=0x0002,
		EEikScrollBarHasHomeEndButtons  =0x0004,
		EEikScrollBarNoShaftOrThumb 	=0x0008,
		EEikScrollBarShaftButNoThumb 	=0x0010,
		EButtonsAtStartOfShaft  		=0x0040,
		EButtonsAtEndOfShaft 			=0x0080,
		EButtonsEitherSideOfShaft 		=EButtonsAtStartOfShaft|EButtonsAtEndOfShaft,
		ENoAutoDimming					=0x0100
		};

	enum TOrientation
		{
		EVertical,
		EHorizontal
		};

	};

struct SLafListBox
	{
	enum TFlags
		{
		EMultipleSelection			= 0x0001,
		ENoExtendedSelection		= 0x0002,
		EIncrementalMatching		= 0x0004,
		EPopout						= 0x0008,
		ELeftDownInViewRect			= 0x0010,
		EItemDoubleClicked			= 0x0020,
		EKeepModel					= 0x0040,
		EScrollBarSizeExcluded		= 0x0080,
		EStateChanged				= 0x0100,
		ECreateOwnWindow			= 0x0200,
        ENoFirstLetterMatching      = 0x0400,
		EPaintedSelection			= 0x0800
		};
    enum TListItemAttribute
        {
		ECurrent    = 0x0001,		 
		EEmphasized = 0x0002,		 
		ESelected   = 0x0004,		 
		 
		 
		EMask		= 0x0007  
        };
	enum TListItemFlags
		{
		EItemDrawMarkSelection			= 0x0001,
		EItemPaintedSelection			= 0x0002,
		EItemDrawOnlyActiveSelection	= 0x0004
		};
	};

struct SLafScrollThumb
	{
	enum TOrientation
		{
		EVertical,
		EHorizontal
		};
	};

struct SLafScrollBarFrame
	{
	enum TScrollBarVisibility
		{
		EOff,
		EOn,
		EAuto
		};

	enum TScrollBarSide
		{
		EBottomOrRight,
		ETopOrLeft
		};

	enum TScrollBarManagement
		{
		EComponent,
		EFloating,
		EApplicationScrollBar
		};
	};

struct SLafControlGroup
	{
	enum TStartCorner
		{
		EFromTopLeft=0x1,
		EFromTopRight=0x2,
		EFromBottomLeft=0x3,
		EFromBottomRight=0x4
		};
	enum TOrientation
		{
		ELayHorizontally=0x10,
		ELayVertically=0x20
		};
	};

struct SLafButtonGroupContainer
	{
	enum TUse
		{
		EView,
		EDialog,
		EToolbar,
		ECba,
		EDialogButtons
		};
	enum TOrientation
		{
		EVertical,
		EHorizontal
		};
	enum TLocation
		{
		EInternal,	 
		EExternal	 
		};
	};

struct SLafMenuBar
	{
	enum { ENominalTextLength = 40 };
	};

struct SLafMenuPane
	{
	enum THighlightType
		{
		ENoHighlight,
		EDrawHighlight,
		ERemoveHighlight
		};
	};

struct SLafButtonBase
	{
	enum TDrawState
		{
		EDrawClear					=0x00,
		EDrawSet					=0x01,
		EDrawIndeterminate			=0x02,
		EDrawClearPressed			=0x10,
		EDrawSetPressed				=0x11,
		EDrawIndeterminatePressed	=0x12
		};
	};



# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbutb.h" 2


class TEikButtonCoordinator;

enum TButtonBehavior
	{
	EEikButtonStaysClear= 0x000 ,
	EEikButtonStaysSet= 0x100 ,
	EEikButtonLatches= 0x200 ,
	EEikButtonReportsOnPointerDown= 0x400 
	};

class CEikButtonBase : public CEikBorderedControl
	{
public:
	  CEikButtonBase();
	  ~CEikButtonBase();
public:
	enum TState
		{
		EClear		  	=0,
		ESet			=1,
		EIndeterminate  =2
		};
public:  
	  TState State() const;
	  void SetState(TState aState);
	  virtual void Animate();
	  void SetCoordinator(TEikButtonCoordinator* aButCoord);
	  void SetBehavior(TButtonBehavior aBehavior);
	  void SetIgnoreNextPointerUp();
protected:
	enum TDrawState
		{
		EDrawClear					=SLafButtonBase::EDrawClear,
		EDrawSet					=SLafButtonBase::EDrawSet,
		EDrawIndeterminate			=SLafButtonBase::EDrawIndeterminate,
		EDrawClearPressed			=SLafButtonBase::EDrawClearPressed,
		EDrawSetPressed				=SLafButtonBase::EDrawSetPressed,
		EDrawIndeterminatePressed	=SLafButtonBase::EDrawIndeterminatePressed
		};
protected:  
	  void SetReportOnPointerDown();
	  TDrawState DrawState() const;
	  TBool IsPressed() const;
	  void SetAllowTristate();
	  void CopyDrawStateTo(CEikButtonBase* aTargetButton) const;
public:	 
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:  
	  void Reserved_2();
private:  
	  virtual void StateChanged();
	  virtual void Reserved_3();
public:  
	  void HandlePointerEventL(const TPointerEvent& aPointerEvent);
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  TCoeInputCapabilities InputCapabilities() const;  
private:  
	TBool ClickCompleted();
private:
	enum { EIgnoreNextPointerUp=0x1000 };
protected:
	TInt iButFlags;
private:
	TEikButtonCoordinator* iButCoord;
	TInt iSpare;
	};

 
 
 

class TEikButtonCoordinator
	{
public:
	  TEikButtonCoordinator();
	  void SetChosenButton(CEikButtonBase* aChosenButton);		
private:
	CEikButtonBase* iChosenButton;
	};		 


# 40 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgpc.h" 1
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgrp.h" 1
 
 
 
 








class CCoeControl;
class CEikCommandButton;
class CFbsBitmap;

 


class MEikButtonGroup
	{
public:
	void Release();
	virtual void SetCommandL(TInt aPosition,TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask)=0;
	virtual void SetCommandL(TInt aPosition,TInt aResourceId)=0;
	virtual void SetCommandSetL(TInt aResourceId)=0;
	virtual void AddCommandL(TInt aPosition,TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask)=0;
	virtual void AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask)=0;
	virtual void AddCommandToStackL(TInt aPosition,TInt aResourceId)=0;
	virtual void AddCommandSetToStackL(TInt aResourceId)=0;
	virtual void SetDefaultCommand(TInt aCommandId)=0;
	virtual TSize CalcMinimumSizeL(TInt aResourceId)=0;
	virtual void RemoveCommandFromStack(TInt aPosition,TInt aCommandId)=0;
	virtual TInt CommandPos(TInt aCommandId) const=0;
	virtual void DimCommand(TInt aCommandId,TBool aDimmed)=0;
	virtual TBool IsCommandDimmed(TInt aCommandId) const=0;
	virtual void MakeCommandVisible(TInt aCommandId,TBool aVisible)=0;
	virtual TBool IsCommandVisible(TInt aCommandId) const=0;
	  virtual void AnimateCommand(TInt aCommandId);
	virtual CCoeControl* AsControl()=0;
	virtual const CCoeControl* AsControl() const=0;
	 
	virtual void SetBoundingRect(const TRect& aBoundingRect)=0;
	virtual void ReduceRect(TRect& aBoundingRect) const=0;
	 
	virtual CCoeControl* GroupControlById(TInt aCommandId) const=0;
	virtual CEikCommandButton* GroupControlAsButton(TInt aCommandId) const=0;
	virtual TInt CommandId(TInt aCommandPos) const=0;
	virtual TInt ButtonCount() const=0;
	virtual TUint ButtonGroupFlags() const=0;
private:
	  void Reserved_1();
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgpc.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcmobs.h" 1
 
 
 
 








class CCoeControl;

class MEikCommandObserver
	{
public:
	virtual void ProcessCommandL(TInt aCommandId)=0;
	  virtual CCoeControl* CreateCustomCommandControlL(TInt aControlType);
	};


# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgpc.h" 2











class MEikCommandObserver;
class CEikButtonGroupStack;
class CEikCommandButton;

 







class CEikButtonGroupContainer : public CCoeControl, public MEikCommandObserver
	{
public:
	enum { ETypeId =  0x101F4107  }; 

	enum TUse
		{
		EView			=SLafButtonGroupContainer::EView,
		EDialog			=SLafButtonGroupContainer::EDialog,
		EToolbar		=SLafButtonGroupContainer::EToolbar,		 
		ECba			=SLafButtonGroupContainer::ECba,			 
		EDialogButtons	=SLafButtonGroupContainer::EDialogButtons	 
		};
	enum TOrientation
		{
		EVertical	=SLafButtonGroupContainer::EVertical,
		EHorizontal =SLafButtonGroupContainer::EHorizontal
		};
	enum TLocation
		{
		EInternal	=SLafButtonGroupContainer::EInternal,	 
		EExternal	=SLafButtonGroupContainer::EExternal 
		};
	enum THotKeyFlags
		{
		EShowHotKey			=0x01,
		EPlainHotKey		=0x02
		};
	enum TFlags
		{
		EAddToStack			=0x01,
		EDelayActivation	=0x02,
		EUseMaxSize			=0x04,
		};
public:
	  static CEikButtonGroupContainer* NewL(TUse aUse,TOrientation aOrientation,
													MEikCommandObserver* aCommandObserver,TInt aResourceId,
													TUint aFlags=EAddToStack);
	  static CEikButtonGroupContainer* NewL(TUse aUse,TOrientation aOrientation,
													MEikCommandObserver* aCommandObserver,TInt aResourceId,
													const CCoeControl& aParent,TUint aFlags=EAddToStack);
	  static CEikButtonGroupContainer* NewL(TUse aUse,TOrientation aOrientation,
													MEikCommandObserver* aCommandObserver,TInt aResourceId,
													RWindowGroup& aParentWg,TUint aFlags=EAddToStack);
	  ~CEikButtonGroupContainer();
	  static CEikButtonGroupContainer* Current();
public:
	inline void SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText);
	inline void SetCommandL(TInt aPosition,TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	inline void SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	inline void SetCommandL(TInt aPosition,TInt aResourceId);
	inline void SetCommandL(TInt aCommandId,const TDesC& aText);
	inline void SetCommandL(TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void SetCommandL(TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void SetCommandL(TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	inline void SetCommandL(TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	  void SetCommandSetL(TInt aResourceId);
	inline void AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText);
	inline void AddCommandL(TInt aPosition,TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	inline void AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	inline void AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aText);
	inline void AddCommandToStackL(TInt aPosition,TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask);
	inline void AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	inline void AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId);
	inline void AddCommandToStackL(TInt aPosition,TInt aResourceId);
	  void AddCommandSetToStackL(TInt aResourceId);
	  void RemoveCommandFromStack(TInt aPosition,TInt aCommandId);
	  void SetDefaultCommand(TInt aCommandId); 
	  TSize CalcMinimumSizeL(TInt aResourceId) const;
	  void CleanupCommandPushL(TInt aPosition);
	inline void CleanupCommandPop();
	  void CleanupCommandPop(TInt aCount);
	inline void CleanupCommandPopAndDestroy();
	inline void CleanupCommandPopAndDestroy(TInt aCount);
	  TInt MaxCommands() const;
	  TInt ButtonCount() const;
	  void DimCommand(TInt aCommandId,TBool aDimmed);
	  TBool IsCommandDimmed(TInt aCommandId) const;
	  void MakeCommandVisible(TInt aCommandId,TBool aVisible);
	  TBool IsCommandVisible(TInt aCommandId) const;
	  void AnimateCommand(TInt aCommandId);
	  TLocation Location() const;
	  CEikCommandButton* CommandButtonOrNull(TInt aCommandId) const;
	 
	  void SetBoundingRect(const TRect& aRect);
	  void ReduceRect(TRect& aBoundingRect) const;
	 
	  CCoeControl* ControlOrNull(TInt aCommandId) const;
	  CEikCommandButton* ButtonById(TInt aCommandId) const;
	  TInt PositionById(TInt aCommandId) const;
	  void UpdateHotKey(TInt aCommandId,THotKeyFlags aFlags,TInt aKeyId);
	  void UpdateCommandObserverL(TInt aPos,MEikCommandObserver& aCommandObserver);
	  void RemoveCommandObserver(TInt aPos);
	  TBool DelayActivation() const;
	 
	inline MEikButtonGroup* ButtonGroup();
	inline TUse ButtonGroupType();
public:  
	  TSize MinimumSize();
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	void MakeVisible(TBool aVisible);
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
public:  
	  virtual void Reserved_MtsmPosition();
	  virtual void Reserved_MtsmObject();
private:
	enum TCommandOp {ESet, EAdd, EPush};
private:
	class TCmdPos
		{
	public:
		inline TCmdPos();
		inline TCmdPos(TInt aPos,TInt aCmd);
	public:
		TInt iPos;
		TInt iCmd;
		};
	class TCmdObserver
		{
	public:
		inline TCmdObserver(TInt aPos,MEikCommandObserver& aObserver);
	public:
		TInt iPos;
		MEikCommandObserver& iObserver;
		};
	class CCmdObserverArray : public CArrayFixFlat<TCmdObserver>
		{
	public:
		inline CCmdObserverArray();
		TInt FindIndex(TInt aPos);
		};
private:
	CEikButtonGroupContainer(TUse aUse);
	void ConstructL(TOrientation aOrientation,MEikCommandObserver* aCommandObserver,TInt aResourceId,RWindowGroup* aParentWg,TUint aFlags);
	  void DoSetCommandL(TInt aPosition,TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask,TCommandOp aOp);
	  void DoSetCommandL(TInt aPosition,TInt aCommandId,const TDesC* aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId,TCommandOp aOp);
	  void DoSetCommandL(TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask,TCommandOp aOp);
	  void DoSetCommandL(TInt aCommandId,const TDesC* aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId,TCommandOp aOp);
	  void DoSetCommandL(TInt aPosition,TInt aResourceId,TCommandOp aOp);
	inline CCoeControl* ButtonGroupAsControl() const;
	void UpdateRect();
	static void CleanupCommandDestroy(TAny* aPtr);
	TCmdPos DoCleanupCommandPop();
	void DoCleanupCommandPopAndDestroy();
private:  
	TInt CountComponentControls() const;
	CCoeControl* ComponentControl(TInt aIndex) const;
	void SizeChanged();
private:  
	void ProcessCommandL(TInt aCommandId);
	CCoeControl* CreateCustomCommandControlL(TInt aControlType);
private:
	MEikButtonGroup* iButtonGroup;
	TUse iUse;
	CArrayFix<TCmdPos>* iCommandsCleanup;
	MEikCommandObserver* iCommandObserver;
	CCmdObserverArray* iObserverArray;
	TDblQueLink iBtLink;
private:
	friend class CCmdObserverArray;
	friend class CEikButtonGroupStack;
	};


 





inline void CEikButtonGroupContainer::SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText)
	{DoSetCommandL(aPosition,aCommandId,&aText,0L ,0L ,ESet);}
 







inline void CEikButtonGroupContainer::SetCommandL(TInt aPosition,TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aPosition,aCommandId,0L ,&aBitmap,&aMask,ESet);}
 







inline void CEikButtonGroupContainer::SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aPosition,aCommandId,&aText,&aBitmap,&aMask,ESet);}
 






inline void CEikButtonGroupContainer::SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aPosition,aCommandId,0L ,aFile,aBitmapId,aMaskId,ESet);}
 






inline void CEikButtonGroupContainer::SetCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aPosition,aCommandId,&aText,aFile,aBitmapId,aMaskId,ESet);}
 





inline void CEikButtonGroupContainer::SetCommandL(TInt aPosition,TInt aResourceId)
	{DoSetCommandL(aPosition,aResourceId,ESet);}
 







inline void CEikButtonGroupContainer::SetCommandL(TInt aCommandId,const TDesC& aText)
	{DoSetCommandL(aCommandId,&aText,0L ,0L ,ESet);}
 









inline void CEikButtonGroupContainer::SetCommandL(TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aCommandId,0L ,&aBitmap,&aMask,ESet);}
 








inline void CEikButtonGroupContainer::SetCommandL(TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aCommandId,&aText,&aBitmap,&aMask,ESet);}
 









inline void CEikButtonGroupContainer::SetCommandL(TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aCommandId,0L ,aFile,aBitmapId,aMaskId,ESet);}
 









inline void CEikButtonGroupContainer::SetCommandL(TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aCommandId,&aText,aFile,aBitmapId,aMaskId,ESet);}
 





inline void CEikButtonGroupContainer::AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText)
	{DoSetCommandL(aPosition,aCommandId,&aText,0L ,0L ,EAdd);}
 





inline void CEikButtonGroupContainer::AddCommandL(TInt aPosition,TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aPosition,aCommandId,0L ,&aBitmap,&aMask,EAdd);}
 





inline void CEikButtonGroupContainer::AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aPosition,aCommandId,&aText,&aBitmap,&aMask,EAdd);}
 





inline void CEikButtonGroupContainer::AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aPosition,aCommandId,0L ,aFile,aBitmapId,aMaskId,EAdd);}
 





inline void CEikButtonGroupContainer::AddCommandL(TInt aPosition,TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aPosition,aCommandId,&aText,aFile,aBitmapId,aMaskId,EAdd);}
 





inline void CEikButtonGroupContainer::AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aText)
	{DoSetCommandL(aPosition,aCommandId,&aText,0L ,0L ,EPush);}
 





inline void CEikButtonGroupContainer::AddCommandToStackL(TInt aPosition,TInt aCommandId,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aPosition,aCommandId,0L ,&aBitmap,&aMask,EPush);}
 





inline void CEikButtonGroupContainer::AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aText,const CFbsBitmap& aBitmap,const CFbsBitmap& aMask)
	{DoSetCommandL(aPosition,aCommandId,&aText,&aBitmap,&aMask,EPush);}
 





inline void CEikButtonGroupContainer::AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aPosition,aCommandId,0L ,aFile,aBitmapId,aMaskId,EPush);}
 





inline void CEikButtonGroupContainer::AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC& aText,const TDesC& aFile,TInt aBitmapId,TInt aMaskId)
	{DoSetCommandL(aPosition,aCommandId,&aText,aFile,aBitmapId,aMaskId,EPush);}
 





inline void CEikButtonGroupContainer::AddCommandToStackL(TInt aPosition,TInt aResourceId)
	{DoSetCommandL(aPosition,aResourceId,EPush);}
 




inline void CEikButtonGroupContainer::CleanupCommandPop()
	{CleanupCommandPop(1);}
 





inline void CEikButtonGroupContainer::CleanupCommandPopAndDestroy()
	{CleanupStack::PopAndDestroy();}
 





inline void CEikButtonGroupContainer::CleanupCommandPopAndDestroy(TInt aCount)
	{CleanupStack::PopAndDestroy(aCount);}

inline MEikButtonGroup* CEikButtonGroupContainer::ButtonGroup()
	{return iButtonGroup;}

inline CEikButtonGroupContainer::TUse CEikButtonGroupContainer::ButtonGroupType()
	{return iUse;}


# 44 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupfader.h" 1
 


















 
 
 
 






class CCoeControl;


class MAknFadedComponent
	{
public:
	  virtual TInt CountFadedComponents();
	  virtual CCoeControl* FadedComponent(TInt aIndex);
	};

class TAknPopupFader
	{
public:
	  void FadeBehindPopup(MAknFadedComponent* aComponent, CCoeControl* aParent, TBool aFade);

public:	 
	static void CreateStaticL();

private:
	void FadeBehindPopupL(MAknFadedComponent* aComponent, CCoeControl* aParent, TBool aFade);

private:
	TBool iBackgroundFaded;  
	};



# 47 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdialg.h" 2


 
 
 

class CEikMover;
class CEikCaptionedControl;
class CEikCapCArray;
class CEikDialogPageSelector;
class CEikButtonGroupContainer;
class CEikDialogButtonCommandObserver;
class MEikCommandObserver;
class CAknDialog;
class CAknNoteDialog;

struct SEikControlInfo;

class  CEikDialogExtension ;
 
class CAknsListBoxBackgroundControlContext ;
 
 
 

class CEikLabel;
class CGlobalText;
struct SEikRange;
struct SEikDegreesMinutesDirection;


 




class CEikDialog : public CEikBorderedControl,public MCoeControlObserver,public MEikDialogPageObserver,public MCoeControlContext, public MAknFadedComponent
	{ 
public:
	  CEikDialog(); 
	  ~CEikDialog(); 
	  virtual TInt ExecuteLD(TInt aResourceId);
	  virtual void PrepareLC(TInt aResourceId);
	  virtual TInt RunLD();
	  void SetTitleL(const TDesC& aText);
	  void SetTitleL(TInt aResourceId);
	  void SetPageDimmedNow(TInt aPageId,TBool aDimmed);
	  void SetLineNonFocusing(TInt aControlId);
	  void SetLineDimmedNow(TInt aControlId,TBool aDimmed);
	  void MakeLineVisible(TInt aControlId,TBool aVisible);
	  void MakeWholeLineVisible(TInt aControlId,TBool aVisible);
	  void DeleteLine(TInt aControlId, TBool aRedraw=ETrue);
	  void InsertLineL(TInt aIndex,TInt aResourceId,TInt aPageId=0);
	  void MakePanelButtonVisible(TInt aButtonId,TBool aVisible);
	  void TryChangeFocusToL(TInt aControlId);
	  void SwitchLineLatency(TInt aBecomesLatent,TInt aNoLongerLatent);
	  void SetPageDensePacking(TInt aPageId,TBool aDensePacking);
	  void ConstructAutoDialogLC(TInt aFlags,TInt aButtonsId);
	  void DeclareItemAuto(TInt aControlId,TInt aControlType,TAny* aReturnValue);
	  void Layout();
	  TSize PreferredSize(const TSize& aMaxSize) const;
	  CCoeControl* CreateLineByTypeL(const TDesC& aCaption,TInt aControlId,TInt aControlType,TAny* aReturnValue);
	  CCoeControl* CreateLineByTypeL(const TDesC& aCaption,TInt aPageId,TInt aControlId,TInt aControlType,TAny* aReturnValue);
	  void SetControlCaptionL(TInt aControlId,const TDesC& aText);
	  void SetControlCaptionL(TInt aControlId,TInt aResourceId);
	  CEikLabel* ControlCaption(TInt aControlId) const;
	  CCoeControl* Control(TInt aControlId) const;
	  CCoeControl* ControlOrNull(TInt aControlId) const;
	  CEikButtonGroupContainer& ButtonGroupContainer() const;
	  CEikMover& Title() const;
	  TInt ActivePageId() const;
	  void ActivateFirstPageL() const;


 
 
	  void SetEditableL( TBool aEditable ) ;
	  TBool IsEditable() const ;


public:  
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
	  TCoeInputCapabilities InputCapabilities() const;
	  void MakeVisible(TBool aVisible);
protected:  
	  virtual void PrepareForFocusTransitionL();
	  virtual void PageChangedL(TInt aPageId);
	  virtual void LineChangedL(TInt aControlId);
public:  
	  virtual SEikControlInfo CreateCustomControlL(TInt aControlType);
	  MEikDialogPageObserver::TFormControlTypes ConvertCustomControlTypeToBaseControlType(TInt aControlType) const;
	  virtual void GetCustomAutoValue(TAny* aReturnValue,TInt aControlType,const CCoeControl* aControl);
protected:  
	  void PrepareContext(CWindowGc& aGc) const;
protected:  
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:  
	  void Draw(const TRect& aRect) const;
protected:
	  TInt CountComponentControls() const;
	  CCoeControl* ComponentControl(TInt aIndex) const;
protected:
	  TInt GetNumberOfLinesOnPage(TInt aPageIndex) const;
	  TInt GetNumberOfPages() const;
	  CEikCaptionedControl* GetLineByLineAndPageIndex(TInt aLineIndex, TInt aPageIndex) const;
private:
	  void SizeChanged();
	  TSize MinimumSize();
	  void ConstructFromResourceL(TResourceReader& aReader);
	  void Reserved_2();
protected:  
	  void HandleControlEventL(CCoeControl* aControl,TCoeEvent aEventType);
protected:  
	  void TryExitL(TInt aButtonId);
	  void AdjustAllIdsOnPage(TInt aPageId,TInt aControlIdDelta);
	  void ConstructSleepingDialogL(TInt aResourceId);
	  void ConstructSleepingAlertDialogL(TInt aResourceId);
	  TInt RouseSleepingDialog();
	  void ExitSleepingDialog();
	  TInt IdOfFocusControl() const;
	  TInt FindLineIndex(const CCoeControl& aControl) const;
	  CEikCaptionedControl* Line(TInt aControlId) const;
	  CEikCaptionedControl* CurrentLine() const;
	  TBool RotateFocusByL(TInt aDelta);
	  TInt ActivePageIndex() const;
	  void ResetLineMinimumSizes();
	  CEikButtonGroupContainer* SwapButtonGroupContainer(CEikButtonGroupContainer* aContainer);
	  MEikCommandObserver* ButtonCommandObserver() const;
protected:  
	  virtual TBool OkToExitL(TInt aButtonId);
	  virtual void PreLayoutDynInitL();
	  virtual void PostLayoutDynInitL();
	  virtual void SetInitialCurrentLine();
	  virtual void HandleControlStateChangeL(TInt aControlId);
	  virtual void HandleInteractionRefused(TInt aControlId);
	  virtual void SetSizeAndPosition(const TSize& aSize);
	  virtual TInt BorderStyle();
	 


 





















	  virtual TInt MappedCommandId( TInt aButtonId );
	  TInt FormFlagsFromActivePage();
 









	  virtual CEikCaptionedControl* GetFirstLineOnFirstPageOrNull();
	  void    ControlsOnPage(RArray<CEikCaptionedControl*>& aControls, TInt aPageId) const;

protected:  
	  TTypeUid::Ptr MopSupplyObject(TTypeUid aId);
private:  
	  virtual void CEikDialog_Reserved_1();
	  virtual void CEikDialog_Reserved_2();

private:  
	void BaseConstructL();
	void StaticConstructL(TInt aResourceId);
	void DynamicConstructL();
	void CreateTitleBarL();
	void CreateButtonGroupContainerL(TInt aResourceId);
	void CreatePageSelectorL();
	void CreatePageSelectorL(TInt aResourceId);
	TInt WaitAsRequired();
	void StopWaitingAsRequired();
	TKeyResponse TryAnimateButtonAndExitL(TInt aKeycode);
	void GetAutoValues();
	void CommonConstructSleepingDialogL(TInt aResourceId);
	void SetBorderStyle();
	void FadeBehindPopup(TBool aFade);
	void DoFadeBehindPopup(TBool aFade);
	 
	  virtual TInt CountFadedComponents();
	  virtual CCoeControl* FadedComponent(TInt aIndex);
private:
	CEikMover* iTitleBar;
	CEikDialogPageSelector* iPageSelector;
	CEikButtonGroupContainer* iButtonGroupContainer;
	CEikDialogButtonCommandObserver* iButtonCommandObserver;
	TInt iDialogFlags;
	TInt* iExitConfirmed;

	TBool iIsEditable ;
	TAknPopupFader iPopupFader;
	CActiveSchedulerWait iWait;		 

public :
	 




	  CEikDialogExtension* Extension() const;

private :
	CEikDialogExtension* iExtension ;  

private:
	friend class CEikDialogButtonCommandObserver;
	friend class CEikDialogExtension;
	friend class CAknDialog;
        friend class CAknCharMapDialog;
	friend class CAknNoteDialog;

public:  
	  TInt DialogFlags();

protected: 
	void RegisterDialgWithPageSelector();

 
 
 
 
public:  
	  void DeclareAutoTextEditorL(TInt aId,TDes* aText);
	  void DeclareAutoNumberEditor(TInt aId,TInt* aNumber);
	  void DeclareAutoRangeEditor(TInt aId,SEikRange* aRange);
	  void DeclareAutoTimeEditor(TInt aId,TTime* aTime);
	  void DeclareAutoDateEditor(TInt aId,TTime* aDate);
	  void DeclareAutoTimeAndDateEditor(TInt aId,TTime* aTimeAndDate);
	  void DeclareAutoDurationEditor(TInt aId,TTimeIntervalSeconds* aDuration);
	  void DeclareAutoTimeOffsetEditor(TInt aId,TTimeIntervalSeconds* aTimeOffset);
 
 
	  void DeclareAutoFixedPointEditor(TInt aId,TInt* aValue);
	  void DeclareAutoSecretEditor(TInt aId,TDes* aText);

public:  
	  void AddAutoTextEditorL(const TDesC& aPrompt,TInt aId,TInt aFlags,TInt aWidthInChars,TInt aNoOfLines,TDes* aReturn);
	  void AddAutoGlobalTextEditorL(const TDesC& aPrompt,TInt aId,TInt aFlags,TInt aWidthInChars,TInt aNoOfLines,TInt aTextLimit,CGlobalText* aReturn,TInt aFontControlFlags= 0x001 ,TInt aFontNameFlags= 0x10 );
	  void AddAutoRichTextEditorL(const TDesC& aPrompt,TInt aId,TInt aFlags,TInt aWidthInChars,TInt aNoOfLines,TInt aTextLimit,CGlobalText* aReturn,TInt aFontControlFlags= 0x001 ,TInt aFontNameFlags= 0x10 );
	  void AddAutoNumberEditorL(const TDesC& aPrompt,TInt aId,TInt aMin,TInt aMax,TInt* aReturn);
	  void AddAutoRangeEditorL(const TDesC& aPrompt,TInt aId,TInt aMin,TInt aMax,HBufC* aSeparatorText,SEikRange* aReturn);
	  void AddAutoTimeEditorL(const TDesC& aPrompt,TInt aId,const TTime& aMin,const TTime& aMax,TBool aNoSeconds,TTime* aReturn);
	  void AddAutoDateEditorL(const TDesC& aPrompt,TInt aId,const TTime& aMin,const TTime& aMax, TBool aNoPopout,TTime* aReturn);
	  void AddAutoTimeAndDateEditorL(const TDesC& aPrompt,TInt aId,const TTime& aMin,const TTime& aMax,TBool aNoSeconds,TBool aNoPopout,HBufC* aInterveningText,TTime* aReturn);
	  void AddAutoDurationEditorL(const TDesC& aPrompt,TInt aId,const TTimeIntervalSeconds& aMin,const TTimeIntervalSeconds& aMax,TBool aNoSeconds,TTimeIntervalSeconds* aReturn);
	  void AddAutoTimeOffsetEditorL(const TDesC& aPrompt,TInt aId,const TTimeIntervalSeconds& aMin,const TTimeIntervalSeconds& aMax,TBool aNoSeconds,TTimeIntervalSeconds* aReturn);
 
 
	  void AddAutoFloatEditorL(const TDesC& aPrompt,TInt aId,const TReal& aMin,const TReal& aMax,TReal* aReturn);
	  void AddAutoFixedPointEditorL(const TDesC& aPrompt,TInt aId,TInt aMin,TInt aMax,TInt* aRetValue,TInt aDecimalPlaces);
	  void AddAutoSecretEditorL(const TDesC& aPrompt,TInt aId,TDes* aReturn);
protected:  
	  void SetLabelL(TInt aControlId, const TDesC& aDes);
	  void SetLabelL(TInt aControlId, TInt aResourceId);
	  void SetLabelReserveLengthL(TInt aControlId, TInt aLength);
	  void SetEdwinTextL(TInt aControlId, const TDesC* aDes);
	  void SetTextEditorTextL(TInt aControlId,const CGlobalText* aGlobalText);
	  void ResetSecretEditor(TInt aControlId);
	  void SetFloatingPointEditorValueL(TInt aControlId, const TReal* aValue);
	  void SetFixedPointEditorValueL(TInt aControlId,TInt aValue);
	  void SetFixedPointEditorDecimal(TInt aControlId, TInt aDecimal);
	  void SetNumberEditorMinAndMax(TInt aControlId, TInt aMinimumValue, TInt aMaximumValue);  
	  void SetNumberEditorValue(TInt aControlId, TInt aNumber);
	  void SetFloatEditorMinAndMax(TInt aControlId,TInt aMin,TInt aMax);
	  void SetFloatEditorValueL(TInt aControlId,TReal aFloat);
	  void SetRangeEditorMinAndMax(TInt aControlId, TInt aMinimumValue, TInt aMaximumValue);  
	  void SetRangeEditorValue(TInt aControlId, const SEikRange& aRange);
	  void SetTTimeEditorMinAndMax(TInt aControlId, const TTime& aMinimumTime, const TTime& aMaximumTime);  
	  void SetTTimeEditorValue(TInt aControlId, const TTime& aTime);
	  void SetDurationEditorMinAndMax(TInt aControlId, const TTimeIntervalSeconds& aMinimumDuration, const TTimeIntervalSeconds& aMaximumDuration);  
	  void SetDurationEditorValue(TInt aControlId, const TTimeIntervalSeconds& aDuration);
	  void SetTimeOffsetEditorMinAndMax(TInt aControlId, const TTimeIntervalSeconds& aMinimumTimeOffset, const TTimeIntervalSeconds& aMaximumTimeOffset);  
	  void SetTimeOffsetEditorValue(TInt aControlId, const TTimeIntervalSeconds& aTimeOffset);
 
 
	  void SetListBoxCurrentItem(TInt aControlId, TInt aItem);
	  void SetFileNameL(TInt aControlId, const TDesC* aFileName);
protected:  
	  void GetLabelText(TDes& aDes,TInt aControlId) const;
	  void GetEdwinText(TDes& aDes,TInt aControlId) const;
	  void GetTextEditorText(CGlobalText*& aGlobalText,TInt aControlId);
	  void GetSecretEditorText(TDes& aDes,TInt aControlId) const;
	  TReal FloatingPointEditorValue(TInt aControlId) const;
	  TInt FixedPointEditorValue(TInt aControlId) const;
	  TInt FixedPointEditorDecimal(TInt aControlId) const;
	  TReal FloatEditorValue(TInt aControlId) const;
	  TInt NumberEditorValue(TInt aControlId) const;
	  SEikRange RangeEditorValue(TInt aControlId) const;
	  TTime TTimeEditorValue(TInt aControlId) const;
	  TTimeIntervalSeconds DurationEditorValue(TInt aControlId) const;
	  TTimeIntervalSeconds TimeOffsetEditorValue(TInt aControlId) const;
 
 
	  void GetAutoValuesFromPage(CEikCapCArray* aLines);
	  TInt ListBoxCurrentItem(TInt aControlId) const;
	  void GetFileName(TFileName* aFileName,TInt aControlId) const;
 





	  void UpdatePageL(TBool aRedraw);
	};




# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknform.h" 1
 




























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/akndialog.h" 1
 





















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikmobs.h" 1
 
 
 
 
















class CCoeControl;
class CEikMenuPane;
class CEikMenuBar;
class CEikHotKeyTable;
class TPoint;

class MEikMenuObserver : public MEikCommandObserver
	{
public:
	enum TMenuType
		{
		EMenuPane,
		EMenuBar
		};
public:
	  virtual void HandleAttemptDimmedSelectionL(TInt aCommandId);
	  virtual TBool CheckHotKeyNotDimmedL(TInt aCommandId);
	  virtual void RestoreMenuL(CCoeControl* aMenuControl,TInt aResourceId,TMenuType aType);
	  virtual void DynInitMenuPaneL(TInt aResourceId,CEikMenuPane* aMenuPane);
	  virtual void DynInitMenuBarL(TInt aResourceId,CEikMenuBar* aMenuBar);
	  virtual void HandleSideBarMenuL(TInt aResourceId,const TPoint& aPos,TInt aModifiers,const CEikHotKeyTable* aTable);
	  virtual void OfferKeyToAppL(const TKeyEvent& aKeyEvent,TEventCode aType);
	virtual void SetEmphasis(CCoeControl* aMenuControl,TBool aEmphasis)=0;
private:
	  virtual void Reserved_1_MenuObserver();
	};

class MEikAutoMenuObserver : public MEikMenuObserver
	{
public:
	virtual TKeyResponse OfferHotKeyL(const TKeyEvent& aKeyEvent,TEventCode aType)=0;
public:  
	  void SetEmphasis(CCoeControl* aMenuControl,TBool aEmphasis);
private:
	  virtual void Reserved_1_MenuObserver();
	};


# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/akndialog.h" 2



class CAknDialogAttributes;

class CAknDialog : public CEikDialog, public MEikMenuObserver
	{
	public :
		 
		  CAknDialog() ;
		  void ConstructL( TInt aMenuTitleResourceId ) ;
		  ~CAknDialog() ;

		 
		  TInt ExecuteLD( TInt aResourceId ) ;
		   void PrepareLC(TInt aResourceId);
		  TInt RunLD();

		 
		  virtual void SetEmphasis( CCoeControl* aMenuControl,TBool aEmphasis ) ;
		  virtual void DynInitMenuPaneL( TInt aResourceId, CEikMenuPane* aMenuPane ) ;
		 
		  virtual void ProcessCommandL( TInt aCommandId ) ;

		 
		  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType) ;
		  void FocusChanged(TDrawNow aDrawNow); 

	private:  
		  virtual void Reserved_MtsmPosition();
		  virtual void Reserved_MtsmObject();

	protected:
		 
		  virtual TBool OkToExitL( TInt aButtonId ) ;

		  void DisplayMenuL() ;
		  void HideMenu() ;
		  TBool MenuShowing() const ;
		
		  virtual void SizeChanged();
		  virtual void Draw(const TRect &aRect) const;

	protected:  
		  TTypeUid::Ptr MopSupplyObject(TTypeUid aId);

	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private:  
		  virtual void CAknDialog_Reserved();
	
	protected:  
			void CreateMenuBarL(TInt aMenuTitleResourceId);

	protected:
		 
		CEikMenuBar* iMenuBar ;
private:
	enum TAknDialogFlag
	    {
	    EAknDialogFlagDialogDeleted = 1,
        EAknDialogFlagDefaultSounds = 2,
		EAknDialogFlagNotConstructed = 4
	    };
	CAknDialogAttributes* iAttributes;   

	CAknDialogAttributes* AttributesL();

	} ;


# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknform.h" 2


class CEikMenuBar ;

class CAknForm : public CAknDialog
	{
	public :
		  CAknForm() ;
		  void ConstructL( TInt aMenuBarId=0 ) ;
		  ~CAknForm() ;

		 
		  virtual void DynInitMenuPaneL( TInt aResourceId, CEikMenuPane* aMenuPane ) ;

		 
		  virtual void ProcessCommandL( TInt aCommandId ) ;


	protected:
		 
		  virtual TBool OkToExitL( TInt aButtonId ) ;
		 
		  virtual void PrepareForFocusTransitionL();

	public:
		 
		 





		  void HandleResourceChange(TInt aType);

	protected:
		 

	 












		  virtual TBool SaveFormDataL() ; 
	 






		  virtual void DoNotSaveFormDataL() ; 

	 








		  virtual TBool QuerySaveChangesL() ;
		  virtual void EditCurrentLabelL() ;
		  virtual void DeleteCurrentItemL() ;
		  virtual void AddItemL() ;
		  void SetChangesPending(TBool aChangesPending);
		  void PostLayoutDynInitL();
		  void HandleControlStateChangeL(TInt aControlId);
		  void SetInitialCurrentLine();

		  TBool UnsavedEdit() const  ;  
		  TBool Deleting() const ;	 

		enum TFlags
			{
			EDeleting = 0x1,
			EUnsavedEdit = 0x2
			} ;

	 





		  void SetFormFlag( TFlags aFlagPattern, TBool aSetTheFlag );

	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknDialog_Reserved();
	private: 
		  virtual void CAknForm_Reserved();
	private:  
		void DoLayout();
	private :
		TInt iMenuBarId ;   

		TInt iFlags ;
		TInt iWsBufferRequestID;
	} ;



# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 1
 
 
 
 
   












# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbo.h" 1
 
 
 
 

 
 
 




class CEikListBox; 


class MEikListBoxObserver
	{
public:
	enum TListBoxEvent
		{
		EEventEnterKeyPressed,
		EEventItemClicked,
		EEventItemDoubleClicked,
		EEventItemActioned,	 
		EEventEditingStarted,
		EEventEditingStopped
		};
public:
	virtual void HandleListBoxEventL(CEikListBox* aListBox, TListBoxEvent aEventType)=0;
	};


# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksbfrm.h" 1
 
 
 
 
	





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknscrlb.h" 1
 
 
 
 
	 	




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikscrlb.h" 1
 
 
 
 
		








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksbobs.h" 1
 
 
 
 

 
 
 



enum TEikScrollEvent
	{
	EEikScrollLeft=1,
	EEikScrollUp,
	EEikScrollRight,
	EEikScrollDown,
	EEikScrollPageLeft,
	EEikScrollPageUp,
	EEikScrollPageRight,
	EEikScrollPageDown,
	EEikScrollHome,
	EEikScrollTop,
	EEikScrollEnd,
	EEikScrollBottom,
	EEikScrollThumbDragHoriz,
	EEikScrollThumbDragVert,
	EEikScrollThumbReleaseHoriz,
	EEikScrollThumbReleaseVert
	};

class CEikScrollBar;
class MEikScrollBarObserver
	{
public:
	virtual void HandleScrollEventL(CEikScrollBar* aScrollBar, TEikScrollEvent aEventType)=0;
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikscrlb.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknscbut.h" 1
 
 
 
 








class CAknScrollIndicator;

class CAknScrollButton : public CCoeControl
	{
public:
	enum TType
		{
		ENudgeLeft,
		ENudgeUp,
		ENudgeRight,
		ENudgeDown,
		EPageLeft,
		EPageUp,
		EPageRight,
		EPageDown,
		EHome,
		ETop,
		EEnd,
		EBottom
		};

public:
	enum TTypeOfScrollBar
		{
		ENormal		=0x00,
		EArrowHead	=0x01
		};

public:  
	  static CAknScrollButton* NewL(TType aType);
	  ~CAknScrollButton();
	  TType Type() const;
	  void CreateWindowOnlyForArrowsL(const CCoeControl* aParent);
	  TBool IsNormalScrollBarUsingButton() const;
	  void SetTypeOfScrollBarUsingButton(TTypeOfScrollBar aTypeOfScrollBar);
	  void SetPosition(const TInt aFocusPosition, const TInt aScrollSpan);
private:  
	CAknScrollButton(TType aType);
	void ConstructL();
	void SizeChanged();
	void DrawIndicator() const;
private:  
	virtual void Draw(const TRect& aRect) const;
private:
	friend class CAknScrollBar;
	TType iType;
	TInt iFlag;
	CAknScrollIndicator* iScrollIndicator;
	TRect iOldRect;
	};



# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikscrlb.h" 2





class CEikCba;
class CAknDoubleSpanScrollIndicator;
class CEikScrollBarExtensionImpl;
class CEikScrollBarExtension;
class CAknDoubleSpanScrollBarExtension;

const TInt KEikScrollEventFromVBar=0;
const TInt KEikScrollEventFromHBar=0x01;
const TInt KEikScrollEventBarMask=0x01;

const TInt KButtonPositionMask=KLafScrollBarButtonPositionMask;  
const TInt KDisplayComponentsMask=0x1f;  

 
 
 

class TEikScrollBarModel
	{
public:
	inline TEikScrollBarModel();
	  TEikScrollBarModel(TInt aScrollSpan,TInt aThumbSpan=0,TInt aThumbPosition=0);
	 
	  TBool operator==(const TEikScrollBarModel aModel) const;
	inline TBool operator!=(const TEikScrollBarModel aModel) const; 
public:
	  TBool ScrollBarUseful() const;
	  TInt MaxThumbPos() const;
	  void CheckBounds();
    enum TEikScrollBarModelType
		{
		EEikScrollBarModel               = 0x00000000,
		EAknDoubleSpanScrollBarModel     = 0x80000000
		};        
    TEikScrollBarModel::TEikScrollBarModelType ScrollBarModelType() const;
public:
	TInt iScrollSpan;
	TInt iThumbSpan;
	TInt iThumbPosition;            
	};

inline TEikScrollBarModel::TEikScrollBarModel() {}
inline TBool TEikScrollBarModel::operator!=(const TEikScrollBarModel aModel) const { return !(*this==aModel); }


 
 
 
 
 
 
 
 
 
 
 
 
 
class TAknDoubleSpanScrollBarModel : public TEikScrollBarModel
	{

public:
    
    


      TAknDoubleSpanScrollBarModel();

    

























      TAknDoubleSpanScrollBarModel(const TEikScrollBarModel& aEikModel);
    
    
    






















      void SetScrollSpan(TInt aValue);     
      void SetFocusPosition(TInt aValue);  
      void SetWindowSize(TInt aValue);     
      void SetFieldSize(TInt aValue);      
      void SetFieldPosition(TInt aValue);  
    
    
    











      TInt ScrollSpan() const;     
      TInt FocusPosition() const;  
      TInt WindowSize() const;     
      TInt FieldSize() const;      
      TInt FieldPosition() const;  


    

















    static TBool ModelIsSupported();

private:   
    






    TUint16 Scale() const;

    






    void SetScale(TUint16 aScale);    

private:   
    






    TInt16 ScrollSpanValue() const;
    TInt16 FocusPositionValue() const;
    TInt16 FieldPositionValue() const;
    TInt16 FieldSizeValue() const;
    TInt16 WindowSizeValue() const;

    






    void SetScrollSpanValue(TInt16 aValue);
    void SetFocusPositionValue(TInt16 aValue);
    void SetFieldPositionValue(TInt16 aValue);
    void SetFieldSizeValue(TInt16 aValue);
    void SetWindowSizeValue(TInt16 aValue);

    






    TInt16 LowBytes(TInt aInt) const;

    





    
    TInt16 HighBytes(TInt aInt) const;
    
    
    





    
    void SetLowBytes(TInt& aInt, TInt16 aValue);

    





        
    void SetHighBytes(TInt& aInt, TInt16 aValue);
    
    
    






        
    TInt16 PrepareScaledValue(TInt aNonScaledValue);
    
    






        
    void ReScale(TUint16 aNewScale);
    
    






        
    void SetScrollBarModelType(TEikScrollBarModelType aModelType);

    







        
    TInt CheckMinMaxValue(TInt aValue);
    };


 
 
 

class CEikScrollThumb;
class CEikScrollBarFrame;
  
 




class CEikScrollBar : public CEikBorderedControl, public MCoeControlObserver
	{
friend class CEikScrollBarExtension;
friend class CAknDoubleSpanScrollBarExtension;
    
public:
	enum TOrientation
		{
		EVertical = SLafScrollBar::EVertical,
		EHorizontal = SLafScrollBar::EHorizontal
		};

	enum TScrollBarType
		{
		ENormalScrollBar	=0x0,
		EArrowHead			=0x200,
		EDoubleSpan			=0x400
		};

	enum TEikScrollBarFlags
		{
		EEikScrollBarDefaultBehaviour   =SLafScrollBar::EEikScrollBarDefaultBehaviour,
		EEikScrollBarNoNudgeButtons		=SLafScrollBar::EEikScrollBarNoNudgeButtons,
		EEikScrollBarHasPageButtons		=SLafScrollBar::EEikScrollBarHasPageButtons,	
		EEikScrollBarHasHomeEndButtons	=SLafScrollBar::EEikScrollBarHasHomeEndButtons,
		EEikScrollBarNoShaftOrThumb		=SLafScrollBar::EEikScrollBarNoShaftOrThumb,	
		EEikScrollBarShaftButNoThumb	=SLafScrollBar::EEikScrollBarShaftButNoThumb,	
		EButtonsAtStartOfShaft			=SLafScrollBar::EButtonsAtStartOfShaft,	
		EButtonsAtEndOfShaft			=SLafScrollBar::EButtonsAtEndOfShaft,			
		EButtonsEitherSideOfShaft		=SLafScrollBar::EButtonsEitherSideOfShaft,
		ENoAutoDimming					=SLafScrollBar::ENoAutoDimming		
		};

	typedef TEikScrollBarFlags TAknScrollBarFlags;

public:
	  ~CEikScrollBar();
	  CEikScrollBar();
public:
	 
	  virtual void ConstructL(MEikScrollBarObserver* aScrollBarObserver,const CCoeControl* aParent,
	TOrientation aOrientation,TInt aLength,TInt aScrollBarFlags=EEikScrollBarDefaultBehaviour);

	 
	  void SetLengthL(TInt aLength);
	  void SetModelL(const TEikScrollBarModel* aModel);
	  void SetModel(const TEikScrollBarModel* aModel);
	  void SetLengthAndModelL(TInt aLength,const TEikScrollBarModel* aModel);
	  void SetModelThumbPosition(TInt aThumbPos);
	  void SetFocusPosToThumbPos(TInt aFocusPosition);
	  static TInt DefaultScrollBarBreadth();
	inline void SetScrollBarObserver(MEikScrollBarObserver* aScrollBarObserver);     

	 
	inline const TEikScrollBarModel* Model() const;
	  TInt ThumbPosition() const;
	  TInt ScrollBarBreadth() const;
	  static TInt MinVisibleLength(const TInt aScrollBarFlags);

	 
	  void SetDecreaseButtonsDimmed(TBool aDimmed);
	  void SetIncreaseButtonsDimmed(TBool aDimmed);
	  void SetAllButtonsDimmed(TBool aDimmed);

	inline CAknScrollButton* IncreaseNudgeButton() const;
	inline CAknScrollButton* DecreaseNudgeButton() const;

	 
	  void SetContainingCba(CEikCba* aCba);

	  void MakeVisible(TBool aVisible);

protected:       
	  CCoeControl* ComponentControl(TInt aIndex) const;
	  TInt CountComponentControls() const;
private:  
	  virtual void HandleControlEventL(CCoeControl* aControl, TCoeEvent aEventType);
private:  
	  virtual void Reserved_2();

protected:
	friend class CEikScrollBarFrame;
	 
	enum TPrivateScrollBarFlags
		{
		ENoComponentsToDisplay          =0x10000,
		EIncreaseButtonsDimmed          =0x20000,
		EDecreaseButtonsDimmed          =0x40000
		};

	enum TPointerDownOn
		{
		ENone,
		EHomeButton,
		EDecreasePageButton,
		EDecreaseNudgeButton,
		EDecreaseShaft,
		EThumb,
		EIncreaseShaft,
		EIncreaseNudgeButton,
		EIncreasePageButton,
		EEndButton
		};

	enum TShaftRedrawRequired
		{
		ENoRedrawRequired,
		ERedrawShaft
		};

	enum TWhichButtons
		{
		EIncreaseOnly,
		EDecreaseOnly,
		EAll
		};

	struct SEikScrollBarButtons
		{
		CAknScrollButton* iDecreaseNudge;
		CAknScrollButton* iIncreaseNudge;
		};


private:
	 
	  virtual void CreateButtonL(CAknScrollButton*& aButton,CAknScrollButton::TType aType);

	void SizeChanged();

	 
	void DoSetModel(const TEikScrollBarModel* aModel);

	CEikCba* Cba() const;

	 
	void AddExternalFrameL(CEikScrollBarFrame* aFrame);
	void RemoveExternalFrame(CEikScrollBarFrame* aFrame);

	void DisconnectExternalFrames();

protected:
	void CreateRequiredComponentsL();
	void DestroyButton(CAknScrollButton*& aButton);
	  virtual void SetButtonPositionL(CAknScrollButton* aButton);
public:
    TScrollBarType ScrollBarType();
public:
	TDblQueLink iSBLink;
protected:
	SEikScrollBarButtons iButtons;
	TOrientation iOrientation;
private:
	TEikScrollBarModel iModel;
protected:    
    CEikScrollBarExtensionImpl* iExtension;
  };


 









class CEikArrowHeadScrollBar : public CEikScrollBar
	{
public:
	  CEikArrowHeadScrollBar(CCoeControl* aParentWindow);
	  ~CEikArrowHeadScrollBar();
public:  
	  void ConstructL(MEikScrollBarObserver* aScrollBarObserver,const CCoeControl* aParent,
				TOrientation aOrientation,TInt aLength,TInt aScrollBarFlags=EEikScrollBarDefaultBehaviour);
private:  
	void CreateButtonL(CAknScrollButton*& aButton,CAknScrollButton::TType aType);
	void SetButtonPositionL(CAknScrollButton* aButton);
private:
	CCoeControl* iParentControl;
	};


 













class CAknDoubleSpanScrollBar : public CEikScrollBar
	{
public:
	  CAknDoubleSpanScrollBar(CCoeControl* aParentWindow);
	  ~CAknDoubleSpanScrollBar();

    






     
      void SetFixedLayoutRect(TRect aScrollBarRect);

    










     
      void ConstructL(TBool aWindowOwning, MEikScrollBarObserver* aScrollBarObserver,const CCoeControl* aParent,
				TOrientation aOrientation,TInt aLength,TInt aScrollBarFlags=EEikScrollBarDefaultBehaviour);
    




     
    TRect FixedLayoutRect();

public:  
	  void ConstructL(MEikScrollBarObserver* aScrollBarObserver,const CCoeControl* aParent,
				TOrientation aOrientation,TInt aLength,TInt aScrollBarFlags=EEikScrollBarDefaultBehaviour);
      void MakeVisible(TBool aVisible);

protected:  
	  CCoeControl* ComponentControl(TInt aIndex) const;
      TInt CountComponentControls() const;

private:   
      void SizeChanged();

private:  
	void CreateButtonL(CAknScrollButton*& aButton,CAknScrollButton::TType aType);
	void SetButtonPositionL(CAknScrollButton* aButton);

    





     
    void SetTransparentBackground(TBool aTransparentBackground);


private:
	CCoeControl* iParentControl;
	};


 
 
 

inline void CEikScrollBar::SetScrollBarObserver(MEikScrollBarObserver*  )
	{ }

inline const TEikScrollBarModel* CEikScrollBar::Model() const
	{ return &iModel; }

inline CAknScrollButton* CEikScrollBar::IncreaseNudgeButton() const
	{ return iButtons.iIncreaseNudge; }

inline CAknScrollButton* CEikScrollBar::DecreaseNudgeButton() const
	{ return iButtons.iDecreaseNudge; }



# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknscrlb.h" 2



 
 
 




 
 
 





# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksbfrm.h" 2



class CEikCba;

 
 
 

class TEikScrollBarFrameLayout
	{
public:
	 
	enum TTilingMode
		{
		EClientRectConstant,
		EInclusiveRectConstant
		};
public:
	 
	  TEikScrollBarFrameLayout();

	 
	  void SetInclusiveMargin(TInt aMargin);
	  void SetClientMargin(TInt aMargin);
public:
	TMargins iInclusiveMargin;
	TMargins iClientMargin;
	TSize iClientAreaGranularity;
	TTilingMode iTilingMode;
	};

 
 
 

class CEikCornerWindow;
class CEikScrollBarFrameExtension;

class CEikScrollBarFrame : public CBase
	{
public:	 
	enum { ETypeId =  0x101F8672  };    

	enum TScrollBarVisibility
		{
		EOff,
		EOn,
		EAuto
		};
	enum TScrollBarType
		{
		ENormalScrollBar	=0x0,
		EArrowHead			=0x200,
		EDoubleSpan			=0x400
		};
	enum TScrollBarSide
		{
		EBottomOrRight		=0x0,
		ETopOrLeft			=0x800
		};

	enum TScrollBarManagement 
		{
		EComponent					, 
		EFloating					, 
		EApplicationScrollBar		 
		};

	enum TScrollBarFrameFlags
		{
		EHVisible			=0x01,
		EVVisible			=0x02,
		};
private:
	enum TMarginsAdjustmentMode
		{
		EGrow,
		EShrink
		};

public:	 
	CEikScrollBarFrame(){}
	  CEikScrollBarFrame(CCoeControl* aParentWindow, MEikScrollBarObserver* aObserver, TBool aPreAlloc=EFalse);
	  ~CEikScrollBarFrame();

	 

    

     
	  void DrawScrollBarsNow() const;

	 
	
    

     
      void SetScrollBarVisibilityL(TScrollBarVisibility aHVisibility, TScrollBarVisibility aVVisibility);

    





     
    inline TScrollBarVisibility HScrollBarVisibility() const;
	
    






     
    inline TScrollBarVisibility VScrollBarVisibility() const;

	 

    



     
	  void SetScrollBarsDimmed(TBool aHorizDimmed, TBool aVertDimmed) const;

	 

    



     
	  void SetScrollBarFrameObserver(MEikScrollBarObserver* aObserver);

	 
	
    






     
      TBool Tile(TEikScrollBarModel* aVModel);
	
    
























     
      TBool TileL(TEikScrollBarModel* aHModel, TEikScrollBarModel* aVModel,
			  TRect& aClientRect, TRect& aInclusiveRect, const TEikScrollBarFrameLayout& aLayout);
	
	 
	
    








     
      void MoveThumbsBy(TInt aDeltaX, TInt aDeltaY);

    







     
	  void MoveHorizThumbTo(TInt aHorizThumbPos);

    







     
      void MoveVertThumbTo(TInt aVertThumbPos);

    






     
      void SetVFocusPosToThumbPos(TInt aFocusPosition);

    





     
 	  TInt ScrollBarBreadth(CEikScrollBar::TOrientation aOrientation) const;

	 

    



     
      void SetAdjustsHorizontalModel(TBool aAdjusts); 

    



     
      void SetAdjustsVerticalModel(TBool aAdjusts);

    



     
      TBool AdjustsHorizontalModel() const;

    



     
      TBool AdjustsVerticalModel() const;

     

    




     
    inline void SetScrollBarFrameFlags(TInt aMask);

    



     
    inline void SetFlagsForHScrollBar(TInt aMask);

    



     
    inline void SetFlagsForVScrollBar(TInt aMask);

    



     
    inline void ClearFlagsForHScrollBar(TInt aMask);

    



     
    inline void ClearFlagsForVScrollBar(TInt aMask);

    



     
    inline TInt FlagsForHScrollBar() const;

    



     
    inline TInt FlagsForVScrollBar() const;
	
    





     
      TBool ScrollBarExists(CEikScrollBar::TOrientation aOrientation) const;

	 

    




     
      TInt CountComponentControls() const;
	
    





         
      CCoeControl* ComponentControl(TInt aIndex) const;
	
    




         
      CEikScrollBar* GetScrollBarHandle(CEikScrollBar::TOrientation aOrientation) const;
	
    



         
      CEikScrollBar* VerticalScrollBar() const;
	
    





         
      void SetTypeOfHScrollBar(TScrollBarType aType);
    
    





         
   	  void SetTypeOfVScrollBar(TScrollBarType aType);
	
    



     
      void SetSideOfHScrollBar(TScrollBarSide aSide);

    



     
	  void SetSideOfVScrollBar(TScrollBarSide aSide);
	
    



         
      TScrollBarType TypeOfHScrollBar() const;

    



         
	  TScrollBarType TypeOfVScrollBar() const;

    
    



     
      TBool RightSideForHScrollBar() const;

    



     
      TBool RightSideForVScrollBar() const;

    




         
      TBool IsArrowHeadScrollBar(TInt aFlag) const;

	 

    



     
      static void SetApplicationScrollBarL(CEikScrollBar::TOrientation aOrientation, CEikScrollBar* aScrollBar);

    



     
	  static CEikScrollBar* ApplicationScrollBar(CEikScrollBar::TOrientation aOrientation);

	 
	
    



     
      void SetScrollBarManagement(CEikScrollBar::TOrientation aOrientation, TScrollBarManagement aManagement);
	
    



     
      TScrollBarManagement ScrollBarManagement(CEikScrollBar::TOrientation aOrientation) const;

    



     
      void SetScrollBarControlType(CEikScrollBar::TOrientation aOrientation, TInt aControlType);

    



     
      TInt ScrollBarControlType(CEikScrollBar::TOrientation aOrientation) const;

    



     
      void SetScrollBarSide(CEikScrollBar::TOrientation aOrientation, TScrollBarSide aSide);

    



     
      TScrollBarSide ScrollBarSide(CEikScrollBar::TOrientation aOrientation) const;

    



     
      void SetScrollBarBreadth(CEikScrollBar::TOrientation aOrientation, TInt aBreadth);

    



     
      TBool AdjustsModel(CEikScrollBar::TOrientation aOrientation) const;

    




     
	void DisconnectExternalScrollBar(CEikScrollBar* aScrollBar);

    





































 
      void CreateDoubleSpanScrollBarsL(TBool aWindowOwning, TBool aRemote);
    
    













     
      void Tile(TEikScrollBarModel* aVModel, TRect& aVScrollBar);

     






     
	  void Tile(TEikScrollBarModel* aHModel, TEikScrollBarModel* aVModel);

     










     
	  TScrollBarVisibility ScrollBarVisibility(CEikScrollBar::TOrientation aOrientation) const;

public:

    



         
    CEikScrollBar* HorizontalScrollBar() const;

protected:
	 
	void SetParentWindow(CCoeControl* aParentWindow);
	CCoeControl* ParentWindow() const;

protected:
	struct SBarData
		{
		CEikScrollBar * iBar;
		TEikScrollBarModel iModel;
		TScrollBarVisibility iVisibility;
		TBool iExternalScrollBarAttached;
		};

private:
	void CalcTheoreticalScrollBarVisibility(const TEikScrollBarModel* aVModel);
	void ApplyModel(SBarData& aSBar);
	void MakeSBarVisible(SBarData& aSBar, TBool aVisible);
	void GetScrollBars();
	CEikCba* GetCurrentCba();
    void DeleteScrollBars();
    void CreateArrowHeadScrollBarsL();

    void CalcTheoreticalScrollBarVisibility(const TEikScrollBarModel* aVModel, const TEikScrollBarModel* aHModel);

protected:
	SBarData iV;

private:
    CEikScrollBarFrameExtension* iExtension; 
    TInt iScrollBarFrameFlags;

    friend class CEikScrollBarFrameExtension;
	};

inline CEikScrollBarFrame::TScrollBarVisibility CEikScrollBarFrame::HScrollBarVisibility() const
    { return EOff; }  
inline CEikScrollBarFrame::TScrollBarVisibility CEikScrollBarFrame::VScrollBarVisibility() const
	{ return iV.iVisibility; }
inline void CEikScrollBarFrame::SetScrollBarFrameFlags(TInt aMask)
	{ iScrollBarFrameFlags|=aMask; }
inline void CEikScrollBarFrame::SetFlagsForHScrollBar(TInt  )
	{ }
inline void CEikScrollBarFrame::SetFlagsForVScrollBar(TInt  )
	{ }
inline void CEikScrollBarFrame::ClearFlagsForHScrollBar(TInt  )
	{ }
inline void CEikScrollBarFrame::ClearFlagsForVScrollBar(TInt  )
	{ }
inline TInt CEikScrollBarFrame::FlagsForHScrollBar() const
	{ return 0; }
inline TInt CEikScrollBarFrame::FlagsForVScrollBar() const
	{ return 0; }



 
class CEikCbaScrollBarFrame : public CEikScrollBarFrame
	{
public:
	CEikCbaScrollBarFrame(CCoeControl* aParentWindow, MEikScrollBarObserver* aObserver, TBool aPreAlloc=EFalse);
	void ConstructL();
	};


# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbm.h" 1
 
 
 
 















enum TListBoxModelItemArrayOwnership
	{
	ELbmOwnsItemArray,
	ELbmDoesNotOwnItemArray
	};


class MListBoxModel 
	{
public:
	  virtual ~MListBoxModel();
	virtual TInt NumberOfItems() const = 0;
	virtual const MDesC16Array * MatchableTextArray() const = 0;
private:
	  virtual TAny* MListBoxModel_Reserved();
	};

class MTextListBoxModel : public MListBoxModel
	{
public:
	  ~MTextListBoxModel();
	virtual TPtrC ItemText(TInt aItemIndex) const = 0;
private:  
	  virtual TAny* MListBoxModel_Reserved();
	};


# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbv.h" 1
 
 
 
 













class CListItemDrawer;
class MListBoxModel;
class CWindowGc;
class RWindowGroup;
class CWsScreenDevice;
class CWindowGc;
class RWindow;

 
 
 

class MListVisibilityObserver 
	{
public:
	virtual TBool IsVisible() const = 0;
	};

 
 
 

class CListBoxView : public CBase
	{
public:
	enum TCursorMovement 
		{
		ECursorNextItem,  	
		ECursorPreviousItem,
		ECursorNextColumn,  
		ECursorPreviousColumn,  
		ECursorPreviousPage, 
		ECursorNextPage,
		ECursorFirstItem,
		ECursorLastItem,
		ECursorNextScreen,
		ECursorPrevScreen
		};  
	enum TFlags
		{
		EAnchorExists		= 0x0001,
		EEmphasized			= 0x0002,
		EDimmed				= 0x0004,
		EHasMatcherCursor	= 0x0008,
		EDisableRedraw		= 0x0010,
		EPaintedSelection     = 0x0020,
		EMarkSelection         = 0x0040,
		EUnmarkSelection       = 0x0080,
		EItemCountModified     = 0x0100
		};
	enum TSelectionMode {ENoSelection, ESingleSelection, EContiguousSelection, EDisjointSelection, EDisjointMarkSelection};
	typedef CArrayFix<TInt> CSelectionIndexArray;
public:
	  ~CListBoxView();
	  CListBoxView();

	 
	  virtual void ConstructL(MListBoxModel* aListBoxModel, CListItemDrawer* aItemDrawer, CWsScreenDevice* aScreen, RWindowGroup* aGroupWin, RWindow* aWsWindow, const TRect& aDisplayArea, TInt aItemHeight);

	 
	  TRect ViewRect() const;
	  void SetViewRect(const TRect& aRect);   

	 
	  virtual TInt CurrentItemIndex() const;	
	  void SetCurrentItemIndex(TInt aItemIndex); 
	  TInt TopItemIndex() const;		
	  virtual void SetTopItemIndex(TInt aItemIndex);
	  TInt BottomItemIndex() const;
	  virtual void CalcBottomItemIndex();
	  virtual void SetItemHeight(TInt aItemHeight);

	 
	  void SetMatcherCursorColor(TRgb aColor);
	  void SetMatcherCursorPos(TInt aPosWithinCurrentItem);
	  TInt MatcherCursorPos() const;
	  virtual void DrawMatcherCursor();
	  void HideMatcherCursor();

	 
	  void SetMatcherCursor(TBool aMatcherCursor);
	  void SetEmphasized(TBool aEmphasized);
	  void SetDimmed(TBool aDimmed);
	  void SetDisableRedraw(TBool aDisableRedraw);
	  TBool RedrawDisabled() const;
	  void SetPaintedSelection( TBool aPaintedSelection );

	 
	  const CSelectionIndexArray* SelectionIndexes() const;
	  void GetSelectionIndexesL(CSelectionIndexArray* aSelectionArray) const;
	  void SetSelectionIndexesL(const CSelectionIndexArray* aSelectionIndexes);
	  void ClearSelection();	  
	  virtual void UpdateSelectionL(TSelectionMode aSelectionMode);   
	  void ToggleItemL(TInt aItemIndex);
	  void SelectItemL(TInt aItemIndex);
	  void DeselectItem(TInt aItemIndex);
	  void SetAnchor(TInt aItemIndex);
	  void ClearSelectionAnchorAndActiveIndex();

	 
	  virtual TBool ScrollToMakeItemVisible(TInt aItemIndex);
	  virtual void VScrollTo(TInt aNewTopItemIndex);
	  virtual void VScrollTo(TInt aNewTopItemIndex, TRect& aMinRedrawRect);
	  virtual void HScroll(TInt aHScrollAmount);
	  TInt HScrollOffset() const;
	  void SetHScrollOffset(TInt aHorizontalOffset);
	  TInt DataWidth() const;
	  virtual void CalcDataWidth();
	  virtual TInt VisibleWidth(const TRect& aRect) const;
	  virtual TInt CalcNewTopItemIndexSoItemIsVisible(TInt aItemIndex) const;

	 
	  virtual void Draw(const TRect* aClipRect = 0L ) const;
	  virtual void DrawItem(TInt aItemIndex) const;

	  void SetListEmptyTextL(const TDesC& aText);
	inline const TDesC* EmptyListText() const;

	 
	  TBool ItemIsSelected(TInt aItemIndex) const; 
	  TBool ItemIsVisible(TInt aItemIndex) const;
	  virtual TPoint ItemPos(TInt aItemIndex) const;
	  virtual TSize ItemSize(TInt aItemIndex=0) const;

	  void SetTextColor(TRgb aColor);
	  void SetBackColor(TRgb aColor);
	  TRgb TextColor() const;
	  TRgb BackColor() const;

	  virtual void MoveCursorL(TCursorMovement aCursorMovement, TSelectionMode aSelectionMode);
	  virtual void VerticalMoveToItemL(TInt aTargetItemIndex, TSelectionMode aSelectionMode);
	  virtual TBool XYPosToItemIndex(TPoint aPosition, TInt& aItemIndex) const;    
	  virtual TInt NumberOfItemsThatFitInRect(const TRect& aRect) const;

	void SetVisibilityObserver(MListVisibilityObserver* aObserver);
	  TBool IsVisible() const;

	inline CListItemDrawer* ItemDrawer() const;

	  virtual void DrawEmptyList(const TRect &aClientRect) const;
private:  
	  virtual TAny* Reserved_1();
protected:
	 
	inline TInt Flags() const;
	inline void SetFlags(TInt aMask);
	inline void ClearFlags(TInt aMask);

    friend class CEikListBox;  

	 
	  void SelectRangeL(TInt aItemIndex1, TInt aItemIndex2);

protected:
	TInt iFlags;   	
	CListItemDrawer* iItemDrawer;
	MListBoxModel* iModel;
	TInt iDataWidth;			 
	TInt iTopItemIndex;
	TInt iBottomItemIndex;
	TInt iHScrollOffset;		 
	TInt iCurrentItemIndex;
	TInt iItemHeight;
	RWindow* iWin;
	RWindowGroup* iGroupWin;
	CWindowGc* iGc;
	TRect iViewRect;

	HBufC *iListEmptyText;
private:
	TInt iMatcherCursorPos;
	TRgb iMatcherCursorColor; 
	TRgb iBackColor;
	TRgb iTextColor;
	TInt iAnchorIndex;  
	TInt iActiveEndIndex;
	CSelectionIndexArray* iSelectionIndexes;
	MListVisibilityObserver* iVisibilityObserver;
	TInt iSpare;
	};

 


inline const TDesC* CListBoxView::EmptyListText() const
	{ return(iListEmptyText); }


class CSnakingListBoxView : public CListBoxView
	{
public:
	  ~CSnakingListBoxView();
	  CSnakingListBoxView();
	inline TInt ColumnWidth() const;
	  void SetColumnWidth(TInt aColumnWidth);
	  virtual void MoveCursorL(TCursorMovement aCursorMovement, TSelectionMode aSelectionMode);
	  virtual void SetTopItemIndex(TInt aItemIndex);
	  virtual void SetItemHeight(TInt aItemHeight);
	  virtual TBool XYPosToItemIndex(TPoint aPosition, TInt& aItemIndex) const;
	  virtual TInt NumberOfItemsThatFitInRect(const TRect& aRect) const;
	  virtual void HScroll(TInt aHScrollAmount);
	  virtual void CalcDataWidth();
	  virtual void CalcBottomItemIndex();
	  virtual void Draw(const TRect* aClipRect = 0L ) const;
	  virtual TInt VisibleWidth(const TRect& aRect) const;
	  virtual TBool ScrollToMakeItemVisible(TInt aItemIndex);
	  virtual TInt CalculateHScrollOffsetSoItemIsVisible(TInt aItemIndex);
	  virtual TInt CalcNewTopItemIndexSoItemIsVisible(TInt aItemIndex) const;
	  virtual TPoint ItemPos(TInt aItemIndex) const;
	  virtual TSize ItemSize(TInt aItemIndex=0) const;
	  void CalcRowAndColIndexesFromItemIndex(TInt aItemIndex, TInt& aRowIndex, TInt& aColIndex) const;
	  void CalcItemIndexFromRowAndColIndexes(TInt& aItemIndex, TInt aRowIndex, TInt aColIndex) const;
	  virtual TInt NumberOfItemsPerColumn() const;
protected:
	  virtual void DrawItemRange(TInt aStartItemIndex, TInt aEndItemIndex) const;
	  void DrawColumnRange(TInt aStartColIndex, TInt aEndColIndex) const;
	  void MoveToPreviousColumnL(TSelectionMode aSelectionMode);
	  void MoveToNextColumnL(TSelectionMode aSelectionMode);
	  void ClearUnusedItemSpace(TInt aStartItemIndex, TInt aEndItemIndex) const;
	  void UpdateHScrollOffsetBasedOnTopItemIndex();
private:  
	  virtual TAny* Reserved_1();
protected:
	TInt iColumnWidth;
	};



inline TInt CListBoxView::Flags() const
	{ return iFlags; }

inline void CListBoxView::SetFlags(TInt aMask)
	{ iFlags|=aMask; }
 
inline void CListBoxView::ClearFlags(TInt aMask)
	{ iFlags&=(~aMask); }

inline CListItemDrawer* CListBoxView::ItemDrawer() const
	{ return iItemDrawer; }

inline TInt CSnakingListBoxView::ColumnWidth() const
	{ return iColumnWidth; }



# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 2








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbed.h" 1
 
 
 
 
   























class CCoeControl;
class CEikEdwin;
class CParaFormatLayer;
class CCharFormatLayer;

 





class MEikListBoxEditor
	{
public:
	 


	virtual TPtrC ItemText() = 0;

	 




	virtual void StartEditingL(const CCoeControl& aContainer,const TRect& aRect,TInt aItemIndex,TInt aMaxLength) = 0;

	 


	virtual void StopEditingL() = 0;

	 


	virtual TBool UpdateModelL() = 0;

	 


	virtual void Release() = 0;
private:
	  virtual void MEikListBoxEditor_Reserved_1();
	};

class MListBoxEditorObserver
	{
public:
	virtual TKeyResponse HandleListBoxEditorEventL(MEikListBoxEditor* aListBoxEditor, const TKeyEvent& aKeyEvent)=0;
	};

 




class CEikListBoxTextEditor : public CCoeControl, public MEikListBoxEditor
	{
public:
	  CEikListBoxTextEditor(MListBoxModel* aModel);
	  ~CEikListBoxTextEditor();
	  void SetFont(const CFont* aFont);
	  CEikEdwin* Editor();
	  void SetListBoxEditorObserver(MListBoxEditorObserver* aObserver);
public:  
	  TPtrC ItemText();
	  void StartEditingL(const CCoeControl& aContainer, const TRect& aRect, TInt aItemIndex, TInt aMaxLength );
	  void StopEditingL();
	  TBool UpdateModelL();
	  TKeyResponse OfferKeyEventL( const TKeyEvent& aKeyEvent, TEventCode aType );
protected:  
	  void Release();
protected:
	  MListBoxModel* ListBoxModel();
	  TInt ItemIndex() const;
private:  
	  void MEikListBoxEditor_Reserved_1();
protected:
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:
	void UseFontL( CEikEdwin& editor, const CFont& aFont );
	TPtrC EditableItemText(TRect* aRect= 0L );
private:
	MListBoxEditorObserver* iEditorObserver;
	MListBoxModel*  iModel;
	CEikEdwin*		iEditor;
	TInt            iItemIndex;
	CFont*          iFont;
	TInt			iItemPos;
	TInt			iItemLen;
	CParaFormatLayer* iParaFormatLayer;
	CCharFormatLayer* iCharFormatLayer;
	};


# 38 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h" 1
 
 
 
 

 
 
 

# 310 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h"





# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h" 1
 
 
 
 

# 338 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h"

# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulftflg.hrh" 1
 
 
 
 

 





 





 





 





 





 





 





 





 





 





 





 





 





 





 





 




# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h" 2


 



const TUint KTextUtilClipEndChar=0x2026;

 



const TUint KColumnListSeparator='\t';

class CFont;
class CFbsFont;
class CWsScreenDevice;
class TResourceReader;
class CColorArray;
class CGraphicsDevice;
class RWsSession;
class CColorList;
template <class T> class CArrayFix;


class TMargins8
 




	{
public :
	 
	TInt8 iLeft;
	 
	TInt8 iRight;
	 
	TInt8 iTop;
	 
	TInt8 iBottom;
public :
	  TMargins8();
	  void SetAllValuesTo(TInt aCommonValue);
      TRect InnerRect(const TRect& aOuterRect) const;
      TRect OuterRect(const TRect& aInnerRect) const;
	  TSize SizeDelta() const;
	};


class DrawUtils
 



	{
public:
	  static void DrawText(CGraphicsContext& aGc,const TDesC& aString,const TRect& aBox,TInt aBaseLineOffset,
									CGraphicsContext::TTextAlign aHoriz,TInt aMargin,const CFont* aFont);
      static void DrawBetweenRects(CGraphicsContext& aGc,const TRect& aOuterRect,const TRect& aInnerRect);
      static void ClearBetweenRects(CGraphicsContext& aGc,const TRect& aOuterRect,const TRect& aInnerRect);
	};


class TextUtils
 



	{
public:
	  static void ClipToFit(TDes& aBuffer,const CFont& aFont,TInt aMaxWidthInPixels,TChar aAlternativeEnd=KTextUtilClipEndChar);
	  static TInt ColumnText(TPtrC& aColumnText,TInt aColumn,const TDesC* aSourceText,TChar aColumnSeparator=KColumnListSeparator);
	  static void TruncateToNumChars(TDes& aBuffer, TInt numChars);
	};

class FontUtils
 




	{
public:
	  static void GetAvailableFontsL(CGraphicsDevice& aDevice,CDesCArray& aFontNameList,
											TInt aFonts= 0x10 );
	  static TInt TypefaceAttributes(CGraphicsDevice& aDevice,const TDesC& aTypefaceName);
	  static TInt GetAvailableHeightsInTwipsL(CGraphicsDevice& aDevice,const TDesC& aTypefaceName,
													CArrayFix<TInt>& aHeightList);
	  static TInt GetAvailableHeightsInTwipsAndPointsL(CGraphicsDevice& aDevice,const TDesC& aTypefaceName,
															CArrayFix<TInt>& aTwipsList,CDesCArray& aPointsList);
	  static TInt PointsFromTwips(TInt aTwips);
	  static TInt TwipsFromPoints(TInt aPoints);
	  static TInt TwipsFromPoints(const TDesC& aPoints);
	  static TInt IndexOfNearestHeight(CArrayFix<TInt>& aTwipsList,TInt aHeight);
	};


class ResourceUtils
 







	{
public:
	  static CFbsFont* CreateNamedScreenFontL(TResourceReader& aResourceReader,CWsScreenDevice& aScreenDevice);
	  static CFbsFont* CreateNamedScreenFontInPixelsL(TResourceReader& aResourceReader,CWsScreenDevice& aScreenDevice);
	  static CFbsFont* CreateScreenFontL(TResourceReader& aResourceReader,CWsScreenDevice& aScreenDevice);
	inline static TInt8 ReadTInt8L(TResourceReader& aReader);
	inline static TInt16 ReadTInt16L(TResourceReader& aReader);
	inline static TInt32 ReadTInt32L(TResourceReader& aReader);
	  static void PopulateColorArrayL(CColorArray& aColors,TResourceReader& aReader);
private:
	enum TResourceTypeInt { EResourceInt8,EResourceInt16,EResourceInt32 };
private:
	  static TInt32 ReadResourceIntL(TResourceReader& aReader,TResourceTypeInt aSize);
	};

class ColorUtils
 




	{
public:
	 
    enum TBitmapOrientation
	    {
		 
	    EBitmapOrientationVertical,
		 
	    EBitmapOrientationHorizontal
	    };
public:
	  static TRgb ColorAdjust(TRgb aColor,TInt aPercentage);
      static void CreateGradientBitmapL(CFbsBitmap& aBitmap,RWsSession& aWs,TInt aBreadth,
                                       TBitmapOrientation aOrientation,TRgb aStartColor,TRgb aEndColor);
	  static CColorList* CreateSystemColorListL(RFs& aFs);
	  static CColorList* CreateSystemColorListL(RFs& aFs,const CColorList& aColorList);
	  static void UpdateSystemColorListL(RFs& aFs,CColorList& aColorList);
	  static void GetRgbDerivedBorderColors(TGulBorder::TColors& aBorderColors,TRgb aBackgroundColor,TDisplayMode aMode);
	  static TRgb RgbDarkerColor(TRgb aRgb,TDisplayMode aMode);
	  static TRgb RgbMidDarkerColor(TRgb aRgb,TDisplayMode aMode);
	  static TRgb RgbLighterColor(TRgb aRgb,TDisplayMode aMode);
	};


class TFindWidthOfWidestTextItem
 









	{
protected:
	 
	inline TFindWidthOfWidestTextItem() {}
public:
	  TInt MaximumWidthInPixels(const CFont& aFont) const;
private:
	 





	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const=0;
	 





	virtual void GetTextItem(TDes& aText, TInt aIndex) const=0;
	};


class TFindWidthOfWidestDigit : public TFindWidthOfWidestTextItem
 







	{
public:
	  TFindWidthOfWidestDigit();
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;
	};

class TFindWidthOfWidestDigitType : public TFindWidthOfWidestTextItem
 



	{
public:
	  TFindWidthOfWidestDigitType(TDigitType aDigitType);
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;

private:
	TDigitType iDigitType;
	};

class TFindWidthOfWidestAmPmName : public TFindWidthOfWidestTextItem
 








	{
public:
	  TFindWidthOfWidestAmPmName();
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;
	};

class TFindWidthOfWidestAbbreviatedDayName : public TFindWidthOfWidestTextItem
 








	{
public:
	  TFindWidthOfWidestAbbreviatedDayName();
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;
	};


class TFindWidthOfWidestDayName : public TFindWidthOfWidestTextItem
 







	{
public:
	  TFindWidthOfWidestDayName();
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;
	};


class TFindWidthOfWidestAbbreviatedMonthName : public TFindWidthOfWidestTextItem
 







	{
public:
	  TFindWidthOfWidestAbbreviatedMonthName();
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;
	};

class TFindWidthOfWidestMonthName : public TFindWidthOfWidestTextItem
 







	{
public:
	  TFindWidthOfWidestMonthName();
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;
	};

class TFindWidthOfWidestDateSuffix : public TFindWidthOfWidestTextItem
 







	{
public:
	  TFindWidthOfWidestDateSuffix();
private:
	virtual void GetFirstAndLastIndex(TInt& aFirstIndex, TInt& aLastIndex) const;
	virtual void GetTextItem(TDes& aText, TInt aIndex) const;
	};

 
inline TInt8 ResourceUtils::ReadTInt8L(TResourceReader& aReader)
 



	{ return((TInt8)ReadResourceIntL(aReader,EResourceInt8)); }
inline TInt16 ResourceUtils::ReadTInt16L(TResourceReader& aReader)
 



	{ return((TInt16)ReadResourceIntL(aReader,EResourceInt16)); }
inline TInt32 ResourceUtils::ReadTInt32L(TResourceReader& aReader)
 



	{ return((TInt32)ReadResourceIntL(aReader,EResourceInt32)); }



# 42 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 2









enum TKeyCode;
class RIncrMatcherBase;
class CListItemDrawer;
class CEikScrollBarFrame;
class CEikButtonBase;
class CMatchBuffer;
class CListBoxExt;

class CEikListBox : public CEikBorderedControl, public MEikScrollBarObserver
	{
public:
	friend class CListBoxExt;
public:
	enum TFlags
		{
		EMultipleSelection			= SLafListBox::EMultipleSelection,
		ENoExtendedSelection		= SLafListBox::ENoExtendedSelection,
		EIncrementalMatching		= SLafListBox::EIncrementalMatching,
		EPopout						= SLafListBox::EPopout,
		ELeftDownInViewRect			= SLafListBox::ELeftDownInViewRect,
		EItemDoubleClicked			= SLafListBox::EItemDoubleClicked,
		EKeepModel					= SLafListBox::EKeepModel,
		EScrollBarSizeExcluded		= SLafListBox::EScrollBarSizeExcluded,
		EStateChanged				= SLafListBox::EStateChanged,
		ECreateOwnWindow			= SLafListBox::ECreateOwnWindow,
        ENoFirstLetterMatching      = SLafListBox::ENoFirstLetterMatching,
 		EPaintedSelection			= SLafListBox::EPaintedSelection ,
		ELoopScrolling = 0x1000,
		EEnterMarks = 0x2000,		 
		EShiftEnterMarks = 0x4000,	 
		EViewerFlag = 0x8000,		 
		EPageAtOnceScrolling = 0x8000,  
		EDisableHighlight = 0x8000   
		};
	enum {KEikMaxMatchingBufferLength = 2};
	enum TScrollBarOwnerShip
	    {
	    ENotOwnedExternally=0x0000,
	    EOwnedExternally   =0x0001
		};
protected:
	enum TReasonForFocusLost
		{ EFocusLostToExternalControl, EFocusLostToInternalEditor };
public:
	 
	  ~CEikListBox();
	  CEikListBox();
	  void ConstructL(MListBoxModel* aListBoxModel,CListItemDrawer* aListItemDrawer,const CCoeControl* aParent,TInt aFlags = 0);
	  void ConstructL(MListBoxModel* aListBoxModel,CListItemDrawer* aListItemDrawer,const CCoeControl* aParent, TGulBorder aBorder, TInt aFlags = 0);

	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  virtual void HandlePointerEventL(const TPointerEvent& aPointerEvent);
	  virtual void SetContainerWindowL(const CCoeControl& aContainer);
	  virtual TSize MinimumSize();
	  virtual void SetDimmed(TBool aDimmed);

	  virtual void HandleScrollEventL(CEikScrollBar* aScrollBar, TEikScrollEvent aEventType);

	 
	  MListBoxModel* Model() const;
	  CListBoxView* View() const;

	 
	  TInt TopItemIndex() const;	 
	  virtual void SetTopItemIndex(TInt aItemIndex) const;
	  TInt BottomItemIndex() const;
	  TInt CurrentItemIndex() const;	  
	  void SetCurrentItemIndex(TInt aItemIndex) const;
	  void SetCurrentItemIndexAndDraw(TInt aItemIndex) const;

	 
	  const CListBoxView::CSelectionIndexArray* SelectionIndexes() const;
	  void SetSelectionIndexesL(CListBoxView::CSelectionIndexArray* aArrayOfSelectionIndexes);
	  void ClearSelection();	

	 
	  void HandleItemAdditionL();
	  void HandleItemRemovalL();
	  void HandleItemAdditionL(CArrayFix<TInt> &aArrayOfNewIndexesAfterAddition);
	  void HandleItemRemovalL(CArrayFix<TInt> &aArrayOfOldIndexesBeforeRemoval);
	  void Reset();

	 
	  virtual void SetItemHeightL(TInt aHeight);
	  TInt ItemHeight() const;

	 
	  CEikScrollBarFrame* CreateScrollBarFrameL(TBool aPreAlloc=EFalse);

	  void SetScrollBarFrame(CEikScrollBarFrame* aScrollBarFrame, TScrollBarOwnerShip aOwnerShip);
	  TBool IsScrollBarFrameOwnedExternally() const;

	  CEikScrollBarFrame* const ScrollBarFrame();
	  virtual void UpdateScrollBarsL();

	 
	  void CalculatePopoutRect(TInt aTargetItemIndex, TInt aTargetYPos, TRect& aListBoxRect, TInt aMinHeightInNumOfItems = 1);
	  TSize CalcSizeInPixels(TInt aWidthAsNumOfChars, TInt aHeightAsNumOfItems) const;
	  TInt CalcWidthBasedOnNumOfChars(TInt aNumOfChars) const;
	  TInt CalcHeightBasedOnNumOfItems(TInt aNumOfItems) const;
	  TInt CalcWidthBasedOnRequiredItemWidth(TInt aTextWidthInPixels) const;

	 
	  void DrawItem(TInt aItemIndex) const;
	  void ScrollToMakeItemVisible(TInt aItemIndex) const;

	 
	  void SetListBoxObserver(MEikListBoxObserver* aObserver);

	  TInt VerticalInterItemGap() const;

	 
	  void SetLaunchingButton(CEikButtonBase* aButton);

     
      void SetItemEditor(MEikListBoxEditor* aEditor);
      void ResetItemEditor();
      MEikListBoxEditor* ItemEditor();
      virtual void EditItemL(TInt aMaxLength);
      void StopEditingL(TBool aUpdateModel);

	 
	 
	  virtual TInt ShortcutValueForNextList();
	  virtual void SetShortcutValueFromPrevList(TInt aValue);

public:	 
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
	  virtual void ActivateL();
	  TCoeInputCapabilities InputCapabilities() const;

protected:
	 
	 
	friend class AknListBoxShortCutsImplementation;
	 
	friend class AknListBoxLayouts;

	  virtual void FocusChanged(TDrawNow aDrawNow);
	  virtual void SizeChanged();
	  virtual void HandleViewRectSizeChangeL();
	  virtual TInt CountComponentControls() const;
	  virtual CCoeControl* ComponentControl(TInt aIndex) const;

	 
	  void CreateMatchBufferL();   
	  void ClearMatchBuffer() const;
	  void MatchTypedCharL(TUint aCode);
	  void UndoLastChar();
	  TBool LastCharMatched() const;

	 
	  virtual void UpdateScrollBarThumbs() const;
	  virtual TInt HorizScrollGranularityInPixels() const;
	  virtual TInt HorizontalNudgeValue() const;
	  virtual void AdjustTopItemIndex() const;

	 
	  void SimulateArrowKeyEventL(TKeyCode aKeyCode);
	  virtual void HandleLeftArrowKeyL(CListBoxView::TSelectionMode aSelectionMode);
	  virtual void HandleRightArrowKeyL(CListBoxView::TSelectionMode aSelectionMode);

	 
	  void RestoreCommonListBoxPropertiesL(TResourceReader& aReader);  
	  virtual void ConstructL(const CCoeControl* aParent,TInt aFlags = 0);
	  virtual void CreateViewL();
	  virtual CListBoxView* MakeViewClassInstanceL();
	  void SetViewRectFromClientRect(const TRect& aClientRect);
	  virtual void RestoreClientRectFromViewRect(TRect& aClientRect) const;
	  virtual TInt AdjustRectHeightToWholeNumberOfItems(TRect& aRect) const;

	 
	  TMargins8 ListBoxMargins() const;

	 
	  TInt HorizontalMargin() const;
	  TInt VerticalMargin() const;
	  void SetHorizontalMargin(TInt aMargin);
	  void SetVerticalMargin(TInt aMargin);
	  RIncrMatcherBase* MatchBuffer() const;
	  TInt ViewRectHeightAdjustment() const;
	  TRgb BackColor() const;
	  void SetViewRectHeightAdjustment(TInt aAdjustment);

	 
	  virtual void ReportListBoxEventL(MEikListBoxObserver::TListBoxEvent aEvent);
	  virtual void Draw(const TRect& aRect) const;
	  void ClearMargins() const;
	  virtual void UpdateCurrentItem(TInt aItemIndex) const;
	  virtual void HandleDragEventL(TPoint aPointerPos);
	  TBool ItemExists(TInt aItemIndex) const;
	  void DrawMatcherCursor() const;

	  static TInt InterItemGap();

	  void UpdateViewColors();
	  void UpdateItemDrawerColors();

protected:	 

	  void SetReasonForFocusLostL(TReasonForFocusLost aReasonForFocusLost);
	  TReasonForFocusLost ReasonForFocusLostL();
	  TBool IsMatchBuffer() const;
	void CheckCreateExtensionL();
	TBool CheckCreateExtension();
	void CheckCreateBufferL();
	CMatchBuffer* Buffer() const;
protected:
	  void CreateScrollBarFrameLayout(TEikScrollBarFrameLayout& aLayout) const;
private:  
	  void Reserved_1();
	  void Reserved_2();
private:
	  virtual void CEikListBox_Reserved();  
	void HorizontalScroll(TInt aScrollAmountInPixels);
	void DrawItemInView(TInt aItemIndex) const;
	void ClearMargins(CWindowGc& aGc) const;
	TKeyResponse DoOfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	void UpdateScrollBarColors(CEikScrollBar* aScrollBar);
	void UpdateScrollBarsColors();

	void HandleItemRemovalWithoutSelectionsL();
protected:
	TInt iListBoxFlags;
	CListBoxView* iView;
	CListItemDrawer* iItemDrawer;
	MListBoxModel* iModel;
	TInt iItemHeight; 	
	CEikScrollBarFrame* iSBFrame;
	TScrollBarOwnerShip iSBFrameOwned;
	TInt iRequiredHeightInNumOfItems;
	CEikButtonBase* iLaunchingButton;  
	MEikListBoxObserver* iListBoxObserver;
private:
	TRgb iBackColor;
 
 
	TMargins8 iMargins ;
	CListBoxExt* iListBoxExt;
	TInt iViewRectHeightAdjustment;
    MEikListBoxEditor* iItemEditor;
	TBool* iLbxDestroyed;
	TBool iLastCharMatched;
	TInt iSpare;
	};


class CEikSnakingListBox : public CEikListBox  
	{
public:
	  CEikSnakingListBox();
	  ~CEikSnakingListBox();
	  virtual CListBoxView* MakeViewClassInstanceL();
	  virtual void SetTopItemIndex(TInt aItemIndex) const;
   	  TInt ColumnWidth() const;
	  void SetColumnWidth(TInt aColumnWidth);
protected:
	  virtual void HandleViewRectSizeChangeL();
	  virtual void HandleLeftArrowKeyL(CListBoxView::TSelectionMode aSelectionMode);
	  virtual void HandleRightArrowKeyL(CListBoxView::TSelectionMode aSelectionMode);
	  virtual TInt HorizontalNudgeValue() const;
	  virtual TInt HorizScrollGranularityInPixels() const;
	  virtual void AdjustTopItemIndex() const;
	  virtual void HandleDragEventL(TPoint aPointerPos);
	  virtual void RestoreClientRectFromViewRect(TRect& aClientRect) const;
	  virtual TInt AdjustRectHeightToWholeNumberOfItems(TRect& aRect) const;
	  void MoveToNextOrPreviousItemL(TPoint aPoint);
protected:  
	  virtual void SizeChanged();
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
private:  
	  void Reserved_1();
	  void Reserved_2();
private:
	  virtual void CEikListBox_Reserved();  
	};


# 28 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiktxlbx.h" 1
 
 
 
 
   















class CTextListBoxModel;

class CEikTextListBox : public CEikListBox
	{
public:
	  ~CEikTextListBox();
	  CEikTextListBox();
	  virtual void ConstructFromResourceL(TResourceReader& aReader);
	  void ConstructL(const CCoeControl* aParent, TInt aFlags = 0);
	  CTextListBoxModel* Model() const;
public:	 
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
protected:  
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
protected:
	  virtual void CreateItemDrawerL();
private:
	  virtual void CEikListBox_Reserved();  
protected:
	TInt iRequiredCellCharWidth;
private:
	TInt iSpare;		 
	};


class CEikSnakingTextListBox : public CEikSnakingListBox
	{
public:
	  ~CEikSnakingTextListBox();
	  CEikSnakingTextListBox();
	  void ConstructL(const CCoeControl* aParent, TInt aFlags = 0);
	  CTextListBoxModel* Model() const;
public:	 
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
	};



# 29 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcmobs.h" 1
 
 
 
 

# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcmobs.h"

# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopuplayout.h" 1
 
























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 1
 


























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiktxlbm.h" 1
 
 
 
 










class CTextListBoxModel : public CBase, public MTextListBoxModel
	{
public:
	  CTextListBoxModel();
	  virtual ~CTextListBoxModel();
	  virtual TInt NumberOfItems() const;
	  virtual const MDesC16Array * MatchableTextArray() const;
	  virtual TPtrC ItemText(TInt aItemIndex) const;
	  virtual void ConstructL(MDesC16Array * aItemTextArray = 0L , TListBoxModelItemArrayOwnership aOwnershipType = ELbmOwnsItemArray);
	  void SetItemTextArray(MDesC16Array * aItemTextArray);
	  void SetOwnershipType(TListBoxModelItemArrayOwnership aOwnershipType); 
	  MDesC16Array * ItemTextArray() const;
protected:
	  TListBoxModelItemArrayOwnership ItemArrayOwnershipType() const;
private:  
	  virtual TAny* MListBoxModel_Reserved();
protected:
	MDesC16Array * iItemTextArray;
private:
	TListBoxModelItemArrayOwnership iItemArrayOwnershipType;
	}; 



# 28 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/avkon.rsg" 1

























































































































































































































































































































































































# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coedef.h" 1
 
 
 
 

# 96 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coedef.h"

# 31 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecobs.h" 1
 
 
 
 

# 64 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecobs.h"

# 32 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulalign.h" 1
 
 
 
 

# 130 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulalign.h"

# 34 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h" 1
 
 
 
 

# 359 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h"


# 35 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh" 1
# 877 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh"


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 1
 
 
 
 

# 627 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coedef.h" 1
 
 
 
 

# 96 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coedef.h"

# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdef.h" 1
 
 
 
 








enum TPopupTargetPosType
	{
	EPopupTargetTopLeft,
	EPopupTargetTopRight,
	EPopupTargetBottomLeft,
	EPopupTargetBottomRight
	};






















static const TLitC<sizeof(L"*" )/2>  KEikDefaultAppBitmapStore ={sizeof(L"*" )/2-1,L"*" } ;

const TInt KUidValueEikColorSchemeChangeEvent	=0x10006956;

const TInt KEikCustomColorsArrayValue			=0x100057C2;

const TInt KEikMessageFadeAllWindows			=0x100056C2;
const TInt KEikMessageUnfadeWindows				=0x100056C3;
const TInt KEikMessageColorSchemeChange			=0x100056C4;
const TInt KEikMessageWindowsFadeChange			=0x10006890;

const TInt KEikMessageZoomChange				=0x100057C3;
const TInt KEikMessageVirtualCursorStateChange	=0x10005D0A;
const TInt KEikMessageCapsLock					=0x100048F9;
const TInt KEikMessagePrepareForSave			=0x100069FD;
const TInt KEikMessageEmbedLevelChange			=0x1000A4AA;

 
const TInt KEikMessageCaptionedControlEditableStateChange			=0x10008E99;
const TInt KEikMessageCaptionedControlNotEditableStateChange		=0x10008E9A;
const TInt KEikMessageCaptionedControlEditableStateChangeWideWithGraphic			=0x101F5FBA;
const TInt KEikMessageCaptionedControlEditableStateChangeWideWithoutGraphic			=0x101F5FBB;
const TInt KEikMessageCaptionedControlNotEditableStateChangeWideWithGraphic			=0x101F5FBC;
const TInt KEikMessageCaptionedControlNotEditableStateChangeWideWithoutGraphic		=0x101F5FBD;

const TInt KEikPartialForegroundFade			=0x101f538d;	 
const TInt KEikPartialForegroundNoFade			=0x101f538e;	 
const TInt KEikRequestPartialForegroundEvent	=0x101f53c5;	 
const TInt KEikClearPartialForegroundState		=0x101f54f4;
const TInt KEikPartialForeground				=0x101f6aab;

 
 
const TInt KEikDynamicLayoutVariantSwitch	= 0x101F8121;
const TInt KEikDynamicLayoutVariantSwitch_ELAF	= 0x101F8122;
const TInt KEikDynamicLayoutVariantSwitch_ABRW	= 0x101F8123;
const TInt KEikDynamicLayoutVariantSwitch_APAC	= 0x101F8124;
 

const TInt KEikInputLanguageChange = 0x101F8519;

const TInt KEikResIdQueryDialog	=0;
const TInt KEikResIdInfoDialog	=1;







 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/asshdbitflags.h" 1
 
 
 
 
 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/babitflags.h" 1
 
 
 
 
 



 


 
 
 
template <class T>
class TBitFlagsT
 




	{
 
public:										 
 

	 


	inline TBitFlagsT();

	 


	inline TBitFlagsT(T aFlags);

	 



	inline TBitFlagsT(const TBitFlagsT& aFlags);

 
public:										 
 

	 


	inline void								SetAll();

	 


	inline void								ClearAll();

	 


	inline void								Set(TInt aFlagIndex);

	 


	inline void								Clear(TInt aFlagIndex);

	 





	inline void								Assign(TInt aFlagIndex, TBool aValue);

	 



	inline void								Toggle(TInt aFlagIndex);

 
public:										 
 

	 




	inline TBool							operator[](TInt aFlagIndex) const;

	 



	inline TBitFlagsT&						operator=(const TBitFlagsT& aFlags);

	 




	inline TBool							operator==(const TBitFlagsT& aFlags);

 
public:										 
 

	 


	inline TBool							IsSet(TInt aFlagIndex) const;

	 


	inline TBool							IsClear(TInt aFlagIndex) const;

	 


	inline T								Value() const { return iFlags; }

	 



	inline void								SetValue(T aFlags) { iFlags = aFlags; }

 
public :									 
 

	 


	inline T								FlagMask(TInt aFlagIndex) const;

 
public:										 
 
	
	 
	T										iFlags;
	};

 



typedef TBitFlagsT<TUint8> TBitFlags8;
typedef TBitFlagsT<TUint16> TBitFlags16;
typedef TBitFlagsT<TUint32>	TBitFlags32;
 
typedef TBitFlags32 TBitFlags;


 
 
 
template <class T>
inline TBitFlagsT<T>::TBitFlagsT() : iFlags(0) 
	{}

template <class T>
inline TBitFlagsT<T>::TBitFlagsT(T aFlags) : iFlags(aFlags) 
	{}

template <class T>
inline TBitFlagsT<T>::TBitFlagsT(const TBitFlagsT<T>& aFlags) : iFlags(aFlags.iFlags) 
	{}

template <class T>
inline T TBitFlagsT<T>::FlagMask(TInt aFlagIndex) const
	{ return T(T(1)<<aFlagIndex); }

template <class T>
inline TBool TBitFlagsT<T>::IsSet(TInt aFlagIndex) const
	{ return iFlags & FlagMask(aFlagIndex); }

template <class T>
inline TBool TBitFlagsT<T>::IsClear(TInt aFlagIndex) const
	{ return !IsSet(aFlagIndex); }

template <class T>
inline void TBitFlagsT<T>::Set(TInt aFlagIndex)
	{ iFlags |= FlagMask(aFlagIndex); }

template <class T>
inline void TBitFlagsT<T>::Clear(TInt aFlagIndex)
	{ iFlags &= ~(FlagMask(aFlagIndex)); }

template <class T>
inline void TBitFlagsT<T>::Assign(TInt aFlagIndex, TBool aVal)
	{ if (aVal) Set(aFlagIndex); else Clear(aFlagIndex); }

template <class T>
inline void TBitFlagsT<T>::Toggle(TInt aFlagIndex)
	{ iFlags ^= FlagMask(aFlagIndex); }

template <class T>
inline TBool TBitFlagsT<T>::operator[](TInt aFlagIndex) const
	{ return IsSet(aFlagIndex); }

template <class T>
inline TBitFlagsT<T>& TBitFlagsT<T>::operator=(const TBitFlagsT<T>& aFlags)
	{ iFlags = aFlags.iFlags; return *this; }

template <class T>
inline TBool TBitFlagsT<T>::operator==(const TBitFlagsT<T>& aFlags)
	{ return iFlags == aFlags.Value(); }

template <class T>
inline void TBitFlagsT<T>::SetAll()
	{ iFlags = ~(T(0)); }

template <class T>
inline void TBitFlagsT<T>::ClearAll()
	{ iFlags = T(0); }



# 7 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/asshdbitflags.h" 2

# 94 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdef.h" 2


 














# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulalign.h" 1
 
 
 
 

# 130 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulalign.h"

# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apaflrec.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apadef.h" 1
 
 
 
 








 

 


const TUint KApaCommandLetterOpen='O';

 


const TUint KApaCommandLetterCreate='C';

 


const TUint KApaCommandLetterRun='R';

 


const TUint KApaCommandLetterBackground='B';

 


const TUint KApaCommandLetterViewActivate='V';

 


const TUint KApaCommandLetterRunWithoutViews='W';

 





enum TApaCommand
	{
	 
	EApaCommandOpen,
	 
	EApaCommandCreate,
	 
	EApaCommandRun,
	 
	EApaCommandBackground,
	 
	EApaCommandViewActivate,
	 


	EApaCommandRunWithoutViews
	};

 



const TInt KApaMaxAppCaption=0x100;	 

 

 




typedef TBuf<KApaMaxAppCaption> TApaAppCaption; 

 


const TInt KApaMaxCommandLine=0x100;	

 


typedef TBuf<KApaMaxCommandLine> TApaCommandLine;

 


const TInt KApaMaxAppFileName=0x10;	 

 


typedef TBuf<KApaMaxAppFileName> TApaAppFileName;

 




const TInt KApaMaxAppGroupName=0x10;  

 






typedef TBuf<KApaMaxAppGroupName> TApaAppGroupName;

 





const TInt KAppUidValue8 = 0x1000006c;

 



const TUid KUidApp8={KAppUidValue8};

 






const TInt KAppUidValue16 = 0x100039CE;

 




const TUid KUidApp16={KAppUidValue16};

 
 
 



const TUid KUidAppDllDoc8={268435565}; 

 



const TUid KUidAppDllDoc16={0x10003A12};

 





const TUid KUidPictureTypeDoor8={268435537};

 





const TUid KUidPictureTypeDoor16={0x10003A33};

 
 
 



const TUid KUidSecurityStream8={268435661};

 



const TUid KUidSecurityStream16={0x10003A40};

 



const TUid KUidAppIdentifierStream8={268435593};  

 



const TUid KUidAppIdentifierStream16={0x10003A34};


 






 







 




 









 




 




# 270 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apadef.h"


const TUid KUidFileEmbeddedApplicationInterfaceUid={0x101f8c96};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apaflrec.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apaid.h" 1
 
 
 
 











 
class TApaAppIdentifier;
class TApaAppEntry;
class CApaAppFinder;
 
 
class RReadStream;
class RWriteStream;
class RFs;
 


class TApaAppIdentifier
 
















	{
public:
	  TApaAppIdentifier();
	  TApaAppIdentifier(TUid aAppUidType,const TFileName& aDllName);
	  void ExternalizeL(RWriteStream& aStream)const;
	  void InternalizeL(RReadStream& aStream);
public:
	 
	TUid iAppUid;
	 
	TFileName iFullName;
	};


class TApaAppEntry
 









	{
public:
	  TApaAppEntry();
	  TApaAppEntry(const TUidType& aAppUidType,const TFileName& aDllName);
	  void ExternalizeL(RWriteStream& aStream)const;
	  void InternalizeL(RReadStream& aStream);
public:
	 
	TUidType iUidType;
	 
	TFileName iFullName;
	};


class TApaAppInfo
 













	{
public:
	  TApaAppInfo();
	  TApaAppInfo(TUid aAppUid,const TFileName& aDllName,const TApaAppCaption& aCaption);
	  TApaAppInfo(TUid aAppUid,const TFileName& aDllName,const TApaAppCaption& aCaption,const TApaAppCaption& aShortCaption);
	  void ExternalizeL(RWriteStream& aStream)const;
	  void InternalizeL(RReadStream& aStream);
public:
	 
	TUid iUid;
	 
	TFileName iFullName;
	 
	TApaAppCaption iCaption;
	 
	TApaAppCaption iShortCaption;
	};


class TApaAppViewInfo
 













	{
public:
	  TApaAppViewInfo();
	  TApaAppViewInfo(TUid aViewUid,const TApaAppCaption& aViewCaption,TInt aScreenMode);
	  void ExternalizeL(RWriteStream& aStream)const;
	  void InternalizeL(RReadStream& aStream);
public:
	 
	TUid iUid;
	 
	TApaAppCaption iViewCaption;
	TInt iScreenMode;
	};


 







typedef CArrayFixFlat<TApaAppViewInfo> CApaAppViewArray;


class TApaAppCapability
 
 
 



	{
public:
	  static void CopyCapability(TDes8& aDest,const TDesC8& aSource);
	  void InternalizeL(RReadStream& aStream);
	  void Internalize7_0L(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream) const;
private:
	  void Externalize7_0L(RWriteStream& aStream) const;
	void DoInternalizeL(RReadStream& aStream, TBool& aLaunchInBackground, TApaAppGroupName& aGroupName);
public:
	 
	 
	enum TEmbeddability {
		 
		ENotEmbeddable=0,
		 
		EEmbeddable=1,
		 
		EEmbeddableOnly=2,
		 
		EEmbeddableUiOrStandAlone=5,
		 
		EEmbeddableUiNotStandAlone=6 };
public:
	 
	TEmbeddability iEmbeddability;
	 

	TBool iSupportsNewFile;
	 


	TBool iAppIsHidden;  
	 

	TBool iLaunchInBackground;	 
	 
	TApaAppGroupName iGroupName;  
private:
	enum { EVersion=3 };
	};

 



typedef TPckgBuf<TApaAppCapability> TApaAppCapabilityBuf;


 




class TApaEmbeddabilityFilter
	{
public:
	  TApaEmbeddabilityFilter();
	  void AddEmbeddability(TApaAppCapability::TEmbeddability aEmbeddability);
	  TBool MatchesEmbeddability(TApaAppCapability::TEmbeddability aEmbeddability) const;
private:
	TUint iEmbeddabilityFlags;
	};


class CApaAppFinder : public CBase
 



	{
public:
	virtual void FindAllAppsL()=0;  
	virtual TBool NextL(TApaAppEntry& aEntry)=0;  
	virtual TFileName FindAppL(const TDesC& aFileName,TUid aFileUid)=0;  
	 
	virtual TFileName TempPath()const=0;  
	virtual TFileName DefaultAppInfoFileName()const=0;  
	};



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apaflrec.h" 2



 
class MApaAppStarter;
class CApaAppLocator;
class CApaFileRecognizer;
class CApaFileRecognizerType;
class CFileRecognizerExtension;
 
 
class TApaAppEntry;
class CApaCommandLine;
class RFs;
 

 
 









 



const TInt KFileRecognizerUidValue8=0x1000013E;

 



const TUid KUidFileRecognizer8={KFileRecognizerUidValue8};

 



const TUid KUidFileRecognizer16={0x10003A37};
 


class CApaAppLocator : public CBase
 


	{
public:
	virtual TInt GetAppEntryByUid(TApaAppEntry& aAppEntry,TUid aAppUid)=0;
	virtual TInt GetAppCapabilityByUid(TDes8& aCapabilityBuf,TUid aAppUid)=0;
	};



class CApaFileRecognizer : public CBase
 



	{
public:
	 
	  CApaFileRecognizerType* RecognizeFileL(const TDesC& aFullFileName,const TUidType* aUidType= 0L );
	  CApaAppLocator* AppLocator() const;
	 
	  ~CApaFileRecognizer();
protected:
	  CApaFileRecognizer(RFs& aFs);
	  void AddFileRecognizerType(CApaFileRecognizerType* aFileRecognizerType);
	  TInt RemoveFileRecognizerType(const CApaFileRecognizerType* aFileRecognizerType);
	  void SetAppLocator(CApaAppLocator* aAppLocator);  
	static inline void SetAppStarter(CApaFileRecognizerType* aRecognizer,MApaAppStarter* aAppStarter);
	  void DestroyRecognizerList();
protected:
	RFs& iFs;
	CApaAppLocator* iAppLocator;
private:
	CApaFileRecognizerType *iFileRecognizerList;
	};



class MApaAppStarter
 






	{
public:
	virtual TThreadId StartAppL(const CApaCommandLine& aCommandLine)=0;
	};



class CApaFileRecognizerType : public CBase
 



	{
public:
	enum TRecognizedType {EProgram,EDoc,EOtherFile,ENotRecognized};
public:
	virtual TThreadId RunL(TApaCommand aCommand,const TDesC* aDocFileName= 0L ,const TDesC8* aTailEnd= 0L ) const=0;
	inline TUid AppUid()const;
	inline TUid TypeUid()const;
	inline TRecognizedType Type()const;
	  void Capability(TDes8& aCapabilityBuf)const;
	  void Lock();
	  void Unlock();
protected:
	  CApaFileRecognizerType();
	  ~CApaFileRecognizerType();
	  TThreadId AppRunL(const CApaCommandLine& aCommandLine) const;
private:
	inline void SetAppStarter(MApaAppStarter* aAppStarter);  
	virtual TRecognizedType DoRecognizeFileL(RFs& aFs,TUidType aUidType)=0;
	TRecognizedType RecognizeFileL(RFs& aFs,const TDesC& aFullFileName,TUidType aUidType);
	TBool Locked()const;
	  virtual void Reserved_1();
public:
	  static CApaFileRecognizerType* CreateFileRecognizerL(TUid aImplUid);
protected:
	CApaFileRecognizer* iFileRecognizer;
	MApaAppStarter* iAppStarter;
	HBufC* iFullFileName;
	TUid iFileType;  
	TUid iAppUid;  
	TRecognizedType iRecognizedType;
	TApaAppCapabilityBuf* iCapabilityBuf;
private:
	CApaFileRecognizerType* iNext;
	TInt iLock;
	CFileRecognizerExtension* iFileRecognizerExtn;
private:
	friend class CApaFileRecognizer;
	};


 
 
 

inline void CApaFileRecognizer::SetAppStarter(CApaFileRecognizerType* aRecognizer,MApaAppStarter* aAppStarter)
	{ aRecognizer->SetAppStarter(aAppStarter); }

inline void CApaFileRecognizerType::SetAppStarter(MApaAppStarter* aAppStarter)
	{ iAppStarter = aAppStarter; }

inline TUid CApaFileRecognizerType::AppUid() const
	{ return iAppUid; }

inline TUid CApaFileRecognizerType::TypeUid() const
	{ return iFileType; }

inline CApaFileRecognizerType::TRecognizedType CApaFileRecognizerType::Type()const
	{ return iRecognizedType; }




 













# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apacmdln.h" 1
 
 
 
 













class CApaCommandLine : public CBase
 















	{
public:
	 
	  static CApaCommandLine* New(HBufC* aCmdLine);
	  static CApaCommandLine* NewL();
	  static CApaCommandLine* NewL(const TDesC& aCmdLine);
	  static CApaCommandLine* NewLC();
	  static CApaCommandLine* NewLC(const TDesC& aCmdLine);
	  ~CApaCommandLine();
	  void SetReserveLengthL(TInt aMaxLength);

	 
	  void SetFullCommandLine(HBufC* aCmdLine);
	  void SetFullCommandLineL(const TDesC& aCmdLine);
	  TPtrC FullCommandLine() const;

	 
	  void SetLibraryNameL(const TDesC& aLibName);
	  TPtrC LibraryName() const;

	 
	  void SetDocumentNameL(const TDesC& aDocName);
	  TPtrC DocumentName() const;

	 
	  void SetTailEndL(const TDesC8& aTailEnd);
	  TPtrC8 TailEnd() const;

	 
	  void SetCommandL(TApaCommand aCommand);
	  TApaCommand Command() const;
private:
	CApaCommandLine();
	void Parse();
	TPtrC StripQuotes(const TDesC& aDes) const;
	void AddQuotes(TDes& aDes) const;
	TBool FileNameNeedsQuotes(const TDesC& aFileName) const;
	TInt DifferenceIncludingQuotes(TDes& aNewDes, const TDesC& aOldDes) const;
	TBool ReAllocIfNecessaryL(TInt aExtraLengthReqd);
private:
	enum TStateFlags { ELibNamePresent=0x01, ECommandPresent=0x02, EDocNamePresent=0x04,
		               ETailEndPresent=0x08 };
	TInt iStateFlags;
	HBufC* iCmdLine;
	TInt iEndLibNameOffset;
	TInt iEndDocNameOffset;
	TInt iNumQuotes;
	TInt iTailEndLength;
	};


# 15 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h" 1
 
 
 
 

 
 
 

# 310 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/badesca.h"





# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/baerrhan.h" 1
 
 
 
 

 
 
 







 











 


const TInt KUidBaflErrorHandlerValue8=0x10000257;
const TUid KUidBaflErrorHandler8={KUidBaflErrorHandlerValue8};
const TInt KUidBaflErrorHandlerValue16=0x10003A13;
const TUid KUidBaflErrorHandler16={KUidBaflErrorHandlerValue16};

 


enum TErrorHandlerResponse
	{
	EErrorNotHandled,
	ENoDisplay,
	EAlertDisplay,
	EInfoDisplay
	};

class CBaErrorHandler : public CBase
 



	{ 
public:
	virtual TErrorHandlerResponse HandleError(TDes& aErrorText,TDes& aContextText)=0;
	inline static TErrorHandlerResponse CallBack(TInt aErrorNumber,TDes& aErrorText,TDes& aContextText);
	};

inline TErrorHandlerResponse CBaErrorHandler::CallBack(TInt aErrorNumber,TDes& aErrorText,TDes& aContextText)
	{
	return((CBaErrorHandler*)(aErrorNumber))->HandleError(aErrorText,aContextText);
	}


# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulcolor.h" 1
 
 
 
 
















 











enum TLogicalColor
	{
	 
	 
	EColorWindowBackground,
	 
	EColorWindowText,
	 
	 
	EColorControlBackground,
	 
	EColorControlText, 
	 
	EColorControlSurroundBackground,
	 
	EColorControlSurroundText,
	 
	EColorControlHighlightBackground, 
	 
	EColorControlHighlightText,
	 
	EColorControlDimmedBackground, 
	 
	EColorControlDimmedText,
	 
	EColorControlDimmedHighlightBackground,
	 
	EColorControlDimmedHighlightText,
	 
	 
	EColorDialogBackground,
	 
	EColorDialogText,
	 
	EColorDialogTitle,
	 
	EColorDialogTitlePressed,
	 
	EColorDialogTitleText,
	 
	EColorDialogTitleTextPressed,
	 
	 
	EColorMenubarBackground,
	 
	EColorMenubarText,
	 
	EColorMenubarTitleBackground,
	 
	EColorMenubarTitleText,
	 
	EColorMenuPaneBackground,
	 
	EColorMenuPaneText,
	 
	EColorMenuPaneHighlight,
	 
	EColorMenuPaneTextHighlight,
	 
	EColorMenuPaneDimmedHighlight,
	 
	EColorMenuPaneDimmedText,
	 
	EColorMenuPaneDimmedTextHighlight,
	 
	 
	EColorButtonFaceClear,
	 
	EColorButtonFaceSet,
	 

	EColorButtonFaceSetPressed,
	 

	EColorButtonFaceClearPressed,
	 
	EColorButtonText,
	 
	EColorButtonTextPressed,
	 
	EColorButtonTextDimmed,		
	 
	 
	EColorMsgWinForeground,
	EColorMsgWinBackground,
	 
	 
	EColorScrollBarBorder,
	EColorScrollBarShaft,
	 
	EColorScrollBarShaftDimmed,
	 
	EColorScrollBarShaftPressed,
	 
	EColorScrollBarNoShaftOrThumb,
	 
	EColorScrollButtonIcon,
	 
	EColorScrollButtonIconPressed,
	 
	EColorScrollButtonIconDimmed,
	 
	EColorScrollButtonThumbBackground,
	 
	EColorScrollButtonThumbBackgroundPressed,
	 
	EColorScrollThumbDimmed,
	 
	EColorScrollThumbEdge,
	 
	 
	EColorToolbarBackground,
	 
	EColorToolbarText,
	 
	 
	EColorStatusPaneBackground,
	 
	EColorStatusPaneText,
	 
	 
	EColorLabelText,
	 
	EColorLabelTextEmphasis,
	 
	EColorLabelDimmedText,
	 
	EColorLabelHighlightPartialEmphasis,
	 
	EColorLabelHighlightFullEmphasis,
	};

class RReadStream;
class RWriteStream;
class CColorArray;

 

class CColorList : public CBase
 









	{
public:
	  static CColorList* NewL(CArrayFix<TRgb>* aColors);
	  ~CColorList();
	 
	  TRgb Color(TLogicalColor aColor) const;
	  TRgb Color(TUid aApp,TInt aColor) const;
	  CColorArray* ColorArray(TUid aApp) const;
	  TBool ContainsColorArray(TUid aApp) const;
	 
	  void SetColor(TLogicalColor aLogicalColor,TRgb aColor);
	  void AddColorArrayL(TUid aApp,CColorArray* aArray);  
	  void DeleteColorArray(TUid aApp);
public:
	static CColorList* NewLC();
	void InternalizeL(RReadStream& aStream);
	void ExternalizeL(RWriteStream& aStream) const;
	void MergeL(const CColorList& aList);
private:
	CColorList(CArrayFix<TRgb>* aColors);
	TInt Find(TUid aApp) const;
private:
	class TAppColorList
		{
	public:
		inline TAppColorList(TUid aApp,CColorArray* aColorArray);
	public:
		TUid iApp;
		CColorArray* iColorArray;
		};
private:
	CArrayFix<TRgb>* iEikColors;
	CArrayFix<TAppColorList>* iAppColors;
	};

 

class CColorArray : public CBase
 



	{
public:
	  static CColorArray* NewL();
	  static CColorArray* NewLC();
	  ~CColorArray();
	  TRgb Color(TInt aLogicalColor) const;
	  void SetColor(TInt aLogicalColor,TRgb aColor);
	  TBool Contains(TInt aLogicalColor) const;
	  TInt Count() const;
	  void Reset();
	  void AddL(TInt aLogicalColor,TRgb aColor);
	  void Remove(TInt aLogicalColor);
public:
	static CColorArray* NewLC(const CColorArray& aArray);
public:
	void InternalizeL(RReadStream& aStream);
	void ExternalizeL(RWriteStream& aStream) const;
private:
	CColorArray();
	void ConstructL();
	TInt Find(TInt aLogicalColor) const;
private:
	class TColor
		{
	public:
		inline TColor();
		inline TColor(TRgb aColor,TInt aLogicalColor);
	public:
		void InternalizeL(RReadStream& aStream);
		void ExternalizeL(RWriteStream& aStream) const;
	public:
		TRgb iColor;
		TInt iLogicalColor;
		};
	CArrayFixFlat<TColor> iColors;
	};

 


static const TLitC<sizeof(L"C:\\System\\Data\\Colorscm.dat" )/2>  KGulColorSchemeFileName ={sizeof(L"C:\\System\\Data\\Colorscm.dat" )/2-1,L"C:\\System\\Data\\Colorscm.dat" } ;


# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdgfty.h" 1
 
 
 
 








class MEikFindAndReplaceDlgObserver;
class CCoeControl;
class CEikEmbeddableAppList;
class CGraphicsDevice;
class CApaDoor;
class CApaDocument;
class TCharFormat;
class TCharFormatMask;
class TRgb;
class CEikGlobalTextEditor;
struct SEdwinFindModel;
class CParaFormat;
class TParaFormatMask;
class CPrintSetup;

 


class MEikCDlgDialogFactory
	{
public:
	 
	 
	 
	virtual TBool RunCharMapDlgLD(CCoeControl* aControl) = 0;
	virtual TBool RunFontDlgLD(	TCharFormat& aFormat,
								TCharFormatMask& aAttribChangedMask,
								TCharFormatMask& aUndeterminedMask,
								TDesC& aTextSelection,
								TInt aFonts,
								CGraphicsDevice* aGraphicsDevice, 
								TInt aFontControlFlags,
								const TRgb aBackGroundColor) = 0;

	virtual TBool RunInsertObjectDlgLD(	CEikEmbeddableAppList*	aList,
										TInt&					aChoice) = 0;

	virtual TBool RunObjectInfoDlgLD(const TDesC& aCaption) = 0;

	virtual TBool RunFormatObjectDlgLD(	CApaDoor&		aDoor,
										CApaDocument&	aDoc,
										const TSize&	aDefaultIconSize) = 0;

	virtual TBool RunEdwinFindDlgLD(SEdwinFindModel* aModel,
									CDesCArray* aFindList) = 0;

	virtual TBool RunEdwinReplaceDlgLD(	SEdwinFindModel* aModel,
										CDesCArray*		aFindList,
										CDesCArray*		aReplaceList) = 0;

	virtual void RunEdwinFindAndReplaceDlgLD(MEikFindAndReplaceDlgObserver& aObserver,
		SEdwinFindModel& aModel, TBool aFindOnly, TRect aEdwinRect)=0;

	virtual TBool RunEdwinReplaceOptionDlgLD(	CEikGlobalTextEditor*	aEdwin,
												SEdwinFindModel*		aModel) = 0;

	virtual TBool RunAlignDlgLD( CParaFormat*		aFormat, 
								TParaFormatMask&	aAttribChangedMask, 
								TParaFormatMask&	aUndeterminedMask) = 0;

	virtual TBool RunBorderDlgLD( CParaFormat*		aFormat, 
								TParaFormatMask&	aAttribChangedMask, 
								TParaFormatMask&	aUndeterminedMask) = 0;

	virtual TBool RunSpaceDlgLD( CParaFormat*		aFormat, 
								TParaFormatMask&	aAttribChangedMask, 
								TParaFormatMask&	aUndeterminedMask) = 0;

	virtual TBool RunTabsDlgLD(	CParaFormat*		aFormat, 
								TParaFormatMask&	aAttribChangedMask, 
								TParaFormatMask&	aUndeterminedMask,
								const TInt			aPageWidth) = 0;

	virtual TBool RunIndentDlgLD(	CParaFormat*		aFormat, 
									TParaFormatMask&	aAttribChangedMask, 
									TParaFormatMask&	aUndeterminedMask,
									const TInt			aPageWidth) = 0;
	};

 


class MEikPrintDialogFactory
	{
public:
	 
	 
	virtual TBool RunPaginateDlgLD(	CEikGlobalTextEditor*	aEditor,
									CPrintSetup*			aPrintSetup,
									CArrayFix<TInt>*		aCharsPerPage) = 0;

	virtual CPrintSetup* NewDefaultPrintSetupL() = 0;

	};

class MEikFileDialogFactory
	{
public:
	 
	 
	 
	virtual TBool RunFileSaveAsDlgLD(	TDes*	aFileName,
										TBool*	aUseNewFile,
										TInt	aTitleId,
										TBool	aAppendExtension) = 0;

	virtual TBool RunScreenCaptureDlgLD(TDes*	aFileName,
										TBool&	aSaveAsMonochromeImage,
										TInt	aTitleId) = 0;

	};



# 19 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikaufty.h" 1
 
 
 
 
 
 
















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemop.h" 1
 
 

# 140 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemop.h"

# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikaufty.h" 2


class CEikHotKeyTable;
class CEikMenuBar;
class CEikMenuPane;
class CEikCommandButton;
class CEikToolBar;
class CEikButtonGroupContainer;
class CEikAppUi;
class CEikonEnv;
class CEikStatusPane;

class MEikAppUiFactory : public MObjectProvider
	{
public:
	virtual void CreateResourceIndependentFurnitureL(CEikAppUi* aAppUi) =0;
	virtual TRect ClientRect() = 0;
	virtual void ReadAppInfoResourceL(TInt aResourceFileOffset,CEikAppUi* aAppUi) = 0;
	virtual void LaunchPopupMenuL(
									TInt aResourceId,
									const TPoint& aTargetPos,
									TPopupTargetPosType aTargetType,
									const CEikHotKeyTable* aHotKeyTable,
									CEikAppUi* aAppUi) = 0;

	virtual void DoLaunchPopupL(
									TInt aResourceId,
									const TPoint& aTargetPos, 
									const CEikHotKeyTable* aHotKeyTable, 
									TPopupTargetPosType aTargetType,
									CEikAppUi* aAppUi) = 0;

   	virtual void ClosePopup(CEikAppUi* aAppUi) = 0;
	virtual void StopDisplayingMenuBar() = 0;
	virtual void HandleSideBarMenuL(
									TInt aResourceId,
									const TPoint& aPos,
									const CEikHotKeyTable* aHotKeyTable,
									CEikAppUi* aAppUi) = 0;
	virtual void CreateHotKeyControlL(TInt aResourceId, CEikAppUi* aAppUi) = 0;
	virtual CEikMenuBar* MenuBar() const = 0;
	virtual CEikMenuBar* SwapMenuBar(CEikMenuBar* aMenu) = 0;
	virtual CEikMenuPane* Popup() const = 0;
	virtual CEikButtonGroupContainer* ToolBar() const = 0;
	virtual CEikButtonGroupContainer* SwapButtonGroup(CEikButtonGroupContainer* aNewGroup) = 0;
	virtual CEikToolBar* ToolBand() const = 0;
	virtual CEikToolBar* TitleBand() const = 0;
	virtual CEikStatusPane* StatusPane() const = 0;
	virtual CEikButtonGroupContainer* Cba() const = 0;
	inline CEikToolBar* SwapToolBand(CEikToolBar* aToolBand);
	inline CEikToolBar* SwapTitleBand(CEikToolBar* aTitleBand);

	virtual CEikCommandButton*  CreateStandardTabButtonL() const = 0;
	virtual void CreateEmbeddedL(CEikonEnv& aEikonEnv) = 0;
	virtual void DestroyEmbedded(CEikonEnv& aEikonEnv) = 0;
	virtual void HandleResourceChangeL(TInt aType) = 0;
protected:
	enum TToolBarType {EBand,ETitle};
private:
	virtual CEikToolBar* SwapToolBar(CEikToolBar* aToolBar,TToolBarType aType) = 0;
	};

inline CEikToolBar* MEikAppUiFactory::SwapToolBand(CEikToolBar* aToolBand)
	{return SwapToolBar(aToolBand,EBand);}
inline CEikToolBar* MEikAppUiFactory::SwapTitleBand(CEikToolBar* aTitleBand)
	{return SwapToolBar(aTitleBand,ETitle);}


# 20 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklibry.h" 1
 
 
 
 
















typedef SEikControlInfo (*TCreateByTypeFunction)(TInt);

 
 
class CEikLibrary : public CBase
	{
public:
	 
	 
	virtual void InitializeL() = 0;
	 
	 
	virtual CArrayFix<TFileName>*				ResourceFileArrayL() const = 0;
	virtual CArrayFix<TCreateByTypeFunction>*	ControlFactoryArrayL() const = 0;
	  virtual void PostAppUiInitializeL();
	};


# 21 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikamnt.h" 1
 
 
 
 






class CGulIcon;
class MEikAutoMenuObserver;

 





class CEikAutoMenuTitle : public CBase
	{
public:
	enum TTitlePos { EStart, EEnd };
	enum { ENominalTextLength=40 };
public:
	  static CEikAutoMenuTitle* NewLC(TTitlePos aPos,const TDesC& aText,MEikAutoMenuObserver& aMenuObserver,
										TInt aMenuPaneResourceId=0,CGulIcon* aIcon= 0L );
	  ~CEikAutoMenuTitle();
private:
	CEikAutoMenuTitle(TTitlePos aPos,const TDesC& aText,MEikAutoMenuObserver& aMenuObserver,
										TInt aMenuPaneResourceId,CGulIcon* aIcon);
public:
	TTitlePos iPos;
	TBuf<ENominalTextLength> iText;
	MEikAutoMenuObserver& iMenuObserver;
	TInt iMenuPaneResourceId;
	CGulIcon* iIcon;
	};

 





class CEikAutoMenuTitleArray : public CArrayPtrFlat<CEikAutoMenuTitle>
	{
public:
	CEikAutoMenuTitleArray();
	~CEikAutoMenuTitleArray();
	};


# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/lafmain.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h" 1
 
 
 
 

# 338 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h"

# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/lafmain.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulcolor.h" 1
 
 
 
 

# 266 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulcolor.h"

# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/lafmain.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 1
 
 
 
 







# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfrmat.h" 1
 
 
 
 









 
class TTabStop;
class TParaBorder;
class TBullet;
class TParaBorderArray;
class CParaFormat;
class TParaFormatMask;
class TFontPresentation;
class TCharFormat;
class TCharFormatMask;

 



























class TLogicalRgb : public TRgb
	{
	public:
 
	 




 
	enum
		{
		ESystemSelectionForegroundIndex = 252,
		ESystemSelectionBackgroundIndex = 253,
		 
		ESystemForegroundIndex = 254,
		 
		ESystemBackgroundIndex = 255
		};

	
	 
	 

	enum TSystemColor
		{
		ESystemSelectionForegroundColor = ESystemSelectionForegroundIndex << 24,
		ESystemSelectionBackgroundColor = ESystemSelectionBackgroundIndex << 24,
		 
		ESystemForegroundColor = ESystemForegroundIndex << 24,
		 
		ESystemBackgroundColor = (ESystemBackgroundIndex << 24) | 0xFFFFFF
		};
		 
	 
	TLogicalRgb() { }
	
	 



	TLogicalRgb(TUint32 aValue): TRgb(aValue) { }
	 



	TLogicalRgb(TSystemColor aValue): TRgb((TUint32)aValue) { }

	 
	TLogicalRgb(const TRgb& aRgb): TRgb(aRgb) { }
	 
	 




	TUint SystemColorIndex() const { return Value() >> 24; }
		
	 


	void SetSystemColorIndex(TUint aIndex) { *this = (Value() & 0x00FFFFFF) | (aIndex << 24); }
	};

 





enum TTextFormatAttribute
	{
	 
	 
	EAttParaLanguage,
	 
	EAttFillColor,
	 
	EAttLeftMargin,
	 
	EAttRightMargin,
	 
	EAttIndent,
	 
	EAttAlignment,
	 
	EAttVerticalAlignment,
	 
	EAttLineSpacing,
	 
	EAttLineSpacingControl,
	 
	EAttSpaceBefore,
	 
	EAttSpaceAfter,
	 
	EAttKeepTogether,
	 
	EAttKeepWithNext,
	 
	EAttStartNewPage,
	 


	EAttWidowOrphan,
	 
	EAttWrap,
	 
	EAttBorderMargin,
	 
	EAttTopBorder,
	 
	EAttBottomBorder,
	 
	EAttLeftBorder,
	 
	EAttRightBorder,
	 
	EAttBullet,
	 
	EAttDefaultTabWidth,
	 
	EAttTabStop,

	 
	 
	EAttCharLanguage,
	 
	EAttColor,
	 
	EAttFontHighlightColor,
	 
	EAttFontHighlightStyle,
	 
	EAttFontHeight,
	 
	EAttFontPosture,
	 
	EAttFontStrokeWeight,
	 
	EAttFontPrintPos,
	 
	EAttFontUnderline,
	 
	EAttFontStrikethrough,
	 
	EAttFontTypeface,
	 
	EAttFontPictureAlignment,
	 
	EAttFontHiddenText,

	 
	ETextFormatAttributeCount
	};
 


enum {EVariableLengthValue = 0};

 


const TInt KMaxStyleName = 0x20;
const TInt KMaxParaAttributes = EAttTabStop;
const TInt KMaxCharAttributes = EAttFontHiddenText - KMaxParaAttributes;
const TInt KTabNotFound = -1;

 














class TTabStop
	{
public:
	 
	enum TTabType
		{
		 
		ENullTab, 
		 

		ELeftTab, 
		 

		ECenteredTab, 
		 
		ERightTab
		};
public:
	  TTabStop();
	  TTabStop(const TTabStop& aTabStop);
	  TTabStop& operator=(const TTabStop& aTabStop);
	  TBool operator==(const TTabStop& aTabStop) const;
	inline TBool operator!=(const TTabStop& aTabStop) const;
public:
	 


	TUint32 iTwipsPosition;
	 
	TTabType iType;
	};

 









class TParaBorder
	{
public:
	
	 
	enum TLineStyle 
		{
		 
		ENullLineStyle, 
		 
		ESolid, 
		 
		EDouble,
		 
		EDotted, 
		 
		EDashed, 
		 
		EDotDash, 
		 
		EDotDotDash
		};
	 
	  TParaBorder();
	  TBool operator==(const TParaBorder& aParaBorder) const;
	inline TBool operator!=(const TParaBorder& aParaBorder) const;
public:
	 
	TLineStyle iLineStyle;
	 
	TInt iThickness;
	 
	TLogicalRgb iColor;
	 


	TBool iAutoColor;
	};

 







class TParaBorderArray
	{
public:
	TParaBorder iBorder[4];
	};

 












class TBullet
	{
	public:
	  TBullet();
	  TBool operator ==(const TBullet& aBullet) const;
	inline TBool operator !=(const TBullet& aBullet) const;

	enum TStyle
		{
		ENullStyle,					 
		EBulletStyle,
		EArabicNumberStyle,
		ESmallRomanNumberStyle,
		ECapitalRomanNumberStyle,
		ESmallLetterStyle,
		ECapitalLetterStyle
		};

	 
	enum TAlignment
		{
		 
		ELeftAlign,
		 
		ECenterAlign,
		 
		ERightAlign
		};

	 

	TChar iCharacterCode;		 
	 

	TUint iHeightInTwips;
	 
	TTypeface iTypeface;
	 

	TBool iHangingIndent;
	 

	TLogicalRgb iColor;
	TStyle iStyle;				 
	TInt iStartNumber;			 
	TAlignment iAlignment;		 
	};

 














class CParaFormat: public CBase
	{
public:
	 
	enum
		{
		 
		EMaxParaBorder = 4
		};

	 
	enum TParaBorderSide
		{
		 
		EParaBorderTop,
		 
		EParaBorderBottom,
		 
		EParaBorderLeft,
		 
		EParaBorderRight
		};

	 
	enum TLineSpacingControl
		{
		 

		ELineSpacingAtLeastInTwips,
		 
		ELineSpacingExactlyInTwips,
		 

		ELineSpacingAtLeastInPixels,
		 

		ELineSpacingExactlyInPixels
		};

	 
	enum TAlignment
		{
		 

		ELeftAlign,
		 
		ETopAlign = ELeftAlign,
		 
		ECenterAlign,
		 

		ERightAlign,
		 
		EBottomAlign = ERightAlign,
		 
		EJustifiedAlign,
		 

		EUnspecifiedAlign,
		 
		ECustomAlign,
		 
		EAbsoluteLeftAlign,
		 
		EAbsoluteRightAlign
		};

	 
	enum TParaFormatGetMode
		{
		 

		EAllAttributes,
		 
		EFixedAttributes
		};

	  static CParaFormat* NewL();
	  static CParaFormat* NewLC();
	  static CParaFormat* NewL(const CParaFormat& aFormat);
	  CParaFormat();
	  ~CParaFormat();
	  void ResetNonDestructive();   
	  void Reset();   
	  void CopyL(const CParaFormat& aFormat, const TParaFormatMask& aMask);
	  void CopyL(const CParaFormat& aFormat);
	  void Strip();   
	  TBool IsEqual(const CParaFormat& aFormat, const TParaFormatMask& aMask) const;
	  TBool IsEqual(const CParaFormat& aFormat) const;
	  void StoreTabL(const TTabStop& aTabStop);
	  void RemoveTab(TInt aTabTwipsPosition);
	inline void RemoveAllTabs();
	  const TTabStop TabStop(TInt aTabIndex) const;
	inline TInt TabCount() const;
	  TInt LocateTab(TInt aTabTwipsPosition) const;
	  void SetParaBorderL(TParaBorderSide aSide, const TParaBorder& aBorder);   
	  void RemoveAllBorders();
	  const TParaBorder ParaBorder(TParaBorderSide aSide) const;

	 


	inline TBool BordersPresent() const { return iParaBorderArray != 0L ;}
	
    inline TParaBorder* ParaBorderPtr(TParaBorderSide aSide)

	 




		{ return iParaBorderArray ? &iParaBorderArray->iBorder[aSide] : 0L ; }
	  TBool AllBordersEqual(const CParaFormat& aFormat) const;
	  TBool IsBorderEqual(TParaBorderSide aSide, const CParaFormat& aFormat) const;
private:
	CParaFormat(const CParaFormat& aFormat);
	void CreateTabListL();
	enum
		{
		ETabStoreGranularity = 2
		};

	CParaFormat& operator=(const CParaFormat& aParaFormat);	 
private:
	CArrayFixFlat<TTabStop>* iTabList;			 
	TParaBorderArray* iParaBorderArray;			 
public:
	 


	TLogicalRgb iFillColor;
	 



	TInt32 iLanguage;						
	 


	TInt32 iLeftMarginInTwips;
	 


	TInt32 iRightMarginInTwips;
	 


	TInt32 iIndentInTwips;
	 

	TAlignment iHorizontalAlignment;
	 

	TAlignment iVerticalAlignment;
	 

	TInt32 iLineSpacingInTwips;	 
	 

	TLineSpacingControl iLineSpacingControl;	 
	 
	TInt32 iSpaceBeforeInTwips;	
	 
	TInt32 iSpaceAfterInTwips;	
	 

	TBool iKeepTogether;	
	 

	TBool iKeepWithNext;	
	 

	TBool iStartNewPage;		
	 



	TBool iWidowOrphan;	
	 

	TBool iWrap;
	 

	TInt32 iBorderMarginInTwips;	
	 

	TBullet* iBullet;		
	 

	TUint32 iDefaultTabWidthInTwips;
	};

 










class TParaFormatMask
	{
public:
	inline TParaFormatMask();
	inline void SetAttrib(TTextFormatAttribute aAttribute);
	inline void ClearAttrib(TTextFormatAttribute aAttribute);
	  void SetAll();
	  void ClearAll();
	inline TBool AttribIsSet(TTextFormatAttribute aAttribute) const;
	inline TBool IsNull() const;
	  TBool operator==(const TParaFormatMask& aMask) const;
	inline TBool operator!=(const TParaFormatMask& aMask) const;

private:
	TUint32 iGuard;
	};

 








class TFontPresentation
	{
public:
		
	 
	enum TFontHighlightStyle
		{
		 
		EFontHighlightNone,
		 
		EFontHighlightNormal,
		 
		EFontHighlightRounded,
		 


		EFontHighlightShadow,
		 
		EFontHighlightNoMatchesIndicator,
		 

		EFontHighlightFirstCustomStyle = 128,
		 

		EFontHighlightLastCustomStyle = 255
		};
	
	
	 
	enum TAlignment
		{
		 

		EAlignTop,
		 

		EAlignBottom,
		 

		EAlignCentered,
		 

		EAlignBaseLine
		};
	 
	  TFontPresentation();
	 
	 
	  TBool IsEqual(const TFontPresentation& aFontPresentation, const TCharFormatMask& aMask) const;
public:
	 
	TLogicalRgb iTextColor;
	 


	TLogicalRgb iHighlightColor;   
	 
	TFontHighlightStyle iHighlightStyle;
	 
	TFontStrikethrough iStrikethrough;
	 
	TFontUnderline iUnderline;
	 



	TBool iHiddenText;
	 

	TAlignment iPictureAlignment;
	};

 












class TCharFormat
	{
public:
	  TCharFormat();
	  TCharFormat(const TDesC &aTypefaceName, TInt aHeight);
	 
	 
	  TBool IsEqual(const TCharFormat& aFormat, const TCharFormatMask& aMask) const;
	  TBool IsEqual(const TCharFormat& aFormat) const;
public:
	 





	TInt32 iLanguage;
	 
	TFontPresentation iFontPresentation; 
	 
	TFontSpec iFontSpec;  
	};

 












class TCharFormatMask
	{
public:
	inline TCharFormatMask();
	inline void SetAttrib(TTextFormatAttribute aAttribute);
	inline void ClearAttrib(TTextFormatAttribute aAttribute);
	inline TBool AttribIsSet(TTextFormatAttribute aAttribute) const;
	  void SetAll();
	  void ClearAll();
	inline TBool IsNull()const;
	  TBool operator==(const TCharFormatMask& aMask) const;
	inline TBool operator!=(const TCharFormatMask& aMask) const;

private:
	TUint32 iGuard;
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfrmat.inl" 1
 
 
 
 


TBool TTabStop::operator!=(const TTabStop& aTabStop)const
 





	{return !(*this==aTabStop);}


TBool TParaBorder::operator!=(const TParaBorder& aParaBorder)const
 





	{return !(*this==aParaBorder);}

 
TBool TBullet::operator!=(const TBullet& aBullet)const
 




	{return !(*this==aBullet);}


 
void CParaFormat::RemoveAllTabs()
 
	{
	if (iTabList)
		{
		delete iTabList;
		iTabList = 0L ;
		}
	}

 
TInt CParaFormat::TabCount()const
 



	{return (iTabList)?iTabList->Count():0;}


 

TParaFormatMask::TParaFormatMask()
	:iGuard(0)
 

	{}

 
void TParaFormatMask::SetAttrib(TTextFormatAttribute aAttribute)
 


	{iGuard|=(1<<aAttribute);}

 

void TParaFormatMask::ClearAttrib(TTextFormatAttribute aAttribute)
 


	{iGuard&=~(1<<aAttribute);}

 

TBool TParaFormatMask::AttribIsSet(TTextFormatAttribute aAttribute)const
 



	{return (iGuard&(1<<aAttribute));}

 

TBool TParaFormatMask::IsNull()const
 


	{return !iGuard;}

 
TBool TParaFormatMask::operator!=(const TParaFormatMask& aMask)const
 



	{return !(*this==aMask);}


 

TCharFormatMask::TCharFormatMask()
	:iGuard(0)
 

	{}

 

void TCharFormatMask::SetAttrib(TTextFormatAttribute aAttribute)
 


	{iGuard|=(1<<((aAttribute-KMaxParaAttributes)-1));}

 
void TCharFormatMask::ClearAttrib(TTextFormatAttribute aAttribute)
 


	{iGuard&=~(1<<((aAttribute-KMaxParaAttributes)-1));}

 

TBool TCharFormatMask::AttribIsSet(TTextFormatAttribute aAttribute)const
 



	{return iGuard&(1<<((aAttribute-KMaxParaAttributes)-1));}

 
TBool TCharFormatMask::IsNull()const
 


	{return !iGuard;}

 
TBool TCharFormatMask::operator!=(const TCharFormatMask& aMask)const
 



	{return !(*this==aMask);}


# 774 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfrmat.h" 2



# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtetext.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldset.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldinfo.h" 1
 
 
 
 








class TFindFieldInfo
 








	{
public:
	  TBool operator==(const TFindFieldInfo& aInfo)const;
	  TBool operator!=(const TFindFieldInfo& aInfo)const;
public:
	 
	TInt iFieldCountInRange;  
	 
	TInt iFirstFieldPos;  
	 
	TInt iFirstFieldLen;  
	};



# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldset.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldbase.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h" 1
 
 
 
 
# 471 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32stor.h"

# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldbase.h" 2


 
class CTextField;
class MTextFieldFactory;




class CTextField : public CBase
 












	{
public:
	  virtual TStreamId StoreL(CStreamStore& aStore)const;  
	  virtual void RestoreL(const CStreamStore& aStore,TStreamId aId);  
	 
	 
	  virtual void ExternalizeL(RWriteStream& aStream)const;  
     


	virtual void InternalizeL(RReadStream& aStream)=0;
	 
	 







	virtual TInt Value(TPtr& aValueText)=0; 
	 
	 


	virtual TUid Type()const=0;
	};


 

class MTextFieldFactory
 























	{
public:
	
	 





	virtual CTextField* NewFieldL(TUid aFieldType)=0; 
	 
	 
	};



# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldset.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldbltin.h" 1
 
 
 
 








 
class MFieldPageNumInfo;
class MFieldNumPagesInfo;
class MFieldFileNameInfo;
 
class CDateTimeField;
class CPageNumField;
class CNumPagesField;
class CFileNameField;
class TRomanNumeral;
 
 
class RReadStream;
class RWriteStream;

 

class MFieldPageNumInfo
 








	{
public:
	
	 
	 


	virtual TInt UpdateFieldPageNum()const=0;
	};


class MFieldNumPagesInfo
 








	{
public:
	
	 
	 



	virtual TInt UpdateFieldNumPages()const=0;
	};


 
class MFieldFileNameInfo
 








	{
public:
	
	 
	 







	virtual TInt UpdateFieldFileName(TPtr& aValueText)const=0;
	};


 
class CDateTimeField : public CTextField
 









	{
public:
	  CDateTimeField();
	  void SetFormat(const TDesC& aFormat);
	 
	  virtual TInt Value(TPtr& aValueText);
	  virtual void InternalizeL(RReadStream& aStream);
	  virtual void ExternalizeL(RWriteStream& aStream)const;
	 
	 
	  const TDesC& FormatString()const;
	  TUid Type()const;
protected:
	TBuf<64> iFormatString;
	};


 

class CPageFieldBase : public CTextField
 








	{





		
public:
	
 

 
	enum TNumberStyle {
		  
		EArabic,			 
		 
		ERomanUpper,		 
		 
		ERomanLower,		 
		 
		EAlphabeticUpper,	 
		 
		EAlphabeticLower	 
		};
public:
	
	 


	inline void SetNumberStyle(TNumberStyle aStyle) { iStyle = aStyle; } 
	 
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream)const;
	 
	 
	  TNumberStyle NumberStyle()const;
protected:
	TInt InsertValue(TPtr& aValueText,TInt aValue);
protected:
	TNumberStyle iStyle;
	};



class CPageNumField : public CPageFieldBase
 







	{
public:




	 




	inline void SetPageNumInfo(MFieldPageNumInfo* aInfo) { iPageNumInfo=aInfo; }
	 
	  TInt Value(TPtr& aValueText);
	  TUid Type()const;
protected:
	MFieldPageNumInfo* iPageNumInfo;
	};



class CNumPagesField : public CPageFieldBase
 







	{
public:




	
	 




	inline void SetNumPagesInfo(MFieldNumPagesInfo* aInfo) { iNumPagesInfo=aInfo; }
	 
	  TInt Value(TPtr& aValueText);
	  TUid Type()const;
protected:
	MFieldNumPagesInfo* iNumPagesInfo;
	};




class CFileNameField : public CTextField
 








	{
public:
	





	 





	inline void SetFileNameInfo(MFieldFileNameInfo* aInfo) { iFileNameInfo=aInfo; }
	 
	  virtual TStreamId StoreL(CStreamStore& aStore)const;   
	  virtual void RestoreL(const CStreamStore& aStore,TStreamId aId);  
	  virtual TInt Value(TPtr& aValueText);
	

	 

	inline virtual void InternalizeL(RReadStream&  ) {};  
	  TUid Type()const;
protected:
	MFieldFileNameInfo* iFileNameInfo;
	};



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fldset.h" 2


 
 
class CTextFieldSet;
 
 
class RReadStream;
class RWriteStream;
class TTextFieldEntry;
class CStreamStore;
class CStoreMap;
class TRollbackInfo;

 


const TInt KFieldArrayGranularity=1;


class CTextFieldSet : public CBase
 



	{
public:
	enum {ENoPasteLimit=-1};
public:
	  static CTextFieldSet* NewL(TInt aDocumentLength=0);
	  static CTextFieldSet* NewL(const MTextFieldFactory* aFactory,const CStreamStore& aStore,TStreamId aStreamId);
	  ~CTextFieldSet();
	 
	 
	  void SetFieldFactory(MTextFieldFactory* aFactory);
	  MTextFieldFactory* FieldFactory()const;
	 
	  void Reset();  
	 
	 
	  TStreamId StoreL(CStreamStore& aStore)const;
	  void RestoreL(const CStreamStore& aFieldStore,TStreamId aStreamId);
	 
	 
	  void StoreFieldsL(CStreamStore& aStore,CStoreMap& aMap)const;
	  void RestoreFieldsL(const CStreamStore& aFieldStore);
	 
	 
	  void InternalizeL(RReadStream& aStream);
	  void ExternalizeL(RWriteStream& aStream)const;
	 
	  TStreamId CopyToStoreL(CStreamStore& aStore,TInt aPos,TInt aLength)const;
	  void CopyComponentsL(CStreamStore& aStore,CStoreMap& aMap,TInt aPos,TInt aLength)const;
	  void CopyToStreamL(RWriteStream& aStream,TInt aPos,TInt aLength)const;
	  void PasteFromStoreL(const CStreamStore& aFieldStore,TStreamId aStreamId,TInt aPos,TInt aMaxLen=ENoPasteLimit);
	  void PasteComponentsL(const CStreamStore& aFieldStore,TInt aPos);
	  void PasteFromStreamL(RReadStream& aStream,TInt aPos,TInt aMaxLen=ENoPasteLimit);
	 
	  CTextField* NewFieldL(TUid aFieldType);
	  TInt InsertFieldL(TInt aPos,CTextField* aField,TUid aFieldType);  
	  TInt RemoveField(TInt aPos);  
	  TInt NewFieldValueL(HBufC*& aBuf, TInt aPos);  
	 
	  void NotifyInsertion(TInt aPos, TInt aNumberAdded);
	  void NotifyDeletion(TInt aPos, TInt aNumberRemoved);
	  void NotifyFieldUpdate(TInt aPos, TInt aNewFieldValueLength);
	 
	  TInt FieldCount() const;  
	  TInt CharCount() const;  
	  TBool FindFields(TInt aPos) const;  
	  TBool FindFields(TFindFieldInfo& aInfo,TInt aPos,TInt aRange=0) const;  
	  const CTextField* TextField(TInt aPos)const;
	 
	  void RollbackPaste();  
protected:
	CTextFieldSet();
	void ConstructL(TInt aDocumentLength);
	void ConstructL(const CStreamStore& aFieldStore,TStreamId aStreamId);
private:
	 
	void StoreFieldsL(CStreamStore& aStore,CStoreMap& aMap,CArrayFixSeg<TTextFieldEntry>* aArray)const;
	void DoRestoreL(const CStreamStore& aFieldStore,TStreamId aStreamId);
	void DoRestoreFieldsL(CArrayFixSeg<TTextFieldEntry>* aArray,const CStreamStore& aFieldStore,TInt aStartIndex=0);
	void InternalizeL(CArrayFixSeg<TTextFieldEntry>* aArray,RReadStream& aStream);
	void ExternalizeL(RWriteStream& aStream,CArrayFixSeg<TTextFieldEntry>* aArray)const;
	void DoPasteL(CArrayFixSeg<TTextFieldEntry>* aSourceArray,TInt aPos);
	 
	void AddInitialFieldEntryL(CArrayFixSeg<TTextFieldEntry>* aArray,TInt aDocumentLength);  
	void InsertEntryL(TInt aIndex,TTextFieldEntry& aEntry);  
	void InsertEntryL(TInt aIndex,TTextFieldEntry& aEntry,CArrayFixSeg<TTextFieldEntry>* aArray);
	void AppendEntryL(TTextFieldEntry& aEntry);  
	void AppendEntryL(TTextFieldEntry& aEntry,CArrayFixSeg<TTextFieldEntry>* aArray);
	void CopyToArrayL(CArrayFixSeg<TTextFieldEntry>* aArray,TInt aPos,TInt aLength)const;
	TBool InField(const TInt aPos, TInt& anIndex, TInt& anOffset) const;  
	void DeleteFieldEntry(TInt anIndex);
	void DeleteFieldEntry(CArrayFixSeg<TTextFieldEntry>* aArray,TInt anIndex);
	TTextFieldEntry SplitEntry(TInt aIndex,TInt aOffset,TInt aRange)const;
	TInt EntryLen(const TTextFieldEntry& aEntry)const;
	TInt EntryLen(TInt aIndex)const;
	 
	void RecordRollbackInfoL(TInt aPastePos);
private:
	MTextFieldFactory* iFieldFactory;
	CArrayFixSeg<TTextFieldEntry>* iFieldArray;  
	TRollbackInfo* iRollbackInfo;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};

class TFieldMapExternalizer : public MExternalizer<TStreamRef>
 




	{
private:
	friend class CPlainText;
	friend class CTextFieldSet;
private:
	  TFieldMapExternalizer(const CStoreMap& aMap);
	  void ExternalizeL(const TStreamRef& anObject,RWriteStream& aStream) const;
private:
	const CStoreMap* iMap;
	};


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtetext.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtetext.h" 2



 
class CParaFormatLayer;
class CCharFormatLayer;
class MTextFieldFactory;
class CTextFieldSet;
class CTextField;
class TFindFieldInfo;
class CInlineEditData;
class MFepInlineTextFormatRetriever;
class TCharFormat;
class CEditableTextOptionalData;
class RFs;


 



const TUid KPlainTextFieldDataUid = {268435555};
const TUid KEditableTextUid = {268450334};
const TUid KPlainTextCharacterDataUid = {268450341};
const TUid KClipboardUidTypePlainText = {268450333};

 


const TInt KMaxFieldBufferSize=0x14;

 



















class CEditableText : public CBase
	{
public:
	  ~CEditableText();
	  TStreamId StoreL(CStreamStore& aStore) const;
	  void RestoreL(const CStreamStore& aStore,TStreamId aStreamId);

	 
	virtual void ExternalizeL(RWriteStream& aStream) const;
	virtual void InternalizeL(RReadStream& aStream);
	
	 






	virtual void StoreComponentsL(CStreamStore& aStore,CStoreMap& aMap) const = 0;
	
	 



	virtual void RestoreComponentsL(const CStreamStore& aStore) = 0;

	 
	
	 

	virtual void Reset() = 0;
	
	 





	virtual void InsertL(TInt aInsertPos,const TChar& aChar) = 0;

	 





	virtual void InsertL(TInt aInsertPos,const TDesC& aBuf) = 0;
	
 	 








	virtual TBool DeleteL(TInt aPos,TInt aLength) = 0;

	 
	
	 





 
 	virtual TPtrC Read(TInt aStartPos) const = 0;

	 







	virtual TPtrC Read(TInt aStartPos,TInt aLength) const = 0;
	
	 







 
 	virtual void Extract(TDes& aBuf,TInt aPos=0) const = 0;

	 







	virtual void Extract(TDes& aBuf,TInt aPos,TInt aLength) const = 0;

	 
	 





	virtual void CopyToStoreL(CStreamStore& aStore,CStreamDictionary& aDictionary,TInt aPos,TInt aLength) const = 0;
	
	 






	virtual TInt PasteFromStoreL(const CStreamStore& aStore,const CStreamDictionary& aDictionary,TInt aPos) = 0;

	 
	 
	 


	virtual TInt WordCount() const = 0;
	
	 




	virtual TInt ParagraphCount() const = 0;
	 
	 



	virtual TInt DocumentLength() const = 0;
	
	 





	virtual TInt ToParagraphStart(TInt& aPos) const = 0;
	inline TBool HasChanged() const;
	
	 













	virtual void GetWordInfo(TInt aCurrentPos,TInt& aStartPos,TInt& aLength,
							 TBool aPictureIsDelimiter,TBool aPunctuationIsDelimiter) const = 0;

	  virtual TInt ScanWords(TInt& aPos,TUint& aScanMask) const;
	  virtual TInt ScanParas(TInt& aPos,TUint& aScanMask) const;
	  virtual void SetHasChanged(TBool aHasChanged);

	 
	  void StartFepInlineEditL(TBool& aParagraphContainingStartPositionOfInlineTextHasChangedFormat,TInt& aNumberOfCharactersSuccessfullyDeleted,TInt& aNumberOfCharactersSuccessfullyInserted,TInt& aPositionOfInsertionPointInDocument,TInt aNewPositionOfInsertionPointInDocument,const TDesC& aInitialInlineText,TInt aPositionOfInlineTextInDocument,TInt aNumberOfCharactersToHide,MFepInlineTextFormatRetriever& aInlineTextFormatRetriever);
	  void UpdateFepInlineTextL(TBool& aParagraphContainingStartPositionOfInlineTextHasChangedFormat,TInt& aNumberOfCharactersSuccessfullyDeleted,TInt& aNumberOfCharactersSuccessfullyInserted,TInt& aPositionOfInsertionPointInDocument,TInt aNewPositionOfInsertionPointInDocument,const TDesC& aNewInlineText);
	  void CommitFepInlineEditL(TBool& aParagraphContainingStartPositionOfInlineTextHasChangedFormat,TInt& aNumberOfCharactersSuccessfullyDeleted,TInt& aNumberOfCharactersSuccessfullyInserted,TInt& aPositionOfInsertionPointInDocument,TInt aNewPositionOfInsertionPointInDocument);
	  void CancelFepInlineEdit(TBool& aParagraphContainingStartPositionOfInlineTextHasChangedFormat,TInt& aNumberOfCharactersSuccessfullyDeleted,TInt& aNumberOfCharactersSuccessfullyInserted,TInt& aPositionOfInsertionPointInDocument,TInt aNewPositionOfInsertionPointInDocument);

	  virtual void Reserved_1();

	 
	enum TDocumentStorage
		{
		  
		EFlatStorage, 
		 
		ESegmentedStorage
		};
		
	 
 	enum 
		{
		 
		EDefaultTextGranularity = 256
		};

	 




	enum
		{								 
		 
		ETabCharacter = 0x0009,			 
		 
		EPageBreak = 0x000C,			 
		 
		ESpace = 0x0020,				 
		EApostrophe = 0x0027,			 
		EHyphenMinus = 0x002D,			 
		 
		ENonBreakingSpace = 0x00A0,		 
		 



		EPotentialHyphen = 0x00AD,		 
		EHyphen = 0x2010,				 
		 
		ENonBreakingHyphen = 0x2011,	 
		ELeftSingleQuote = 0x2018,		 
		ERightSingleQuote = 0x2019,		 
		ELeftDoubleQuote = 0x201C,		 
		ERightDoubleQuote = 0x201D,		 
		EBullet = 0x2022,				 
		EEllipsis = 0x2026,				 
		 
		ELineBreak = 0x2028,			 
		 
		EParagraphDelimiter = 0x2029,	 
		 
		EPictureCharacter = 0xFFFC,		 
		EZeroWidthNoBreakSpace = 0xFEFF, 
		EByteOrderMark = 0xFEFF,		 
		EReversedByteOrderMark = 0xFFFE	 
		};

protected:
	 
	  void OverrideFormatOfInlineTextIfApplicable(TPtrC& aView,TCharFormat& aFormat,TInt aStartPos) const;

	TBool iHasChanged;

private:
	void SetAndTransferOwnershipOfInlineEditDataL(CInlineEditData* aInlineEditData);
	CInlineEditData* InlineEditData() const;
	void DeleteInlineEditDataAndSetToNull();

	CEditableTextOptionalData* iOptionalData;
	};


 

 










class TEtextComponentInfo
	{
public:
	  TEtextComponentInfo();
	  TEtextComponentInfo(TInt aFieldCount,TInt aPictureCount,TInt aStyleCount);
public:
	 
	TInt iFieldCount;
	 
	TInt iPictureCount;
	 
	TInt iStyleCount;
	};

 







typedef CArrayFix<TInt> TPageTable;

 



















class CPlainText: public CEditableText
	{
public:
	 
	enum TTextOrganisation
		{
		 
		 




		EOrganiseByParagraph,
		 






		EOrganiseByLine
		};

	  
	enum
		{
		 
		EScanBackwards = 0x01,
		 

		EScanStayIfBoundary = 0x02,
		 
		EScanToUnitStart = 0x04,
		 
		EScanToUnitEnd = 0x08,
		 


		EScanJoinDelimiters = 0x10,
		 
		EScanPictureIsDelimiter = 0x20,
		 

		EScanPunctuationIsDelimiter = 0x40
		};

	
	 

	enum TScanDataEnd
		{
		 
		EScanEndOfData = -1
		};

	class TImportExportParam
	 

		{
		public:
		TImportExportParam():
			iOrganisation(EOrganiseByParagraph),
			iMaxOutputChars(KMaxTInt),
			iMaxInputChars(KMaxTInt),
			iMaxLineLength(KMaxTInt),
			iOutputInternal(0 ),
			iInputInternal(0 ),
			iForeignEncoding(0),
			iGuessForeignEncoding(0 ),
			iFileSession(0L ),
			iReserved(0)
		 

			{
			}

		 



		TTextOrganisation iOrganisation;
		 


		TInt iMaxOutputChars;
		 


		TInt iMaxInputChars;
		 




		TInt iMaxLineLength;   
		 


		TBool iOutputInternal; 
		 


		TBool iInputInternal;	
		 





		TUint iForeignEncoding;			
		 






		TBool iGuessForeignEncoding;		
		 


		RFs* iFileSession;
		TUint iReserved;
		};

 	class TImportExportResult
	 

		{
		public:
		TImportExportResult():
			iOutputChars(0),
			iInputChars(0),
			iForeignEncoding(0),
			iReserved(0)
		 
			{
			}

		 

		TInt iOutputChars;
		 

		TInt iInputChars;
		 


		TUint iForeignEncoding;				 
		TUint iReserved;		
		};
			   
	  static CPlainText* NewL(TDocumentStorage aStorage = ESegmentedStorage,
									 TInt aDefaultTextGranularity = EDefaultTextGranularity);
	  static CPlainText* NewL(const CStreamStore& aStore,TStreamId aStreamId,
									 MTextFieldFactory* aFieldFactory = 0L ,
									 TDocumentStorage aStorage = ESegmentedStorage);
	  virtual ~CPlainText();

	 
	  virtual void StoreComponentsL(CStreamStore& aStore,CStoreMap& aMap) const;
	  virtual void RestoreComponentsL(const CStreamStore& aStore);
	  virtual void ExternalizeL(RWriteStream& aStream) const;
	  virtual void InternalizeL(RReadStream& aStream);

	 
	  void ExternalizePlainTextL(RWriteStream& aStream) const;
	  void InternalizePlainTextL(RReadStream& aStream);
	  void ExternalizePlainTextNoLengthCountL(RWriteStream& aStream) const;  
	  void InternalizePlainTextL(RReadStream& aStream,TInt aLength);  

	 
	  void ImportTextL(TInt aPos,RReadStream& aInput,TTextOrganisation aTextOrganisation,
							  TInt aMaxOutputChars = KMaxTInt,TInt aMaxInputChars = KMaxTInt,
							  TInt* aOutputChars = 0L ,TInt* aInputChars = 0L );
	  void ExportTextL(TInt aPos,RWriteStream& aOutput,TTextOrganisation aTextOrganisation,
							  TInt aMaxOutputChars = KMaxTInt,TInt aMaxInputChars = KMaxTInt,
							  TInt aMaxLineLength = KMaxTInt,
							  TInt* aOutputChars = 0L ,TInt* aInputChars = 0L ) const;
	  virtual TInt ImportTextFileL(TInt aPos,const TDes& aFileName,TTextOrganisation aTextOrganisation);
	  virtual void ExportAsTextL(const TDes& aFileName,TTextOrganisation aTextOrganisation,
										TInt aMaxLineLength) const;

	 
	  void ImportTextL(TInt aPos,RReadStream& aInput,
							  const TImportExportParam& aParam,TImportExportResult& aResult);
	  void ExportTextL(TInt aPos,RWriteStream& aOutput,
							  const TImportExportParam& aParam,TImportExportResult& aResult) const;

	 
	  void StoreFieldComponentsL(CStreamStore& aStore,CStoreMap& aMap) const;
	  void RestoreFieldComponentsL(const CStreamStore& aStore);
	  void ExternalizeFieldDataL(RWriteStream& aStream) const;
	  void InternalizeFieldDataL(RReadStream& aStream);

	 
	  virtual void Reset();
	  virtual void InsertL(TInt aPos,const TChar& aChar);
	  virtual void InsertL(TInt aPos,const TDesC& aBuf);
	  virtual TBool DeleteL(TInt aPos,TInt aLength);

	 
	  virtual TPtrC Read(TInt aStartPos) const;
	  virtual TPtrC Read(TInt aStartPos,TInt aLength) const;
	  virtual void Extract(TDes& aBuf,TInt aPos=0) const;
	  virtual void Extract(TDes& aBuf,TInt aPos,TInt aLength) const;

	 
	enum
		{
		EExtractAll = 0,	 
		EExtractVisible = 1	 
		};
	  void ExtractSelectively(TDes& aBuf,TInt aPos,TInt aLength,TUint aFlags);

	 
	  virtual void CopyToStoreL(CStreamStore& aStore,CStreamDictionary& aDictionary,TInt aPos,TInt aLength) const;
	  virtual TInt PasteFromStoreL(const CStreamStore& aStore,const CStreamDictionary& aDictionary,TInt aPos);

	 
	  void SetPageTable(TPageTable* aPageTable);
	  TInt PageContainingPos(TInt aPos) const;
	  virtual TInt DocumentLength() const;
 	  virtual TInt WordCount() const;
	  virtual TInt ParagraphCount() const;
	  virtual TInt ToParagraphStart(TInt& aPos) const;
	  virtual TInt CharPosOfParagraph(TInt& aLength,TInt aParaOffset) const;
	  virtual TInt ParagraphNumberForPos(TInt& aPos) const;
	  virtual void GetWordInfo(TInt aCurrentPos,TInt& aStartPos,TInt& aLength,
						TBool aPictureIsDelimiter,TBool aPunctuationIsDelimiter) const;
	  virtual TInt ScanWords(TInt& aPos,TUint& aScanMask) const;
	  virtual TInt ScanParas(TInt& aPos,TUint& aScanMask) const;
	  virtual TEtextComponentInfo ComponentInfo() const;
	 
	 
	  void SetFieldFactory(MTextFieldFactory* aFactory);
	inline const MTextFieldFactory* FieldFactory() const;
	  CTextField* NewTextFieldL(TUid aFieldType) const;
	  void InsertFieldL(TInt aPos,CTextField* aField,TUid aFieldType); 
	  virtual void UpdateFieldL(TInt aPos); 
	  void UpdateAllFieldsL(); 
	  TInt FieldCount() const;
	  const CTextField* TextField(TInt aPos) const;
	  TBool FindFields(TInt aPos) const; 
	  TBool FindFields(TFindFieldInfo& aInfo,TInt aPos,TInt aRange=0) const;
	  TBool RemoveField(TInt aPos);  
	  TBool ConvertFieldToText(TInt aPos); 
	  void ConvertAllFieldsToText();

protected:
	  CPlainText();
	  void ConstructL(TDocumentStorage aStorage = ESegmentedStorage,
							 TInt aDefaultTextGranularity = EDefaultTextGranularity);
	  void ConstructL(const CStreamStore& aStore,TStreamId aStreamId,MTextFieldFactory* aFieldFactory,
							 TDocumentStorage aStorage = ESegmentedStorage);
	  void DoConstructL(TDocumentStorage aStorage,TInt aDefaultTextGranularity,
							   MTextFieldFactory* aFieldFactory = 0L );
	void DoExtract(TDes& aBuf,TInt aPos,TInt aLength,TUint aFlags = 0) const;
	  void PtInsertL(TInt aInsertPos,const TDesC& aBuf);
	  void DoPtInsertL(TInt aPos,const TDesC& aBuf);
	  TBool DoPtDelete(TInt aPos,TInt aLength);
	void InsertL(TInt aPos,const CPlainText* aText);
	TBool Delete(TInt aPos,TInt aLength);

	 
	  void DoExternalizeFieldDataL(RWriteStream& aStream) const;
	  void DoInternalizeFieldDataL(RReadStream& aStream);
	  void DoExternalizePlainTextL(RWriteStream& aStream) const;
	  void DoInternalizePlainTextL(RReadStream& aStream);
	TStreamId DoCopyToStoreL(CStreamStore& aStore,CStreamDictionary& aDictionary,TInt aPos,TInt aLength) const;
	TInt DoPasteFromStoreL(const CStreamStore& aStore,TStreamId aStreamId,TInt aPos);
	void CopyComponentsL(CStreamStore& aStore,CStoreMap& aMap,TInt aPos,TInt aLength) const;
	void PasteComponentsL(const CStreamStore& aStore,TInt aPos);
	void CopyToStreamL(RWriteStream& aStream,TInt aPos,TInt aLength) const;

	 
	inline static void ConsumeAdornmentL(RReadStream& aStream);
	inline static TUid UidFromStreamL(RReadStream& aStream);
protected:
	enum
		{
		EImportBufSize = 512,
		EBiggestCharacterPaste=0x100000
		};

	enum TUnitOfText
		{
		EUnitIsWord,
		EUnitIsParagraph
		};

	struct SScanData
		{
		TInt pos;			 
		TInt oldPos;		 
		TText* buf;			 
		TInt currentSegLen;  
		TInt totalBufLen;	 
		TInt delta;			 
		TUint32 scanMask;	 
		enum
			{
			EInsideUnit = 0x10000000,
			EStopEnd = 0x20000000,
			EStopBegin = 0x40000000,
			EIsDelimiter = 0x80000000
			};
		};

private:
	CPlainText(const CPlainText& aPlainTextDoc);
	CPlainText& operator=(const CPlainText& aPlainTextDoc);
	TInt PasteFromStreamL(RReadStream& aStream,TInt aPos);
	void InsertEodL();
	void InitScanControl(TInt& aPos,TUint& aScanMask,TUnitOfText aContext,SScanData& aScanData) const;
	void InitScanData(TInt aPos,SScanData& aScanData) const;
	void KillFieldSet();
	TInt CountUnits(TUnitOfText aContext) const;
	TInt ScanUnit(TInt& aPos,TUnitOfText aContext,SScanData& aScanData) const;
	TBool TestForDelimiter(TUnitOfText aContext,SScanData& aScanData) const;
	TBool GetChar(SScanData& aScanData,TChar& aChar) const;
	void UpdatePageTable(TInt aPos,TInt aLength);
	inline TBool FieldSetPresent() const;
	void CreateFieldSetL(TInt aDocumentLength);

	  void Reserved_1();			 
	  virtual void Reserved_2();	 

	void* iReserved_1;

protected:
	CBufBase* iByteStore;				 
	TSwizzle<CTextFieldSet> iFieldSet;   
	TPageTable* iPageTable;				 
	MTextFieldFactory* iFieldFactory;   

	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtetext.inl" 1
 
 
 
 


 
TBool CEditableText::HasChanged()const
 




	{return iHasChanged;}


TBool CPlainText::FieldSetPresent()const
	{return (iFieldSet.IsPtr() && iFieldSet.AsPtr()!= 0L );}


 

const MTextFieldFactory* CPlainText::FieldFactory()const
 



	{return (FieldSetPresent()) ? iFieldSet->FieldFactory() : 0L ;}


void CPlainText::ConsumeAdornmentL(RReadStream& aStream)
	{
	TStreamId id;
	aStream>> id;
	}


TUid CPlainText::UidFromStreamL(RReadStream& aStream)
	{
	TUid uid;
	aStream>> uid;
	return uid;
	}
# 710 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtetext.h" 2



# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmlaydt.h" 1
 
 
 
 











 






class CLayoutData

	{
public:
	enum
		{
		EFLargeNumber = KMaxTInt / 3,	 
		EFFontHeightIncreaseFactor = 7,	 
		EFMinimumLineDescent = 3,		 
		EFBaseLinePosition = 82			 
		};

	enum
		{
		EFHeightForFormattingAllText = EFLargeNumber,
		EFBodyWidthForNoWrapping = EFLargeNumber
		};
	
	 



	enum		
		{
		 



		EFIndividualChars = 0,
		 



		EFWholeLinesOnly = 1,
		 



		EFWholeTBoxesOnly=EFWholeLinesOnly,
		 





		EFDisambiguateEndOfLine = 2,
		};

	 
	enum TFormatMode
		{
		 
		EFScreenMode, 
		 
		EFPrintMode,
		 
		EFPrintPreviewMode, 
		 
		EFWysiwygMode
		};
private:
	 
	CLayoutData(CLayoutData&);
	};


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmparam.h" 1
 
 
 
 

 







 





















class MFormParam

	{
	public:

	 
























	virtual TRgb SystemColor(TUint aColorIndex,TRgb aDefaultColor) const = 0;
	  virtual void Reserved();
	  static void Set(const MFormParam* aParam);
	  static const MFormParam* Get();
	};


# 15 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmvis.h" 1
 
 
 
 







class RReadStream;
class RWriteStream;

 









class TNonPrintingCharVisibility

	{
private:
	enum TShowFormatChars
		{
		EFNothingVisible=0x000,
		EFTabsVisible=0x001,
		EFSpacesVisible=0x002,
		EFParagraphDelimitersVisible=0x004,
		EFLineBreaksVisible=0x008,
		EFPotentialHyphensVisible=0x010,
		EFNonBreakingHyphensVisible=0x020,
		EFNonBreakingSpacesVisible=0x040,
		EFPageBreaksVisible=0x080,
		EFEverythingVisible=0xffffffff
		};
public:
	  TNonPrintingCharVisibility();
	  TNonPrintingCharVisibility(const TNonPrintingCharVisibility& aVisibility);
	  TNonPrintingCharVisibility& operator=(const TNonPrintingCharVisibility& aVisibility);
	  void ExternalizeL(RWriteStream& aStream)const;
	  void InternalizeL(RReadStream& aStream);
	  void SetAllVisible();
	  void SetNoneVisible();
	  void SetTabsVisible(TBool aVisible);
	  void SetSpacesVisible(TBool aVisible);
	  void SetParagraphDelimitersVisible(TBool aVisible);
	  void SetLineBreaksVisible(TBool aVisible);
	  void SetPotentialHyphensVisible(TBool aVisible);
	  void SetNonBreakingHyphensVisible(TBool aVisible);
	  void SetNonBreakingSpacesVisible(TBool aVisible);
	  void SetPageBreaksVisible(TBool aVisible);

	 


	inline TBool AllVisible()const{return iVisible==EFEverythingVisible;};

	 


	inline TBool NoneVisible()const{return iVisible==EFNothingVisible;};

	 

	inline TBool TabsVisible()const{return iVisible&EFTabsVisible;};

	 




	inline TBool SpacesVisible()const{return iVisible&EFSpacesVisible;};

	 

	inline TBool ParagraphDelimitersVisible()const{return iVisible&EFParagraphDelimitersVisible;};
	
	 


	inline TBool LineBreaksVisible()const{return iVisible&EFLineBreaksVisible;};
	
	 




	inline TBool PotentialHyphensVisible()const{return iVisible&EFPotentialHyphensVisible;};
	
	 


	inline TBool NonBreakingHyphensVisible()const{return iVisible&EFNonBreakingHyphensVisible;};
	
	 

	inline TBool NonBreakingSpacesVisible()const{return iVisible&EFNonBreakingSpacesVisible;};

	 

	inline TBool PageBreaksVisible()const{return iVisible&EFPageBreaksVisible;};

private:
	TUint32 iVisible;
	};




# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmcurs.h" 1
 
 
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmconst.h" 1
 
 
 
 

 
 
 






 



const TText KVisibleParagraphBreak = 0x00B6;		 
const TText KVisibleLineBreak = 0x2193;				 
const TText KVisibleNonBreakSpace = 0x00B0;			 
const TText KVisiblePotentialHyphen = 0x00AC;		 
const TText KVisibleNonBreakHyphen = 0x007E;		 
const TText KVisibleSpace = 0x00B7;					 
const TText KVisibleTab = 0x2192;					 
const TText KVisiblePicture = 0x25A3;				 

 



const TText KZeroWidthSpace = 0x200B;
const TText KZeroWidthNoBreakSpace = 0xFEFF;

 



enum TFormPanic
	{
	EFDummy = 0,				 

	 

	 
	EFInvalidDocument = 200,	 
	EFInvalidLayout,			 
	EFBadCharacterEditType,		 
	EFInvalidJumpValue,			 

	 
	EFInvalidDocPos = 300,		 

	 
	EFLineCursorBitmapNotSet = 400,	 

	 
	EFDocumentToPaginateNotSet = 500,  
 	EFInvalidNumberCharsOnPage,	 
	EFPageListEmpty,			 

	 
	EFInvalidPageList = 600,	 
	EFInvalidPageNumber,		 

	 

	 
	EFNotEnoughFormat = 700,	 
	EFZeroHeightLine,			 
	EFSelectedRangeZeroLen,		 
	EFCursorNotInCurrentFormat,	 
	EFPixelNotInFormattedLine,	 
 	EFScrollCurtailed,			 

	 
	EFSelectionCannotCharEdit = 800,	 
	EFFormatOutOfDate,			 
	EFBackgroundFormatting,		 

	 
	EFScrollByZero1 = 900,		 
	EFScrollByZero2,			 
	EFScrollError,				 
	EFScrollDownError,			 
	EFScrollUpError,			 
	EFInvalidScrollingType,		 

	 
	EFNoMemory = 1000,			 
	EFRecoverNoMemory,			 

	 
	EFCursorOffDisplay = 1100,	 
	EFNoCursorPositionPolicy,	 
	EFPosHintInvalid,			 
	EFPositionNotFormatted,		 
	EFPositionInvalid,			 

	 
	EFSelectionNotVisible = 1200,  
 	EFPartialLineClearError,     
	EFGcNotSet,					 

	 
	EFViewNotPositionedCorrectly = 1300,  
	EFShouldNotLeave,			 
	EFIncorrectCursorMovement,	 
	EFNoPictureFrame,			 
	EFSystemConstantsChanged,	 
	};

 


void FormPanic(TFormPanic aPanic);


enum TCursorMove
 





	{
	 
	ECursNoMovement,
     
    ECursLeft,
     
    ECursRight,
     
    ECursLineUp,
     
    ECursLineDown,
     
    ECursReserved1,
    ECursReserved2,
     
    ECursLineBegin,
     
    ECursLineEnd
	};



# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmcurs.h" 2



class CTmViewAnchoredLayout;
class TTmDocPos;

 





class MCursorPositioningPolicy

	{
public:

	 


	 

	enum TDeleteType
		{
		EDeleteUndefined = 0,
		EDeleteBackspace = 1,
		EDeleteForward   = 2,

		EDeleteLast
		};
 
	 

	enum TTextChangeType
		{
		ETextChangeUndefined = 0,
		 
		ETextChangeNonLocal  = 1,
		 
		ETextChangeTyping    = 2,

		 
		 
		ETExtChangeLast
	};
 
	 



	enum TPosHint
		{
		EPosHintUndefined           = 0,
		 
		EInsertStrongL2R = 1,
		 
		EInsertStrongR2L = 2,

		 
		 
		EPosHintLast
		};

public:

	 

	 

	virtual ~MCursorPositioningPolicy() {}

	 



	virtual void SetTmLayout(CTmViewAnchoredLayout* aLayout) = 0;


	 
	
	 



	virtual const TTmDocPos& Pos() const = 0;

	 



	virtual void SetPos(const TTmDocPos& aNewPos) = 0;


	 


	virtual void PosXyL(TPoint& aXy) const = 0;

	 





	virtual void SetPosByXyL(TPoint& aNewXy) = 0;

	 




	virtual void SetPositioningHintL(TPosHint aHint) = 0;
	
	 



	virtual void SetLatentX(TInt aX) = 0;

	 



	virtual void SetLatentY(TInt aY) = 0;

	 



	virtual const TPoint& LatentXy() const = 0;

	 



	virtual void SetLatentXy(const TPoint& aXy) = 0;

	 


	virtual const TPoint& UpdateLatentXyL() = 0;


	 
	

	 




	virtual TCursorMove UpDownL(TBool aUp) = 0;

	 




	virtual TCursorMove LeftRightL(TBool aLeft) = 0;

	 




	virtual TCursorMove LineStartEndL(TBool aStart) = 0;


	 


	 


	virtual void HandleGlobalReformatL() = 0;

	 







	virtual void HandleReformatL(TInt aStart, TInt aOldEnd, 
		TInt aNewEnd, TBool aParaFormatChg, TTextChangeType aChgType) = 0;
	

	 


	 





	virtual void GetDeletePosition(TDeleteType aDelType, TInt& aStart, 
		TInt& aEnd) const = 0;
		
	 



	virtual void* ExtendedInterface(TUid aInterfaceId) = 0;

	};



# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/tagma.h" 1
 





 











# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtstyle.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfmlyr.h" 1
 
 
 
 






# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfmstm.h" 1
 
 
 
 

 







 
class RReadStream;
class RWriteStream;
class TCharFormatX;
class TCharFormatXMask;

 



class RFormatStream
	{
public:
	RFormatStream::RFormatStream();
	void CopyL(const RFormatStream& aSource);
	void ExternalizeL(RWriteStream& aStream) const;
	void InternalizeL(RReadStream& aStream);
	void Reset();
	const TUint8* Ptr(TInt& aSize) const;
	void SetParaFormatL(const CParaFormat* aDesiredFormat,const TParaFormatMask& aDesiredMask,const CParaFormat* aCurrentFormat);
	void SenseParaFormatL(CParaFormat* aParaFormat,TParaFormatMask& aMask,CParaFormat::TParaFormatGetMode aMode)const;
	void SetCharFormatL(const TCharFormatX& aCharFormat,const TCharFormatXMask& aMask);
	void SenseCharFormat(TCharFormatX& aCharFormat,TCharFormatXMask& aMask)const;
	void Swap(RFormatStream& aStream);

private:
	void AllocL(TInt aSize);
	TInt Length(TUint8*& aPtr,TTextFormatAttribute aType)const;
	TInt DoCalcSizeParaFormat(const CParaFormat* aDesiredFormat,TParaFormatMask aMask,const CParaFormat* aCurrentFormat);
	void DoSetParaFormat(const CParaFormat* aDesiredFormat,TParaFormatMask aMask,const CParaFormat* aCurrentFormat);
	void RemoveRedundantCharFormat(TCharFormatMask& aMask,const TCharFormatX& aFormat,const TCharFormatX& aEffectiveFormat);
	TInt DoCalcSizeCharFormat(const TCharFormatX& aCharFormat,const TCharFormatXMask& aMask);
	void DoStoreCharFormat(const TCharFormatX& aCharFormat,TCharFormatXMask aMask);
	TUint8* StoreBullet(TUint8* aPtr,const TBullet& aSource);
	TUint8* StoreBorder(TUint8* aPtr,TTextFormatAttribute aType,const TParaBorder& aSource);
	TUint8* StoreTab(TUint8* aPtr,const TTabStop& aSource);
	TInt StoreTabs(TUint8*& aPtr,const CParaFormat* aDesiredFormat,const CParaFormat* aCurrentFormat,TBool aStoreData);
	TInt MergeTabLists(TUint8*& aPtr,const CParaFormat* aDesiredFormat,TInt aDesiredTabCount,
					   const CParaFormat* aCurrentFormat,TInt aCurrentTabCount,TBool aStoreData);
	void StoreAllTabs(TUint8*& aPtr,const CParaFormat* aSource);
	TUint8* Store(TUint8* aPtr,const TRgb& aRgb);
	TUint8* Store(TUint8* aPtr,const TTypeface& aTypeface);
	TUint8* ReadValue(TUint8* aPtr,TRgb& aRgb)const;
	TUint8* ReadValue(TUint8* aPtr,TTypeface& aTypeface)const;
	TUint8* ReadValue(TUint8* aPtr,TParaBorder& aBorder)const;
	TUint8* ReadValue(TUint8* aPtr,TBullet& aBullet)const;
	TUint8* ReadTabL(TUint8* aPtr,CParaFormat* aTarget)const;

	TUint8* iBase;	 
	TUint8* iEnd;	 

	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
private:
	void TestInvariantL() const;
	TBool DoInvariantCheck() const;
	};


# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfmlyr.h" 2



 
class CFormatStream;  
class RReadStream;
class RWriteStream;
class TCharFormatX;

 


const TUid KNormalParagraphStyleUid={268435531};

 





























class CFormatLayer : public CBase
	{
public:
	 
	 
	  void Reset();   
	  void SetBase(const CFormatLayer* aBaseFormatLayer);   
	  const CFormatLayer* SenseBase()const;
	  TInt ChainCount()const;   
	 
	 
	

	 







	virtual void InternalizeL(RReadStream& aStream,const CFormatLayer* aBase= 0L )=0;
	
 
	 





	virtual void ExternalizeL(RWriteStream& aStream)const=0;
	 
	 
	  void InternalizeChainL(RReadStream& aStream,const CFormatLayer* aBase= 0L );
	 
	  void ExternalizeChainL(RWriteStream& aStream,TInt aExcludeCount=0)const;
	 









	virtual TBool IsIdentical(CFormatLayer* aLayer,TBool aCheckBasedOnLink=ETrue)const=0;
	  TBool IsEmpty()const;
	void Swap(CFormatLayer& aLayer);
private:
	CFormatLayer(const CFormatLayer& aFormatLayer);
	CFormatLayer& operator=(const CFormatLayer& aFormatLayer);
	virtual CFormatLayer* DoCloneL()const=0;
protected:
	CFormatLayer();
	~CFormatLayer();
	virtual CFormatLayer* RestoreNewL(RReadStream& aStream)=0;
	void ExternalizeLayersRecurseL(RWriteStream& aStream,TInt aDescendantCount)const;
	TBool IsIdentical(const TUint8* aPtr,TInt aSize)const;
	const TUint8* Ptr(TInt& aSize)const;
	void CloneLayerL(CFormatLayer* aClone)const;
protected:
	RFormatStream iStore;
	const CFormatLayer* iBasedOn;   
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


 










class CParaFormatLayer : public CFormatLayer
	{
public:
	  static CParaFormatLayer* NewL();
	  static CParaFormatLayer* NewL(const CParaFormat* aParaFormat,const TParaFormatMask& aMask);
	  static CParaFormatLayer* NewL(RReadStream& aStream);
	static CParaFormatLayer* NewL(const CParaFormatLayer* aLayer);
	static CParaFormatLayer* NewCopyBaseL(const CParaFormatLayer* aLayer);
	 
	 
	 
	 
	  virtual void InternalizeL(RReadStream& aStream,const CFormatLayer* aBase= 0L );	
	  virtual void ExternalizeL(RWriteStream& aStream)const;
	 
	 
	  void SetL(const CParaFormat* aDesiredEffectiveFormat,const TParaFormatMask& aMask);
	  void SenseEffectiveL(CParaFormat* aParaFormat,CParaFormat::TParaFormatGetMode aMode=CParaFormat::EAllAttributes)const;
	  void SenseL(CParaFormat* aParaFormat,TParaFormatMask& aMask,CParaFormat::TParaFormatGetMode aMode=CParaFormat::EAllAttributes)const;
	 
	 
	inline CParaFormatLayer* CloneL()const;
	  TBool IsIdenticalL(const CParaFormat* aParaFormat,const TParaFormatMask& aMask)const;
	  virtual TBool IsIdentical(CFormatLayer* aLayer,TBool aCheckBasedOnLink=ETrue)const;
	  virtual TUid Type()const;
	  const TUint8* Ptr(TInt& aSize)const;
private:
	 
	 
	CParaFormatLayer(const CParaFormatLayer& aParaFormatLayer);
	CParaFormatLayer& operator=(const CParaFormatLayer& aParaFormatLayer);
	  virtual CFormatLayer* DoCloneL()const;
	void FillParaFormatL(CParaFormat* aParaFormat,TParaFormatMask& aMask,CParaFormat::TParaFormatGetMode aMode)const;
	void CleanupEffectiveFormat(CParaFormat* aParaFormat,TParaFormatMask aMask)const;
	void CleanupBorders(CParaFormat* aParaFormat)const;
protected:
	CParaFormatLayer();
	virtual CFormatLayer* RestoreNewL(RReadStream& aStream);
	};

 










class CCharFormatLayer : public CFormatLayer
	{
public:
	  static CCharFormatLayer* NewL();
	  static CCharFormatLayer* NewL(const TCharFormat& aFormat,const TCharFormatMask& aMask);
	  static CCharFormatLayer* NewL(RReadStream& aStream);
	  virtual void InternalizeL(RReadStream& aStream,const CFormatLayer* aBase= 0L );	
	  virtual void ExternalizeL(RWriteStream& aStream)const;
	  void SetL(const TCharFormat& aCharFormat,const TCharFormatMask& aMask);
	  void SenseEffective(TCharFormat& aCharFormat)const;
	  void Sense(TCharFormat& aCharFormat,TCharFormatMask& aMask)const;
	inline CCharFormatLayer* CloneL()const;
	  virtual TBool IsIdentical(CFormatLayer* aLayer,TBool aCheckBasedOnLink=ETrue)const;
	  TBool IsIdentical(const TCharFormat& aCharFormat,const TCharFormatMask& aMask)const;
	  const TUint8* Ptr(TInt& aSize)const;

	 
	static CCharFormatLayer* NewL(const CCharFormatLayer* aLayer);
	static CCharFormatLayer* NewCopyBaseL(const CCharFormatLayer* aLayer);
	static CCharFormatLayer* NewL(const TCharFormatX& aFormat,const TCharFormatXMask& aMask);
	void SetL(const TCharFormatX& aCharFormat,const TCharFormatXMask& aMask);
	void SenseEffective(TCharFormatX& aCharFormat)const;
	void Sense(TCharFormatX& aCharFormat,TCharFormatXMask& aMask) const;
	
private:
	CCharFormatLayer();
	virtual CFormatLayer* RestoreNewL(RReadStream& aStream);
	virtual void FillCharFormat(TCharFormatX& aCharFormat,TCharFormatXMask& aMask)const;
	  virtual CFormatLayer* DoCloneL()const;
	};


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfmlyr.inl" 1
 
 
 
 




inline CParaFormatLayer* CParaFormatLayer::CloneL()const
 





	{return (static_cast< CParaFormatLayer* >( DoCloneL() )) ;}




inline CCharFormatLayer* CCharFormatLayer::CloneL()const
 





	{return (static_cast< CCharFormatLayer* >( DoCloneL() )) ;}
# 217 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtfmlyr.h" 2




# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtstyle.h" 2



 
class CParagraphStyle;
class CStyleTable;
 
 
class RReadStream;
class RWriteStream;

 



const TInt KMaxParagraphStyleName=0x20;


 




typedef TBuf<KMaxParagraphStyleName> TParagraphStyleName;

 


const TUid KUserDefinedParagraphStyleUid={268435535};


 
 


class RParagraphStyleInfo
 














	{
public:
	inline RParagraphStyleInfo();
	inline RParagraphStyleInfo(CParagraphStyle* aStyle,CParagraphStyle* aStyleForNextPara= 0L );
	inline void Discard();
public:
	 

	CParagraphStyle* iStyle;   
	 
	CParagraphStyle* iStyleForNextPara;   
	};




class CParagraphStyle : public CParaFormatLayer
 
 















	{
public:
	friend class CStyleList;
	friend class CRichTextIndex;
	


 

	enum TStylePasteMode
		{
	 

		EAddNewStyles,
	 



		EConvertNewStyles,
	 
		EIgnoreNewStyles
		};
	


 
	enum TApplyParaStyleMode
		{
	 


		ERetainAllSpecificFormats,
	 


		ERetainNoSpecificFormats,
	 





		ERetainSpecificParaFormat,
	 





		ERetainSpecificCharFormat
		};
public:
	 
	  static CParagraphStyle* NewL(const CParaFormatLayer& aGlobalParaFormatLayer,const CCharFormatLayer& aGlobalCharFormatLayer);
	  ~CParagraphStyle();
	 
	 
	inline CCharFormatLayer* CharFormatLayer()const;
	inline TInt OutlineLevel()const;
	inline void SetOutlineLevel(TInt aOutlineLevel);
	 
	 
	  virtual TUid Type()const;
	inline void SetType(TUid aType);
	inline CParagraphStyle* CloneL()const;
private:
	CParagraphStyle();	
	void ConstructL(const CParaFormatLayer& aGlobalParaFormatLayer,
							 const CCharFormatLayer& aGlobalCharFormatLayer);
	  virtual CFormatLayer* DoCloneL()const;
	 
	 
	static CParagraphStyle* NewL(RReadStream& aStream,const CParaFormatLayer& aGlobalParaFormatLayer,const CCharFormatLayer& aGlobalCharFormatLayer);
	virtual void InternalizeL(RReadStream& aStream,const CFormatLayer* aParaLayerBase,const CFormatLayer* aCharLayerBase);
	virtual void ExternalizeL(RWriteStream& aStream)const;
private:
	TUid iType;
	TInt iOutlineLevel;
	CCharFormatLayer* iCharFormatLayer;   
public:
	 
	TParagraphStyleName iName;
	};


 



const TInt KMaxStyleListGranularity=0x04;



class CStyleList : public CBase
 



















	{
public:
	  static CStyleList* NewL(TInt aCapacity=KMaxStyleListGranularity);
	  static CStyleList* NewL(RReadStream& aStream,
									const CParaFormatLayer* aGlobalParaFormatLayer,
									const CCharFormatLayer* aGlobalCharFormatLayer);
	  ~CStyleList();
	 
	inline const RParagraphStyleInfo& operator[](TInt aIndex)const;
	inline RParagraphStyleInfo& operator[](TInt aIndex);
	  const RParagraphStyleInfo& At(TInt aIndex)const;
	  RParagraphStyleInfo& At(TInt aIndex);
	 
	 
	  TStreamId StoreL(CStreamStore& aStore)const;
	  void ExternalizeL(RWriteStream& aStream)const;
	  void InternalizeL(RReadStream& aStream,
								const CParaFormatLayer* aGlobalParaFormatLayer,
								const CCharFormatLayer* aGlobalCharFormatLayer);
	 
	 
	  void Reset();   
	  TInt AppendL(RParagraphStyleInfo* aStyleSet);
	  void Remove(CParagraphStyle* aStyle);
	  TInt SetStyleToFollow(const RParagraphStyleInfo& aStyleSet);   
	  CStyleList* DeepCloneL()const;
	 
	 
	  RParagraphStyleInfo* PtrByName(const TParagraphStyleName& aName)const;
	  RParagraphStyleInfo* PtrByType(const TUid aType)const;
	  TInt IndexByPtr(const CParaFormatLayer* aPtr)const;
	 
	 
	  TInt IndexByName(const TDesC& aName)const;
	 
	 
	 
	inline TInt Count()const;
protected:
	  CStyleList();
	  void ConstructL(TInt aGranularity);
private:
	void KillStyleList();
private:
	CArrayFixFlat<RParagraphStyleInfo>* iList;
	public:   void __DbgTestInvariant() const; void __DbgTest(TAny *aPtr) const ;
	};


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtstyle.inl" 1
 
 
 
 

 

RParagraphStyleInfo::RParagraphStyleInfo()
	: iStyle(0L ),iStyleForNextPara(0L )
 

	{}

RParagraphStyleInfo::RParagraphStyleInfo(CParagraphStyle* aStyle,CParagraphStyle* aStyleForNextPara)
	: iStyle(aStyle),iStyleForNextPara(aStyleForNextPara)
 






	{}

 

void RParagraphStyleInfo::Discard()
 

	{delete iStyle;}


 

CCharFormatLayer* CParagraphStyle::CharFormatLayer()const
 






	{return iCharFormatLayer;}

 
TInt CParagraphStyle::OutlineLevel()const
 


	{return iOutlineLevel;}


 

void CParagraphStyle::SetOutlineLevel(TInt aOutlineLevel)
 


	{iOutlineLevel=aOutlineLevel;}


 

void CParagraphStyle::SetType(TUid aType)
 





	{iType=aType;}


 
CParagraphStyle* CParagraphStyle::CloneL()const
 



	{return (static_cast< CParagraphStyle* >( DoCloneL() )) ;}


 

const RParagraphStyleInfo& CStyleList::operator[](TInt aIndex)const
 








 








	{return iList->At(aIndex);}


RParagraphStyleInfo& CStyleList::operator[](TInt aIndex)
	{return iList->At(aIndex);}

 

TInt CStyleList::Count()const
 


	{return (iList) ? iList->Count() : 0;}
# 259 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/txtstyle.h" 2



# 19 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/tagma.h" 2


 
class TTmLineInfo;
class CTmTextImp;
class RWindow;
class RWsSession;
class RParagraphStyleInfo;
class CStyleList;
class TTmDocPosSpec;
class TTmDocPos;


 



class TTmCharFormatMask

	{
public:
	 
	enum TAttrib
		{
		EFontName = 0x1,
		EFontCoverage = 0x2,
		EBold = 0x4,
		EItalic = 0x8,
		ESerif = 0x10,
		EMonoWidth = 0x20,
		EHeight = 0x40,
		EPrintPosition = 0x80,
		ETextColor = 0x100,
		EBackgroundColor = 0x200,
		EBackground = 0x400,
		EUnderline = 0x800,
		EStrikethrough = 0x1000,
		EShadow = 0x2000,
		EUserDefinedEffects = 0x4000,
		ELanguage = 0x8000,
		EPictureAlignment = 0x10000
		};

	inline TTmCharFormatMask();
	  TTmCharFormatMask(const TCharFormatMask& aMask);
	  void GetTCharFormatMask(TCharFormatMask& aMask) const;
	inline void Clear(TAttrib aAttrib);
	inline void Set(TAttrib aAttrib);
	inline TBool IsSet(TAttrib aAttrib); 

	TUint iFlags;
	};

 






class TTmCharFormat
	{
public:
	 
	enum
		{
		EBackground = 1,	 
		ERounded = 2,		 
		EUnderline = 4,	 
		EStrikethrough = 8,	 
		EShadow = 16,	 
		 
		EUserDefinedMask = 0xFF000000,
		 

		EUserDefinedShift = 24,
		 
		ENoMatchesIndicator = 0x4000000,
		 

		ECustomDrawEffectIsExternallyDefined = 0x80000000
		};

	 
	enum TPictureAlignment
		{
		EPictureAlignBaseline,
		EPictureAlignTop,
		EPictureAlignBottom,
		EPictureAlignCenter
		};

	  TTmCharFormat();
	  TTmCharFormat(const TDesC& aFontName,TInt aFontHeight);
	  void operator=(const TCharFormat& aFormat);
	inline TTmCharFormat(const TCharFormat& aFormat);
	  void GetTCharFormat(TCharFormat& aFormat) const;
	  TBool operator==(const TTmCharFormat& aFormat) const;
	inline TBool operator!=(const TTmCharFormat& aFormat) const;

	TOpenFontSpec iFontSpec;
	TLogicalRgb iTextColor;
	TLogicalRgb iBackgroundColor;		 
	TUint iEffects;						 
										 
										 
	TUint iLanguage;					 
	TPictureAlignment iPictureAlignment; 
	TUint iTag;							 
										 
	};

 





class TTmTab

	{
public:
	 
	enum TType
		{
		EStandardTab,	 
		ECenterTab,		 
		EReverseTab		 
		};

	inline TTmTab();
	inline TTmTab(const TTabStop& aTab);
	  void operator=(const TTabStop& aTab);
	  void GetTTabStop(TTabStop& aTab) const;
	  TBool operator==(const TTmTab& aTab) const;
	inline TBool operator!=(const TTmTab& aTab) const;

	TInt iPosition;
	TType iType;
	};

 




class TTmBullet

	{
public:
	 
	enum TStyle
		{
		EBulletStyle,
		EArabicNumberStyle,
		ESmallRomanNumberStyle,
		ECapitalRomanNumberStyle,
		ESmallLetterStyle,
		ECapitalLetterStyle
		};

	 
 	enum TAlignment
		{
		 
		ELeftAlign,
		 
		ECenterAlign,
		 
		ERightAlign
		};

	  TTmBullet();
	  void operator=(const TBullet& aBullet);
	inline TTmBullet(const TBullet& aBullet);
	  void GetTBullet(TBullet& aBullet) const;
	  TBool operator==(const TTmBullet& aBullet) const;
	inline TBool operator!=(const TTmBullet& aBullet) const;

	TChar iCharacterCode;		 
	TOpenFontSpec iFontSpec;
	TBool iHangingIndent;
	TLogicalRgb iColor;
	TStyle iStyle;				 
	TInt iStartNumber;			 
	TAlignment iAlignment;		 
	};

 




class TTmParBorder

	{
public:
	 
	enum TStyle
		{
		ESolidStyle,
		EDoubleStyle,
		EDotStyle,
		EDashStyle,
		EDotDashStyle,
		EDotDotDashStyle
		};

	  TTmParBorder();
	  void operator=(const TParaBorder& aBorder);
	inline TTmParBorder(const TParaBorder& aBorder);
	  void GetTParaBorder(TParaBorder& aBorder) const;
	  TBool operator==(const TTmParBorder& aBorder) const;
	inline TBool operator!=(const TTmParBorder& aBorder) const;

	TStyle iStyle;
	TInt iWeight;
	TLogicalRgb iColor;
	TBool iAutoColor;
	};


 


	
class TTmParFormatMask

	{
public:
	 
	enum TAttrib
		{
		EAlignment = 0x1,
		EDirection = 0x2,
		EKeepTogether = 0x4,
		EKeepWithNext = 0x8,
		EStartNewPage = 0x10,
		EWidowOrphan = 0x20,
		ENoWrap = 0x40,
		EExactLineSpacing = 0x80,
		EPixelLineSpacing = 0x100,
		ELeadingMargin = 0x200,
		ETrailingMargin = 0x400,
		EFirstLineIndent = 0x800,
		ELineSpacing = 0x1000,
		ESpaceAbove = 0x2000,
		ESpaceBelow = 0x4000,
		ETabSize = 0x8000,
		EBorderMargin = 0x10000,
		ETabList = 0x20000,
		EBullet = 0x40000,
		EBorder = 0x80000
		};

	inline TTmParFormatMask();
	  TTmParFormatMask(const TParaFormatMask& aMask);
	  void GetTParaFormatMask(TParaFormatMask& aMask) const;
	inline void Clear(TAttrib aAttrib);
	inline void Set(TAttrib aAttrib);
	inline TBool IsSet(TAttrib aAttrib);

	TUint iFlags;
	};

 



class RTmParFormat

	{
public:
	 
	enum TBorderIndex
		{
		ETopBorder = 0,
		EBottomBorder = 1,
		ELeadingBorder = 2,
		ETrailingBorder = 3,
		};

	 
	enum
		{
		 
		ERightToLeft = 1,
		 
		EKeepTogether = 2,
		 
		EKeepWithNext = 4,
		 
		EStartNewPage = 8,
		 
		EWidowOrphan = 16,
		 
		ENoWrap = 32,
		 

		EExactLineSpacing = 64,
		 
		EPixelLineSpacing = 128,
		 
		EDirectionalityFromText = 256
		};

	 
	enum TAlignment
		{
		EAlignNormalBidirectional,
		EAlignNormal = EAlignNormalBidirectional,		 
		EAlignCenter,
		EAlignReverseBidirectional,
		EAlignReverse = EAlignReverseBidirectional,		 
		EAlignJustify,
		EAlignAbsoluteLeft,
		EAlignAbsoluteRight
		};

	  RTmParFormat();
	  void Close();



	  void CopyL(const RTmParFormat& aFormat);
	  void CopyL(const CParaFormat& aFormat);
	  void GetCParaFormatL(CParaFormat& aFormat) const;
	  TBool operator==(const RTmParFormat& aFormat) const;
	inline TBool operator!=(const RTmParFormat& aFormat) const;
	  TInt Tabs() const;
	inline const TTmTab& Tab(TInt aIndex) const;
	inline const TTmBullet* Bullet() const;
	inline const TTmParBorder* Border(TBorderIndex aIndex) const;
	  TBool HaveBorders() const;
	inline TBool RightToLeft() const;

	TAlignment iAlignment;
	TUint iFlags;						 
	TInt iLeadingMargin;				 
	TInt iTrailingMargin;				 
	TInt iFirstLineIndent;				 
	TInt iLineSpacing;					 
	TInt iSpaceAbove;					 
	TInt iSpaceBelow;					 
	TInt iTabSize;						 
	TInt iBorderMargin;					 
	TLogicalRgb iBackgroundColor;		 

private:
	RTmParFormat(const RTmParFormat& aFormat);	 
	void operator=(const RTmParFormat& aFormat); 

	RArray<TTmTab>* iTabList;			 
	TTmBullet* iBullet;					 
	TTmParBorder* iBorder[4];			 
	};

 










class MTmCustom

	{
public:
	class TLineHeightParam
	 


		{
	public:
		inline TLineHeightParam();

		TInt iMaxCharHeight;			 
		TInt iMaxCharDepth;				 
		TInt iMaxTopPictureHeight;		 
		TInt iMaxBottomPictureHeight;	 
		TInt iMaxCenterPictureHeight;	 
		TInt iFontMaxCharHeight;		 
		TInt iFontMaxCharDepth;			 
		TInt iFontMaxAscent;			 
		TInt iFontMaxDescent;			 
		TInt iDesiredLineHeight;		 
		TBool iExactLineHeight;			 
		};

	 






	enum
		{
		 
		EOpLineBreakClass,
		 
		EClLineBreakClass,
		 
		EQuLineBreakClass,
		 

		EGlLineBreakClass,
		 

		ENsLineBreakClass,
		 

		EExLineBreakClass,
		 

		ESyLineBreakClass,
		 

		EIsLineBreakClass,
		 
		EPrLineBreakClass,
		 
		EPoLineBreakClass,
		 
		ENuLineBreakClass,
		 
		EAlLineBreakClass,
		 
		EIdLineBreakClass,
		 
		EInLineBreakClass,
		 
		EHyLineBreakClass,
		 

		EBaLineBreakClass,
		 

		EBbLineBreakClass,
		 


		EB2LineBreakClass,
		 
		EZwLineBreakClass,
		 
		ECmLineBreakClass,
		 
		EBkLineBreakClass,
		 
		ECrLineBreakClass,
		 
		ELfLineBreakClass,
		 
		ESgLineBreakClass,
		 

		ECbLineBreakClass,

		 

		ESpLineBreakClass, 

		 

		ESaLineBreakClass,

		 


		EAiLineBreakClass,

		 
		EXxLineBreakClass,

		 
		ELineBreakClasses
		};

	  virtual TRgb SystemColor(TUint aColorIndex,TRgb aDefaultColor) const;
	  virtual TInt Stretch(TUint aChar) const;
	  virtual TUint Map(TUint aChar) const;
	  virtual void SetLineHeight(const TLineHeightParam& aParam,TInt& aAscent,TInt& aDescent) const;
	  virtual void DrawBackground(CGraphicsContext& aGc,const TPoint& aTextLayoutTopLeft,const TRect& aRect,
										 const TLogicalRgb& aBackground,TRect& aRectDrawn) const;
	  virtual void DrawLineGraphics(CGraphicsContext& aGc,const TPoint& aTextLayoutTopLeft,const TRect& aRect,
										   const TTmLineInfo& aLineInfo) const;
	  virtual void DrawText(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aRect,
								   const TTmLineInfo& aLineInfo,const TTmCharFormat& aFormat,
								   const TDesC& aText,const TPoint& aTextOrigin,TInt aExtraPixels) const;
	  virtual void DrawPicture(CGraphicsContext& aGc,
		const TPoint& aTextLayoutTopLeft, const TRect& aRect,
		MGraphicsDeviceMap& aDevice, const CPicture& aPicture) const;
	  virtual TUint LineBreakClass(TUint aCode,TUint& aRangeStart,TUint& aRangeEnd) const;
	  virtual TBool LineBreakPossible(TUint aPrevClass,TUint aNextClass,TBool aHaveSpaces) const;
	  virtual TBool GetLineBreakInContext(const TDesC& aText,TInt aMinBreakPos,TInt aMaxBreakPos,
												 TBool aForwards,TInt& aBreakPos) const;
	  virtual TBool IsHangingCharacter(TUint aChar) const;

	 
	  void SetPenColor(CGraphicsContext& aGc,TLogicalRgb aColor) const;
	  void SetBrushColor(CGraphicsContext& aGc,TLogicalRgb aColor) const;
	  TRgb SystemColor(TLogicalRgb aColor) const;
	};

 


const TUid KFormLabelApiExtensionUid = { 0x101FD03C};

 






class MTmSource: public MTmCustom

	{
public:
	 
	enum TLabelType
		{
		 
		ENoLabel,

		 
		EParLabel
		};

	enum
		{
		 



		ELineBreakContext = 32
		};

	 
	
	 
	virtual MGraphicsDeviceMap& FormatDevice() const = 0;

	 




	virtual MGraphicsDeviceMap& InterpretDevice() const = 0;

	 
	virtual TInt DocumentLength() const = 0;

	 



	virtual void GetText(TInt aPos,TPtrC& aText,TTmCharFormat& aFormat) const = 0;

	 



	virtual void GetParagraphFormatL(TInt aPos,RTmParFormat& aFormat) const = 0;

	 



	virtual TInt ParagraphStart(TInt aPos) const = 0;

	 
	  virtual CPicture* PictureL(TInt aPos) const;
	  virtual TInt GetPictureSizeInTwipsL(TInt aPos,TSize& aSize) const;
	  virtual TAny* GetExtendedInterface(const TUid& aInterfaceId);
	  virtual void MTmSource_Reserved_1();
	  virtual void MTmSource_Reserved_2();
	  virtual TBool PageBreakInRange(TInt aStartPos,TInt aEndPos) const;

	 
	  TInt ParagraphEnd(TInt aPos) const;
	  TBool GetLineBreakL(const TDesC& aText,TInt aDocPos,TInt aMinBreakPos,TInt aMaxBreakPos,TBool aForwards,
								 TInt& aBreakPos,TInt& aHangingChars,TInt& aBreakPosAfterSpaces) const;
	  static void GetStandardLineBreak(const TDesC& aText,TInt aMinBreakPos,TInt aMaxBreakPos,
											  TInt& aBreakPos,TInt& aNextLineStart);
	};

 







class MFormLabelApi
	{
public:
	  virtual TBool LabelModeSelect(MTmSource::TLabelType aType, TInt aPos);
	  virtual void LabelModeCancel();
	  virtual void LabelMetrics(MTmSource::TLabelType aType, TSize& aLabelSize, TInt& aMarginSize) const;
	};

 


class CTmBufSeg: public CBufSeg
	{
public:
	inline CTmBufSeg(TInt aExpandSize);
	TInt MemoryUsed() const;
	};

 
class CTmCode: public CBase
	{
public:
	inline ~CTmCode();
	void InsertByteL(TUint8 aByte,TInt aPos);
	TInt InsertNumberL(TInt aNumber,TInt aPos);
	TInt InsertRectL(const TRect& aRect,TInt aPos);
	void AppendByteL(TUint8 aByte);
	TInt AppendNumberL(TInt aNumber);
	TInt AppendRectL(const TRect& aRect);
	void ChangeL(TInt aStart,TInt aEnd,CTmCode& aNewCode);
	TInt MemoryUsed() const;
	TInt Size() const;
	void Delete(TInt aPos,TInt aLength);
	void Reset();
	inline TPtr8 Ptr(TInt aPos);
	void CreateBufferL();
	inline CBufBase* Buffer();
	inline const CBufBase* Buffer() const;

private:
	enum
		{
		EExpandSize = 512
		};
	TInt WriteNumber(TInt aNumber,TUint8* aBuffer);

	CTmBufSeg* iBuffer;
	};

 



class TTmFormatParamBase

	{
public:
	enum
		{
		EWrap = 1,							 
		EAtLeastMaxHeight = 2,				 
		ETruncateWithEllipsis = 4,			 
		ELegalLineBreaksOnly = 8			 
											 
		};

	  TTmFormatParamBase();
	inline TBool IsWrapping() const;
	inline TBool IsTruncatingWithEllipsis() const;
	inline TBool LegalLineBreaksOnly() const;

	TInt iWrapWidth;					 
	TInt iMaxHeight;					 
	TInt iMaxLines;						 
	TInt iFlags;						 
	TChar iEllipsis;					 
	};

 




class TTmFormatParam: public TTmFormatParamBase

	{
public:
	  TTmFormatParam();
	  TTmFormatParam(const TTmFormatParamBase& aBase);

	TInt iStartChar;					 
	TInt iEndChar;						 
	TInt iLineInPar;					 
	};

 



class TTmReformatParam

	{
public:
	  TTmReformatParam();

	TInt iStartChar;					 
	TInt iOldLength;					 
	TInt iNewLength;					 
	TInt iMaxExtraLines;				 
										 
	TBool iParFormatChanged;			 
	TBool iParInvalid;					 
	};

 



class TTmReformatResult

	{
public:
	  TTmReformatResult();

	TRect iRedrawRect;					 
	TInt iHeightChange;					 
	TInt iUnchangedTop;					 
										 
	TInt iUnformattedStart;				 
	};

 








class TTmLineInfo

	{
public:
	 
	enum
		{
		EParStart = 1,
		EParEnd = 2,
		EParRightToLeft = 4,
		ELineEndsInForcedLineBreak = 8
		};

	inline TTmLineInfo();

	TRect iOuterRect;	 
	TRect iInnerRect;	 
	TInt iBaseline;		 
	TInt iStart;		 
	TInt iEnd;			 
	TInt iLineNumber;	 
	TInt iParNumber;	 
	TInt iLineInPar;	 
	TInt iParTop;		 
	TUint iFlags;		 
	};

 

















class TTmDocPosSpec

	{
public:
	 


	enum TType
		{
		ETrailing,
		ELeading,
		ELeftToRight,
		ERightToLeft
		};

	inline TTmDocPosSpec();
	inline TTmDocPosSpec(TInt aPos,TType aType);
	inline TTmDocPosSpec(const TTmDocPos& aRawDocPos);

	TInt iPos;		 
	TType iType;	 
	};

 








class TTmDocPos

	{
public:
	inline TTmDocPos();
	inline TTmDocPos(TInt aPos,TBool aLeadingEdge);
	  TBool operator==(const TTmDocPos& aPos) const;
	inline TBool operator!=(const TTmDocPos& aPos) const;
	  TBool operator>(const TTmDocPos& aPos) const;
	  TBool operator>=(const TTmDocPos& aPos) const;
	inline TBool operator<(const TTmDocPos& aPos) const;
	inline TBool operator<=(const TTmDocPos& aPos) const;

	TInt iPos;			 
	TBool iLeadingEdge;	 
	};

 


	
class TTmPosInfo2

	{
public:
	 
	TTmDocPos iDocPos;
	 
	TBool iRightToLeft;
	 
	TPoint iEdge;
	};

 




class TTmPosInfo

	{
public:
	TTmPosInfo() {}
	TTmPosInfo(const TTmPosInfo2& a) : iDocPos(a.iDocPos), iEdge(a.iEdge) {}
	TTmDocPos iDocPos;	 
	TPoint iEdge;			 
	};

 


class TTmHighlightExtensions

	{
public:
	inline TTmHighlightExtensions();
	inline void SetAll(TInt aExtension);
	inline void SetLeftExtension(TInt aExtension);
	inline void SetRightExtension(TInt aExtension);
	inline void SetTopExtension(TInt aExtension);
	inline void SetBottomExtension(TInt aExtension);
	inline TInt LeftExtension() const;
	inline TInt RightExtension() const;
	inline TInt TopExtension() const;
	inline TInt BottomExtension() const;
	inline TBool Extends() const;
	inline void ExtendRect(TRect& aRect) const;
	inline void AdjustRect(TRect& aRect) const;
public:
	TInt iLeftExtension;
	TInt iRightExtension;
	TInt iTopExtension;
	TInt iBottomExtension;
	};

 




enum TTmCursorPlacement
	{
	  


	ECursorVertical,		
	 

	ECursorUnderlineNext,
	 

	ECursorUnderlinePrev
	};

 






























class CTmTextLayout: public CBase

	{
public:
	
	class TTmChunkDescription
	 




		{
	public:
		 

		TInt iStart;
		 
		TInt iEnd;
		 
		TBool iRightToLeft;
		};

	  CTmTextLayout();
	  ~CTmTextLayout();
	  void SetTextL(MTmSource& aSource,const TTmFormatParam& aParam);
	  void FormatL(const TTmFormatParamBase& aParam,const TTmReformatParam& aReformatParam,
						  TTmReformatResult& TTmReformatResult);
	  TBool AddParL(const TTmFormatParamBase& aParam,TBool aAtStart,TInt& aHeightIncrease,TInt& aParagraphsIncrease);
	  TBool DeletePar(const TTmFormatParamBase& aParam,TBool aAtStart,TInt aMaxDeletedHeight,TInt& aHeightDecrease);
	  void Clear();
	  void DrawLayout(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,
							 const TLogicalRgb* aDocBackground,TBool aDrawParBackground) const;
	  void DrawBackground(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,
								 const TLogicalRgb& aBackground) const;
	  void InvertLayout(CGraphicsContext& aGc, const TPoint& aTopLeft,
		TInt aStartDocPos, TInt aEndDocPos) const;
	  void HighlightSection(CGraphicsContext& aGc, const TPoint& aTopLeft,
		TInt aStartDocPos, TInt aEndDocPos, const TRect& aClipRect) const;
	  void DrawSection(CGraphicsContext& aGc, const TPoint& aTopLeft,
		TInt aStartDocPos, TInt aEndDocPos, const TRect& aClipRect) const;
	  void HighlightSection(CGraphicsContext& aGc, const TPoint& aTopLeft,
		TInt aStartDocPos, TInt aEndDocPos, const TRect& aClipRect, const TTmHighlightExtensions& aHighlightExtensions,
		TInt aHighlightStartDocPos, TInt aHighlightEndDocPos) const;
	  void InvertLayout(CGraphicsContext& aGc,
		const TPoint& aTopLeft, TInt aStartDocPos,TInt aEndDocPos, const TTmHighlightExtensions& aHighlightExtensions,
		TInt aHighlightStartDocPos, TInt aHighlightEndDocPos) const;
	  void DrawSection(CGraphicsContext& aGc, const TPoint& aTopLeft,
		TInt aStartDocPos, TInt aEndDocPos, const TRect& aClipRect, const TTmHighlightExtensions& aHighlightExtensions,
		TInt aHighlightStartDocPos, TInt aHighlightEndDocPos) const;
	  TBool FindDocPos(const TTmDocPosSpec& aDocPos,TTmPosInfo2& aPosInfo,TTmLineInfo& aLineInfo) const;
	  TBool FindXyPos(const TPoint& aXyPos,TTmPosInfo2& aPosInfo,TTmLineInfo& aLineInfo) const;
	  TBool FindXyPosWithDisambiguation(const TPoint& aXyPos,
		TTmPosInfo2& aPosLeft, TTmPosInfo2& aPosRight,
		TTmLineInfo& aLineInfo) const;
	  TInt FindNextPos(TInt aStart) const;
	  TInt FindPreviousPos(TInt aStart) const;
	  TInt Lines() const;
	  TInt Paragraphs() const;
	  TBool DocPosToLine(const TTmDocPosSpec& aDocPos,TTmLineInfo& aLineInfo) const;
	  TBool LineNumberToLine(TInt aLineNumber,TTmLineInfo& aLineInfo) const;
	  TBool ParNumberToLine(TInt aParNumber,TInt aLineInPar,TTmLineInfo& aLineInfo) const;
	  TBool YPosToLine(TInt aYPos,TTmLineInfo& aLineInfo) const;
	  TBool GetDisplayedTextL(TInt aLineNumber,TDes& aText,TInt& aNeeded) const;
	  void GetMinimumLayoutSizeL(TInt aWrapWidth,TSize& aSize) const;
	  TInt WidthOfWidestLine(TInt aTop = 0,TInt aBottom = KMaxTInt) const;
	  void HorizontalExtremes(TInt &aLeft, TInt &aRight,
		TInt aTopY = 0, TInt aBottomY = KMaxTInt) const;
	  TBool GetNextVisualCursorPos(const TTmDocPosSpec& aDocPos,TTmPosInfo2& aInfo,TBool aToLeft) const;
	  TBool GetNextPosLeftWithDisambiguation(const TTmDocPosSpec& aDocPos,
		TTmPosInfo2& aPosLeft, TTmPosInfo2& aPosRight) const;
	  TBool GetNextPosRightWithDisambiguation(const TTmDocPosSpec& aDocPos,
		TTmPosInfo2& aPosLeft, TTmPosInfo2& aPosRight) const;
	  TBool LineExtreme(const TTmDocPosSpec& aPos, TBool aToRight,
		TTmDocPos& aExtreme) const;
	  TBool FindAdjacentChunks(const TTmDocPosSpec& aPos,
		TTmChunkDescription& aLeft, TTmChunkDescription& aRight) const;
	  TBool GetCursor(const TTmDocPosSpec& aDocPos,TTmCursorPlacement aPlacement,
							 TTmLineInfo& aLineInfo,TPoint& aOrigin,TInt& aWidth,TInt& aAscent,TInt& aDescent) const;
	  TInt MemoryUsed() const;
	inline TInt StartChar() const;
	inline TInt EndChar() const;
	inline TInt LayoutWidth() const;
	inline TInt LayoutHeight() const;
	inline MTmSource* Source();
	inline const MTmSource* Source() const;
	inline const CTmCode& Code() const;

	 
	 
	  TBool GetDisplayedText(TInt aLineNumber,TDes& aText,TInt& aNeeded) const;
	 
	  TBool FindDocPos(const TTmDocPos& aDocPos,TTmPosInfo& aPosInfo,TTmLineInfo& aLineInfo) const;
	 
	  TBool FindXyPos(const TPoint& aXyPos,TTmPosInfo& aPosInfo,TTmLineInfo& aLineInfo) const;
	 
	  TBool GetNextVisualCursorPos(const TTmDocPos& aDocPos,TTmPosInfo& aInfo,TBool aToLeft) const;
	 
	  TBool DocPosToLine(const TTmDocPos& aDocPos,TTmLineInfo& aLineInfo) const;
	 
	  TBool GetCursor(const TTmDocPos& aDocPos,
		TTmCursorPlacement aPlacement, TTmLineInfo& aLineInfo,
		TPoint& aOrigin, TInt& aWidth, TInt& aAscent, TInt& aDescent) const;
private:



	void Invariant() const { }

	void AdjustWidth(const TTmFormatParamBase& aParam,TInt aWidthOfNewText);
	void HighlightRect(CGraphicsContext& aGc, const TPoint& aTopLeft, const TRect& aClipRect, const TTmHighlightExtensions& aHighlightExtensions, const TRect& aRect) const;
	void InvertLayout(CGraphicsContext& aGc, const TPoint& aTopLeft, const TRect& aClipRect, const TTmHighlightExtensions& aHighlightExtensions, TInt aStartDocPos,TInt aEndDocPos, TInt aHighlightStartDocPos, TInt aHighlightEndDocPos) const;
	void InvertRect(CGraphicsContext& aGc, const TPoint& aTopLeft, const TTmHighlightExtensions& aHighlightExtensions, const TRect& aInvertRect,TInt aOriginalHighlightStartPos,TInt aOriginalHighlightEndPos, TInt aNewHighlightStartPos,TInt aNewHighlightEndPos) const;
	TBool FindOverlapRect(const TPoint& aTopLeft, const TTmHighlightExtensions& aHighlightExtensions, const TRect& aRect, TInt aHighlightStartPos,TInt aHighlightEndPos, TRect& aOverlapRect) const;
	void DrawRect(CGraphicsContext& aGc, const TPoint& aTopLeft, const TRect& aClipRect, const TTmHighlightExtensions& aHighlightExtensions, const TRect& aRect) const;
	void DrawRectExcludingHighlight(CGraphicsContext& aGc, const TPoint& aTopLeft, const TRect& aClipRect, const TTmHighlightExtensions& aHighlightExtensions, TInt aHighlightStartPos,TInt aHighlightEndPos, const TRect& aRect) const;

	MTmSource* iSource;				 
	CTmCode iCode;					 
	TInt iWidth;					 
	TInt iHeight;					 
	TInt iStartChar;				 
	TInt iEndChar;					 
	};

 














class MTmTextLayoutForwarder

	{
public:
	  void DrawLayout(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,
							 const TLogicalRgb* aDocBackground,TBool aDrawParBackground) const;
	  void DrawBackground(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,
								 const TLogicalRgb& aBackground) const;
	  void InvertLayout(CGraphicsContext& aGc,const TPoint& aTopLeft,TInt aStartDocPos,TInt aEndDocPos);
	  TBool FindDocPos(const TTmDocPosSpec& aDocPos,TTmPosInfo2& aPosInfo,TTmLineInfo& aLineInfo) const;
	  TBool FindXyPos(const TPoint& aXyPos,TTmPosInfo2& aPosInfo,TTmLineInfo& aLineInfo) const;
	  TBool FindXyPosWithDisambiguation(const TPoint& aXyPos,
		TTmPosInfo2& aPosLeft, TTmPosInfo2& aPosRight,
		TTmLineInfo& aLineInfo) const;
	  TBool DocPosToLine(const TTmDocPosSpec& aDocPos,TTmLineInfo& aLineInfo) const;
	  TBool LineNumberToLine(TInt aLineNumber,TTmLineInfo& aLineInfo) const;
	  TBool ParNumberToLine(TInt aParNumber,TInt aLineInPar,TTmLineInfo& aLineInfo) const;
	  TBool YPosToLine(TInt aYPos,TTmLineInfo& aLineInfo) const;
	  TInt WidthOfWidestLine(TInt aTop = 0,TInt aBottom = KMaxTInt) const;
	  void HorizontalExtremes(TInt &aLeft, TInt &aRight,
		TInt aTopY = 0, TInt aBottomY = KMaxTInt) const;
	  TBool GetNextVisualCursorPos(const TTmDocPosSpec& aDocPos,TTmPosInfo2& aInfo,TBool aToLeft) const;
	  TBool GetNextPosLeftWithDisambiguation(const TTmDocPosSpec& aDocPos,
		TTmPosInfo2& aPosLeft, TTmPosInfo2& aPosRight) const;
	  TBool GetNextPosRightWithDisambiguation(const TTmDocPosSpec& aDocPos,
		TTmPosInfo2& aPosLeft, TTmPosInfo2& aPosRight) const;
	  TBool GetCursor(const TTmDocPosSpec& aDocPos,TTmCursorPlacement aPlacement,
							 TTmLineInfo& aLineInfo,TPoint& aOrigin,TInt& aWidth,TInt& aAscent,TInt& aDescent) const;

	  TInt Lines() const;
	  TInt Paragraphs() const;
	  TBool GetDisplayedText(TInt aLineNumber,TDes& aText,TInt& aNeeded) const;
	  void GetMinimumLayoutSizeL(TInt aWrapWidth,TSize& aSize) const;
	  TInt StartChar() const;
	  TInt EndChar() const;
	  TInt LayoutWidth() const;
	  TInt LayoutHeight() const;

	 
	 
	  TBool FindDocPos(const TTmDocPos& aDocPos,TTmPosInfo& aPosInfo,TTmLineInfo& aLineInfo) const;
	 
	  TBool FindXyPos(const TPoint& aXyPos,TTmPosInfo& aPosInfo,TTmLineInfo& aLineInfo) const;
	 
	  TBool DocPosToLine(const TTmDocPos& aDocPos,TTmLineInfo& aLineInfo) const;
	 
	  TBool GetNextVisualCursorPos(const TTmDocPos& aDocPos,TTmPosInfo& aInfo,TBool aToLeft) const;
	 
	  TBool GetCursor(const TTmDocPos& aDocPos,
		TTmCursorPlacement aPlacement, TTmLineInfo& aLineInfo,
		TPoint& aOrigin, TInt& aWidth, TInt& aAscent, TInt& aDescent) const;
private:
	 

	virtual const CTmTextLayout& TextLayout() const = 0;
	
	 

	  virtual void GetOrigin(TPoint& aPoint) const;

	void FixUpLineInfo(TTmLineInfo& aInfo,const TPoint* aOrigin = 0L ) const;
	};

 


	
class TTmCharFormatLayer

	{
public:
	inline TTmCharFormatLayer();
	  TTmCharFormatLayer(const CCharFormatLayer& aFormat);

	TTmCharFormat iFormat;
	TTmCharFormatMask iMask;
	};

 



class RTmParFormatLayer

	{
public:
	inline void Close();
	  void CopyL(const CParaFormatLayer& aFormat);

	RTmParFormat iFormat;
	TTmParFormatMask iMask;
	};

 



class RTmStyle

	{
public:
	enum
		{
		EMaxName = KMaxParagraphStyleName
		};

	inline void Close();
	  void CopyL(const RParagraphStyleInfo& aStyle);
	  void GetRParagraphStyleInfoL(RParagraphStyleInfo& aStyle,
		const CParaFormatLayer& aGlobalParaFormatLayer,const CCharFormatLayer& aGlobalCharFormatLayer,
		const CStyleList& aList) const;

	TBuf<KMaxName> iName;
	TBuf<KMaxName> iNextStyleName;
	TTmCharFormatLayer iCharFormat;
	RTmParFormatLayer iParFormat;
	TInt iOutlineLevel;
	};

 





class CTmText: public CBase, public MTmTextLayoutForwarder

	{
public:
	  static CTmText* NewL(MGraphicsDeviceMap* aDevice = 0L ,const TTmFormatParamBase* aFormatParam = 0L );
	  static CTmText* NewL(MGraphicsDeviceMap& aDevice,const TTmFormatParamBase& aFormatParam);
	  static CTmText* NewL(MGraphicsDeviceMap& aDevice,TInt aWrapWidth,TInt aFlags);
	  ~CTmText();
	  void InsertL(TInt aPos,const TDesC& aText,
						  const TTmCharFormat* aCharFormat = 0L ,const RTmParFormat* aParFormat = 0L ,
						  TRect* aRedrawRect = 0L ,TInt* aScroll = 0L );
	  void GetFormat(TTmFormatParamBase& aFormatParam) const;
	  void SetWrapWidthL(TInt aWrapWidth);
	  void ChangeFormatL(const TTmFormatParamBase& aFormatParam);
	  void Clear();
	  void CustomizeL(const MTmCustom* aCustom);
	  TInt MemoryUsed() const;
	inline void Draw(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,
					 const TLogicalRgb* aDocBackground,TBool aDrawParBackground);

private:
	CTmText();
	  void Spare1();

	 
	const CTmTextLayout& TextLayout() const;

	CTmTextImp* iImp;		 
	};

 
 
TTmCharFormatMask::TTmCharFormatMask(): iFlags(0xFFFFFFFF)
	{
	}

 
void TTmCharFormatMask::Clear(TAttrib aAttrib)
	{
	iFlags &= ~aAttrib;
	}

 
void TTmCharFormatMask::Set(TAttrib aAttrib)
	{
	iFlags |= aAttrib;
	}

 
TBool TTmCharFormatMask::IsSet(TAttrib aAttrib)
	{
	return iFlags & aAttrib;
	}

 
TTmCharFormat::TTmCharFormat(const TCharFormat& aFormat)
	{
	*this = aFormat;
	}

 
TBool TTmCharFormat::operator!=(const TTmCharFormat& aFormat) const
	{
	return !operator==(aFormat);
	}

 
TTmTab::TTmTab():
	iPosition(0),
	iType(EStandardTab)
	{
	}

 
TTmTab::TTmTab(const TTabStop& aTab)
	{
	*this = aTab;
	}

 

TBool TTmTab::operator!=(const TTmTab& aTab) const
	{
	return !operator==(aTab);
	}

 
TTmBullet::TTmBullet(const TBullet& aBullet)
	{
	*this = aBullet;
	}

 

TBool TTmBullet::operator!=(const TTmBullet& aBullet) const
	{
	return !operator==(aBullet);
	}

 
TTmParBorder::TTmParBorder(const TParaBorder& aBorder)
	{
	*this = aBorder;
	}

 

TBool TTmParBorder::operator!=(const TTmParBorder& aBorder) const
	{
	return !operator==(aBorder);
	}

 
TTmParFormatMask::TTmParFormatMask():
	iFlags(0xFFFFFFFF)
	{
	}

 
void TTmParFormatMask::Clear(TAttrib aAttrib)
	{
	iFlags &= ~aAttrib;
	}

 
void TTmParFormatMask::Set(TAttrib aAttrib)
	{
	iFlags |= aAttrib;
	}

 


TBool TTmParFormatMask::IsSet(TAttrib aAttrib)
	{
	return iFlags & aAttrib;
	}








 


TBool RTmParFormat::operator!=(const RTmParFormat& aFormat) const
	{
	return !operator==(aFormat);
	}

 
const TTmTab& RTmParFormat::Tab(TInt aIndex) const
	{
	return (*iTabList)[aIndex];
	}

 

const TTmBullet* RTmParFormat::Bullet() const
	{
	return iBullet;
	}

 

const TTmParBorder* RTmParFormat::Border(TBorderIndex aIndex) const
	{
	return iBorder[aIndex];
	}

 
TBool RTmParFormat::RightToLeft() const
	{
	return iFlags & ERightToLeft;
	}

 

MTmCustom::TLineHeightParam::TLineHeightParam()
	{
	Mem::FillZ(this,sizeof(*this));
	}

CTmBufSeg::CTmBufSeg(TInt aExpandSize):
	CBufSeg(aExpandSize)
	{
	}

CTmCode::~CTmCode()
	{
	delete iBuffer;
	}

TPtr8 CTmCode::Ptr(TInt aPos)
	{
	return iBuffer->Ptr(aPos);
	}

CBufBase* CTmCode::Buffer()
	{
	return iBuffer;
	}

const CBufBase* CTmCode::Buffer() const
	{
	return iBuffer;
	}

 
TBool TTmFormatParamBase::IsWrapping() const
	{
	return iFlags & EWrap;
	}

 
TBool TTmFormatParamBase::IsTruncatingWithEllipsis() const
	{
	return iFlags & ETruncateWithEllipsis;
	}

 

TBool TTmFormatParamBase::LegalLineBreaksOnly() const
	{
	return iFlags & ELegalLineBreaksOnly;
	}

 
TTmLineInfo::TTmLineInfo()
	{
	Mem::FillZ(this,sizeof(*this));
	}

 





TTmDocPos::TTmDocPos():
	iPos(0),
	iLeadingEdge(0 )
	{
	}

 


TTmDocPos::TTmDocPos(TInt aPos,TBool aLeadingEdge):
	iPos(aPos),
	iLeadingEdge(aLeadingEdge)
	{
	}

 

TTmDocPosSpec::TTmDocPosSpec():
	iPos(0),
	iType(ETrailing)
	{
	}

TBool TTmDocPos::operator!=(const TTmDocPos& aPos) const { return !((*this)==aPos); }
TBool TTmDocPos::operator<(const TTmDocPos& aPos) const { return !((*this)>=aPos); }
TBool TTmDocPos::operator<=(const TTmDocPos& aPos) const { return !((*this)>aPos); }

 


TTmDocPosSpec::TTmDocPosSpec(TInt aPos,TType aType):
	iPos(aPos),
	iType(aType)
	{
	}

 
TTmDocPosSpec::TTmDocPosSpec(const TTmDocPos& aDocPos):
	iPos(aDocPos.iPos),
	iType(aDocPos.iLeadingEdge ? ELeading : ETrailing)
	{
	}

 
TInt CTmTextLayout::StartChar() const
	{
	return iStartChar;
	}

 
TInt CTmTextLayout::EndChar() const
	{
	return iEndChar;
	}

 

TInt CTmTextLayout::LayoutWidth() const
	{
	return iWidth;
	}

 
TInt CTmTextLayout::LayoutHeight() const
	{
	return iHeight;
	}

 

MTmSource* CTmTextLayout::Source()
	{
	return iSource;
	}

const MTmSource* CTmTextLayout::Source() const
	{
	return iSource;
	}

 




const CTmCode& CTmTextLayout::Code() const
	{
	return iCode;
	}

 

TTmCharFormatLayer::TTmCharFormatLayer()
	{
	}

 

void RTmParFormatLayer::Close()
	{
	iFormat.Close();
	}

 

void RTmStyle::Close()
	{
	iParFormat.Close();
	}

 



void CTmText::Draw(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,
				   const TLogicalRgb* aDocBackground,TBool aDrawParBackground)
	{
	DrawLayout(aGc,aTopLeft,aClipRect,aDocBackground,aDrawParBackground);
	}


TTmHighlightExtensions::TTmHighlightExtensions()
	{
	}

void TTmHighlightExtensions::SetAll(TInt aExtension)
	{
	iLeftExtension=iRightExtension=iTopExtension=iBottomExtension=aExtension;
	}

void TTmHighlightExtensions::SetLeftExtension(TInt aExtension)
	{
	iLeftExtension=aExtension;
	}

void TTmHighlightExtensions::SetRightExtension(TInt aExtension)
	{
	iRightExtension=aExtension;
	}

void TTmHighlightExtensions::SetTopExtension(TInt aExtension)
	{
	iTopExtension=aExtension;
	}

void TTmHighlightExtensions::SetBottomExtension(TInt aExtension)
	{
	iBottomExtension=aExtension;
	}

TInt TTmHighlightExtensions::LeftExtension() const
	{
	return iLeftExtension;
	}

TInt TTmHighlightExtensions::RightExtension() const
	{
	return iRightExtension;
	}

TInt TTmHighlightExtensions::TopExtension() const
	{
	return iTopExtension;
	}

TInt TTmHighlightExtensions::BottomExtension() const
	{
	return iBottomExtension;
	}

TBool TTmHighlightExtensions::Extends() const
	{
	if (iTopExtension>0 || iBottomExtension>0 || iLeftExtension>0 || iRightExtension>0)
		return ETrue;
	else
		return EFalse;
	}

inline void TTmHighlightExtensions::ExtendRect(TRect& aRect) const
	{
	if (iLeftExtension>0)
		aRect.iTl.iX-=iLeftExtension;
	if (iRightExtension>0)
		aRect.iBr.iX+=iRightExtension;
	if (iTopExtension>0)
		aRect.iTl.iY-=iTopExtension;
	if (iBottomExtension>0)
		aRect.iBr.iY+=iBottomExtension;
	}

inline void TTmHighlightExtensions::AdjustRect(TRect& aRect) const
	{
	aRect.iTl.iX-=iLeftExtension;
	aRect.iTl.iY-=iTopExtension;
	aRect.iBr.iX+=iRightExtension;
	aRect.iBr.iY+=iBottomExtension;
	}



# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtlay.h" 2


class CWindowGc;
class MLayDoc;


 










class MFormCustomInterfaceProvider
    {
    public:
	 








	virtual TAny* GetExtendedInterface(const TUid& aInterfaceId) = 0;
    };


 






class TViewYPosQualifier
	{
friend class CTextLayout;
friend class CTextView;
public:
	 

	enum TPartOfLine
		{
		 
		EFViewTopOfLine = 1,
		 
		EFViewBaseLine = 0,
		 
		EFViewBottomOfLine = 2	
		};

	 
	enum TFullyVisible
		{
		 
		EFViewForceLineFullyVisible = ETrue,
		 
		EFViewDontForceLineFullyVisible = EFalse
		};
public:
	inline TViewYPosQualifier();
	  void SetHotSpot(TPartOfLine aHotSpot);
	  void SetFillScreen(TBool aFillScreen = ETrue);
	  void SetMakeLineFullyVisible(TFullyVisible aMakeLineFullyVisible = EFViewForceLineFullyVisible);
private:
	TPartOfLine iHotSpot;
	TBool iFillScreen;
	TFullyVisible iFullyVisible;
	};

 





class TViewRectChanges

	{
public:
	inline TViewRectChanges();
	void AdjustAll(TInt aDelta);
public:
	 

	TInt iFormattedFrom;
	 

	TInt iFormattedTo;
	 

	TInt iScrollAtTop;
	 

	TInt iScrollAtBottom;
	};

 









class TCursorSelection

	{
public:
	inline TCursorSelection();
	inline TCursorSelection(TInt aCursorPos,TInt aAnchorPos);
	inline void SetSelection(TInt aCursorPos,TInt aAnchorPos);
	inline TInt LowerPos() const;
	inline TInt HigherPos() const;
	inline TInt Length() const;
public:
	 
	TInt iCursorPos;
	 
	TInt iAnchorPos;
	};

 











class TDrawTextLayoutContext

	{
private:
	enum TDrawMode
		{
		EFDrawText=0x001,
		EFDrawGraphics=0x002,
		EFUseClippingRect=0x004,
		EFUseWindowGc=0x008,
		EFUseGcClear=0x020,
		EFUseBackgroundColor=0x040,
		EFUseOverrideTextColor=0x080,
		EFParagraphFillTextOnly=0x100,
		EFAllFlags=0xfff
		};
public:
	  TDrawTextLayoutContext();

	  void SetGc(CGraphicsContext* aGc,CGraphicsContext* aPictureGc= 0L );
	  void SetBitmapGc(CBitmapContext* aGc,CBitmapContext* aPictureGc= 0L );
	  void SetWindowGc(CWindowGc* aGc,CWindowGc* aPictureGc= 0L );
	  void SetDrawToEveryPixel(TBool aDrawToEveryPixel);
	  void SetTextColorOverride(const TRgb *aOverrideColor);
	  void SetDrawTextOnly();
	  void SetDrawGraphicsOnly();
	  void SetDrawTextAndGraphics();
	  void SetClipping(TBool aClipping);
	 
	  void SetParagraphFillTextOnly(TBool aFillTextOnly);

 
	  const TRgb* TextOverrideColor() const;
	  CGraphicsContext* PrimaryGc() const;
	  CGraphicsContext* PictureGc() const;
	  TBool UseClippingRect() const;
	  TBool UseGcClear() const;
	  TBool DrawText() const;
	  TBool DrawGraphics() const;
	  TBool UseBackgroundColor() const;
	 
	  TBool ParagraphFillTextOnly() const;

 
	  TRect TextArea() const;
	  TInt DisplayHeight() const;
	  TPoint TopLeftTextArea() const;
	  TRect TotalMargin() const;
	  TRect LabelMargin() const;
	  TBool IsLabelMargin() const;
	  TRect GutterMargin() const;
	  TBool IsGutterMargin() const;
	  TPoint TopLeftText() const;
	  void WindowToText(TPoint& aWinPos) const;
	  void WindowToText(TRect& aRect) const;
	  void TextToWindow(TPoint& aTextAreaPos) const;
	  void TextToWindow(TRect& aRect) const;
public:
	 



	TRect iViewRect;
	 

	TInt iLabelMarginWidth;
	 

	TInt iGutterMarginWidth;
	 

	TInt iTextStartX;
	 



	TLogicalRgb iBackgroundColor;
private:
	CGraphicsContext* iGc;
	CGraphicsContext* iPictureGc;
	TLogicalRgb iOverrideTextColor;
	TUint iDrawMode;
	};

 











class MFormCustomDraw

	{
	public:
	
	class TParam
	 




			{
		public:
		TParam(CGraphicsContext& aGc,MGraphicsDeviceMap& aMap,const TPoint& aTextLayoutTopLeft,const TRect& aDrawRect):
			iGc(aGc), iMap(aMap), iTextLayoutTopLeft(aTextLayoutTopLeft), iDrawRect(aDrawRect) { }

		CGraphicsContext& iGc;
		MGraphicsDeviceMap& iMap;
		const TPoint& iTextLayoutTopLeft;
		const TRect& iDrawRect;
		};

	class TLineInfo
	 




			{
		public:
		TLineInfo(const TRect& aOuterRect,const TRect& aInnerRect,TInt aBaseline):
			iOuterRect(aOuterRect), iInnerRect(aInnerRect), iBaseline(aBaseline) { }

		const TRect& iOuterRect;
		const TRect& iInnerRect;
		TInt iBaseline;
		};

	  virtual void DrawBackground(const TParam& aParam,const TRgb& aBackground,TRect& aDrawn) const;
	  virtual void DrawLineGraphics(const TParam& aParam,const TLineInfo& aLineInfo) const;
	  virtual void DrawText(const TParam& aParam,const TLineInfo& aLineInfo,const TCharFormat& aFormat,
								   const TDesC& aText,const TPoint& aTextOrigin,TInt aExtraPixels) const;
	  virtual TRgb SystemColor(TUint aColorIndex,TRgb aDefaultColor) const;

	  virtual void MFormCustomDraw_Reserved_1();
	  virtual void MFormCustomDraw_Reserved_2();
	};


 
















class MFormCustomWrap

	{
public:
	  virtual TUint LineBreakClass(TUint aCode,TUint& aRangeStart,TUint& aRangeEnd) const;
	  virtual TBool LineBreakPossible(TUint aPrevClass,TUint aNextClass,TBool aHaveSpaces) const;
	  virtual TBool GetLineBreakInContext(const TDesC& aText,TInt aMinBreakPos,TInt aMaxBreakPos,
												 TBool aForwards,TInt& aBreakPos) const;
	  virtual TBool IsHangingCharacter(TUint aChar) const;
private:
	  virtual void MFormCustomWrap_Reserved_1();
	  virtual void MFormCustomWrap_Reserved_2();	
	};

 



class TLayDocTextSource: public MTmSource, public MFormLabelApi
	{
	public:

	enum
		{
		EDefaultFontHeightIncreaseFactor = 7,
		EDefaultMinimumLineDescent = 3
		};

	TLayDocTextSource();

	 
	MGraphicsDeviceMap& FormatDevice() const;
	MGraphicsDeviceMap& InterpretDevice() const;
	TInt DocumentLength() const;
	void GetText(TInt aPos,TPtrC& aText,TTmCharFormat& aFormat) const;
	void GetParagraphFormatL(TInt aPos,RTmParFormat& aFormat) const;
	TInt ParagraphStart(TInt aPos) const;

	 
	TRgb SystemColor(TUint aColorIndex,TRgb aDefaultColor) const;
	CPicture* PictureL(TInt aPos) const;
	TInt GetPictureSizeInTwipsL(TInt aPos,TSize& aSize) const;
	TBool LabelModeSelect(TLabelType aType, TInt aPos);
	void LabelModeCancel();
	void LabelMetrics(TLabelType aType, TSize& aLabelSize, TInt& aMarginSize) const;
	TUint Map(TUint aChar) const;
	void SetLineHeight(const TLineHeightParam& aParam,TInt& aAscent,TInt& aDescent) const;
	TBool PageBreakInRange(TInt aStartPos,TInt aEndPos) const;
	void DrawBackground(CGraphicsContext& aGc,const TPoint& aTextLayoutTopLeft,const TRect& aRect,
						const TLogicalRgb& aBackground,TRect& aRectDrawn) const;
	void DrawLineGraphics(CGraphicsContext& aGc,const TPoint& aTextLayoutTopLeft,const TRect& aRect,
						  const TTmLineInfo& aLineInfo) const;
	void DrawText(CGraphicsContext& aGc,const TPoint& aTextLayoutTopLeft,const TRect& aRect,
				  const TTmLineInfo& aLineInfo,const TTmCharFormat& aFormat,
				  const TDesC& aText,const TPoint& aTextOrigin,TInt aExtraPixels) const;
	
	 
	 
	TBool LineBreakPossible(TUint aPrevClass,TUint aNextClass,TBool aHaveSpaces) const;
	TUint LineBreakClass(TUint aCode,TUint& aRangeStart,TUint& aRangeEnd) const;
	TBool GetLineBreakInContext(const TDesC& aText,TInt aMinBreakPos,TInt aMaxBreakPos,
												 TBool aForwards,TInt& aBreakPos) const;
	TBool IsHangingCharacter(TUint aChar) const;
	
	 
	TBool CanMap() const;

	TAny* GetExtendedInterface(const TUid& aInterfaceId);

	 
	enum
		{
		EWrap = 1,
		ETruncateWithEllipsis = 2,
		EUseLabelsDevice = 4
		};

	MLayDoc* iLayDoc;
	TUint iFlags;								 
	TInt iWidth;								 
	TChar iEllipsis;							 
	TInt iLabelsWidth;
	TInt iLabelsGutter;
	CLayoutData::TFormatMode iFormatMode;
	MGraphicsDeviceMap* iImageDevice;			 
	MGraphicsDeviceMap* iLabelsDevice;			 
	MGraphicsDeviceMap* iFormatDevice;			 
	TInt iFontHeightIncreaseFactor;				 
	TInt iMinimumLineDescent;					 
	TNonPrintingCharVisibility iNonPrintingCharVisibility;
	const MFormParam* iFormParam;				 
	const MFormCustomDraw* iCustomDraw;			 
	const MFormCustomWrap* iCustomWrap;			 
     

	MFormCustomInterfaceProvider* iInterfaceProvider;
	};

 


































class CTextLayout: public CBase

	{
public:

	 
	enum TDiscard
		{
		 
		EFViewDiscardAllFormat = 1 ,
		 
		EFViewDontDiscardFormat = 0 
		};

	 

	enum TAllowDisallow
		{
		 
		EFAllowScrollingBlankSpace = 1 ,
		 
		EFDisallowScrollingBlankSpace = 0 
		};

	enum									 
		{
		 
		EFCharacterInsert,
		 
		EFParagraphDelimiter,
		 
		EFLeftDelete,
		 
		EFRightDelete
		};

	enum
		{
		 



		EFScrollRedrawWholeScreen = CLayoutData::EFLargeNumber,
		 
		EFMaximumLineWidth = CLayoutData::EFBodyWidthForNoWrapping,
		};

	enum
		{
		 
		EFAllParagraphsNotWrapped = 1 ,
		 
		EFParagraphsWrappedByDefault = 0 
		};

	 
	enum TAmountFormatted
		{
		 
		EFFormatAllText = 0 ,
		 
		EFFormatBand = 1 ,
		};

	enum TScrollFlags
		{
		EFScrollOnlyToTopsOfLines = 1
		};

	 
	enum TCurrentFormat
		{
		  


		EFNoCurrentFormat = -1,
		 
		EFNotInCurrentFormat = 0
		};
public:
	class TRangeChange
	 























			{
	public:
		 
		enum TChangeType
			{
			 
			ESet,
			 
			EClear
			};
		  TRangeChange(TInt aStart, TInt aEnd, TChangeType aChange);
		  TRangeChange();
		  void Set(TInt aStart, TInt aEnd, TChangeType aChange);
		  TChangeType Get(TInt& aStart, TInt& aEnd) const;
		  void OptimizeWith(TRangeChange& aBuddy);
		  TBool NonNull() const;
		  TBool Clip(TInt aMin, TInt aMax);
	private:
		TInt iA;
		TInt iB;
		};

public:

	class TTagmaForwarder: public MTmTextLayoutForwarder
	 








		{
	public:
		inline TTagmaForwarder(const CTextLayout& aLayout);

	private:
		 
		inline const CTmTextLayout& TextLayout() const;
		inline void GetOrigin(TPoint& aPoint) const;

		const CTextLayout& iLayout;
		};

	 



	class TUtf32SourceCache
		{
	public:
		TUtf32SourceCache(const MTmSource& aSource);
		TUtf32SourceCache(const CTextLayout& aLayout);
		TText GetUtf16(TInt aIndex);
		TChar GetUtf32(TInt aIndex);
	private:
		const MTmSource* iSource;
		TPtrC16 iCurrentView;
		TInt iCurrentViewIndex;
		};
	friend class TUtf32SourceCache;

	  static CTextLayout *NewL(MLayDoc *aDoc,TInt aWrapWidth);
	  ~CTextLayout();
	  void DiscardFormat();
	  void SetLayDoc(MLayDoc *aDoc);
	  void SetWrapWidth(TInt aWrapWidth);
	  void SetBandHeight(TInt aHeight);
	  TInt BandHeight() const;
	  void SetImageDeviceMap(MGraphicsDeviceMap *aGd);
	  void SetLabelsDeviceMap(MGraphicsDeviceMap *aDeviceMap);
	  void SetAmountToFormat(TAmountFormatted aAmountOfFormat = EFFormatBand);
	  TBool IsFormattingBand() const;
	  void SetFormatMode(CLayoutData::TFormatMode aFormatMode,TInt aWrapWidth,MGraphicsDeviceMap* aFormatDevice);
	  void ForceNoWrapping(TBool aNoWrapping = EFAllParagraphsNotWrapped);
	  TBool IsWrapping() const;
	  void SetTruncating(TBool aOn);
	  TBool Truncating() const;
	  void SetTruncatingEllipsis(TChar aEllipsis);
	  TChar TruncatingEllipsis() const;
	  void SetLabelsMarginWidth(TInt aWidth);
	  void SetNonPrintingCharsVisibility(TNonPrintingCharVisibility aVisibility);
	  TNonPrintingCharVisibility NonPrintingCharsVisibility() const;
	  TBool IsBackgroundFormatting() const;
	  void NotifyTerminateBackgroundFormatting();
	 
	  void SetExcludePartialLines(TBool aExcludePartialLines = 1 );
	 
	  TBool ExcludingPartialLines() const;
	  void SetFontHeightIncreaseFactor(TInt aPercentage);
	  TInt FontHeightIncreaseFactor() const;
	  void SetMinimumLineDescent(TInt aPixels);
	  TInt MinimumLineDescent() const;
	  TInt DocumentLength() const;
	  TInt ToParagraphStart(TInt& aDocPos) const;
	  TInt PixelsAboveBand() const;
	  TInt YBottomLastFormattedLine() const;
	  TInt FormattedHeightInPixels() const;
	  TInt PosRangeInBand(TInt& aDocPos) const;
	  TBool PosInBand(const TTmDocPos& aDocPos,TTmLineInfo* aLineInfo = 0L ) const;
	  TBool PosInBand(TInt aDocPos,TPoint& aXyPos) const;
	  TBool PosIsFormatted(TInt aDocPos) const;
	  TInt FirstCharOnLine(TInt aLineNo) const;
	  TInt FormattedLength() const;
	  TInt FirstFormattedPos() const;
	  TInt NumFormattedLines() const;
	  TInt FirstLineInBand() const;
	  TInt GetLineRect(TInt aYPos,TRect& aLine) const;
	  TInt ParagraphHeight(TInt aDocPos) const;
	  TRect ParagraphRectL(TInt aDocPos) const;
	  TBool CalculateHorizontalExtremesL(TInt& aLeftX,TInt& aRightX,TBool aOnlyVisibleLines,
												TBool aIgnoreWrapCharacters = 0 ) const;
	  void GetCharacterHeightAndAscentL(TInt aDocPos,TInt& aHeight,TInt& aAscent) const;
	  void GetFontHeightAndAscentL(const TFontSpec& aFontSpec,TInt& aHeight,TInt& aAscent) const;
	  TInt XyPosToDocPosL(TPoint &aPos, TUint aFlags = 0) const;
	  TBool DocPosToXyPosL(TInt aDocPos, TPoint& aPos, TUint aFlags = 0) const;
	  TBool FindXyPos(const TPoint& aXyPos,TTmPosInfo2& aPosInfo,TTmLineInfo* aLineInfo = 0L ) const;
	  TBool FindDocPos(const TTmDocPosSpec& aDocPos,TTmPosInfo2& aPosInfo,TTmLineInfo* aLineInfo = 0L ) const;
	  TRect GetLineRectL(TInt aDocPos1,TInt aDocPos2) const;
	  TBool PictureRectangleL(TInt aDocPos,TRect& aPictureRect,TBool* aCanScaleOrCrop = 0L ) const;
	  TBool PictureRectangleL(const TPoint& aXyPos,TRect& aPictureRect,TBool* aCanScaleOrCrop = 0L ) const;
	  TInt FirstDocPosFullyInBand() const;
	  void GetMinimumSizeL(TInt aWrapWidth,TSize& aSize);
	  TInt MajorVersion() const;
	  TInt SetViewL(const TTmDocPos& aDocPos,TInt& aYPos,TViewYPosQualifier aYPosQualifier,
						   TDiscard aDiscardFormat = EFViewDontDiscardFormat);
	  TInt SetViewL(TInt aDocPos,TInt& aYPos,TViewYPosQualifier aYPosQualifier,
						   TDiscard aDiscardFormat = EFViewDontDiscardFormat);
	  void FormatBandL();
	  void FormatCharRangeL(TInt aStartDocPos,TInt aEndDocPos);
	void FormatCharRangeL(TInt aStartDocPos,TInt aEndDocPos,TInt aPixelOffset);
	  TBool FormatNextLineL(TInt& aBotPixel);
	  TBool FormatLineL(CParaFormat* aParaFormat,TInt& aDocPos,TInt& aHeight,TBool& aPageBreak);
	  TInt ScrollParagraphsL(TInt& aNumParas,TAllowDisallow aScrollBlankSpace);
	  TInt ScrollLinesL(TInt& aNumLines,TAllowDisallow aScrollBlankSpace = EFDisallowScrollingBlankSpace);
	  TInt ChangeBandTopL(TInt& aPixels,TAllowDisallow aScrollBlankSpace = EFDisallowScrollingBlankSpace);
	  void PageUpL(TInt& aYCursorPos,TInt& aPixelsScrolled);
	  void PageDownL(TInt& aYCursorPos,TInt& aPixelsScrolled);
	  TBool HandleCharEditL(TUint aType,TInt& aCursorPos,TInt& aGood,TInt& aFormattedUpTo,
								   TInt& aFormattedFrom,TInt& aScroll,TBool aFormatChanged);
	  void HandleBlockChangeL(TCursorSelection aSelection,TInt aOldCharsChanged,TViewRectChanges& aViewChanges,
									 TBool aFormatChanged);
	  void HandleAdditionalCharactersAtEndL(TInt& aFirstPixel,TInt& aLastPixel);
	 
	  void ReformatVerticalSpaceL();
	  void AdjustVerticalAlignment(CParaFormat::TAlignment aVerticalAlignment);
	  static void DrawBorders(const MGraphicsDeviceMap* aGd,CGraphicsContext& aGc,const TRect& aRect,
									 const TParaBorderArray& aBorder,const TRgb* aBackground = 0L ,
									 TRegion* aClipRegion = 0L ,const TRect* aDrawRect = 0L );
	  void DrawL(const TRect& aDrawRect,const TDrawTextLayoutContext* aDrawTextLayoutContext,
						const TCursorSelection* aHighlight = 0L );
	  TBool GetNextVisualCursorPos(const TTmDocPosSpec& aDocPos,
		TTmPosInfo2& aPosInfo, TBool aToLeft) const;
	 
	  void InvertRangeL(const TCursorSelection& aHighlight,const TRect& aDrawRect,
							   const TDrawTextLayoutContext* aDrawTextLayoutContext);
	  void Highlight(const TRangeChange& aHighlight,const TRect& aDrawRect,
		const TDrawTextLayoutContext* aDrawTextLayoutContext);
	  void SetCustomDraw(const MFormCustomDraw* aCustomDraw);
	  const MFormCustomDraw* CustomDraw() const;
	  void SetCustomWrap(const MFormCustomWrap* aCustomWrap);
	  const MFormCustomWrap* CustomWrap() const;
	  void ExtendFormattingToCoverYL(TInt aYPos);
	  void ExtendFormattingToCoverPosL(TInt aDocPos);

	  TInt GetLineNumber(TInt aDocPos);
	  void SetHighlightExtensions(TInt aLeftExtension, TInt aRightExtension, TInt aTopExtension, TInt aBottomExtension);

      void SetInterfaceProvider( MFormCustomInterfaceProvider* aProvider ); 
	inline const CTmTextLayout& TagmaTextLayout() const;
	inline void GetOrigin(TPoint& aPoint) const;


	inline void RestrictScrollToTopsOfLines(TBool aRestrict);


	 
	void DrawBackground(CGraphicsContext& aGc,const TPoint& aTopLeft,const TRect& aClipRect,
						const TLogicalRgb& aBackground) const;
	TBool CalculateHorizontalExtremes(TInt& aLeftX,TInt& aRightX,TBool aOnlyVisibleLines) const;
	TBool GetCursor(const TTmDocPos& aDocPos,TTmCursorPlacement aPlacement,
				    TRect& aLineRect,TPoint& aOrigin,TInt& aWidth,TInt& aAscent,TInt& aDescent) const;
	void GetParagraphRect(const TTmDocPos& aDocPos,TRect& aRect) const;
	TInt ScrollDocPosIntoViewL(const TTmDocPos& aDocPos);
	TInt PictureRectangleAndPosL(const TPoint& aXyPos, TRect& aPictureRect,
		TBool* aCanScaleOrCrop = 0) const;
	void HighlightUsingExtensions(const CTextLayout::TRangeChange& aChangeHighlight,const TRangeChange& aFullHighlight,
		const TRect& aDrawRect,	const TDrawTextLayoutContext* aDrawTextLayoutContext);
	inline const TTmHighlightExtensions& HighlightExtensions() const;
	void GetHighlightRemnants(const TRect& aRect, const TDrawTextLayoutContext& aDrawTextLayoutContext, TRect* aRemainderRects) const;
	void ClearHighlightRemnants(const TRect& aDrawRect, const TDrawTextLayoutContext& aDrawTextLayoutContext);
	TInt WrapWidth() const;





	enum TPanicNumber
		{
		EUnimplemented,
		ENoMemory,
		EDrawingBorderError,
		EFormatDeviceNotSet,
		EImageDeviceNotSet,
		EPixelNotInFormattedLine,
		EInvalidDocPos,
		ENoCharRangeToFormat,
		ECharacterNotFormatted,
		EPrintPreviewModeError,
		EBadCharacterEditType,
		EInvalidLineNumber,
		EPosNotFormatted,
		EMustFormatAllText,
		EPageScrollError
		};
	static void Panic(TPanicNumber aNumber);

private:
	  CTextLayout();
 	  void ConstructL(MLayDoc *aDoc,TInt aWrapWidth);
	void InitFormatParam(TTmFormatParamBase& aParam);
	TInt ScrollL(TInt aDy,TAllowDisallow aScrollBlankSpace);
	void FormatBandL(TInt aStartDocPos,TInt aEndDocPos);
	void PruneFormat(TBool aFromStart);
	TInt VisibleHeightInPixels() const;
	TInt BandHeightInPixels() const;
	TInt SuggestCursorPos(TInt aCurrentCursorPos) const;
	TInt SetBandTop();

	CTmTextLayout iText;		 
	TInt iDummy[17];	 
						 
						 
						 
	TInt iBandTop;		 
						 
	TInt iVisibleHeight; 
	TInt iBandHeight;	 

	TInt iScrollFlags;		 
	TInt iUnformattedStart;  
							 
							 
	TBool iParInvalid;		 
							 
							 
	TTmHighlightExtensions iHighlightExtensions;
	TLayDocTextSource iSource;	 
	};

 








class TCursorPosition

	{
public:


	 
	enum TMovementType
		{
		 
		EFNoMovement,
		 
		EFLeft,
		 
		EFRight,
		 
		EFLineUp,
		 
		EFLineDown,
		 
		EFPageUp,
		 
		EFPageDown,
		 
		EFLineBeg,
		 
		EFLineEnd
		};

	 
	enum TVisualEnd
		{
		 
		EVisualLeft,
		 
		EVisualRight
		};

	inline TCursorPosition();
	inline void SetLayout(CTextLayout *aLayout);
	inline void UpdateLatentX(TInt aX);
	inline void SetToPreviousHighlight();
	inline void SetToCurrentHighlight();
	inline void CancelHighlight();
	inline void SetDocPos(const TTmDocPos& aDocPos);
	void UpdateLatentPosition();
	TInt SetSelectionL(const TCursorSelection& aSelection);
	void SetPendingSelection(const TCursorSelection& aSelection);
	void GetOldSelection(TCursorSelection& aSelection) const;
	void GetSelection(TCursorSelection& aSelection) const;
	TInt SetDocPosL(TBool aDragSelectOn,const TTmDocPos& aDocPos);
	TInt SetXyPosL(TBool aDragSelectOn,TPoint aPos,TBool aAllowPictureFrame);
	TInt MoveL(TBool aDragSelectOn,TMovementType& aMovement,TBool aAllowPictureFrame);
	const TTmDocPos& VisualEndOfRunL(
		const TTmDocPos& aStart, const TTmDocPos& aEnd,
		TVisualEnd aDirection);
	void TextMoveVertically();
	inline void DontDrawOldPictureFrame();

	 
	inline TBool IsSelection() const;
	inline TBool IsSelectionToDraw() const;
	TBool IsPictureFrame() const;
	TBool IsNewPictureFrame() const;
	inline const TTmDocPos& TmDocPos() const;
	inline TInt DocPos() const;
	inline TBool DrawHighlight() const;
	inline TBool DrawOldPictureFrame() const;
	inline TBool DrawNewPictureFrame() const;
	TBool GetCursor(TTmCursorPlacement aPlacement,TPoint& aOrigin,TInt& aWidth,TInt& aAscent,TInt& aDescent) const;
	MCursorPositioningPolicy::TPosHint PositioningHint() const { return iPositioningHint; }
	void SetPositioningHint (MCursorPositioningPolicy::TPosHint aHint)
		{iPositioningHint = aHint;}

	TTmPosInfo2& ChoosePosition(TTmPosInfo2& aPreferred,
		TTmPosInfo2& aBackup);

private:
	enum
		{
		EFAbove = -1,
		EFInside = 0,
		EFBelow = 1
		};

	 
	enum
		{
		EDrawHighlight = 1,
		EDrawOldPictureFrame = 2,
		EDrawNewPictureFrame = 4,
		EReturnPreviousHighlight = 8,
		ESelected = 16
		};

	TInt ViewTopOfLineL(const TTmDocPos& aDocPos,TInt& aYPos);
	void CheckSelection(TBool aSelect);
	void CheckNullSelection();
	inline void UpdateLatentY(TInt aY);
	TInt CheckCursorOnScreenL(TInt& aY);
	TBool LeftRightL(TTmPosInfo2& aPos, TTmLineInfo& aLine, TMovementType& aMove);
	void StartEndL(TTmPosInfo2& aPos, TTmLineInfo& aLine, TMovementType& aMove);
	void UpDownL(TTmPosInfo2& aPos, TTmLineInfo& aLine, TMovementType& aMove);
	TInt PageScrollL(TMovementType& aMove);
	TInt DoSetDocPosL(const TTmDocPos& aDocPos);
	TInt DoSetVisibleDocPosL(const TTmDocPos& aDocPos);
	void DoSetXyPos(TPoint& aXy);
	void SetPictureFrame(const TTmDocPos& aDocPos,TInt aAnchor,const TRect& aPictureRect);
	inline TBool CalculateCursorPos(TPoint& aCurPos);

	TTmDocPos iDocPos;
	TInt iAnchor;
	TInt iOldDocPos;
	TInt iOldAnchor;
	TUint iFlags;
	TInt iLatentX;
	TInt iLatentY;
	CTextLayout* iLayout;
	MCursorPositioningPolicy::TPosHint iPositioningHint;
	};

 
inline const CTmTextLayout& CTextLayout::TagmaTextLayout() const
	{
	return iText;
	}

inline void CTextLayout::GetOrigin(TPoint& aPoint) const
	{
	aPoint.iX = 0;
	aPoint.iY = -iBandTop;
	}

inline CTextLayout::TTagmaForwarder::TTagmaForwarder(const CTextLayout& aLayout):
	iLayout(aLayout)
	{
	}

inline const CTmTextLayout& CTextLayout::TTagmaForwarder::TextLayout() const
	{
	return iLayout.TagmaTextLayout();
	}

inline void CTextLayout::TTagmaForwarder::GetOrigin(TPoint& aPoint) const
	{
	iLayout.GetOrigin(aPoint);
	}

inline const TTmHighlightExtensions& CTextLayout::HighlightExtensions() const
	{
	return iHighlightExtensions;
	}

 



void CTextLayout::RestrictScrollToTopsOfLines(TBool a)
	{
	if (a)
		iScrollFlags |= EFScrollOnlyToTopsOfLines;
	else
		iScrollFlags &= ~EFScrollOnlyToTopsOfLines;
	}

 


inline TViewYPosQualifier::TViewYPosQualifier():
	iHotSpot(EFViewBaseLine),
	iFillScreen(EFalse),
	iFullyVisible(EFViewDontForceLineFullyVisible)
	{
	}


 

inline TViewRectChanges::TViewRectChanges():
	iScrollAtTop(0),
	iScrollAtBottom(0)
	{
	}

 

inline TCursorSelection::TCursorSelection():
	iCursorPos(0),
	iAnchorPos(0)
	{
	}

 


inline TCursorSelection::TCursorSelection(TInt aCursorPos,TInt aAnchorPos):
	iCursorPos(aCursorPos),
	iAnchorPos(aAnchorPos)
	{
	}

 


inline void TCursorSelection::SetSelection(TInt aCursorPos,TInt aAnchorPos)
	{
	iCursorPos = aCursorPos;
	iAnchorPos = aAnchorPos;
	}

 

inline TInt TCursorSelection::LowerPos() const
	{
	return Min(iCursorPos,iAnchorPos);
	}

 

inline TInt TCursorSelection::HigherPos() const
	{
	return Max(iCursorPos,iAnchorPos);
	}

 

inline TInt TCursorSelection::Length() const
	{
	return Abs(iCursorPos - iAnchorPos);
	}

inline TCursorPosition::TCursorPosition():
	iAnchor(0),
	iOldDocPos(0),
	iOldAnchor(0),
	iFlags(0),
	iLatentX(0),
	iLatentY(0),
	iLayout(0L ),
	iPositioningHint(MCursorPositioningPolicy::EPosHintUndefined)
	{
	}

inline void TCursorPosition::SetLayout(CTextLayout *aLayout)
	{
	iLayout = aLayout;
	}

inline TBool TCursorPosition::IsSelection() const
	{
	return iFlags & ESelected;
	}

inline TBool TCursorPosition::IsSelectionToDraw() const
	{
	return iFlags & (EDrawHighlight | EDrawOldPictureFrame | EDrawNewPictureFrame);
	}

inline void TCursorPosition::SetToPreviousHighlight()
	{
	iFlags |= EReturnPreviousHighlight;
	}

inline void TCursorPosition::SetToCurrentHighlight()
	{
	iFlags &= ~EReturnPreviousHighlight;
	}

inline void TCursorPosition::CancelHighlight()
	{
	iFlags &= ~(ESelected | EDrawHighlight | EDrawOldPictureFrame | EDrawNewPictureFrame);
	}

inline void TCursorPosition::UpdateLatentX(TInt aX)
	{
	iLatentX = aX;
	}

inline void TCursorPosition::UpdateLatentY(TInt aY)
	{
	iLatentY = aY;
	}

inline TBool TCursorPosition::CalculateCursorPos(TPoint& aPos)
	{
	TTmPosInfo2 pos_info;
	TBool result = iLayout->FindDocPos(iDocPos,pos_info);
	aPos = pos_info.iEdge;
	return result;
	}

inline const TTmDocPos& TCursorPosition::TmDocPos() const
	{
	return iDocPos;
	}

inline TInt TCursorPosition::DocPos() const
	{
	return iDocPos.iPos;
	}

inline void TCursorPosition::SetDocPos(const TTmDocPos& aDocPos)
	{
	iDocPos = aDocPos;
	}

inline TBool TCursorPosition::DrawHighlight() const
	{
	return iFlags & EDrawHighlight;
	}

inline TBool TCursorPosition::DrawOldPictureFrame() const
	{
	return iFlags & EDrawOldPictureFrame;
	}

inline TBool TCursorPosition::DrawNewPictureFrame() const
	{
	return iFlags & EDrawNewPictureFrame;
	}

inline void TCursorPosition::DontDrawOldPictureFrame()
	{
	iFlags &= ~EDrawOldPictureFrame;
	}


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/lafmain.h" 2


class CCoeControl;
class CFont;
class TLogicalFont;
class MLafEnv;

 





class CLafEdwinCustomDrawBase : public CBase, public MFormCustomDraw
	{
public:
	  static CLafEdwinCustomDrawBase* NewL(const MLafEnv& aEnv,const CCoeControl& aControl);
public:  
	  void DrawBackground(const TParam& aParam,const TRgb& aBackground,TRect& aDrawn) const;
	  TRgb SystemColor(TUint aColorIndex,TRgb aDefaultColor) const;
public:
	  virtual void LineSpacingChanged();
protected:
	  CLafEdwinCustomDrawBase(const MLafEnv& aEnv,const CCoeControl& aControl);
protected:
	const MLafEnv& iEnv;
	const CCoeControl& iControl;
private:
	TInt iSpare;
	};

class MLafEnv
	{
public:
	virtual const CFont* Font(const TLogicalFont& aLogicalFont) const=0;
	virtual const CFbsBitmap* Bitmap( TUid aBmpUid) const=0;
	virtual TRgb ControlColor(TLogicalColor aLogicalColor, const CCoeControl& aControl) const=0;
	virtual TRgb Color(TLogicalColor aLogicalColor, TUid aColorListUid= TUid::Null() ) const=0;
	virtual TDisplayMode DefaultDisplayMode() const=0; 
	};

 



class MLafClientRectResolver
	{
public:
	enum TScreenFurniture
		{ EMenuBar, EButtonGroup, EToolBand, ETitleBand, EStatusPane, ECba };
public:
	virtual void ReduceRect(TScreenFurniture aScreenFurniture,TRect& aRect) const=0;
	};


# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikvcurs.h" 1
 
 
 
 

 
 
 







 






class TEikVirtualCursor
	{
public:
	enum TState
		{
		EOff=0,
		EOn,
		ESuspended
		};
public:
	TEikVirtualCursor();
private:  
	inline TEikVirtualCursor(const TEikVirtualCursor&);
public:
	  void SetCursorStateL(TState aState, CCoeEnv& aEnv);
	  TState CursorState(CCoeEnv& aEnv);
public:  
	void HandleAppToForeground(CCoeEnv& aEnv);
private:
	void SwitchOffEmulationAndBitmap(CCoeEnv& aEnv);
	void SwitchOnEmulationAndBitmap(CCoeEnv& aEnv);
private:
	TState iState;
	TInt iSpare;
	};


 

inline TEikVirtualCursor::TEikVirtualCursor(const TEikVirtualCursor&)
	{}


# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikenv.h" 2

 

class CEikProcess;
class CEikInfoMsgWin;
class CEikBusyMsgWin;
class CEikAppUi;
class CEikHotKeyTable;
class CCoeControl;
class CParaFormatLayer;
class CCharFormatLayer;
class CCoeBrushAndPenContext;
class CEikCommandButton;
class CPrintSetup;
class CDictionaryStore;
class CApaWindowGroupName;
class CEikErrorIdler;
class CEikApplication;
class MEikInfoDialog;
class MEikAlertWin;
class CEikDialog;
class MEikDebugKeys;
class CEikLibrary;
class MEikAppUiFactory;
class MEikIrFactory;
class CGulIcon;
class CApaMaskedBitmap;
class CEikLogicalBorder;
class CEikLafEnv;
class TLogicalFont;
class CEikPictureFactory;
class CEikEnvExtra;
class TAknSystemFont;  
namespace AknLayout { class CInstance; }

 
const TInt KTimeBetweenClicks=1000000;	  
const TInt KDoubleClickDistance=10;

const TInt KKeyboardRepeatRate=50000;
const TInt KKeyboardRepeatInitialDelay=800000;

const TUid KSystemIniFileUid = {0x1000010C};
const TUid KUikonLibraryUid = {0x10004CC1 };
 

typedef void (*TRequestDialogFunc)();

 




 





class MEikPictureFactory
	{
public:
	  virtual TUid Id() const;
	 


	virtual TBool SupportsPictureType(TUid aPictureType) const=0;
	 



	virtual const MPictureFactory* PictureFactory(TUid aPictureType) const=0;
	 


	virtual TPictureHeader InsertL(TUid aPictureType,CBase* aData)=0;
	 


	virtual void EditL(const TPictureHeader& aPictureHeader,TBool aReadOnly)=0;
private:
	  virtual void MEikPictureFactory_Reserved_1();
	  virtual void MEikPictureFactory_Reserved_2();
	};


class CEikonEnv : public CCoeEnv, public MApaAppStarter
	{
public:
	  ~CEikonEnv();
	  CEikonEnv();
	  void ConstructL();
	  void ConstructL(TBool aInitialFocusState);
	  void ConstructAppFromCommandLineL(const CApaCommandLine& aCommandLine);
	  void ControlStackReadyL();
	  static TVersion Version();
	 
	inline static CEikonEnv* CEikonEnv::Static();
	  const CFont* AnnotationFont() const;
	  const CFont* TitleFont() const;
	  const CFont* LegendFont() const;
	  const CFont* SymbolFont() const;
	  const CFont* DenseFont() const;
	  const CFont* Font(const TLogicalFont& aLogicalFont) const;
	 
public:  
	  const CFbsBitmap* TexturedBitmap() const;
public:  
	  const CFbsBitmap* GrayBitmap() const;
	  const CFbsBitmap* OptionBitmap() const;
	  const CFbsBitmap* HighlightedOptionBitmap() const;
	  const CFbsBitmap* OptionMaskBitmap() const;
public:
	  const CFbsBitmap* Bitmap(TUid aUidBmp) const;
	void InitSystemBitmapsL();
public:  
	  MLafEnv& LafEnv() const;
	inline TInt EditableControlStandardHeight() const;
public:
	inline CEikProcess* Process() const;
	inline const MEikAlertWin* Alert() const;
	  MPictureFactory* PictureFactory()const;
	  MEikPictureFactory* ExtendedPictureFactory(TUid aPictureType) const;
	  void AddPictureFactoryL(MEikPictureFactory& aFactory);
	  void RemovePictureFactory(TUid aFactoryId);
	  void SetAlertWin(MEikAlertWin* aAlertWin);
	  void AlertWin(const TDesC& aMsg);
	  void AlertWin(const TDesC& aMsg1,const TDesC& aMsg2);
	  void LeaveWithInfoMsg(TInt aResourceId,...);
public:  
	  void LeaveWithErrorContext(TInt aError,const TDesC& aContextText);
	  void GetErrorText(TDes& aDes,TInt aError) const;
public:
	  void InfoMsg(const TDesC& aDes);
	  void InfoMsgWithAlignment(TGulAlignment aCorner,const TDesC& aDes);
	  void InfoMsg(TInt aResourceId,...);
	  void InfoMsg(TInt aResourceId,VA_LIST aList);
	  void InfoMsgWithAlignment(TGulAlignment aCorner,TInt aResourceId,...);
	  void InfoMsgWithAlignment(TGulAlignment aCorner,TInt aResourceId,VA_LIST aList);
	  void InfoMsgWithDuration(const TDesC& aDes, TTimeIntervalMicroSeconds32 aDuration);
	  void InfoMsgWithDuration(TInt aResourceId, TTimeIntervalMicroSeconds32 aDuration,...);
	  void InfoMsgWithDuration(TInt aResourceId, TTimeIntervalMicroSeconds32 aDuration, VA_LIST aList);
	  void InfoMsgWithAlignmentAndDuration(TGulAlignment aCorner,const TDesC& aDes, TTimeIntervalMicroSeconds32 aDuration);
	  void InfoMsgWithAlignmentAndDuration(TGulAlignment aCorner,TInt aResourceId, TTimeIntervalMicroSeconds32 aDuration,...);
	  void InfoMsgWithAlignmentAndDuration(TGulAlignment aCorner,TInt aResourceId, TTimeIntervalMicroSeconds32 aDuration,VA_LIST aList);
	  void InfoMsgCancel();
	  void VerboseInfoMsg(const TDesC& aDes);
public:  
	  void SetVerboseInfoReporting(TBool aVerbose);
public:
	  void BusyMsgL(const TDesC& aDes);
	  void BusyMsgL(const TDesC& aDes,TGulAlignment aCorner);
	  void BusyMsgL(TInt aResourceId);
	  void BusyMsgL(const TDesC& aDes,TTimeIntervalMicroSeconds32 aInitialDelay);
	  void BusyMsgL(const TDesC& aDes,TGulAlignment aCorner,TTimeIntervalMicroSeconds32 aInitialDelay);
	  void BusyMsgL(TInt aResourceId,TTimeIntervalMicroSeconds32 aInitialDelay);
	  void BusyMsgCancel();
	
	  TBool ConfirmLossOfAllChangesL() const;
	  static TBool QueryWinL(const TDesC& aFirstLine,const TDesC& aSecondLine);
	  TBool QueryWinL(TInt aFirstLineId,TInt aSecondLineId=0) const;
	  static void InfoWinL(const TDesC& aFirstLine,const TDesC& aSecondLine);
	  void InfoWinL(TInt aFirstLineId,TInt aSecondLineId=0) const;
	  void SetQueryDialog(MEikInfoDialog* aQueryDialog);
	  void SetInfoDialog(MEikInfoDialog* aInfoDialog);
	  void SetRequestQueryDialogFunc(TRequestDialogFunc aQueryDialogFunc);
	  void SetRequestInfoDialogFunc(TRequestDialogFunc aInfoDialogFunc);

	  void AllocInfoMsg();
	  void WservAllocInfoMsg();
	  void FservAllocInfoMsg();
	 
	  static void Beep();

 










	  CWsBitmap* CreateBitmapL(const TDesC& aFileName,TInt aId);
	  CGulIcon* CreateIconL(const TDesC& aFileName,TInt aBitmapId,TInt aMaskId=-1);
	  static CGulIcon* CreateIconFromMaskedBitmapL(const CApaMaskedBitmap& aApaMaskedBitmap);
public:  
	  void SetDebugKeys(MEikDebugKeys* aDebugKeys);
	  void LaunchPopupMenuL(TInt aResourceId,const TPoint& aTargetPos,TPopupTargetPosType aTargetType=EPopupTargetTopLeft,const CEikHotKeyTable* aHotKeyTable= 0L );
public:
	  static void AddWindowShadow(CCoeControl* aWinArea);
	  RAnimDll& ClockDllL();
	 
	  CParaFormatLayer* SystemSingleLineParaFormatLayerL();
	  CParaFormatLayer* SystemParaFormatLayerL();
	  CCharFormatLayer* SystemCharFormatLayerL();
	  static CParaFormatLayer* NewDefaultSingleLineParaFormatLayerL();
	  static CParaFormatLayer* NewDefaultParaFormatLayerL();
	  static CCharFormatLayer* NewDefaultCharFormatLayerL();
	  static void GetPrinterNamesL(CPrinterModelList* aModelNameList,CDesCArray& aPrinterNameList);
  	 
	inline CEikAppUi* EikAppUi() const;
	  void AddDialogLikeControlToStackL(CCoeControl* aControl);
	  void AddAlertDialogLikeControlToStackL(CCoeControl* aControl);
	  void RemoveFromStack(CCoeControl* aControl);
	  void AddSleepingDialogToStackL(CCoeControl* aControl);
	  void AddSleepingAlertDialogToStackL(CCoeControl* aControl);
	  void RouseSleepingDialog(CCoeControl* aControl,TBool aRoused);
	 
	  void DrawCursor(const CCoeControl* aControl,const TPoint& aPosition,TInt aWidth);
	  void DrawCursor(const CCoeControl* aControl,const TPoint& aPosition,TInt aWidth,TInt aAscent,TInt aHeight);
	  void HideCursor(const CCoeControl* aControl);
	 
	  void UpdateTaskNameL();
	 
	  void BringForwards(TBool aForwards,TInt aPriority=ECoeWinPriorityAlwaysAtFront);
	  void SetAutoForwarding(TBool aForwarding);
public:  
	  TPtrC KeyPressLabel(TInt aIndex) const;
public:
	  CPrintSetup* NewDefaultPrintSetupL();
public:  
	  void DisplayTaskList();
	  void DismissTaskList();
	  void SendEventToEikonServer(TInt aEvent,const TAny* aPtr,TInt aLength);
public:
	  void SetBusy(TBool aBusy);
	  TBool IsBusy() const;
	  void SetSystem(TBool aSystem);
	  TBool IsSystem() const;
	  void SetDocNameIsAFile(TBool aDocNameIsAFile);
	  TBool DocNameIsAFile() const;
	  void SetRespondsToShutdownEvent(TBool aRespondsToShutdownEvent);
	  TBool RespondsToShutdownEvent() const;
	  void SetRespondsToSwitchFilesEvent(TBool aRespondsToSwitchFilesEvent);
	  TBool RespondsToSwitchFilesEvent() const;
	
	  TEikVirtualCursor& VirtualCursor();

	  void NotifyIdleErrorWhileRedrawing(TInt aError);
	  void NotifyIdleError(TInt aError,TInt aContextRid);
	  void HandleErrorWithContext(TInt aError,TInt aContextRid);

	  MEikAppUiFactory* AppUiFactory() const;
	  MEikAppUiFactory* AppUiFactory(const CEikAppUi& aAppUi) const;
public:  
	  void SetAppUiFactoryL(MEikAppUiFactory* aAppUiFactory);  
	  void AddAppUiFactoryL(MEikAppUiFactory* aAppUiFactory);
	  void RemoveAppUiFactory();

public:
	  TInt AddLibraryL(TCreateByTypeFunction aControlFactory, TFileName* aResourceFile);
	inline TInt AddLibraryL(TCreateByTypeFunction aControlFactory);
	inline TInt AddLibraryL(TFileName* aResourceFile);
	  void RemoveLibrary(TCreateByTypeFunction aControlFactory, TInt aResourceFileOffset);
	inline void RemoveLibrary(TCreateByTypeFunction aControlFactory);
	inline void RemoveLibrary(TInt aResourceFileOffset);

	inline TChar NudgeCharMinus() const;
	inline TChar NudgeCharPlus() const;

	inline CColorList& ColorList() const;
	inline TRgb Color(TLogicalColor aLogicalColor) const;
	inline void SetColor(TLogicalColor aLogicalColor, TRgb aColor);
	  TRgb ControlColor(TLogicalColor aLogicalColor,const CCoeControl& aControl) const;
	inline CColorArray& CustomColorArray() const;

	 
	  static TRgb AvkonColor(TInt aIndex);

	 
	  const AknLayout::CInstance& AknLayout() const;

private:
	 
	 
	friend class CAknSgcClient;
	  void CreateResourceReaderNoPanicLC(TResourceReader& aReader,TInt aResourceId) const;

public:  
	inline void SetCDlgDialogFactory(MEikCDlgDialogFactory* aDialogFactory); 
																			 
																			 
	inline void SetPrintDialogFactory(MEikPrintDialogFactory* aDialogFactory);	 
	inline void SetFileDialogFactory(MEikFileDialogFactory* aDialogFactory);	 
	inline void SetIrFactory(MEikIrFactory* aIrFactory);  
	inline MEikCDlgDialogFactory* CDlgDialogFactory() const;
	inline MEikPrintDialogFactory* PrintDialogFactory() const;
	inline MEikFileDialogFactory* FileDialogFactory() const;
	inline MEikIrFactory* IrFactory() const;
	CArrayFix<TCreateByTypeFunction>* ControlFactoryFuncArray() const;
	inline void SetZoomFactor(TZoomFactor& aZoomFactor);
	inline TZoomFactor ZoomFactor() const;
	inline TInt StatusPaneCoreResId() const;
	inline void SetStatusPaneCoreResId(TInt aStatusPaneCoreResId);
	  void AddAutoMenuTitleL(CEikAutoMenuTitle* aTitle);
	inline CEikAutoMenuTitleArray* AutoMenuTitleArray() const;
	 
public:
	  TDisplayMode DefaultDisplayMode() const;
public:  
	  void SetExtension(CBase* aExtension);
	inline CBase* Extension() const;
public:  
	 
	  void HandleError(TInt aError);
public:  
	  void WriteInternalStateOfStackedControlsL();
public:
	void UpdateColorListL();
	void PostAppUiDestroy();
	void PostAppUiInitializeL();
protected:  
	 
	  void DestroyEnvironment();
private:  
	  void DestroyScreen();
	  void InitSystemFontsL();
	  TInt ResourceFileVersionNumber() const;
	  void Reserved_1();
	  void Reserved_2();
private:  
	  TThreadId StartAppL(const CApaCommandLine& aCommandLine);
protected:
	friend class CEikServAppUi;
private:  
	void InitSystemResourceFileL();
	void InitPrivateResourceFileL();
	void InitInfoMsgL();
	void PrepareBusyMsgL();
	void InitAlertWinL();
	void SetUpFepL();
	TErrorHandlerResponse PrepareToHandleError(TInt aError);
	void DoHandleError(TErrorHandlerResponse aType);
	static TInt IdleErrorCallBack(TAny* aThis);
	void InitColorsL();
	void LoadParserListL();
	void LoadLibrariesL();
	void CloseLibraries();
	MEikInfoDialog* QueryDialog();
	MEikInfoDialog* InfoDialog();
	TRequestDialogFunc RequestQueryDialogFunc();
	TRequestDialogFunc RequestInfoDialogFunc();
	void SetAppReady();
	void DisplayGlobalNote(const TDesC& aMsg1, const TDesC& aMsg2);
	void SetCommandLineDebugMemFail(TPtrC8& aTail);
	 
	void InfoNote(TInt aResourceId,VA_LIST aList);
	void InfoNote(TInt aResourceId,...);
	void InfoNote(const TDesC& aDes);
	void InstallAknEnvAsExtensionL();
private:
	class TEikAppUiFactory
		{
	public:
		MEikAppUiFactory*	iFactory;
		CEikAppUi*			iAppUi;
		};
private:
	TInt iEikonEnvFlags;
	TInt iForwardsCount;
	TInt iBusyCount;
	CEikProcess* iProcess;
	RAnimDll* iClockDll;
 
	CArrayFixFlat<TAknSystemFont>* iFontArray;
	CEikInfoMsgWin* iInfoMsgWin;
	CEikBusyMsgWin* iBusyMsgWin;
	MEikAlertWin* iAlertWin;
	TInt iSystemResourceFileOffset;
	HBufC8* iKeyPressLabels;
	CParaFormatLayer* iSingleLineParaFormatLayer;
	CParaFormatLayer* iParaFormatLayer;
	CCharFormatLayer* iCharFormatLayer;
	const CCoeControl* iCursorWindow;
	TInt iEditableControlStandardHeight;
	CApaWindowGroupName* iWgName;
	CEikErrorIdler* iErrorIdler;
	TInt iPrivateResourceFileOffset;
	CColorList* iColorList;
	CEikPictureFactory* iPictureFactory;
	TBuf<2> iNudgeChars;
	MEikInfoDialog* iQueryDialog;
	MEikInfoDialog* iInfoDialog;
	TRequestDialogFunc	iQueryDialogFunc;
	TRequestDialogFunc	iInfoDialogFunc;
	CArrayFix<RLibrary>* iLibArray;
	CArrayFix<TCreateByTypeFunction>* iControlFactoryFuncArray;
	CArrayFix<TInt>* iResourceFileOffsetArray;
	TBool iAlertWinInitialized;
	MEikDebugKeys* iDebugKeys;
	MEikCDlgDialogFactory* iCDlgDialogFactory;
	MEikPrintDialogFactory* iPrintDialogFactory;
	MEikFileDialogFactory* iFileDialogFactory;
	CArrayFix<TEikAppUiFactory>* iAppUiFactoryArray;
	MEikIrFactory* iIrFactory;
	CArrayPtr<CEikLibrary>* iLibraries;
	TInt iEmbeddedAppLevel;
	TInt iAutoLoadedResourceFiles;
	TInt iAutoLoadedControlFactories;
	TZoomFactor iZoomFactor;
	CBase* iExtension;
	TInt iStatusPaneCoreResId;
	CEikAutoMenuTitleArray* iAutoMenuTitleArray;
	TEikVirtualCursor iVirtualCursor;
	CEikLogicalBorder* iLogicalBorder;
	CEikLafEnv* iLafEnv;
	CArrayPtrFlat<CFbsBitmap>* iBitmapArray;
	CEikEnvExtra* iEikEnvExtra;  
	HBufC* iOOMErrorText;		 
	TInt iSpare3;
	TInt iSpare4;
	};

class MEikInfoDialog
	{
public:
	virtual TBool RunDlgLD(TInt aResource, const TDesC& aTitle, const TDesC& aMsg) = 0;
	};

class MEikAlertWin
	{
public:
	virtual void ConstructL() = 0;
	virtual void RunAlert(const TDesC& aTitle, const TDesC& aMsg) = 0;
	virtual void Release() = 0;
	virtual CEikDialog* AsEikDialog() = 0;
	inline const CEikDialog* AsEikDialog() const;
	};

class MEikDebugKeys
	{
public:
	virtual void ConstructL() = 0;
	virtual void Release() = 0;
	};

inline CEikonEnv* CEikonEnv::Static()
	{ return((CEikonEnv*)(CCoeEnv::Static())); }
inline TInt CEikonEnv::EditableControlStandardHeight() const
	{ return(iEditableControlStandardHeight); }
inline CEikProcess* CEikonEnv::Process() const
	{ return(iProcess); }
inline CEikAppUi* CEikonEnv::EikAppUi() const
	{ return((CEikAppUi*)iAppUi); }
inline const MEikAlertWin* CEikonEnv::Alert() const
	{ return(iAlertWin); }
inline TChar CEikonEnv::NudgeCharMinus() const
	{return(iNudgeChars[0]);}
inline TChar CEikonEnv::NudgeCharPlus() const
	{return(iNudgeChars[1]);}
inline TRgb CEikonEnv::Color(TLogicalColor aLogicalColor) const
	{return ColorList().Color(aLogicalColor); }
inline CColorArray& CEikonEnv::CustomColorArray() const
	{return *(ColorList().ColorArray(TUid::Uid(KEikCustomColorsArrayValue)));}
inline CColorList& CEikonEnv::ColorList() const
	{ ; return *iColorList; }
inline void CEikonEnv::SetColor(TLogicalColor aLogicalColor, TRgb aColor)
	{ ColorList().SetColor(aLogicalColor, aColor); }
inline void CEikonEnv::SetCDlgDialogFactory(MEikCDlgDialogFactory* aDialogFactory)
	{iCDlgDialogFactory=aDialogFactory;}
inline void CEikonEnv::SetPrintDialogFactory(MEikPrintDialogFactory* aDialogFactory)
	{iPrintDialogFactory=aDialogFactory;}
inline void CEikonEnv::SetFileDialogFactory(MEikFileDialogFactory* aDialogFactory)
	{iFileDialogFactory=aDialogFactory;}
inline void CEikonEnv::SetIrFactory(MEikIrFactory* aIrFactory)
	{iIrFactory=aIrFactory;}
inline MEikCDlgDialogFactory* CEikonEnv::CDlgDialogFactory() const
	{return iCDlgDialogFactory;}
inline MEikPrintDialogFactory* CEikonEnv::PrintDialogFactory() const
	{return iPrintDialogFactory;}
inline MEikFileDialogFactory* CEikonEnv::FileDialogFactory() const
	{return iFileDialogFactory;}
inline MEikIrFactory* CEikonEnv::IrFactory() const
	{return iIrFactory;}
inline TInt CEikonEnv::AddLibraryL(TCreateByTypeFunction aControlFactory)
	{return(AddLibraryL(aControlFactory, 0L ));}
inline TInt CEikonEnv::AddLibraryL(TFileName* aResourceFile)
	{return(AddLibraryL(0L , aResourceFile));}
inline void CEikonEnv::RemoveLibrary(TCreateByTypeFunction aControlFactory)
	{RemoveLibrary(aControlFactory, 0L );}
inline void CEikonEnv::RemoveLibrary(TInt aResourceFileOffset)
	{RemoveLibrary(0L , aResourceFileOffset);}
inline void CEikonEnv::SetZoomFactor(TZoomFactor& aZoomFactor)
	{iZoomFactor=aZoomFactor;}
inline TZoomFactor CEikonEnv::ZoomFactor() const
	{return iZoomFactor;}
 



inline CBase* CEikonEnv::Extension() const
	{return iExtension;}
 


inline TInt CEikonEnv::StatusPaneCoreResId() const
	{return iStatusPaneCoreResId;}
 


inline void CEikonEnv::SetStatusPaneCoreResId(TInt aStatusPaneCoreResId)
	{iStatusPaneCoreResId=aStatusPaneCoreResId;}
inline CEikAutoMenuTitleArray* CEikonEnv::AutoMenuTitleArray() const
	{return iAutoMenuTitleArray;}

inline const CEikDialog* MEikAlertWin::AsEikDialog() const
	{return (const CEikDialog*)const_cast<MEikAlertWin*>(this)->AsEikDialog();}


 
enum TEikPortFlag
	{
	ESerialPort =0x01,
	EParallelPort =0x02,
	EIrdaPort= 0x04,
	EFilePort=0x08,
	EViaPCPort=0x10
	};

  void InternalizeL(TEikPortFlag& aThing,RReadStream& aStream);
inline RWriteStream& operator<<(RWriteStream& aStream,const TEikPortFlag& aThing)
	{aStream.WriteUint8L(aThing);return aStream;}
inline RReadStream& operator>>(RReadStream& aStream,TEikPortFlag& aThing)
	{InternalizeL(aThing,aStream);return aStream;}


# 36 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/biditext.h" 1
 
 
 
 






enum CGraphicsContext::TTextAlign;
class MLineBreaker;

 








class TBidiText
	{
public:
	 
	enum TDirectionality
		{
		 
		ELeftToRight = 0,
		 
		ERightToLeft = 1
		};
	  static TDirectionality ScriptDirectionality(TLanguage aLanguage);
	  static TDirectionality TextDirectionality(
		const TDesC& aText, TBool* aFound = 0);
protected:
	 
	TBidiText();
public:
	  static TBidiText* NewL(const TDesC& aText, TInt aMaxLines);
	  static TBidiText* NewL(const TDesC& aText, TInt aMaxLines,
		TDirectionality aDirectionality);
	  void SetTruncationChar(TChar aTruncateWith);
	  void WrapText(TInt aWrappingWidth, const CFont& aFont,
		const MLineBreaker* aBreaker, TInt aMaxLines);
	  void WrapText(TInt aWrappingWidth, const CFont& aFont,
		const MLineBreaker* aBreaker);
	  TPtrC Text() const;
	  TPtrC DisplayText() const;
	  TInt WrappingWidth() const;
	  TDirectionality Directionality() const;
	  TInt NumberOfLinesInDisplayText() const;
	  TPtrC LineOfDisplayText(TInt aLine, TInt& aWidth) const;
	  void DrawText(CGraphicsContext& aGc, const TPoint& aLeft) const;
	  void DrawText(CGraphicsContext& aGc,
		const TPoint& aLeft, TInt aBaseLineSpacing,
		CGraphicsContext::TTextAlign aAlignment) const;
	  void DrawText(CGraphicsContext& aGc,
		const TPoint& aLeft, TInt aBaseLineSpacing) const;
	};


# 37 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksbfrm.h" 1
 
 
 
 
	
# 675 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksbfrm.h"

# 38 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlayout.lag" 1
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlayoutdef.h" 1
 






















class TAknLayoutRect;


 


enum TAknLayoutId
	{
	EAknLayoutIdELAF = 0,
	EAknLayoutIdABRW = 1,
	EAknLayoutIdAPAC = 2
	};

 



class TAknLayoutTableLimits
	{
public:
	TInt iFirstIndex;
	TInt iLastIndex;
	};

 


class TAknWindowLineLayout
	{
public:
	inline TAknWindowLineLayout() {}
	inline TAknWindowLineLayout(TInt  ) {}

	 



	inline TBool IsRect() const;
	 







	inline TRect Rect() const;

public:
	TInt16 iC;
	TInt16 il;
	TInt16 it;
	TInt16 ir;
	TInt16 ib;
	TInt16 iW;
	TInt16 iH;
	};


 


class TAknTextLineLayout
	{
public:
	inline TAknTextLineLayout() {}
	inline TAknTextLineLayout(TInt  ) {}

	inline TInt FontId() const { return iFont; }
	inline TInt BaselineSkip() const { return iBaselineSkip; }
	inline TInt NumberOfLinesShown() const { return iNumberOfLinesShown; }

public:
	TInt16 iC;
	TInt16 il;
	TInt16 ir;
	TInt16 iB;
	TInt16 iW;
	TInt16 iJ;
	TInt16 iFont;

	TInt iBaselineSkip;
	TInt iNumberOfLinesShown;
	};


 




class TAknMultiLineTextLayout : public TAknTextLineLayout
	{
	};



inline TBool TAknWindowLineLayout::IsRect() const 
	{ 
	return (il!= (-16380)  && it!= (-16380)  && iW!= (-16380)  && iH!= (-16380) ); 
	}

inline TRect TAknWindowLineLayout::Rect() const 
	{ 
	  ; 
	return TRect(TPoint(il, it), TSize(iW, iH)); 
	}


 
# 11 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlayout.lag" 2



# 40 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknutils.h" 2


 
const TInt KMaxColumnDataLength = 80;  
const TInt KMaxTotalDataLength = 8*KMaxColumnDataLength;   

 














class CCoeControl;
class CEikTextListBox;
class CEikColumnListBox;
class CEikFormattedCellListBox;
class CGulIcon;
class CEikSettingsListBox;
class CAknLAF;
class CEikImage;
class CEikMfne;
class CEikListBox;
class CEikLabel;
class CEikEdwin;
class CEikMenuPane;
class CAknPopupField;
class CListBoxView;
class CAknColumnListBox;
class CEikSecretEditor;
class CFindExtension;
 



const TInt  KDefaultClipWidth = -1;
const TUint KDefaultClipChar  = TUint(0x2026);

 






class AknTextUtils 
    {
public:
    enum TClipDirection
	{
	EDoNotClip,
	EClipFromEnd,
	EClipFromBeginning
	};
     










    
      static TBool ClipToFit(TDes& aBuffer, const CFont& aFont, TInt aMaxWidthInPixels, TClipDirection aDir=EClipFromEnd, TInt aClipWidth = KDefaultClipWidth, const TDesC &aClipString= (TPtrC((const TText *)L"..." )) );

     





      static TBool ClipToFit(TDes& aBuffer, TClipDirection aDir, CEikFormattedCellListBox *aListBox, TInt aItemIndex, TInt aSubCellNumber);

     





      static TBool ClipToFit(TDes& aBuffer, TClipDirection aDir, CEikColumnListBox *aListBox, TInt aItemIndex, TInt aColumnNumber);
            
     









      static void WrapToArrayL( 
        const TDesC& aStringToWrap,
	    const CArrayFix<TInt>& aLineWidthArray,
	    const CFont& aFont,
	    CArrayFix<TPtrC>& aWrappedArray);

     









      static void WrapToArrayL( 
        const TDesC& aStringToWrap,
	    TInt aLineWidth,
	    const CFont& aFont,
	    CArrayFix<TPtrC>& aWrappedArray );

     















      static void WrapToArrayAndClipL( 
        TDes& aStringToWrap,             
	    const CArrayFix<TInt>& aLineWidthArray, 
	    const CFont& aFont,                     
	    CArrayFix<TPtrC>& aWrappedArray );       
	
	 
















	  static void ChopToArrayAndClipL(
		TDes& aStringToChop,             
	    const CArrayFix<TInt>& aLineWidthArray, 
	    const CFont& aFont,                    
	    CArrayFix<TPtrC>& aChoppedArray);

	 
















	  static void ChopToArrayAndClipL(
		TDes& aStringToChop,             
	    TInt aLineWidth, 
	    const CFont& aFont,                    
	    CArrayFix<TPtrC>& aChoppedArray );

     











      static void WrapToStringL( 
        const TDesC& aStringToWrap,
	    const CArrayFix<TInt>& aLineWidthArray,
	    const CFont& aFont,
	    TDes& aWrappedString );

    













	  static void WrapToStringAndClipL(
	    const TDesC& aStringToWrap, 
	    const CArrayFix<TInt>& aLineWidthArray, 
	    const CFont& aFont, 
	    TDes& aWrappedString ); 

     














      static void StripCharacters(TDes &aDes, const TDesC &aCharacters);

     










      static void ReplaceCharacters(TDes &aDes, const TDesC &aChars, TChar aReplacement);

     






      static void PackWhiteSpaces(TDes &aDes, const TDesC &aWhiteSpaceChars);
    
     

    static void WrapToStringL(
        const TDesC& aStringToWrap, 
	    const CArrayFix<TInt>& aLineWidthArray, 
	    const CFont& aFont, 
	    TDes& aWrappedString,
        TInt aFlags,
        TInt aDirectionality );

    static void WrapToArrayL( 
        TDes& aStringToWrap,
        const CArrayFix<TInt>* aLineWidthArray, 
        const CFont& aFont,
        CArrayFix<TPtrC>& aWrappedArray,
        TInt aLineWidth,
        TInt aFlags,
        TInt aDirectionality );

    static void ChopToArrayAndClipL(
		TDes& aStringToChop,             
	    const CArrayFix<TInt>* aLineWidthArray,
	    const CFont& aFont,                 
	    CArrayFix<TPtrC>& aChoppedArray,
        TInt aLineWidth );    

	 






	static TBool IsEmptyText( const TDesC& aTextToTest );

	 













	  static void LanguageSpecificNumberConversion(TDes &aDes);

     







      static void ConvertDigitsTo( TDes& aDes, TDigitType aDigitType );

     











      static TBidiText::TDirectionality CurrentScriptDirectionality();

     





    static TDigitType InputLanguageFilteredDigitType();

     





    static TDigitType DisplayTextLanguageFilteredDigitType();

     




 
	  static TDigitType NumericEditorDigitType();

     















      static void DisplayTextLanguageSpecificNumberConversion(TDes &aDes);
  
     









 
      static TDigitType TextEditorDigitType();

	enum TDigitModeQueryType {
		EDigitModeEditorDefault,  
		EDigitModeUserModifiableEditor,  
	    EDigitModeShownToUser  
	};
	 













	  static TBool DigitModeQuery(TDigitModeQueryType aQueryType = EDigitModeShownToUser);

     





      static HBufC *ConvertFileNameL(const TDesC &aDes);


     



      static HBufC* LoadScalableTextL(CCoeEnv& aCoe, TInt aResourceId);

     



      static HBufC* LoadScalableTextLC(CCoeEnv& aCoe, TInt aResourceId);

     



      static TInt LoadScalableText(CCoeEnv& aCoe, TInt aResourceId, TDes& aBuffer ); 

     



      static HBufC* ClipAccordingScreenOrientationLC(CCoeEnv& aCoe, HBufC* aBuf); 

    };

static const TLitC<sizeof(L"\t" )/2>  KAknStripTabs ={sizeof(L"\t" )/2-1,L"\t" } ;
static const TLitC<sizeof(L"\t\n" )/2>  KAknStripListControlChars ={sizeof(L"\t\n" )/2-1,L"\t\n" } ;
static const TLitC<sizeof(L"\t" )/2>  KAknReplaceTabs ={sizeof(L"\t" )/2-1,L"\t" } ;
static const TLitC<sizeof(L"\t\n" )/2>  KAknReplaceListControlChars ={sizeof(L"\t\n" )/2-1,L"\t\n" } ;
static const TLitC<sizeof(L" \n\t\r" )/2>  KAknCommonWhiteSpaceCharacters ={sizeof(L" \n\t\r" )/2-1,L" \n\t\r" } ;

 









class AknSelectionService
    {
public:
     

      static void HandleSelectionListProcessCommandL(TInt aCommand, CEikListBox* aListBox);
     

      static void HandleMultiselectionListProcessCommandL(TInt aCommand, CEikListBox* aListBox);
     

      static void HandleMarkableListProcessCommandL(TInt aCommand, CEikListBox* aListBox);

     

      static TKeyResponse HandleMenuListOfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType, CEikListBox* aListBox);
     

      static void HandleMarkableListDynInitMenuPane(TInt aResourceId, CEikMenuPane *aMenu, CEikListBox *aListBox);
     

      static void HandleMarkableListDynInitMenuItem(CEikMenuPane *aMenu, CEikListBox *aListBox, TInt aCommandId, TBool aCanBeAppliedToMultipleItems);
     

      static void HandleMarkableListUpdateAfterCommandExecution(CEikListBox *aListBox);

     

      static void HandleItemRemovalAndPositionHighlightL(CEikListBox *aListBox, TInt aValueOfCurrentItemIndexBeforeRemoval, TBool aCurrentItemWasRemoved);
     
     




      static void HandleItemRemovalAndPositionHighlightL(CEikListBox *aListBox, TInt aValueOfCurrentItemIndexBeforeRemoval, CArrayFix<TInt> &aIndexesOfRemovedItemsBeforeRemoval);
    };



class CAknSearchField;

 











class AknFind
    {
public:
      static void HandleFindPopupProcessCommandL(TInt aCommand, CEikListBox *aListBox, CAknSearchField *aSearchField, CCoeControl *aParentControl);
      static TKeyResponse HandleFindOfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType, CCoeControl *aListBoxParent, CEikListBox *aListBox, CAknSearchField *aSearchField, TBool isFindPopup, TBool &aNeedRefresh);

     




      static void HandleFindSizeChanged(CCoeControl *aParentControl, 
					       CEikListBox *aListBox, 
					       CAknSearchField *aSearchField, 
					       TBool ispopup = ETrue, 
					       TInt aFindWindowResourceId = 0x8cc007e , 
					       TInt aListAreaId = 0x8cc0075 , 
					       TInt aListResourceIdWithFindPopup = 0x8cc0074 , 
					       TInt aFindWindowParentResourceId = 0x8cc007d );

     

      static void HandleFixedFindSizeChanged(CCoeControl *aParentControl,
						    CAknColumnListBox *aListBox,  
						    CAknSearchField *aSearchField);
    
     

      static void HandlePopupFindSizeChanged(CCoeControl *aParentControl,
						    CEikListBox *aListBox,   
						    CAknSearchField *aSearchField);
     



      static void HandleFindSizeChangedLayouts(CCoeControl *aParentControl, 
        CEikListBox* aListBox, 
        CAknSearchField* aSearchField, 
        const TAknWindowLineLayout& aFindWindow,
        const TAknWindowLineLayout& aListArea,
        TBool aIsPopup,
        const TAknWindowLineLayout& aFindWindowParent );

public:
     



      static TBool IsFindMatch(const TDesC& aItemText, const TDesC& aSearchText);

     


      static TBool IsFindWordSeparator(TChar aCh);


     


    static void HandleFindPaneVisibility(CAknSearchField *aSearchField, TBool ispopup, TBool textchanged, TBool &aNeedRefresh);

    };


 




class AknEditUtils
    {
    public:
    struct SAknEditorParameters 
	{
	TInt iEditingSpace;
	TInt iEditingWindow;
	TInt iCharacterCase;
	TInt iJustification;
	TBool iAllowedToMoveInsertionPoint;
	TBool iCursorYesNo;
	TBool iOverflowYesNo;
	};

      static void ConstructEditingL(CEikEdwin* aEdwin, TInt aResourceId);
      static void ConstructEditingL(CEikEdwin* aEdwin, TResourceReader& aReader);
      static void ConstructEditingL(CEikEdwin* aEdwin, const SAknEditorParameters &aParams);

 

















      static void ConstructEditingL(CEikEdwin* aEdwin, 
					   TInt aEditingSpace, 
                       TInt aEditingWindow, 
                       TInt aCharacterCase, 
                       TInt aJustification, 
                       TBool aAllowedToMoveInsertionPoint, 
                       TBool aCursorYesNo, 
                       TBool aOverflowYesNo);
                       
 


















      static void ConstructEditingL(CEikEdwin* aEdwin, 
                                              TInt aEditingSpace, 
                                              TInt aEditingWindow, 
                                              TInt aCharacterCase, 
                                              TInt aJustification, 
                                              TBool aAllowedToMoveInsertionPoint, 
                                              TBool aCursorYesNo, 
                                              TBool aOverflowYesNo,
                                              TBool aIsResizable);

    };

 






class CListBoxNumbers : public CBase
	{
public:
	  CListBoxNumbers(CEikTextListBox* aListBox);
	  void ConstructL();
	  void UpdateL();
private:
	CEikTextListBox* iListBox;
	};

class CAknListBoxFilterItems;

 






class CAknFilteredTextListBoxModel : public CTextListBoxModel, public MDesC16Array 
    {
public:  
     


      void CreateFilterL(CEikListBox* aListBox, CAknSearchField* aSearchField);
     


      CAknListBoxFilterItems* Filter() const;
     


      ~CAknFilteredTextListBoxModel();
public:  
     


      virtual TInt NumberOfItems() const;
     


      virtual TPtrC ItemText(TInt aItemIndex) const;
public:  
     


      const MDesC16Array * MatchableTextArray() const;

private:
    CAknListBoxFilterItems* iFilter;  
private:  
      TInt MdcaCount() const;
      TPtrC MdcaPoint(TInt aIndex) const;
private:  
	  virtual TAny* MListBoxModel_Reserved();
    };

 



















class CAknListBoxFilterItems : public CBase, public MCoeControlObserver
    {
public:
      CAknListBoxFilterItems(CEikListBox *aListBox, CAknSearchField *aSearchField, MListBoxModel *aModel, CListBoxView *aView);
      void ConstructL();  
     



      void ResetFilteringL();
     



      void UpdateCachedDataL();  
      ~CAknListBoxFilterItems();    

public: 
     

      CArrayFix<TInt> *SelectionIndexes();
     





      void UpdateSelectionIndexesL();
      void UpdateSelectionIndexL(TInt aVisibleIndex);

public:  
     


      TInt FilteredNumberOfItems() const;
     





      TInt FilteredItemIndex(TInt aVisibleItemIndex) const;

public:  

     

      TInt NonFilteredNumberOfItems() const;  
     






      TInt VisibleItemIndex(TInt aOriginalIndex) const;
public: 
     



      TPtrC DefaultMatchableItemFromItem(TPtrC aText);

public: 
     

      void HandleOfferkeyEventL();
     


      void HandleItemArrayChangeL();

public:  
     


      void SetObserver(MCoeControlObserver *aObserver);
     


      void HandleControlEventL(CCoeControl *aControl, TCoeEvent aEventType);

public:  
     







      void DeferredSendKeyEventToFepL(TUint aValue);
     


    static TInt IdleCallBack(TAny *aFilterItems);

public:  
     




      void SetParentControl(CCoeControl *aControl);
    



      void SetPopup();

public:  
	 




	  void SetListBox(CEikListBox *aListBox);
	 




	  void SetSearchField(CAknSearchField *aSearchField);
	 




	  void SetModel(MListBoxModel *aModel);
	 




	  void SetView(CListBoxView *aView);

public:
      CCoeControl *FindBox() const;

private:
    void NoCriteriaL();  
    void TightenCriteriaL(const TDesC& aCriteria);  
    void ReleaseCriteriaL(const TDesC& aCriteria);  
     
    void InstallEmptyTextL();
    void UninstallEmptyTextL();
     
     
    void FetchSelectionIndexesFromListBoxL();
    void PushSelectionIndexesToListBoxL();

     
    void HandleItemAdditionL();
    void HandleItemRemovalL();
private:
    TBool IsItemVisible(const TDesC& aMatchableItemString, const TDesC& aSearchText);
    static TBool IsSeparatorCharacter(TChar c);
    TBool IsItemSelected(TInt aRealIndex) const;
private:
    CArrayFix<TInt> *iShownIndexes;  
    CArrayFix<TInt> *iSelectionIndexes;  
    HBufC *iOldSearchCriteria;  
    MListBoxModel *iModel;
    CListBoxView *iView;
    TInt iOldItemCount;
    HBufC* iEmptyListText;  
    CEikListBox* iListBox;
    CAknSearchField* iSearchField;
    TBuf<256> iMatchableText;
    MCoeControlObserver *iObserver;
    CFindExtension *iExtension;
    TUint iKeyValue;
    CCoeControl *iParentControl;
    TBool iIsPopup;
    TBool iDisableChangesToShownIndexes;
    };


 





template<class T>
class NoOptimizationView : public T
    {
public:
    virtual void VScrollTo(TInt aNewTopItemIndex, TRect& aMinRedrawRect)
	{
	 
	if (this->RedrawDisabled())
		return;
	if (this->iTopItemIndex == aNewTopItemIndex)
		return;
	aMinRedrawRect.SetRect(this->iViewRect.iTl,this->iViewRect.Size());
	this->SetTopItemIndex(aNewTopItemIndex);
	this->Draw(&aMinRedrawRect);
	 
	}
    };


 





class AknLAFUtils 
	{
public:
	static void DrawLines(CGraphicsContext* aGc, 
			      const TRect& mainpane,
			      TInt x);
	  static void ReplaceColumn(TPtr aTarget, TDesC* aSource, TDesC* aReplacement, TChar aColumnSeparator, TInt aColumn);
	};


 








struct SAknLayoutGfx;
struct SAknLayoutText;
struct SAknLayoutCmd;
struct SAknLayoutGfx;
 
struct SAknLayoutPos 
    {
    TInt l, t, r, b, W, H;

    typedef SAknLayoutPos ItemType;
    static void ReadResource(TResourceReader& aReader, ItemType& aTarget);    
    };
template<class T> class CArrayReader;
class CAknGenericReader : public CBase
    {
public:
      void ConstructL(TInt aResourceId);
      virtual void ConstructFromResourceL(TResourceReader& aReader);
      ~CAknGenericReader();

      const SAknLayoutGfx* GfxItem(TInt aIndex) const;
      const SAknLayoutText* TextItem(TInt aIndex) const;
      const SAknLayoutCmd* CmdItem(TInt aIndex) const;
      const SAknLayoutGfx* AreaItem(TInt aIndex) const;

    CArrayReader<SAknLayoutGfx>* iGfx;
    CArrayReader<SAknLayoutText>* iText;
    CArrayReader<SAknLayoutCmd>* iCmd;
    CArrayReader<SAknLayoutGfx>* iArea;
    };



 
const TInt AknLayoutUtilsNoValue = (-16380) ;

 






























class AknLayoutUtils
    {
public:

    struct SAknLayoutText
	{
	TInt iFont, iC, iL, iR, iB, iW, iJ;
	};
    struct SAknLayoutTextMultiline
	{
	TInt iFont, iC, iL, iR, iB, iW, iJ, iNumberOfLinesShown, iNextLineB;
	};
    typedef SAknLayoutTextMultiline SAknLayoutLabel;
    typedef SAknLayoutTextMultiline SAknLayoutEdwin;
    typedef SAknLayoutText SAknLayoutMfne;
    typedef SAknLayoutText SAknLayoutSecEd;
    struct SAknLayoutRect
	{
	TInt iC, iL, iT, iR, iB, iW, iH;
	};
    typedef SAknLayoutRect SAknLayoutControl;
    typedef SAknLayoutRect SAknLayoutImage;

     


      static void LayoutLabel(CEikLabel* aLabel, const TRect& aLabelParent, TInt aResourceId, const CFont* aCustomFont=0);
     


      static void LayoutLabel(CEikLabel* aLabel, const TRect& aLabelParent, TResourceReader& aReader, const CFont* aCustomFont=0);
     


      static void LayoutLabel(CEikLabel* aLabel, const TRect& aLabelParent, const SAknLayoutLabel& aLayout, const CFont *aCustomFont=0);
     


      static void LayoutLabel(CEikLabel* aLabel, const TRect& aLabelParent, const TAknMultiLineTextLayout& aLayout, const CFont *aCustomFont=0);
     


      static void LayoutLabel(CEikLabel* aLabel, const TRect& aLabelParent, const TAknTextLineLayout& aLayout, const CFont *aCustomFont=0);
     











      static void LayoutLabel(CEikLabel* aLabel, const TRect& aLabelParent, TInt font, TInt C, TInt l, TInt r, TInt B, TInt W, TInt J, TInt NextLineB=0, const CFont* aCustomFont=0);

     


      static void LayoutEdwin(CEikEdwin* aEdwin, const TRect& aEdwinParent, TInt aResourceId, TInt aNumberOfLines = 0, const CFont* aCustomFont=0, TBool aMinimizeEdwinView=EFalse);
     


      static void LayoutEdwin(CEikEdwin* aEdwin, const TRect& aEdwinParent, TResourceReader& aReader, TInt aNumberOfLines = 0, const CFont* aCustomFont=0, TBool aMinimizeEdwinView=EFalse);

     


      static void LayoutEdwin(CEikEdwin* aEdwin, const TRect& aEdwinParent, const SAknLayoutEdwin& aLayout, const CFont* aCustomFont=0, TBool aMinimizeEdwinView=EFalse);
     



	  static void LayoutEdwin(CEikEdwin* aEdwin, const TRect& aEdwinParent, const TAknMultiLineTextLayout& aLayout, const CFont* aCustomFont=0, TBool aMinimizeEdwinView=EFalse);
 

     static void LayoutEdwin(CEikEdwin* aEdwin, const TRect& aEdwinParent, const TAknTextLineLayout& aLayout, const CFont* aCustomFont=0, TBool aMinimizeEdwinView=EFalse);
     












      static void LayoutEdwin(CEikEdwin* aEdwin, const TRect& aEdwinParent, TInt font, TInt C, TInt l, TInt r, TInt B, TInt W, TInt J, TInt aNumberOfLinesShown, TInt aNextLineBaseline, const CFont* aCustomFont=0 , TBool aMinimizeEdwinView=EFalse);
     


      static TRect MinimizedEdwinRect(const CEikEdwin *aEdwin);


     


      static void LayoutMfne(CEikMfne* aMfne, const TRect& aMfneParent, TInt aResourceId);
     


      static void LayoutMfne(CEikMfne* aMfne, const TRect& aMfneParent, TResourceReader& aReader);

      static void LayoutMfne(CEikMfne* aMfne, const TRect& aMfneParent, const SAknLayoutMfne& aLayout);
      static void LayoutMfne(CEikMfne* aMfne, const TRect& aMfneParent, const TAknTextLineLayout& aLayout);
      static void LayoutMfne(CEikMfne* aMfne, const TRect& aMfneParent, TInt font, TInt C, TInt l, TInt r, TInt B, TInt W, TInt J);

     


      static void LayoutControl(CCoeControl* aControl, const TRect& aControlParent, TInt aResourceId);
     


      static void LayoutControl(CCoeControl* aControl, const TRect& aControlParent, TResourceReader& aReader);

      static void LayoutControl(CCoeControl* aControl, const TRect& aControlParent, const SAknLayoutControl& aLayout);
      static void LayoutControl(CCoeControl* aControl, const TRect& aControlParent, const TAknWindowLineLayout& aLayout);
      static void LayoutControl(CCoeControl* aControl, const TRect& aControlParent, TInt  , TInt l, TInt t, TInt r, TInt b, TInt W, TInt H);

     


      static void LayoutImage(CEikImage* aImage, const TRect& aParent, TInt aResourceId);
     

    
      static void LayoutImage(CEikImage* aImage, const TRect& aParent, TResourceReader& aReader);

      static void LayoutImage(CEikImage* aImage, const TRect& aParent, const SAknLayoutControl& aLayout);
      static void LayoutImage(CEikImage* aImage, const TRect& aParent, const TAknWindowLineLayout& aLayout);
      static void LayoutImage(CEikImage* aImage, const TRect& aParent, TInt C, TInt l, TInt t, TInt r, TInt b, TInt W, TInt H);

     


      static void LayoutSecretEditor(CEikSecretEditor* aSecEd, const TRect& aParent, const SAknLayoutText& aLayout);
      static void LayoutSecretEditor(CEikSecretEditor* aSecEd, const TRect& aParent, const TAknTextLineLayout& aLayout);

public:
     




      static TRect TextRectFromCoords(const TRect& aParent, const CFont* aFont, TInt l, TInt r, TInt B, TInt W, TInt LB = 0);
      static TRect RectFromCoords(const TRect& aParent, TInt l, TInt t, TInt r, TInt b, TInt W, TInt H);

     

















      static const CFont* FontFromId(TInt aFontId, const CFont* aCustomFont=0);

      static const CFont* FontFromName(const TDesC& aName); 

	  static CGraphicsContext::TTextAlign TextAlignFromId(TInt aId);
      static TGulAlignment GulAlignFromId(TInt aId);

	  static TInt CursorHeightFromFont(const TFontSpec& aFont);
	  static TInt CursorWidthFromFont (const TFontSpec& aFont);
	  static TInt CursorAscentFromFont(const TFontSpec& aFont);
	  static void CursorExtensionsFromFont(const TFontSpec&  , TInt& aFirstExtension, TInt& aSecondExtension);

	  static TInt HighlightLeftPixelsFromFont (const TFontSpec& aFont);
	  static TInt HighlightRightPixelsFromFont(const TFontSpec& aFont);
    static void HighlightExtensionsFromFont(const CFont* aFont, TInt& aLeft, TInt& aRight, TInt&  aTop, TInt& aBottom);

	  static TBool LayoutMirrored();

     








	  static EVariantFlag Variant();

     






	  static EVariantFlag Variant( CEikonEnv& aEnv );

      static ESubVariantFlag SubVariant();

	  static void OverrideControlColorL(CCoeControl& aControl, TLogicalColor aLogicalColor, TRgb aColor);
    
     













      static CEikScrollBarFrame::TScrollBarType DefaultScrollBarType(CEikAppUi* aApplication);

     



























      static void LayoutVerticalScrollBar(CEikScrollBarFrame* aScrollBarFrame, const TRect& aControlParent, const TAknWindowLineLayout& aLayout);

     












      static void LayoutHorizontalScrollBar(CEikScrollBarFrame* aScrollBarFrame, const TRect& aControlParent, const TAknWindowLineLayout& aLayout);

public:    
	enum TAknLayoutMetrics
		{
		EScreen,
		EApplicationWindow,
		EStatusPane,
		EMainPane,
		EControlPane,
		ESignalPane,
		EContextPane,
		ETitlePane,
		EBatteryPane,
		EUniversalIndicatorPane,
		ENaviPane,
		EFindPane,
		EWallpaperPane,
		EIndicatorPane,
		EAColunm,
		EBColunm,
		ECColunm,
		EDColunm
		};


	 






      static void LayoutMetricsRect(TAknLayoutMetrics aParam, TRect& aRect);

	 






      static void LayoutMetricsSize(TAknLayoutMetrics aParam, TSize& aSize);

	 






	  static void LayoutMetricsPosition(TAknLayoutMetrics aParan, TPoint& aPos);
};

 



class TAknLayoutText
    {
public:
      TAknLayoutText();
     



      void LayoutText(const TRect& aParent, TInt aResourceId, const CFont* aCustomFont=0);
      void LayoutText(const TRect& aParent, TResourceReader& aReader, const CFont* aCustomFont=0);
      void LayoutText(const TRect& aParent, const AknLayoutUtils::SAknLayoutText& aLayout, const CFont* aCustomFont=0);
      void LayoutText(const TRect& aParent, const TAknTextLineLayout& aLayout, const CFont* aCustomFont=0);
      void LayoutText(const TRect& aParent, TInt fontid, TInt C, TInt l, TInt r, TInt B, TInt W, TInt J, const CFont* aCustomFont=0);

     

      void DrawText(CGraphicsContext& aGc, const TDesC& aText) const;
    
     




      void DrawText(
        CGraphicsContext& aGc,
        const TDesC& aText,
        TBool aUseLogicalToVisualConversion ) const;

      void DrawText(
        CGraphicsContext& aGc,
        const TDesC& aText,
        TBool aUseLogicalToVisualConversion,
        const TRgb &aColor) const;
                           

public:
     




      TRect TextRect() const;
    const CFont *Font() const { return iFont; }
    TRgb Color() const { return CEikonEnv::AvkonColor( iColor ) ; }
    CGraphicsContext::TTextAlign Align() const { return iAlign; }
private:
    TRect iTextRect;
    const CFont *iFont;  
    TInt iColor;
    TInt iOffset;
    CGraphicsContext::TTextAlign iAlign;
    };

 







class TAknLayoutRect
    {    
public:
      TAknLayoutRect();
     

      void LayoutRect(const TRect &aParent, TInt aResourceId);
      void LayoutRect(const TRect &aParent, TResourceReader &aReader);
      void LayoutRect(const TRect &aParent, const AknLayoutUtils::SAknLayoutRect &aLayout);
      void LayoutRect(const TRect &aParent, const TAknWindowLineLayout &aLayout);
      void LayoutRect(const TRect &aParent, TInt C, TInt l, TInt t, TInt r, TInt b, TInt W, TInt H);
    
     






    
      TRgb Color() const;
     

      TRect Rect() const;
	TBool Valid() const;

     

      void DrawRect(CWindowGc& aGc) const;
      void DrawOutLineRect(CWindowGc& aGc) const;
      void DrawImage(CBitmapContext& aGc, CFbsBitmap* aBitmap, CFbsBitmap* aMask) const;
private:
    TInt iColor;
    TRect iRect;
    };

 


class AknDraw 
    {
public:
     





      static void DrawEmptyList(const TRect& aRect, CWindowGc& aGc, TPtrC aText);
     





      static void DrawEmptyListForSettingPage(const TRect &aRect, CWindowGc &aGc, TPtrC text);  
     





      static void DrawEmptyListWithFind(const TRect& aClientRect, CWindowGc& aGc, TPtrC aText);  
     





      static void DrawEmptyListHeading(const TRect &aClientRect, CWindowGc& aGc, TPtrC aText);  
     
     







      static void DrawWindowShadow(CWindowGc& aGc, const TAknLayoutRect& aCoverRect, const TAknLayoutRect& aSecondShadowRect, const TAknLayoutRect& aFirstShadowRect, const TAknLayoutRect& aOutlineFrameRect, const TAknLayoutRect& aInsideAreaRect);
public:

     







      static void DrawEmptyListImpl(const TRect& aRect, CWindowGc& aGc, TPtrC aText, TInt aLayoutLine1, TInt aLayoutLine2);
    
    };

 


class AknDrawWithSkins
    {
public:
     





      static void DrawEmptyList(const TRect& aRect, CWindowGc& aGc, TPtrC aText, CCoeControl *aControl);
     





      static void DrawEmptyListForSettingPage(const TRect &aRect, CWindowGc &aGc, TPtrC text, CCoeControl *aControl);  
     





      static void DrawEmptyListWithFind(const TRect& aClientRect, CWindowGc& aGc, TPtrC aText, CCoeControl *aControl);  
     





      static void DrawEmptyListHeading(const TRect &aClientRect, CWindowGc& aGc, TPtrC aText, CCoeControl *aControl);  
     
     







      static void DrawWindowShadow(CWindowGc& aGc, const TAknLayoutRect& aCoverRect, const TAknLayoutRect& aSecondShadowRect, const TAknLayoutRect& aFirstShadowRect, const TAknLayoutRect& aOutlineFrameRect, const TAknLayoutRect& aInsideAreaRect, CCoeControl *aControl);
    
    };




 
 
  const CFont *LatinPlain12();
  const CFont *LatinBold12();
  const CFont *LatinBold13();
  const CFont *LatinBold16();  
  const CFont *LatinBold17();
  const CFont *LatinBold19(); 
  const CFont *NumberPlain5();
  const CFont *ClockBold30();
  const CFont *LatinClock14();



  const CFont *ApacPlain12();
  const CFont *ApacPlain16();


 

























  TInt CompleteWithAppPath( TDes& aFileName );



 









# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopuplayout.h" 2



struct TAknPopupWindowLayoutDef;
class CEikListBox;
class CAknPopupHeadingPane;
class CWindowGc;
class CCoeControl;
class CEikonEnv;

const TInt EAknPopupLayoutsDynamic = 0x80;
const TInt EAknPopupLayoutsFind = 0x100;

 

















struct TAknPopupLayoutsNode;
struct TAknPopupLayoutsNode
{
	TAknPopupLayoutsNode *iNext;
	TInt iId;
	CCoeControl *iControl;
};
enum TAknPopupLayoutsNodeList
{
	EListNode = 0x5555,
	EHeadingNode,
	EWindowOwningNode,
	EMessageBoxNode,
    EFindBoxNode
};

class AknPopupLayouts
    {
public: 
     







    enum TAknPopupLayouts
	{
	 
	EMenuWindow,  
	EMenuGraphicWindow,  
	EMenuGraphicHeadingWindow,  
	EMenuDoubleWindow,  
	EMenuDoubleLargeGraphicWindow,  
	EPopupSNotePopupWindow,
	
	 
	 
	 
	EDynMenuWindow = EMenuWindow + 0x80,
	EDynMenuGraphicWindow,
	EDynMenuGraphicHeadingWindow,
	EDynMenuDoubleWindow,
	EDynMenuDoubleLargeGraphicWindow,
	};

public:  
    

    






      static void HandleSizeChanged(TAknPopupWindowLayoutDef &aDef,
					   TAknPopupLayouts aLayout,
					   TAknPopupLayoutsNode *aListOfControls);
      static void HandleSizeChanged(TAknPopupWindowLayoutDef &aDef, 
				  TAknPopupLayouts aLayout,
				  CAknPopupHeadingPane *aHeadingOrNull,
				  CEikListBox *aListBox,
				  CCoeControl *aWindowOwningControl);
    

    
      static void HandleDraw(CEikonEnv* aEikEnv,
			   CWindowGc &aGc,
			   const TAknPopupWindowLayoutDef &aDef, 
			   CEikListBox *aListBox,
			   CAknPopupHeadingPane *aHeadingOrNull);


public:  
    


      static void ModifyWindowGraphicForHeading(TAknPopupWindowLayoutDef &aDef);
      static void ModifyWindowGraphicForMessageBox(TAknPopupWindowLayoutDef &aDef, TInt aNumOfLines);

public:  
    


      static void CalcPopupMenuWindow(TAknPopupWindowLayoutDef &aDef, 
					     TRect aClientRect, 
					     TInt aNumberOfLinesInListBox);
    


      static void CalcPopupMenuGraphicWindow(TAknPopupWindowLayoutDef &aDef,
						    TRect aClientRect, 
						    TInt aNumberOfLinesInListBox);
    


      static void CalcPopupMenuGraphicHeadingWindow(TAknPopupWindowLayoutDef &aDef,
							   TRect aClientRect, 
							   TInt aNumberOfLinesInListBox);
    


      static void CalcPopupMenuDoubleWindow(TAknPopupWindowLayoutDef &aDef,
						   TRect aClientRect, 
						   TInt aNumberOfLinesInListBox);
    


      static void CalcPopupMenuDoubleLargeGraphicWindow(TAknPopupWindowLayoutDef &aDef,
							       TRect aClientRect, 
							       TInt aNumberOfLinesInListBox);
    


      static void CalcPopupSNoteGroupWindow(TAknPopupWindowLayoutDef &aDef, 
						   TRect aClientRect, 
						   TInt aNumberOfLinesInListBox);

     


      static void SetupMenuPopupWindow(TAknPopupWindowLayoutDef &aDef, 
					      TInt aNumberOfLinesInListBox, 
					      TBool aHeading);
     


      static void SetupPopupMenuGraphicWindow(TAknPopupWindowLayoutDef &aDef, 
						     TInt aNumberOfLinesInListBox,
						     TBool aHeading);
     


      static void SetupPopupMenuGraphicHeadingWindow(TAknPopupWindowLayoutDef &aDef, 
							    TInt aNumberOfLinesInListBox, 
							    TBool aHeading);
     


      static void SetupPopupMenuDoubleWindow(TAknPopupWindowLayoutDef &aDef, 
						    TInt aNumberOfLinesInListBox, 
						    TBool aHeading);    
     


      static void SetupImageSelectionMenuPopupWindow(TAknPopupWindowLayoutDef &aDef,
							    TInt num, 
							    TBool heading);
     


      static void SetupPopupSNoteGroupWindow(TAknPopupWindowLayoutDef &aDef,
						    TInt num,
						    TBool heading);

    
public:  
      static void HandleSizeAndPositionOfComponents(const TAknPopupWindowLayoutDef &aDef, 
						  CCoeControl *aContentInsidePopup,
						  CAknPopupHeadingPane *aHeadingOrNull);
      static void SetupDefaults(TAknPopupWindowLayoutDef &aDef);
public:  
     


      static TRect WindowRect(TAknPopupWindowLayoutDef &aDef);
     


      static TRect MenuRect(TAknPopupWindowLayoutDef &aDef);
     


      static void CheckRange(TInt &aValue, TInt aMin, TInt aMax);
     


      static void MenuPopupWindowGraphics(TAknPopupWindowLayoutDef &aDef);
    };

 




struct TAknPopupWindowLayoutDef
    {
    __attribute__(( dllexport ))   TAknPopupWindowLayoutDef();
    TAknLayoutRect iListRect;
    TAknLayoutRect iHeadingRect;
    
    TAknLayoutRect iCover;
    TAknLayoutRect iSecond;
    TAknLayoutRect iFirst;
    TAknLayoutRect iOutline;
    TAknLayoutRect iInside;
    
    TAknLayoutRect iVertLineExt1;
    TAknLayoutRect iVertLineExt2;

     
    TRect iWindowRect;

     
    TPoint iPopupMenuWindowOffset;
    TInt iMaximumHeight;
    };





# 31 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknintermediate.h" 1
 

















 












class MAknIntermediateState
    {
public:
    virtual void CloseState() = 0;
    };


# 32 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 1
 



















   



 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h" 1
 
 
 
 

# 338 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulbordr.h"

# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 1
 
 
 
 
 



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h" 1
 
 
 
 
# 376 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/s32std.h"

# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/medobsrv.h" 1
 
 
 
 








class MEditObserver
 











	{
public:
	 
	 
	 
	 
	 
	
	
	 










	virtual void EditObserver(TInt aStart, TInt aExtent) = 0;
	};


# 12 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h" 1
 
 
 
 

# 359 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulutil.h"


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fepbase.h" 1
 
 
 
 




























 
















# 65 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fepbase.h"

 












 
















# 114 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fepbase.h"

 














class TFepOnOrOffKeyData
 



























	{
public:
	inline TFepOnOrOffKeyData(TUint aCharacterCodeForFoldedMatch, TUint aModifierMask, TUint aModifierValues) :iCharacterCodeForFoldedMatch(aCharacterCodeForFoldedMatch), iModifierMask(aModifierMask), iModifierValues(aModifierValues) 
	 





		{}

	inline TUint CharacterCodeForFoldedMatch() const 
	 


		{return iCharacterCodeForFoldedMatch;}
	inline TUint ModifierMask() const 
	 


		{return iModifierMask;}
	inline TUint ModifierValues() const 
	 


		{return iModifierValues;}
private:
	TUint iCharacterCodeForFoldedMatch;
	TUint iModifierMask;
	TUint iModifierValues;
	};

class CDictionaryStore;
class RWriteStream;
class RReadStream;


class CFepGenericGlobalSettings : public CBase
 
















	{
public:
	  static CFepGenericGlobalSettings* NewL(CCoeEnv& aConeEnvironment, const TFepOnOrOffKeyData& aDefaultOnKeyData, const TFepOnOrOffKeyData& aDefaultOffKeyData, TBool aDefaultIsOn);
	  static CFepGenericGlobalSettings* NewLC(CCoeEnv& aConeEnvironment, const TFepOnOrOffKeyData& aDefaultOnKeyData, const TFepOnOrOffKeyData& aDefaultOffKeyData, TBool aDefaultIsOn);
	  TFepOnOrOffKeyData OnKeyData() const;
	  void SetOnKeyData(const TFepOnOrOffKeyData& aOnKeyData);
	  TFepOnOrOffKeyData OffKeyData() const;
	  void SetOffKeyData(const TFepOnOrOffKeyData& aOffKeyData);
	  TBool IsOn() const;
	  void SetIsOn(TBool aIsOn);
	  void StoreChangesAndBroadcastL();
	  void RefreshL();
	static void ReadOnAndOffKeyDataFromStreamL(TFepOnOrOffKeyData& aOnKeyData, TFepOnOrOffKeyData& aOffKeyData, RReadStream& aStream);
	static void ReadIsOnFromStreamL(TUint& aFlags, TUint aFlagIsOn, RReadStream& aStream);
	static void StoreIsOnAndBroadcastL(CCoeEnv& aConeEnvironment, TBool aIsOn);
private:
	CFepGenericGlobalSettings(CCoeEnv& aConeEnvironment, const TFepOnOrOffKeyData& aDefaultOnKeyData, const TFepOnOrOffKeyData& aDefaultOffKeyData, TBool aDefaultIsOn);
	void ConstructL();
	static void ReadOnOrOffKeyDataFromStreamL(TFepOnOrOffKeyData& aOnOrOffKeyData, RReadStream& aStream);
	static void WriteOnOrOffKeyDataToStreamL(const TFepOnOrOffKeyData& aOnOrOffKeyData, RWriteStream& aStream);
	static void WriteOnAndOffKeyDataAndBroadcastL(CCoeEnv& aConeEnvironment, const TFepOnOrOffKeyData& aOnKeyData, const TFepOnOrOffKeyData& aOffKeyData, CDictionaryStore& dictionaryStore);
	static void WriteIsOnDataAndBroadcastL(CCoeEnv& aConeEnvironment, TBool aIsOn, CDictionaryStore& aDictionaryStore);
private:
	enum
		{
		EFlagDefaultIsOn	=0x00000001,
		EFlagIsOn			=0x00000002
		};
private:
	CCoeEnv& iConeEnvironment;
	TUint iFlags;
	TFepOnOrOffKeyData iDefaultOnKeyData;
	TFepOnOrOffKeyData iDefaultOffKeyData;
	TFepOnOrOffKeyData iOnKeyData;
	TFepOnOrOffKeyData iOffKeyData;
	};


class MCoeFepObserver
 








	{
public:
	 
	  virtual void HandleStartOfTransactionL();  
	  virtual void HandleCompletionOfTransactionL();  
private:
	  virtual void MCoeFepObserver_Reserved_1();
	  virtual void MCoeFepObserver_Reserved_2();
	};

 












  void FepObserverHandleStartOfTransactionL(MCoeFepObserver& aFepObserver);


class CCoeFepParameters : public CBase
 



	{
public:  
	  static CCoeFepParameters* NewL(const TFepOnOrOffKeyData& aDefaultOnKeyData, const TFepOnOrOffKeyData& aDefaultOffKeyData, TBool aDefaultIsOn);
	  static CCoeFepParameters* NewLC(const TFepOnOrOffKeyData& aDefaultOnKeyData, const TFepOnOrOffKeyData& aDefaultOffKeyData, TBool aDefaultIsOn);
	TFepOnOrOffKeyData DefaultOnKeyData() const;
	TFepOnOrOffKeyData DefaultOffKeyData() const;
	TBool DefaultIsOn() const;
private:
	CCoeFepParameters(const TFepOnOrOffKeyData& aDefaultOnKeyData, const TFepOnOrOffKeyData& aDefaultOffKeyData, TBool aDefaultIsOn);
private:
	TFepOnOrOffKeyData iDefaultOnKeyData;
	TFepOnOrOffKeyData iDefaultOffKeyData;
	TBool iDefaultIsOn;
	};


class MFepAttributeStorer
 
















	{
public:
	  void ReadAllAttributesL(CCoeEnv& aConeEnvironment);
	  void WriteAttributeDataAndBroadcastL(CCoeEnv& aConeEnvironment, TUid aAttributeUid);
	  void WriteAttributeDataAndBroadcastL(CCoeEnv& aConeEnvironment, const TArray<TUid>& aAttributeUids);
	 


	virtual TInt NumberOfAttributes() const=0;
	 



	virtual TUid AttributeAtIndex(TInt aIndex) const=0;
	 






	virtual void WriteAttributeDataToStreamL(TUid aAttributeUid, RWriteStream& aStream) const=0;
	 











	virtual void ReadAttributeDataFromStreamL(TUid aAttributeUid, RReadStream& aStream)=0;
private:
	  virtual void MFepAttributeStorer_Reserved_1();
	  virtual void MFepAttributeStorer_Reserved_2();
	TInt NumberOfOccurrencesOfAttributeUid(TUid aAttributeUid) const;
	};

class CCoeControl;


class CCoeFep : public CBase, protected MFepAttributeStorer, public MCoeForegroundObserver, public MCoeFocusObserver, private MCoeMessageObserver
 




























	{
public:
	 
	enum TEventResponse
		{
		 
		EEventWasNotConsumed,
		 
		EEventWasConsumed
		};
	class MDeferredFunctionCall
	 




		{
	public:
		 

		virtual void ExecuteFunctionL()=0;
	private:
		  virtual void MDeferredFunctionCall_Reserved_1();
		  virtual void MDeferredFunctionCall_Reserved_2();
		};

	class MKeyEventQueue  
		{
	public:
		virtual void AppendKeyEventL(const TKeyEvent& aKeyEvent)=0;
	private:
		  virtual void MKeyEventQueue_Reserved_1();
		  virtual void MKeyEventQueue_Reserved_2();
		};

	class MModifiedCharacter
	 



		{
	public:
		 


		virtual TUint CharacterCode() const=0;
		 



		virtual TUint ModifierMask() const=0;
		 




		virtual TUint ModifierValues() const=0;
	private:
		  virtual void MModifiedCharacter_Reserved_1();
		  virtual void MModifiedCharacter_Reserved_2();
		};
public:
	  virtual ~CCoeFep();
	  TBool IsSimulatingKeyEvent() const;
	  TBool IsTurnedOnByL(const TKeyEvent& aKeyEvent) const;
	  TBool IsTurnedOffByL(const TKeyEvent& aKeyEvent) const;
	 
	 




	virtual void CancelTransaction()=0;
public:  
	 
	  TEventResponse OfferKeyEvent(TInt& aError, MKeyEventQueue& aKeyEventQueue, const TKeyEvent& aKeyEvent, TEventCode aEventCode);
	  TEventResponse OfferPointerEvent(TInt& aError, MKeyEventQueue& aKeyEventQueue, const TPointerEvent& aPointerEvent, const CCoeControl* aWindowOwningControl);
	  TEventResponse OfferPointerBufferReadyEvent(TInt& aError, MKeyEventQueue& aKeyEventQueue, const CCoeControl* aWindowOwningControl);
	  static TEventResponse OfferEventToActiveScheduler(CCoeFep* aFep, TInt& aError, MKeyEventQueue& aKeyEventQueue, TInt aMinimumPriority);  
public:
	  void OnStartingHandlingKeyEvent_WithDownUpFilterLC();
	  void OnStartingHandlingKeyEvent_NoDownUpFilterLC();
	  TKeyResponse OnFinishingHandlingKeyEvent_WithDownUpFilterL(TEventCode aEventCode, const TKeyEvent& aKeyEvent, TKeyResponse aKeyResponse);
	  TKeyResponse OnFinishingHandlingKeyEvent_NoDownUpFilterL(TEventCode aEventCode, const TKeyEvent& aKeyEvent, TKeyResponse aKeyResponse);
protected:
	  CCoeFep(CCoeEnv& aConeEnvironment);
	  void BaseConstructL(const CCoeFepParameters& aFepParameters);
	  void ReadAllAttributesL();
	  void MakeDeferredFunctionCall(MDeferredFunctionCall& aDeferredFunctionCall);
	  void SimulateKeyEventsL(const TArray<TUint>& aArrayOfCharacters);
	  void SimulateKeyEventsL(const TArray<MModifiedCharacter>& aArrayOfModifiedCharacters);
	  void WriteAttributeDataAndBroadcastL(TUid aAttributeUid);
	  void WriteAttributeDataAndBroadcastL(const TArray<TUid>& aAttributeUids);
	  TBool IsOn() const;
private:
	enum {EUndefinedEventResponse=100};
	enum
		{
		EFlagDefaultIsOn		=0x00000001,
		EFlagIsOn				=0x00000002,
		EFlagIsHandlingKeyEvent	=0x00000004,
		EFlagNoDownUpFilter		=0x00000008
		};
	struct SKeyEvent
		{
		TEventCode iEventCode;
		TKeyEvent iKeyEvent;
		TKeyResponse iKeyResponse;
		};
	class CHighPriorityActive;
	class CLowPriorityActive;
private:
	void DoOnStartingHandlingKeyEventLC(TUint aFlagNoDownUpFilter);
	TKeyResponse DoOnFinishingHandlingKeyEventL(TEventCode aEventCode, const TKeyEvent& aKeyEvent, TKeyResponse aKeyResponse);
	static TBool KeyEventMatchesOnOrOffKeyData(const TKeyEvent& aKeyEvent, const TFepOnOrOffKeyData& aOnOrOffKeyData);
	static void TurnOffKeyEventHandlingFlags(TAny* aFlags);
	void DoHandleMessageL(TMessageResponse& aMessageResponse, RReadStream& aStream, TUid aMessageUid);
	 
	  virtual void MFepAttributeStorer_Reserved_1();
	  virtual void MFepAttributeStorer_Reserved_2();
	 
	  virtual void MCoeForegroundObserver_Reserved_1();
	  virtual void MCoeForegroundObserver_Reserved_2();
	 
	  virtual void MCoeFocusObserver_Reserved_1();
	  virtual void MCoeFocusObserver_Reserved_2();
	 
	  virtual TMessageResponse HandleMessageL(TUint32 aClientHandleOfTargetWindowGroup, TUid aMessageUid, const TDesC8& aMessageParameters);
	  virtual void MCoeMessageObserver_Reserved_1();
	  virtual void MCoeMessageObserver_Reserved_2();
	 
	 







	virtual void IsOnHasChangedState()=0;
	 






































	virtual void OfferKeyEventL(TEventResponse& aEventResponse, const TKeyEvent& aKeyEvent, TEventCode aEventCode)=0;
	 

















	virtual void OfferPointerEventL(TEventResponse& aEventResponse, const TPointerEvent& aPointerEvent, const CCoeControl* aWindowOwningControl)=0;
	 






















	virtual void OfferPointerBufferReadyEventL(TEventResponse& aEventResponse, const CCoeControl* aWindowOwningControl)=0;
	  virtual void CCoeFep_Reserved_1();
	  virtual void CCoeFep_Reserved_2();
private:
	CCoeEnv& iConeEnvironment;
	TUint iFlags;
	TFepOnOrOffKeyData iDefaultOnKeyData;
	TFepOnOrOffKeyData iDefaultOffKeyData;
	TFepOnOrOffKeyData iOnKeyData;
	TFepOnOrOffKeyData iOffKeyData;
	CHighPriorityActive* iHighPriorityActive;
	CLowPriorityActive* iLowPriorityActive;
	MKeyEventQueue* iKeyEventQueue;  
	SKeyEvent* iLastKeyEvent;
	};


class CFepFastFileAccessor : public CBase, private MCoeMessageObserver  
 



	{
public:  
	class MFileObserver
		{
	public:
		virtual void FileHasChangedL(const TDesC& aFullFileName, const TUint8* aData, TInt aDataLength, TBool aIsRom)=0;
	private:
		  virtual void MFileObserver_Reserved_1();
		  virtual void MFileObserver_Reserved_2();
		};
public:  
	inline static CFepFastFileAccessor* NewL(CCoeEnv& aConeEnvironment) {return NewL(aConeEnvironment, 0L );}
	inline static CFepFastFileAccessor* NewL(CCoeEnv& aConeEnvironment, MFileObserver& aFileObserver) {return NewL(aConeEnvironment, &aFileObserver);}
	inline static CFepFastFileAccessor* NewLC(CCoeEnv& aConeEnvironment) {return NewLC(aConeEnvironment, 0L );}
	inline static CFepFastFileAccessor* NewLC(CCoeEnv& aConeEnvironment, MFileObserver& aFileObserver) {return NewLC(aConeEnvironment, &aFileObserver);}
	  virtual ~CFepFastFileAccessor();
	  void AddFileL(const TDesC& aFullFileName);
	  void RemoveFile(const TDesC& aFullFileName);
	inline void GetData(const TDesC& aFullFileName, const TUint8*& aData, TInt& aDataLength) const {GetData(aFullFileName, aData, aDataLength, 0L );}
	inline void GetData(const TDesC& aFullFileName, const TUint8*& aData, TInt& aDataLength, TBool& aIsRom) const {GetData(aFullFileName, aData, aDataLength, &aIsRom);}
	  void FileHasChangedL(const TDesC& aFullFileName);
private:
	enum {EGranularity=5};
	enum {EBroadcastUid=0x1000162a};
	struct SFile
		{
		HBufC* iFullName;
		TBool iIsRom;
		TUint8* iData;
		TInt iDataLength;
		};
private:
	  static CFepFastFileAccessor* NewL(CCoeEnv& aConeEnvironment, MFileObserver* aFileObserver);
	  static CFepFastFileAccessor* NewLC(CCoeEnv& aConeEnvironment, MFileObserver* aFileObserver);
	CFepFastFileAccessor(CCoeEnv& aConeEnvironment, MFileObserver* aFileObserver);
	void ConstructL();
	  void GetData(const TDesC& aFullFileName, const TUint8*& aData, TInt& aDataLength, TBool* aIsRom) const;  
	void LoadNonRomFileL(SFile& aFile);
	void CloseArrayIfEmpty();
	static void CloseFile(SFile& aFile);
	static TBool IsFullFileName(const TDesC& aFileName);
	 
	virtual TMessageResponse HandleMessageL(TUint32 aClientHandleOfTargetWindowGroup, TUid aMessageUid, const TDesC8& aMessageParameters);
private:
	CCoeEnv& iConeEnvironment;
	TInt iArrayLength;
	SFile* iArrayOfFiles;
	MFileObserver* iFileObserver;
	};


class CFepGlobalDynamicFrequencyTable : public CBase  
 


	{
public:  
	typedef TInt (*TCharacterCompareFunction)(TUint aCharacter1, TUint aCharacter2);  
	enum TSortType
		{
		ESortByFrequencyThenByUserDefinedCompareFunction,
		ESortByUserDefinedCompareFunctionThenByFrequency
		};
	class MCharacterArray
		{
	public:
		virtual TInt NumberOfCharacters() const=0;
		virtual TUint CharacterAtIndex(TInt aIndex) const=0;
		virtual void SetCharacterAtIndex(TInt aIndex, TUint aCharacter)=0;
	private:
		  virtual void MCharacterArray_Reserved_1();
		  virtual void MCharacterArray_Reserved_2();
		};
public:  
	  static CFepGlobalDynamicFrequencyTable* NewL(TInt aMaximumNumberOfCharacters);
	  static CFepGlobalDynamicFrequencyTable* NewLC(TInt aMaximumNumberOfCharacters);
	  virtual ~CFepGlobalDynamicFrequencyTable();
	  void IncrementFrequencyOfCharacter(TUint aCharacter);
	  void SortL(MCharacterArray& aCharacterArray, TCharacterCompareFunction aUserDefinedCharacterCompareFunction, TSortType aSortType);
	  void Reset();
private:
	struct SFrequencyCountedCharacter
		{
		TUint iCharacter;
		TInt iFrequencyCount;
		};
	struct SGlobalData
		{
		struct SArrayOfCharactersOrderedByAge
			{
			TInt iMaximumCount;
			TInt iCount;
			TInt iIndexOfOldest;
			TInt iOffsetToArray;  
			};
		struct SArrayOfFrequencyCountedCharactersOrderedByCharacterEncoding
			{
			TInt iCount;
			TInt iOffsetToArray;  
			};
		SArrayOfCharactersOrderedByAge iArrayOfCharactersOrderedByAge;
		SArrayOfFrequencyCountedCharactersOrderedByCharacterEncoding iArrayOfFrequencyCountedCharactersOrderedByCharacterEncoding;
		};
	struct SSortItem
		{
		SFrequencyCountedCharacter iFrequencyCountedCharacter;
		TInt iOriginalIndex;
		};
	typedef TBool (*TFirstParameterComesBeforeSecondFunction)(const SSortItem& aSortItem1, const SSortItem& aSortItem2, TCharacterCompareFunction aUserDefinedCharacterCompareFunction);  
private:
	CFepGlobalDynamicFrequencyTable();
	void ConstructL(TInt aMaximumNumberOfCharacters);
	void HeapSort(TInt aNumberOfSortItems, SSortItem* aArrayOfSortItems, TFirstParameterComesBeforeSecondFunction aFirstParameterComesBeforeSecondFunction, TCharacterCompareFunction aUserDefinedCharacterCompareFunction);
	TInt IndexInArrayOfFrequencyCountedCharactersOrderedByCharacterEncoding(TUint aCharacter, TBool& aExists);
	static TBool FirstParameterComesBeforeSecondWhenSortedByFrequencyThenByUserDefinedCompareFunction(const SSortItem& aSortItem1, const SSortItem& aSortItem2, TCharacterCompareFunction aUserDefinedCharacterCompareFunction);
	static TBool FirstParameterComesBeforeSecondWhenSortedByUserDefinedCompareFunctionThenByFrequency(const SSortItem& aSortItem1, const SSortItem& aSortItem2, TCharacterCompareFunction aUserDefinedCharacterCompareFunction);
private:
	RMutex iMutex;
	RChunk iChunk;
	SGlobalData* iGlobalData;  
	TAny* iSpareForFutureUse;
	};


class MFepPointerEventHandlerDuringInlineEdit  
 








	{
public:
	 







	virtual void HandlePointerEventInInlineTextL(TPointerEvent::TType aType, TUint aModifiers, TInt aPositionInInlineText)=0;
private:
	  virtual void MFepPointerEventHandlerDuringInlineEdit_Reserved_1();
	  virtual void MFepPointerEventHandlerDuringInlineEdit_Reserved_2();
	};

class TCharFormat;
class TCursorSelection;
class MFormCustomDraw;
class MFepInlineTextFormatRetriever;
class MCoeFepAwareTextEditor_Extension1;


class MCoeFepAwareTextEditor  
 


























	{
public:
	 



























	virtual void StartFepInlineEditL(const TDesC& aInitialInlineText, TInt aPositionOfInsertionPointInInlineText, TBool aCursorVisibility, const MFormCustomDraw* aCustomDraw, MFepInlineTextFormatRetriever& aInlineTextFormatRetriever, MFepPointerEventHandlerDuringInlineEdit& aPointerEventHandlerDuringInlineEdit)=0;
	 













	virtual void UpdateFepInlineTextL(const TDesC& aNewInlineText, TInt aPositionOfInsertionPointInInlineText)=0;
	 







	virtual void SetInlineEditingCursorVisibilityL(TBool aCursorVisibility)=0;
	  void CommitFepInlineEditL(CCoeEnv& aConeEnvironment);
	 





	virtual void CancelFepInlineEdit()=0;
	 
	 


	virtual TInt DocumentLengthForFep() const=0;
	 



	virtual TInt DocumentMaximumLengthForFep() const=0;
	 


	virtual void SetCursorSelectionForFepL(const TCursorSelection& aCursorSelection)=0;
	 



	virtual void GetCursorSelectionForFep(TCursorSelection& aCursorSelection) const=0;
	 






	virtual void GetEditorContentForFep(TDes& aEditorContent, TInt aDocumentPosition, TInt aLengthToRetrieve) const=0;
	 








	virtual void GetFormatForFep(TCharFormat& aFormat, TInt aDocumentPosition) const=0;
	 













	virtual void GetScreenCoordinatesForFepL(TPoint& aLeftSideOfBaseLine, TInt& aHeight, TInt& aAscent, TInt aDocumentPosition) const=0;
	  MCoeFepAwareTextEditor_Extension1* Extension1();
private:
	 







	virtual void DoCommitFepInlineEditL()=0;
	  virtual MCoeFepAwareTextEditor_Extension1* Extension1(TBool& aSetToTrue);
	  virtual void MCoeFepAwareTextEditor_Reserved_2();
	};

class MLayDoc;


class MCoeFepLayDocExtension
 
 
 
 

 
 



	{
public:
	 
	virtual MLayDoc* GetCurrentMLayDoc() const = 0;
	 
	virtual void SetMLayDoc(MLayDoc* aLayDoc) = 0;
	 
	virtual void GetFepEditorState(TInt& aPositionInDocument, TInt& aCursorPositionInDocument, TInt& aSelectionLength) = 0;
	 
	 
	 
	 
	 
     
	 
	 
	virtual void HandleInsertDeleteL(TCursorSelection aSelection,TInt aDeletedChars) = 0;
private:
	  virtual void MCoeFepLayDocExtension_Reserved_1();
	  virtual void MCoeFepLayDocExtension_Reserved_2();
	};



class MCoeFepAwareTextEditor_Extension1  
 


























	{
public:
	class CState : public CBase
	 


		{
	protected:
		  CState();
		  void BaseConstructL();
	public:
		  virtual ~CState();
	private:
		  virtual void CState_Reserved_1();
		  virtual void CState_Reserved_2();
		  virtual void CState_Reserved_3();
		  virtual void CState_Reserved_4();
	private:
		TAny* iSpareForFutureUse;
		};
public:
	 








	virtual void SetStateTransferingOwnershipL(CState* aState, TUid aTypeSafetyUid)=0;  
	 










	virtual CState* State(TUid aTypeSafetyUid)=0;
public:
	  virtual void StartFepInlineEditL(TBool& aSetToTrue, const TCursorSelection& aCursorSelection, const TDesC& aInitialInlineText, TInt aPositionOfInsertionPointInInlineText, TBool aCursorVisibility, const MFormCustomDraw* aCustomDraw, MFepInlineTextFormatRetriever& aInlineTextFormatRetriever, MFepPointerEventHandlerDuringInlineEdit& aPointerEventHandlerDuringInlineEdit);
	  virtual void SetCursorType(TBool& aSetToTrue, const TTextCursor& aTextCursor);
	  virtual MCoeFepLayDocExtension* GetFepLayDocExtension(TBool& aSetToTrue);
private:
	  virtual void MCoeFepAwareTextEditor_Extension1_Reserved_4();
	};


class MCoeCaptionRetrieverForFep  
 












	{
public:
	 


















	virtual void GetCaptionForFep(TDes& aCaption) const=0;  
private:
	  virtual void MCoeCaptionRetrieverForFep_Reserved_1();
	  virtual void MCoeCaptionRetrieverForFep_Reserved_2();
	};



# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtview.h" 1
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmframe.h" 1
 
 
 
 






 
















class TFrameOverlay

    {
public:
 

enum TEdges
	{
	 
	ENoEdges=0x00,
	 
	EEdgeLeft=0x01,
	 
	EEdgeRight=0x02,
	 
	EEdgeTop=0x04,
	 
	EEdgeBottom=0x08
	};

 
enum TFrameOverlayFlags
	{
	 
	EFrameOverlayFlagBlobsInternal=0x01,
	 
	EFrameOverlayFlagShowBorder=0x02,
	 
	EFrameOverlayFlagTopBlobsDimmed=0x04,
	 
	EFrameOverlayFlagBottomBlobsDimmed=0x08,
	 

	EFrameOverlayFlagLeftBlobsDimmed=0x10,
	 

	EFrameOverlayFlagRightBlobsDimmed=0x20
	};
public:
	  TFrameOverlay();
      void SetBlobWidthInPixels(const TInt aWidth);  
      void SetVisibleBlobWidthInPixels(const TInt aWidth);  
      void SetActiveBlobWidthInPixels(const TInt aWidth);  
	  void SetFlags(TInt aFlag);
      void ClearFlags(TInt aFlag);
      void SetRect(const TRect& aRect);
      void XorDraw(CGraphicsContext& aGc) const;
      TInt XyPosToEdges(const TPoint& aPos) const;
    inline TRect Rect() const;		 
    inline const TRect& RefRect() const;
    inline TInt Flags() const;
private:
	TInt VisibleBlobWidth() const;
	TInt ActiveMarginWidth() const;
	TBool DrawLeftAndRight() const;
	TBool DrawTopAndBottom() const;
	void DrawDottedRectangle(CGraphicsContext& aGc,const TRect& aRect) const;
private:
    TInt iFlags;
    TInt iVisibleBlobWidth;
	TInt iActiveBlobWidth;
	TRect iRect;
    };

 	
inline TRect TFrameOverlay::Rect() const
	{
	return(iRect);
	}

inline const TRect& TFrameOverlay::RefRect() const
	{
	return(iRect);
	}

TInt TFrameOverlay::Flags() const
	{
	return(iFlags);
	}


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/frmtview.h" 2


 



class RScreenDisplay

	{
public:
	enum TClippingRects
		{
		EFClipTextArea = 0x0001,
		EFClipLineCursor = 0x0002,
		EFClipExtendedTextArea = 0x0004,
		EFClipViewRect = 0x0008,
		EFClipExtendedViewRect = 0x0010,
		EFClipInvalid = 0x0200,
		EFClipAllFlags = 0xFFFF
		};
public:
	RScreenDisplay(TDrawTextLayoutContext* const aDrawTextLayoutContext); 
	void Close();
	void Destroy();
	void SetWindowsServer(RWsSession *aSession) { iSession = aSession; }
	void SetWindowGroup(RWindowGroup *aWin) { iGroupWin = aWin; }
	
	void SetWindow(RWindow *aWin);
	RWindow* Window() const { return iWin; }
	void SetBitmapContext(CBitmapContext* aGc) { iGc = aGc; }
	CBitmapContext* BitmapContext() const { return iGc; }
	RWsSession* WindowServerSession() { return iSession; }
	void SetGraphicsDeviceL(CBitmapDevice *aGd);
	CBitmapDevice* BitmapDevice() const {return iGd; }
	void CreateContextL(CBitmapDevice *aGd);
	void CreateContextL();
	void SetInvalidRect(const TRect& aRect);
	void SetInvalidRect(TInt aHeight);
	void SetInvalidRectHorizontal(TInt aWidth);
	void SetRects(TUint aRects);
	TRect LineCursorMargin() const;
	TPoint TopLeftTextArea() const;
	TBool IsLineCursor() const;
	
	void AddRects(TUint aRects);
	void SubRects(TUint aRects);
	TRect ClippingRect();	
	void ResetClippingRect();	
	void Scroll(TRect aRect,const TPoint& aBy,TBool aScrollBackground);
	void Flush();
	void ClearRect(const TRect& aRect);
	void InvertRect(TRect aRect,const TRgb aInvertColor);
	void SetTextCursor(TPoint aPos, const TTextCursor &aCursor);
	void RemoveTextCursor();
	void BlastBitmap(const TPoint& aPoint,const CFbsBitmap* aBitmap,const TRect& aRect);
	void DrawPictureFrame(TFrameOverlay* aPictureFrame,const TRect& aLineRect);
	void Invalidate(TRect aRect);
	void ActivateContext();
	void ActivateContext(CGraphicsContext *aGc);
	void DeactivateContext();
	void DeactivateContext(CGraphicsContext *aGc);
	void SetLayout(const CTextLayout* aLayout);

private:
	void DestroyContexts();
private:
	RWsSession *iSession;
	RWindowGroup *iGroupWin;
	RWindow *iWin;
	CBitmapContext *iGc;
	CBitmapDevice *iGd;
	TDrawTextLayoutContext* const iDrawTextLayoutContext;
	TUint iRects;
	TRect iInvalidRect;
	TLogicalRgb iBackground;
	const CTextLayout* iTextLayout;
	};

 





class TCursor
	{
	public:
	enum TCursors
		{
		EFNeitherCursor = 0,
		EFTextCursor = 1,
		EFLineCursor = 2,
		EFBothCursors = EFTextCursor | EFLineCursor
		};

	 
	enum TVisibility
		{
		 
		EFCursorInvisible = 0,
		 
		EFCursorVisible,
		 




		EFCursorFlashing
		};

	TCursor(TCursorPosition& aCursorPos,RScreenDisplay& aDisplay);
	void SetLineCursorBitmap(const CFbsBitmap* aLineCursorBitmap);
	inline TUint LineCursorVisibility();
	inline TUint TextCursorVisibility();
	void Draw(TUint aCursors);

	void SetVisibility(TVisibility aLineCursor,TVisibility aTextCursor);
	void SetType(TTextCursor::EType aType);
	void SetPlacement(TTmCursorPlacement aPlacement);
	void SetAscentAndDescent(TInt aAscent,TInt aDescent);
	void SetWeight(TInt aWeight);
	void SetFlash(TBool aEnabled);
	void SetXorColor(TRgb aColor);
	void MatchCursorHeightToAdjacentChar();
	void SetExtensions(TInt aFirstExtension, TInt aSecondExtension);
	private:
	enum
		{
		ELineCursorToLabelGap = 2,
		ETextCursorWeight = 3,
		ETextCursorInvertColor = 0xFFFFFF
		};

	void DrawLineCursor(TInt aHeight);
	void RemoveLineCursor();
	void DrawTextCursor(TPoint aOrigin,TInt aWidth,TInt aAscent,TInt aDescent);
	void RemoveTextCursor();

	RScreenDisplay& iDisplay;				 
	TCursorPosition& iCursorPos;			 
	TBool iVisible;							 
	TBool iFlash;							 
	TVisibility iLineCursor;				 
	TVisibility iTextCursor;				 
	const CFbsBitmap* iLineCursorBitmap;	 
	TInt iAscent;							 
	TInt iDescent;							 
	TInt iWeight;							 
	TTextCursor::EType iType;				 
	TRgb iXorColor;							 
	TTmCursorPlacement iPlacement;			 
	TInt iFirstExtension;					 
	TInt iSecondExtension;					 
	TInt iReserved[2];
	};

 




























































class CTextView : public CBase

	{
friend class CTestTextView;
public:
	enum TPriorities
		{
		EFBackgroundFormattingPriority = (CActive::EPriorityIdle + CActive::EPriorityLow) / 2
		};

	 
	enum
		{
		EFFirstCharOnLine = -1000000,
		EFLastCharOnLine = 1000000
		};

	 


	enum TBeforeAfter
		{
		 
		EFCharacterBefore = ETrue,
		 
		EFCharacterAfter = EFalse
		};

	

	 
	enum TDiscard
		{
		 
		EFViewDiscardAllFormat,
		 
		EFViewDontDiscardFormat,
		 
		EFViewDiscardAllNoRedraw,
		 
		EFViewDontDiscardFullRedraw
		};
	
	 








	class MObserver

		{
		public:

		 


		virtual void OnReformatL(const CTextView* aTextView) = 0;
		};

	 
	enum TDoHorizontalScroll
		{
		EFNoHorizontalScroll = EFalse,
		EFCheckForHorizontalScroll = ETrue
		};

	
	 









	class TTagmaForwarder: public MTmTextLayoutForwarder
	
		{
	public:
		inline TTagmaForwarder();
		inline void InitL(CTextView* aView);
		
	private:
		 
		inline const CTmTextLayout& TextLayout() const;
		inline void GetOrigin(TPoint& aPoint) const;

		CTextView* iView;
		};

private:
	enum TDrawParameters
		{
		EFDrawAllWindow = CLayoutData::EFLargeNumber  
		};

	 
	enum
		{
		EFSelectionVisible = 1,
		EFPictureFrameEnabled = 2,
		EFEverythingVisible = 3,
		EFFlickerFreeRedraw = 4
		};

	 
	enum THorizontalScrollJump
		{
		EFDefaultHorizontalScrollJump = 20



		};

	 
	enum TPictureFrameBlobWidths
		{
		EFFrameVisibleBlobWidth = 10,
		EFFrameActiveBlobWidth = 20
		};

	enum THorizontalScroll
		{
		EFNoPreviousHorizontalScroll = 0,
		EFPreviousHorizontalScroll
		};

	enum TMemoryStatus
		{
		EFMemoryOK,
		EFOutOfMemory,
		EFRecovering
		};

	enum TExtendedHighlightRedraw
		{
		EFTopEdge = 0x0001,
		EFBottomEdge = 0x0002
		};


public:
	  static CTextView *NewL(CTextLayout* aLayout,const TRect &aDisplay,CBitmapDevice* aGd,
									MGraphicsDeviceMap* aDeviceMap,RWindow* aWin,RWindowGroup* aGroupWin,
									RWsSession* aSession);
	  ~CTextView();
	  void SetDisplayContextL(CBitmapDevice* aGd,RWindow* aWin,RWindowGroup* aGroupWin,RWsSession* aSession);
	  void SetLayout(CTextLayout* aLayout);
	inline const CTextLayout* Layout() const;
	  void SetViewRect(const TRect& aDisplay);
	  void AlterViewRect(const TRect &aViewRect);
	  void SetMarginWidths(TInt aLabels,TInt aLineCursor);
	  void SetHorizontalScrollJump(TInt aScrollJump);
	  void SetLineCursorBitmap(const CFbsBitmap* aLineCursorBitmap);
	  void SetHighlightExtensions(TInt aLeftExtension, TInt aRightExtension, TInt aTopExtension, TInt aBottomExtension);
	  void SetBackgroundColor(TRgb aColor);
	  void SetTextColorOverride(const TRgb* aOverrideColor = 0L );
	  void SetCursorVisibilityL(TUint aLineCursor,TUint aTextCursor);
	  void SetSelectionVisibilityL(TBool aSelectionVisible);
	  TBool SelectionVisible() const;
	  void EnablePictureFrameL(TBool aEnabled);
	  const TRect& ViewRect() const;
	  const TRect& AlteredViewRect() const;
	  void MarginWidths(TInt& aLabels,TInt& aLineCursor) const;
	  TInt HorizontalScrollJump() const;
	  TInt LeftTextMargin() const;
 	  void SetLatentXPosition(TInt aLatentX);
	 
	  void SetParagraphFillTextOnly(TBool aFillTextOnly);
	  void SetCursorWidthTypeL(TTextCursor::EType aType,TInt aWidth = 0);
	  void SetCursorPlacement(TTmCursorPlacement aPlacement);
	  void SetCursorWeight(TInt aWeight);
	  void SetCursorFlash(TBool aEnabled);
	  void SetCursorXorColor(TRgb aColor);
	  void SetCursorExtensions(TInt aFirstExtension, TInt aSecondExtension);
	  TCursorSelection Selection() const;
	  TBool IsPictureFrameSelected(TRect& aPictureFrameRect,TInt& aDocPos) const;
	  TBool GetPictureRectangleL(TInt aDocPos,TRect& aPictureRect,TBool* aCanScaleOrCrop = 0L ) const;
	  TBool GetPictureRectangleL(TPoint aXyPos,TRect& aPictureRect,TBool* aCanScaleOrCrop = 0L );
	  TBool FindXyPosL(const TPoint& aXyPos,TTmPosInfo2& aPosInfo,TTmLineInfo* aLineInfo = 0L );
	  TInt XyPosToDocPosL(TPoint& aPoint);
	  TBool FindDocPosL(const TTmDocPosSpec& aDocPos,TTmPosInfo2& aPosInfo,TTmLineInfo* aLineInfo = 0L );
	  TBool DocPosToXyPosL(TInt aDocPos,TPoint& aPoint);
	  TRect ParagraphRectL(TInt aDocPos) const;
	  void CalculateHorizontalExtremesL(TInt& aLeftX,TInt& aRightX,TBool aOnlyVisibleLines);
	  void MatchCursorHeightL(const TFontSpec& aFontSpec);
	  void MatchCursorHeightToAdjacentChar(TBeforeAfter aBasedOn = EFCharacterBefore);
	  TPoint SetSelectionL(const TCursorSelection& aSelection);
	  void CancelSelectionL();
	  void ClearSelectionL();
	  TPoint SetDocPosL(const TTmDocPosSpec& aDocPos,TBool aDragSelectOn = EFalse);
	  TPoint SetDocPosL(TInt aDocPos,TBool aDragSelectOn = EFalse);
	  TPoint SetXyPosL(TPoint aPos,TBool aDragSelectOn,TRect*& aPictureRect,TInt& aPictureFrameEdges);
	  TPoint MoveCursorL(TCursorPosition::TMovementType& aMovement,TBool aDragSelectOn);
	  TInt ScrollDisplayL(TCursorPosition::TMovementType aMovement,
		CTextLayout::TAllowDisallow aScrollBlankSpace=CTextLayout::EFDisallowScrollingBlankSpace);
	  TPoint SetViewLineAtTopL(TInt aLineNo);
	  void ScrollDisplayPixelsL(TInt& aDeltaY);
	  TInt ScrollDisplayLinesL(TInt& aDeltaLines,
		CTextLayout::TAllowDisallow aScrollBlankSpace = CTextLayout::EFDisallowScrollingBlankSpace);
	  TInt ScrollDisplayParagraphsL(TInt& aDeltaParas,
		CTextLayout::TAllowDisallow aScrollBlankSpace = CTextLayout::EFDisallowScrollingBlankSpace);
	  TPoint SetViewL(TInt aDocPos,TInt& aYPos,TViewYPosQualifier aYPosQualifier = TViewYPosQualifier(),
		TDiscard aDiscardFormat = EFViewDontDiscardFormat,
		TDoHorizontalScroll aDoHorizontalScroll = EFCheckForHorizontalScroll);
 	  void SetLeftTextMargin(TInt aLeftMargin);
	  void DrawL(TRect aRect);
	  void DrawL(TRect aRect,CBitmapContext& aGc);
	inline void SetObserver(MObserver* aObserver);
	  void SetPendingSelection(const TCursorSelection& aSelection);
	inline void EnableFlickerFreeRedraw();
	inline void DisableFlickerFreeRedraw();
	inline TBool FlickerFreeRedraw() const;
	inline void GetOrigin(TPoint& aPoint) const;
	  TCursorSelection GetForwardDeletePositionL();
	  TCursorSelection GetBackwardDeletePositionL();

	 
 	  void FormatTextL();
	  TInt HandleCharEditL(TUint aType = CTextLayout::EFCharacterInsert,TBool aFormatChanged = EFalse);
	  TPoint HandleRangeFormatChangeL(TCursorSelection aSelection,TBool aFormatChanged = EFalse);
	  TPoint HandleInsertDeleteL(TCursorSelection aSelection,TInt aDeletedChars,TBool aFormatChanged = EFalse);
	  void HandleGlobalChangeL(TViewYPosQualifier aYPosQualifier = TViewYPosQualifier());
	  void HandleGlobalChangeNoRedrawL(TViewYPosQualifier aYPosQualifier = TViewYPosQualifier());
	  void HandleAdditionalCharactersAtEndL();
	  void FinishBackgroundFormattingL();

	  CBitmapContext* BitmapContext();
	  const TTmDocPos& VisualEndOfRunL(
		const TTmDocPos& aStart, const TTmDocPos& aEnd,
		TCursorPosition::TVisualEnd aDirection);
	  void GetCursorPos(TTmDocPos& aPos) const;

	  TPoint SetDocPosL(const TTmDocPos& aDocPos,TBool aDragSelectOn = EFalse);

	  void SetCursorPositioningHintL(MCursorPositioningPolicy::TPosHint aHint);

private:
	  static TInt IdleL(TAny *aSelf);
	  CTextView();
	  void ConstructL(CTextLayout* aLayout,const TRect &aDisplay,CBitmapDevice* aGd,MGraphicsDeviceMap* aDeviceMap,
							 RWindow* aWin,RWindowGroup* aGroupWin,RWsSession* aSession);
	inline TInt TopViewRect() const;
	inline TBool IsFormatting() const;
	TBool NoMemoryCheckL();
	void StartIdleObject();
	inline void DrawWithPreviousHighlight();
	inline void DrawWithCurrentHighlight();
	TInt CalculateBaseLinePos(TTmDocPos& aDocPos);
	TInt DrawAfterCursorMoveL(TInt aScrollBy);
	TBool NextLineL();
	void ClearRectAtBottom(TInt aHeight);
	void DrawTextL(TInt aFromHeight = 0,TInt aToHeight = EFDrawAllWindow);
	void DisplayNewLinesL(TInt aFrom,TInt aTo);
	void DrawCursor(TUint aCursors = TCursor::EFBothCursors);
	TPoint DoMoveCursorL(TBool aDragSelectOn,TCursorPosition::TMovementType& aMovement,TBool aAllowPictureFrame);
	void ScrollTextL(TInt aScrollY,TInt aFrom,TInt aScrollX,TBool aScrollBackground);
	void ScrollRect(TRect& aRect,TInt aScrollY,TInt aFrom,TInt aScrollX,TBool aScrollBackground);
	void ScrollRect(TInt aScrollY,TInt& aFrom,TInt& aTo);
	TPoint HandleBlockChangeL(TCursorSelection aSelection,TInt aOldCharsChanged,TBool aFormatChanged);
	void CheckScrollUpL();
	TInt CheckHorizontalScroll(const TTmDocPos& aDocPos);
	TInt DoHorizontalScrollDisplayL(TCursorPosition::TMovementType aMovement,
		CTextLayout::TAllowDisallow aScrollBlankSpace);
	TInt DoScrollDisplayL(TCursorPosition::TMovementType aMovement,CTextLayout::TAllowDisallow aScrollBlankSpace);
	void ScrollDisplayL(TInt aPixels,TInt aHorizPixels = 0,TInt aYScrollLimit = EFDrawAllWindow);
	void ScrollUpperDisplayL(TInt aPixels);
	TPoint ViewTopOfLineL(const TTmDocPos& aDocPos,TInt& aYPos,
		CTextView::TDiscard aDiscardFormat = EFViewDontDiscardFormat,
		TDoHorizontalScroll aHorizontalScroll = EFCheckForHorizontalScroll);
	TPoint ViewL(const TTmDocPos& aDocPos,TInt& aYPos,TViewYPosQualifier aYPosQualifier = TViewYPosQualifier(),
		CTextView::TDiscard aDiscardFormat = EFViewDontDiscardFormat,
		TDoHorizontalScroll aHorizontalScroll = EFCheckForHorizontalScroll);
	TPoint DoHandleGlobalChangeL(TViewYPosQualifier aYPosQualifier,CTextView::TDiscard aDiscard);
	void UpdateHighlightL();
	void Highlight(CTextLayout::TRangeChange aRange);
	void HighlightUsingExtensions(CTextLayout::TRangeChange aOptimizedRange, CTextLayout::TRangeChange aOriginalRange);
	void InvertPictureFrameL(TInt aPos,TRect* aDrawRect = 0L );
	void DestroyWindowServerObjects();
	void NoMemoryL(TInt aErr);
	void RecoverNoMemoryL();
	void RecreateWindowServerObjectsL();
	void DrawTextSupportL(const TRect& aRect,const TCursorSelection* aHighlight);
	void DisplayLineRangeL(TInt aFrom,TInt aTo);
	inline void NotifyReformatL();
	void CalculateHorizontalExtremes(TInt& aLeftX,TInt& aRightX,TBool aOnlyVisibleLines);
	TBool ExtendedHighlightExists() const;
	void DoClearSelectionL(const TCursorSelection& aSelection, TBool aIsPictureFrame);
	void UpdateExtendedHighlightL();
	void ClearHighlightRemnantsForScroll(const TRect& aScrollRect, TInt aScrollY, TInt aScrollX);
	void AdjustRectForScrolling(TRect &aRect, TInt aScrollY, TInt aScrollX) const;
private:

	CIdle* iWrap;
	RScreenDisplay iDisplay;
	CTextLayout* iLayout;
	TDrawTextLayoutContext iDrawTextLayoutContext;
	TCursor iCursor;
	TCursorPosition iCursorPos;
	TFrameOverlay* iPictureFrame;
	TMemoryStatus iNoMemory;
	TUint iFlags;
	TUint iHorizontalScroll;
	TInt iGood;
	TInt iFormattedUpTo;
	TInt iHorizontalScrollJump;
	TInt iHeightNotDrawn;
	MObserver* iObserver;
	 
	CBitmapContext* iOffScreenTestContext;
	TRect iReducedDrawingAreaRect;
	TUint iRedrawExtendedHighlight;
	TBool iContextIsNavigation;
	};

inline TUint TCursor::LineCursorVisibility()
	{
	return iLineCursor;
	}

inline TUint TCursor::TextCursorVisibility()
	{
	return iTextCursor;
	}

 

inline const CTextLayout* CTextView::Layout() const
	{
	return iLayout;
	}

 





inline void CTextView::SetObserver(MObserver* aObserver)
	{
	iObserver = aObserver;
	}

inline void CTextView::EnableFlickerFreeRedraw()
	{
	iFlags |= EFFlickerFreeRedraw;
	}

inline void CTextView::DisableFlickerFreeRedraw()
	{
	iFlags &= ~EFFlickerFreeRedraw;
	}

inline TBool CTextView::FlickerFreeRedraw() const
	{
	return iFlags & EFFlickerFreeRedraw;
	}

inline void CTextView::NotifyReformatL()
	{
	if (iObserver)
		iObserver->OnReformatL(this);
	}

inline TBool CTextView::IsFormatting() const
	{
	return iLayout->IsBackgroundFormatting();
	}

inline TInt CTextView::TopViewRect() const
	{
	return iDrawTextLayoutContext.iViewRect.iTl.iY;
	}

inline void CTextView::DrawWithPreviousHighlight()
	{
	iCursorPos.SetToPreviousHighlight();
	}

inline void CTextView::DrawWithCurrentHighlight()
	{
	iCursorPos.SetToCurrentHighlight();
	}

 

inline void CTextView::GetOrigin(TPoint& aPoint) const
	{
	iLayout->GetOrigin(aPoint);
	aPoint += iDrawTextLayoutContext.TopLeftText();
	}

 

inline CTextView::TTagmaForwarder::TTagmaForwarder():
	iView(0L )
	{
	}

 

inline void CTextView::TTagmaForwarder::InitL(CTextView* aView)
	{
	iView = aView;
	iView->FinishBackgroundFormattingL();
	}

inline const CTmTextLayout& CTextView::TTagmaForwarder::TextLayout() const
	{
	return iView->Layout()->TagmaTextLayout();
	}

inline void CTextView::TTagmaForwarder::GetOrigin(TPoint& aPoint) const
	{
	iView->GetOrigin(aPoint);
	}


# 16 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh" 1
# 877 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh"


# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbctrl.h" 1
 
 
 
 

# 40 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbctrl.h"

# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwob.h" 1
 
 
 
 




class CEikEdwin;

class MEikEdwinObserver
	{
public:
	enum TEdwinEvent
		{
		EEventFormatChanged,
		EEventNavigation,
		EEventTextUpdate
		};
public:
	virtual void HandleEdwinEventL(CEikEdwin* aEdwin,TEdwinEvent aEventType)=0;
	};

class MEikEdwinSizeObserver
	{
public:
	enum TEdwinSizeEvent
		{
		EEventSizeChanging
		};
public:
	virtual TBool HandleEdwinSizeEventL(CEikEdwin* aEdwin, TEdwinSizeEvent aEventType, TSize aDesirableEdwinSize)=0;
	};


# 19 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksbfrm.h" 1
 
 
 
 
	
# 675 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksbfrm.h"

# 20 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikccpu.h" 1



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 4 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikccpu.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdef.h" 1
 
 
 
 

# 110 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdef.h"

# 5 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikccpu.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikmobs.h" 1
 
 
 
 

# 58 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikmobs.h"

# 6 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikccpu.h" 2


class CEikButtonGroupContainer;
class CEikMenuBar;


 
 
 
class MEikCcpuEditor
	{
public:
	virtual TBool CcpuIsFocused() const = 0;
	virtual TBool CcpuCanCut() const = 0;
	virtual void CcpuCutL() = 0;
	virtual TBool CcpuCanCopy() const = 0;
	virtual void CcpuCopyL() = 0;
	virtual TBool CcpuCanPaste() const = 0;
	virtual void CcpuPasteL() = 0;
	virtual TBool CcpuCanUndo() const = 0;
	virtual void CcpuUndoL() = 0;
	};


 
 
 
class CAknCcpuSupport : public CCoeControl, public MEikMenuObserver
	{
public:
	  CAknCcpuSupport(MEikCcpuEditor* aEditor);
	  ~CAknCcpuSupport();
	  void ConstructL();

	  void HandleSelectionChangeL();
	  void HandleFocusChangeL();

	 
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);

	 
	  void DynInitMenuPaneL(TInt aResourceId,CEikMenuPane* aMenuPane);
	  void ProcessCommandL(TInt aCommandId);

private:
	void UpdateCBALabelsL();
	TBool UpdateCBALabelL(TInt aPosition, TInt aCommandId, TInt aTextResId);
	void SetEmphasis(CCoeControl* aMenuControl,TBool aEmphasis);

private:
	TBitFlags iFlags;

	 
	CEikButtonGroupContainer* iCba;

	 
	CEikMenuBar* iMenu;
	MEikCcpuEditor* iEditor;
	};





# 21 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklay.h" 1
 
 
 
 



class TAvkonEditorCustomWrap : public MFormCustomWrap
	{
public:
	enum
		{
		EAvkSpaceLineBreakClass=MTmCustom::ELineBreakClasses,  
		EAvkLineBreakClasses
		};

public:
	 
	TUint LineBreakClass(TUint aCode,TUint& aRangeStart,TUint& aRangeEnd) const;
	TBool LineBreakPossible(TUint aPrevClass,TUint aNextClass,TBool aHaveSpaces) const;
	};

# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpictographdrawerinterface.h" 1
 























 



 

enum TAknPictographHeight
    {
    EHeight12 = 0,
    EHeight16 = 1
    };

 

class CBitmapContext;
class CFont;

 

class MAknPictographAnimatorCallBack
    {
    public:
         










        virtual void DrawPictographArea() = 0;
    };

 





class MAknPictographDrawer
	{
    public:   

         


        inline virtual ~MAknPictographDrawer() {};

    public:  

         









        virtual HBufC* SupportedPictographCodesL() const = 0;

         






        virtual TBool IsPictograph( TText aCode ) const = 0;

         






        virtual TBool ContainsPictographs( const TDesC& aText ) const = 0;

         









	    virtual void DrawPictograph(
            CBitmapContext& aGc,
            const TPoint& aTopLeft,
            TText aCode,
            TAknPictographHeight aHeight ) const = 0;

         









	    virtual void DrawPictograph(
            CBitmapContext& aGc,
            const TRect& aRect,
            TText aCode,
            TAknPictographHeight aHeight ) const = 0;

         











	    virtual void DrawPictograph(
            CBitmapContext& aGc,
            const TRect& aRect,
            const TRect& aClipRect,
            TText aCode,
            TAknPictographHeight aHeight ) const = 0;

         
















        virtual void DrawText(
            CBitmapContext& aGc,
            const CFont& aFont,
            const TDesC& aText,
            const TPoint& aPosition ) const = 0;

         





















        virtual void DrawText(
            CBitmapContext& aGc,
            const CFont& aFont,
            const TDesC& aText,
            const TRect& aBox,
            TInt aBaselineOffset,
            CGraphicsContext::TTextAlign aAlignment =
                CGraphicsContext::ELeft,
            TInt aLeftMargin = 0 ) const = 0;

         










        virtual void DrawPictographsInText(
            CBitmapContext& aGc,
            const CFont& aFont,
            const TDesC& aText,
            const TPoint& aPosition ) const = 0;

         














        virtual void DrawPictographsInText(
            CBitmapContext& aGc,
            const CFont& aFont,
            const TDesC& aText,
            const TRect& aBox,
            TInt aBaselineOffset,
            CGraphicsContext::TTextAlign aAlignment =
                CGraphicsContext::ELeft,
            TInt aLeftMargin = 0 ) const = 0;

         





        virtual TBool IsAnimated( TText aCode, TAknPictographHeight aHeight ) const = 0;
    };


            
 
# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 2


 


class CGlobalText;
class CParaFormatLayer;
class CCharFormatLayer;
class MLayDoc;
class CEikEdwinFepSupport;
class CLafEdwinCustomDrawBase;
class CClipboard;
class CAknEdwinFormAccessor;
class CAknEdwinState;
class CAknInputPolicyManager;
class CFormCursorModifier;
class CTextView;
class MAknsControlContext;
class CAknEdwinDrawingModifier;
class CAknEdwinFormExtendedInterfaceProvider;
class CAknPhoneNumberInlineTextSource;
class CAknNoMatchesIndicatorInlineTextSource;
class CAknInlineTextSource;
class CAknPictographInterface;

 
class CEikAvkonCustomDraw;

 
class CEikAvkonCustomDraw;

 
class CRichText;

enum TReplaceOption
	{
	ENoReplace,
	EReplaceOnce,
	EReplaceAll,
	EReplaceSkip
	};

struct SEdwinFindModel
	{
	TInt iFlags;  
	TBuf< 500 > iText;
	TBuf< 500 > iReplaceText;
	TReplaceOption iReplaceOption;
	};


class CEikEdwin : public CEikBorderedControl, public MEikScrollBarObserver, public CTextView::MObserver, public MEditObserver, public MEikCcpuEditor
	{
private:
	class CUndoBuffer;
	class CEikEdwinExtension : public CBase
		{
	public:
		static CEikEdwinExtension* NewL(CEikEdwin* aEdwin);
		~CEikEdwinExtension();
		  CAknEdwinFormAccessor* FormAccessor() const;
		  void SetFormAccessor(CAknEdwinFormAccessor* aFormAccessor);
		  void SetScrollBarSetter(CIdle* aScrollBarSetter);
		  CIdle* ScrollBarSetter();
		  const TAvkonEditorCustomWrap& TextWrapper();

		 
          CFormCursorModifier* FormCursorModifier() const;
          void SetFormCursorModifier(CFormCursorModifier* aFormCursorModifier);
        
         




        void SetSkinBackgroundControlContext( MAknsControlContext* aBackgroundControlContext );
        
         




        
        MAknsControlContext* SkinBackgroundControlContext() const;
        
         





        TBool SkinBackgroundControlContextHasBeenSet() const;

         




        void SetAlignment(TInt aAlignment);

         




        TInt CurrentAlignment() const;

         


        void SetPictoCallBack( TCallBack& aCallBack );

         


        const TCallBack& PictoCallBack() const;

         


        void CreateFormExtendedInterfaceProviderIfNeededL();

         


        CAknEdwinFormExtendedInterfaceProvider* FormExtendedInferfaceProvider() const;

         








        void CreatePurePhoneNumberFormatterL( CTextLayout& aTextLayout, const CPlainText& aText);

         







        void CreateNoMatchesIndicatorFormatterL( CTextLayout& aTextLayout );

         








        void CreateRichTextPhoneNumberFormatterL( CTextLayout& aTextLayout, const CRichText& aText );

         






        CAknInlineTextSource* InlineTextSource() const;

         




        CAknPictographInterface* PictographInterface() const;

	private:
		CEikEdwinExtension();
		void ConstructL(CEikEdwin* aEdwin);
    private:
        enum TFlagIndices
            {
            ESkinBackgroundControlContextHasBeenSetIndex = 0
            };
        class TAknEdwinPictographDrawer : public MAknPictographAnimatorCallBack
            {
            private:  
                void DrawPictographArea();
            };        
	private:
		CIdle* iSetScrollBar;
		TAvkonEditorCustomWrap iTextWrapper;
		CAknEdwinFormAccessor* iFormAccessor;
        CFormCursorModifier* iFormCursorModifier;
        MAknsControlContext* iSkinBackgroundControlContext;
        TBitFlags iFlags;
        TInt iAlignment;
        TCallBack iPictoCallBack;       
        CAknEdwinFormExtendedInterfaceProvider* iFormExtendedInterfaceProvider;  
        CAknInlineTextSource* iPhoneNumberFormatter;                  
        CAknNoMatchesIndicatorInlineTextSource* iNoMatchesIndicatorFormatter;    
        TAknEdwinPictographDrawer iPictographDrawer;
        CAknPictographInterface* iPictographInterface;
		};

public:
	enum TFlags
		{  
		EZeroEnumValue			=0x00000000, 
		EKeepDocument			=0x00000001,
		ESegmentedStorage		=0x00000002,
		EWidthInPixels			=0x00000004,
		ENoAutoSelection		=0x00000008,
		EJustAutoCurEnd			=0x00000010,
		ENoWrap					=0x00000020,
		ELineCursor				=0x00000040, 
		ENoHorizScrolling		=0x00000080, 
		EInclusiveSizeFixed		=0x00000100, 
		EUserSuppliedText		=0x00000200,
		EOwnsWindow				=0x00000400,
		EDisplayOnly			=0x00000800,
		EAlwaysShowSelection	=0x00001000,
		EReadOnly				=0x00002000,
		EAllowPictures			=0x00004000,
		EAllowUndo				=0x00008000,
		ENoLineOrParaBreaks		=0x00010000,
		EOnlyASCIIChars			=0x00020000,
		EResizable				=0x00040000,
		EIgnoreVirtualCursor	=0x00080000,
		ENoCustomDraw			=0x01000000,
		EAvkonEditor			=0x02000000,
		EAvkonDisableCursor		=0x04000000,
		EAvkonNotEditable		=0x08000000, 
		EEdwinAlternativeWrapping = 0x10000000
		};
	enum TClipboardFunc
		{
		ENoClipboard,
		ECut,
		ECopy,
		EPaste
		};
	enum TFindFlags
		{
		EFindDirectionUp	=0x01,
		EFindWholeWord		=0x02,
		EFindCaseSensitive	=0x04,
		EFindAgain			=0x08,
		ENoBusyMessage		=0x10,
		EReadOnlyFile		=0x20  
		};
	enum TSetContent
		{
		EUseText,
		ECopyText
		};
	enum TOwnershipType
		{
		EOwnsText,
		EDoesNotOwnText
		};
	enum TEdwinHotKeys  
		{
		EHotKeyCut,
		EHotKeyCopy,
		EHotKeyPaste,
		EHotKeyUndo,
		EHotKeyFind,
		EHotKeyInsertChar,
		EHotKeyBold,
		EHotKeyItalic,
		EHotKeyUnderline,
		EHotKeyFont,
		EHotKeyInsertObject,
		EHotKeyEditObject,
		EHotKeyFormatObject
		};
public:  
	  ~CEikEdwin();
	  CEikEdwin();
	  CEikEdwin(const TGulBorder& aBorder);
	  void ConstructL(TInt aEdwinFlags=0,TInt aWidthInChars=0,TInt aTextLimit=0,TInt aNumberOfLines=0);
	  void SetEdwinObserver(MEikEdwinObserver* aEdwinObserver);
	  void AddEdwinObserverL(MEikEdwinObserver* aEdwinObserver);
	  void RemoveEdwinObserver(MEikEdwinObserver* aEdwinObserver);
	  void SetContainerWindowL();
	  void SetDocumentContentL(CGlobalText& aText,TSetContent aContent=CEikEdwin::ECopyText);
public:  
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  void FocusChanged(TDrawNow aDrawNow);
	  void ActivateL();
	  void ConstructFromResourceL(TResourceReader& aReader);
	  void HandlePointerEventL(const TPointerEvent& aPointerEvent);
	  TSize MinimumSize();
	  void Draw(const TRect& aRect) const;
	  void SetDimmed(TBool aDimmed);
	  void SetContainerWindowL(const CCoeControl& aParent);
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
	 




	  TCoeInputCapabilities InputCapabilities() const;
	 





	  void SetInputCapabilitiesL(const TCoeInputCapabilities& aInputCapabilities); 
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
public:  
	  void HandleScrollEventL(CEikScrollBar* aScrollBar, TEikScrollEvent aEventType);  
public:  
	  void OnReformatL(const CTextView* aTextView);
public:
	  TInt TextLength() const;
	  TInt CursorPos() const;
	  TInt SelectionLength() const;
	  TCursorSelection Selection() const;
	  void ClearSelectionL();
	  void SetSelectionL(TInt aCursorPos,TInt aAnchorPos);
	  void SetCursorPosL(TInt aCursorPos,TBool aSelect);
	  void SelectAllL();
	  void CalculateWidth(TInt aWidthInChars);
	  void GetText(TDes& aDes) const;
	  HBufC* GetTextInHBufL() const;
	  void SetTextL(const TDesC* aDes);
	  void ClipboardL(TClipboardFunc aClipboardFunc);
	  void InsertFieldL(CTextField* aField,TUid aFieldType);
	  void UpdateAllFieldsL();
	  void UpdateCurrentFieldL();
	  TInt CountWords();
	  void InsertFromTextFileL(const TFileName &aFileName,const CPlainText::TTextOrganisation aTextOrganisation=CPlainText::EOrganiseByLine);
	  static TInt IdleL(TAny *aPtr);
	  CPlainText* Text() const;
	  void CancelFepTransaction();  
	  void HandleTextChangedL();
	  TInt LayoutWidth() const;
	  void NotifyNewDocumentL();
	  void NotifyNewFormatL();
	  TBool FindL(const TDesC* aFindText,TInt aFindFlags=0);
	  TInt FindTextL(const TDesC* aFindText,TInt aPos,TInt aFindFlags);
	  void ReplaceL(SEdwinFindModel* aFindModel);
	  void ReplaceAllL(SEdwinFindModel* aFindModel);
	  void GetFindText(TDes* aFindText);
	  void UpdateScrollBarsL();
	  CEikScrollBarFrame* CreateScrollBarFrameL();
	inline CEikScrollBarFrame* CreatePreAllocatedScrollBarFrameL();
	inline CEikScrollBarFrame* ScrollBarFrame();
	  void SetWordWrapL(TBool aWrapIsOn);
	  virtual TInt LineCursorWidth() const;
	  void SetZoomFactorL(TZoomFactor* aZoomFactor);
	  void SetBackgroundColorL(TRgb aBackground);
	  void SetWysiwygModeOn(TInt aLayoutWidth,MGraphicsDeviceMap* aDevice);
	  void SetWysiwygModeOff();
	  void UpdateLayoutWidth(TInt aLayoutWidth);  
	  void SendDataOverIrL();
	  void ReceiveDataOverIrL();
	  void SetAmountToFormatL(TBool aIsNewDoc=EFalse);
	  void SetPasteFromIrStore(TBool aPasteFromIrStore);
	  void PasteFromStoreL(CStreamStore& aStore, CStreamDictionary& aDict);
	  void CopyToStoreL(CStreamStore& aStore, CStreamDictionary& aDict);
	  void SetBorderViewMargins(TMargins8 aMargins);
	  void ForceScrollBarUpdateL();
	  void SetDocumentOwnership(TOwnershipType aOwner);
	  void SetTextLimit(TInt aLimit);
	  void RunCharMapDialogL();
	  TMargins8 Margins() const;
	  TInt UpperFullFormattingLength() const;
	  TInt LowerPartialFormattingLength() const;
	  void SetReadOnly(TBool aReadOnly);
	  TBool IsReadOnly() const;
	  void CheckNotReadOnlyL();
	  void SetAllowPictures(TBool aAllow);
	  void CheckRemovePictures(TInt aStartPos,TInt aLength);
	  void SetRightWrapGutter(TInt aGap);
	  void UndoL();
	  void ClearUndo();
	  void SetAllowUndo(TBool aAllow);
	  TBool SupportsUndo() const;
	  TBool CanUndo() const;
	  void SetWordDelimiters(TBool aPicture,TBool aPunctuation);
	  void GetWordInfo(TInt aCurrentPos,TInt& aStartPos,TInt& aLength) const;
	  void MoveCursorL(TCursorPosition::TMovementType aMovement,TBool aSelect);
	  void MoveDisplayL(TCursorPosition::TMovementType aMovement);
	  void CheckValidityOfChars(TInt aStartPos,TInt aLength);
	  void SetOnlyASCIIChars(TBool aASCIIOnly);
	  TBool OnlyASCIIChars() const;
	inline TInt AvgLinesInViewRect() const;
	inline TInt AvgCharsPerLine() const;
	inline void SetAvgLinesInViewRect(TInt aAvgLines);
	inline void SetAvgCharsPerLine(TInt aAvgChars);
	  void SetEdwinSizeObserver(MEikEdwinSizeObserver* aEdwinSizeObserver);
	  TInt MinimumHeight() const;
 



	  TInt MaximumHeight() const;

	  void SetMinimumHeight(TInt aHeight);
 



	  void SetMaximumHeight(TInt aHeight);
public:  
	  void InsertDeleteCharsL(TInt aInsertPos,const TDesC& aText,const TCursorSelection& aDelete);
	  void SetNonPrintingCharsVisibility(TNonPrintingCharVisibility aVisibility);
	  TNonPrintingCharVisibility NonPrintingCharsVisibility() const;
public:  
	  void SetAvkonWrap(TBool aAvkonWrapIsOn);
public:	 

     








      void SetAknEditorCase(TInt aCase);

     








      void SetAknEditorPermittedCaseModes(TInt aPermittedCaseModes);

     











      void SetAknEditorNumericKeymap(TAknEditorNumericKeymap aNumericKeymap);

     







      void SetAknEditorInputMode(TInt aInputMode);

     






      void SetAknEditorAllowedInputModes(TInt aInputModes);

     




      void SetAknEditorSpecialCharacterTable(TInt aSCTResId);

     






      void SetAknEditorFlags(TInt aFlags);

      void EnableCcpuSupportL(TBool aSupport);

     








      void SetAknEditorCurrentInputMode(TInt aInputMode);

     





      TInt AknEditorCurrentInputMode();

     









      void SetAknEditorCurrentCase(TInt aCase);

     






      void SetAknEditorLocalLanguage(TLanguage aLanguage);

     



      void NotifyEditorStateObserverOfStateChangeL();
public:
 
 
	  void SetMaximumHeightInLines(TInt aLines, TInt aBaselineSeparation);
	  TInt MaximumHeightInLines() const;
public:  
	  TBool CcpuIsFocused() const;
	  TBool CcpuCanCut() const;
	  void CcpuCutL();
	  TBool CcpuCanCopy() const;
	  void CcpuCopyL();
	  TBool CcpuCanPaste() const;
	  void CcpuPasteL();
	  TBool CcpuCanUndo() const;
	  void CcpuUndoL();
	  TInt  AknEdwinFlags() const;
 

public:  
	 
	  void CreateTextViewL();
	  CTextView* TextView() const;
	  CTextLayout* TextLayout() const;
	  TBool SetUndoBufferL(const TCursorSelection& aSelection);
	  void SetUndoableText(const TCursorSelection& aSelection);

	CAknEdwinState* EditorState() const;
	inline void SetMaxLength(TInt aLength );
	inline TInt MaxLength() const;
public:
	 
	  void AddFlagToUserFlags(TUint32 aFlag);
	  void RemoveFlagFromUserFlags(TUint32 aFlag);
	  TUint32 UserFlags() const ;

public:
	  void SetCharFormatLayer(CCharFormatLayer* aCharFormatLayer);
	  void SetParaFormatLayer(CParaFormatLayer* aParaFormatLayer);

 
public:
     












      void SetSkinBackgroundControlContextL( MAknsControlContext* aContext );

     










    MAknsControlContext* SkinBackgroundControlContext() const;

     







    TBool SkinEnabled() const;

	 









	  void SetAlignment(TInt aAlignment);

 
public:

     


    void DrawTextView() const;

     






      void SetPictographAnimationCallBack( TCallBack& aCallBack );

     



    const TCallBack& PictographAnimationCallBack() const;

protected:
	enum TEnd
		{
		EStart,
		EEnd   
		};
	enum TChunkSize
		{
		EChunkWord,
		EChunkPara
		};
	enum TEikEdwinFlags
		{  
		ERichText           =0x00000001,
		EDragDouble			=0x00000002,
		ELeftDownInViewRect =0x00000004,
		ENumericCharacters	=0x00000008,  
		EHasOneLineOnly     =0x00000010,   
        EPhoneNumberGrouping = 0x00000020  
		};
protected:  
	  void EditObserver(TInt aStartEdit,TInt aEditLength);
protected:
	  void TrappedDraw(const TRect& aRect) const;
	  void DrawContents();
	  void BaseConstructL();
	  void FormatTextL();
	  TInt DeleteHighlightL(TBool& aChanged,TBool aIsBackSpace=EFalse,TBool aPromptConfirmation=ETrue);
	  TBool OkToDeleteSelectionL();
	  void DeleteL(TBool& aChanged,const TCursorSelection& aSelection,TBool aIsBackSpace=EFalse,TBool aAllowUndo=ETrue);
	  void TrappedSizeChanged();
	  void HandleSizeChangedL();
	  void CancelSelectionL(TEnd aEndOfSelectionToLeaveCursor);
	  void MoveCursorToChunkStartL(TBool aSelect,TChunkSize aChunkSize,TEnd aEndScanningTowards);
	  void CancelInsertCharFormat();
	  void PlaceDataOnClipboardL();
	  void ReportEdwinEventL(MEikEdwinObserver::TEdwinEvent aEventType);
	  void SetLineCursorDetailsL();
	  virtual void CopyDocumentContentL(CGlobalText& aInText,CGlobalText& aOutText);
	  void DisplayFindTextNotFound(TDes& aFindText);
	  virtual void HandleTextPastedL(TInt aStartPos,TInt& aLength);
	  virtual CLafEdwinCustomDrawBase* CreateCustomDrawL();
	 
	  void ReadAknResourceL(TResourceReader& aReader);
protected:  
	  void CreateLayoutL(MLayDoc* aLayDoc);
	  void CreateTextAndLayoutL(CParaFormatLayer* aParaFormatLayer,CCharFormatLayer* aCharFormatLayer);
	  void CheckEdwinExtensionL();
	  CEikEdwinExtension* EdwinExtension();

private:
	enum
		{  
		EWysiwygOn						=0x00000010,
		EUnderOneScreenFormattedText	=0x00000020,
		EPictureDelimits				=0x00000040,
		EPunctuationDelimits			=0x00000080,
		EPasteFromIrStore				=0x00000100,
		ELockScrollBarState				=0x00000200,
		EOnReformatting					=0x00000400
		};

private:  
	  void SizeChanged();
	  TInt CountComponentControls() const;
	  CCoeControl* ComponentControl(TInt aIndex) const;
	  void Reserved_2();
private:
	  virtual void Reserved_3();
	  virtual void NotifyInvalidOperationOnReadOnlyL();
	  CEikScrollBarFrame* CreateScrollBarFrameL(TBool aPreAlloc);
	void SetVirtualCursorStateL(TBool aIsFocused) const;
	void SetHeightForNumOfLinesL();
	void ApplyAutoSelectionL();
	void SetScrollBarsL();
	void SetVertScrollBarModelByCharactersL(TEikScrollBarModel& aVertModel) const;
	void RetrieveDataFromClipboardL();
	void SetCursorVisibilityL(TBool aEmphasis);
	TBool OwnsScrollBars() const;
	void CreateScrollBarFrameLayout(TEikScrollBarFrameLayout& aLayout) const;
	void UpdateHorizScrollBarThumb();
	void UpdateVertScrollBarThumbL();
	void DoSetUndoBufferL(const TCursorSelection& aSelection);
	void DoPasteFromStoreL(const CStreamStore& aStore,const CStreamDictionary& aDict);
	void DoReplaceAllL(SEdwinFindModel* aModel,TBool& aTextFound,TBool& aReplaced);
	void DeleteExtraParasL(TInt aStartPos,TInt aLength);
	TInt LocateChar(TChar aChar,TInt aStartPos,TInt aLength);
	TBool IsValidChar(TInt aChar) const;
	TInt CalcMinimumHeightFromNumOfLinesL() const;
	void CheckEdwinHeight();
	TBool IsNewHeightWithinMinimumAndMaximum(TInt aNewHeight) const;
	void SetEdwinHeight(TInt aHeight);
	void DoCreateCustomDrawL();
	void SetCursorSizeAndType();
	TKeyResponse DoOfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	void DoCcpuCanPasteL() const;
	void DoReportEventL(MCoeControlObserver::TCoeEvent aEvent);
	void CheckIfEdwinIsResizable();
	void SetKeyboardRepeatRate(TTimeIntervalMicroSeconds32 aKeyRepeatRate) const;
	HBufC* GetAllowedCharsLC() const;
	TInt CheckAllowedCharsL(const TDesC& aChars, CClipboard& aClipboard, TBool aRichText) const;

	TInt CursorWidth() const;
	TFontSpec CursorFontSpec() const;

	void BuildEdwinFepSupport();
	void MakeCharFormatLayerMatchL(CCharFormatLayer* aCharFormatLayer);
	void MakeParaFormatLayerMatchL(CParaFormatLayer* aParaFormatLayer);
    void UpdateCache(TInt aId);
	void DrawBackgroundAroundTextView( 
		CWindowGc& gc, 
		const TRect& aOuterRect, 
		const TRect& aInnerRect, 
		const TRgb& aBackgroundColor  ) const;
	TInt CurrentAlignment() const;
	void DoAlignment();
	void NewParagraphL();
private:
	void DrawFirstLineTextL() const;
    CAknEdwinDrawingModifier* AknEdwinDrawingModifier();
    TBool EditorSupportsNeutralProtection() const;

     










    TBool NeedsNeutralProtection( TInt aPosOfLowEndOfDelete, TInt aLengthToDelete, TDes& aNewText, TBool& aForwardProtectionNeeded );

     







    TBool GetStrongDirectionality(TChar aChar, TBool& aRightToLeft ) const;

     





    TBool CharIsNeutral( TInt aPos ) const;

     













    TBool GetExposedDirectionOfTextInDescriptor( const TDesC& aText, TBool aForward, TBool& aIsRightToLeft ) const;

     











    TBool GetExposedDirectionOfText( TInt aPos, TBool aForward, TBool& aIsRightToLeft ) const;

     















    void ReplaceSelectionWithTextL( const TDesC& aNewText, 
                                    TInt aCursorPosInNewText,
                                    TBool& aFormatHasChanged );

     








    TBool IsPurePhoneNumberEditor() const;

protected:	 
	  TTypeUid::Ptr MopSupplyObject(TTypeUid aId);
protected:
	TUint32 iEdwinUserFlags;
	TUint32 iEdwinInternalFlags;
	CPlainText* iText;
protected:  
	CTextView* iTextView;
	CTextLayout* iLayout;
protected:
	TInt iTextLimit;
	TInt iNumberOfLines;
	MGraphicsDeviceMap* iZoomFactor;
	TInt iLastPointerDocPos;
	TMargins8 iMargins;
private:
	friend class CEikEdwinFepSupport;
	friend class CEikEdwinExtension;
	 
	CEikEdwinExtension* iEdwinExtension;  
	CEikScrollBarFrame* iSBFrame;
	MEikEdwinObserver* iEdwinObserver;
	CArrayPtr<MEikEdwinObserver>* iObserverArray;
	CEikEdwinFepSupport* iEdwinFepSupport;
	CUndoBuffer* iUndoStore;
	TInt iAvgLinesInViewRect;
	TInt iAvgCharsPerLine;
	TInt iRightWrapGutter;
	TInt iLayoutWidth;
	MEikEdwinSizeObserver* iEdwinSizeObserver;
	TInt iMinimumHeight;
	TInt iMaximumHeight;
 
























	TInt iMaximumHeightInLines; 
	CLafEdwinCustomDrawBase* iCustomDrawer;
	TInt iLastPointerAnchorPos;
	CAknCcpuSupport* iCcpuSupport;
	CCharFormatLayer* iCharFormatLayer;
	CParaFormatLayer* iParaFormatLayer;
	TInt iSpare_1;
	TInt iSpare_2;
	};


inline CEikScrollBarFrame* CEikEdwin::CreatePreAllocatedScrollBarFrameL()
	{ return CreateScrollBarFrameL(ETrue);}
inline CEikScrollBarFrame* CEikEdwin::ScrollBarFrame()
	{ return ((CEikScrollBarFrame* const)iSBFrame); }
inline TInt CEikEdwin::AvgLinesInViewRect() const
	{ return iAvgLinesInViewRect; }
inline TInt CEikEdwin::AvgCharsPerLine() const
	{ return iAvgCharsPerLine;}
inline void CEikEdwin::SetAvgLinesInViewRect(TInt aAvgLines)
	{ iAvgLinesInViewRect=aAvgLines; }
inline void CEikEdwin::SetAvgCharsPerLine(TInt aAvgChars)
	{ iAvgCharsPerLine=aAvgChars; }

inline void CEikEdwin::SetMaxLength(TInt aLength ) 
	{ SetTextLimit(aLength); }
inline TInt CEikEdwin::MaxLength() const 
	{ return iTextLimit; }


# 29 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikseced.h" 1
 
 
 
 












# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fepbase.h" 1
 
 
 
 

# 1119 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/fepbase.h"


# 17 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikseced.h" 2


 
class TResourceReader;
class CEikSecretEditorExtension;
class MAknsControlContext;

class CEikSecretEditor : public CEikBorderedControl, public MCoeFepAwareTextEditor, public MCoeFepAwareTextEditor_Extension1
	{
public:
	enum { EMaxSecEdBufLength=32, EMaxSecEdSecArrayLength = 255 };
public:
	  CEikSecretEditor();
	  ~CEikSecretEditor();
public:	 
	  virtual void ConstructFromResourceL(TResourceReader& aReader);
	  virtual TSize MinimumSize();
	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);	 
	  virtual TCoeInputCapabilities InputCapabilities() const;
public:	 
	 




	  void GetText(TDes& aText) const;
	 



	  virtual void SetText(const TDesC& aText);
	 






	  virtual void InitializeDisplay(TInt aNumberOfChars);
	  void Reset();
	 





	  void SetMaxLength(TInt aMaxLength);


	  void AknSetFont(const CFont &aFont);

	  void AknSetAlignment(const CGraphicsContext::TTextAlign &aAlign);

     










      void SetDefaultInputMode(TInt aInputMode);

	 



	  TInt MaxLength() const;

	 




	  const TDesC& Buffer() const;


	 




	  void RevealSecretText( TBool aReveal );

     










      void SetSkinBackgroundControlContextL( MAknsControlContext* aContext );

protected:	 
     
      virtual void AppendCharacterL( TInt aKeyCode );
      virtual void Update();
	void InsertSecretChar();
      void SizeChanged();
private:  
	  virtual void Draw(const TRect& aRect) const;

private:  
	  void StartFepInlineEditL(const TDesC& aInitialInlineText, TInt aPositionOfInsertionPointInInlineText, TBool aCursorVisibility, const MFormCustomDraw* aCustomDraw, MFepInlineTextFormatRetriever& aInlineTextFormatRetriever, MFepPointerEventHandlerDuringInlineEdit& aPointerEventHandlerDuringInlineEdit);
	  void UpdateFepInlineTextL(const TDesC& aNewInlineText, TInt aPositionOfInsertionPointInInlineText);
	  void SetInlineEditingCursorVisibilityL(TBool aCursorVisibility);
	  void CancelFepInlineEdit();
	  TInt DocumentLengthForFep() const;
	  TInt DocumentMaximumLengthForFep() const;
	  void SetCursorSelectionForFepL(const TCursorSelection& aCursorSelection);
	  void GetCursorSelectionForFep(TCursorSelection& aCursorSelection) const;
	  void GetEditorContentForFep(TDes& aEditorContent, TInt aDocumentPosition, TInt aLengthToRetrieve) const;
	  void GetFormatForFep(TCharFormat& aFormat, TInt aDocumentPosition) const;
	  void GetScreenCoordinatesForFepL(TPoint& aLeftSideOfBaseLine, TInt& aHeight, TInt& aAscent, TInt aDocumentPosition) const;
	  void DoCommitFepInlineEditL();
	  MCoeFepAwareTextEditor_Extension1* Extension1(TBool& aSetToTrue);
	  void SetStateTransferingOwnershipL(CState* aState, TUid aTypeSafetyUid);
	  CState* State(TUid aTypeSafetyUid);  

private:
	void OverflowAlert();

private:  
	  void Reserved_1();
	  void Reserved_2();
private:  
	  void MCoeFepAwareTextEditor_Reserved_2();
private:   
	  virtual void MCoeFepAwareTextEditor_Extension1_Reserved_2();
	  virtual void MCoeFepAwareTextEditor_Extension1_Reserved_3();
	  virtual void MCoeFepAwareTextEditor_Extension1_Reserved_4();

private:  
	void InsertChar();
    TInt CharsFitOnEditor() const;
	  virtual MCoeFepAwareTextEditor_Extension1::CState* CreateFepStateL();

private:
	typedef TBuf<EMaxSecEdBufLength> TSecEdBuf;
protected:
    HBufC* iSecCharArr;
	TInt iSecPos;
	TSecEdBuf iBuf;
	TInt iMaxLen;
	TInt iCharWidth;
	TInt iAscent;
	TBool iBufferFull;

public:  
	void StartTimer();
private:
	static TInt TimerCallback(TAny* aThis);
private:
	CPeriodic* iTimer;
	const CFont *iFont;
	CGraphicsContext::TTextAlign iAlign;
	TBool iRevealSecretText;  
	CEikSecretEditorExtension* iExtension;
	CState* iFepState;
	HBufC* iInlineEditText;
	};


# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikmfne.h" 1
 
 
 
 
















 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcal.h" 1
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikscbut.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbutb.h" 1
 
 
 
 

# 100 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbutb.h"

# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikscbut.h" 2



class CEikScrollButton : public CEikButtonBase
	{
public:
	enum TType
		{
		ENudgeLeft=SLafScrollButton::ENudgeLeft,
		ENudgeUp=SLafScrollButton::ENudgeUp,
		ENudgeRight=SLafScrollButton::ENudgeRight,
		ENudgeDown=SLafScrollButton::ENudgeDown,
		EPageLeft=SLafScrollButton::EPageLeft,
		EPageUp=SLafScrollButton::EPageUp,
		EPageRight=SLafScrollButton::EPageRight,
		EPageDown=SLafScrollButton::EPageDown,
		EHome=SLafScrollButton::EHome,
		ETop=SLafScrollButton::ETop,
		EEnd=SLafScrollButton::EEnd,
		EBottom=SLafScrollButton::EBottom
		};

public:
	enum TTypeOfScrollBar
		{
		ENormal		=0x00,
		EArrowHead	=0x01
		};

public:  
	  ~CEikScrollButton();
	  CEikScrollButton(TType aType);
	  TType Type() const;
	};


 
 
 

class CEikArrowHeadScrollButton : public CEikScrollButton
	{

public:
	  static CEikArrowHeadScrollButton* NewL(const CCoeControl* aParent, TType aType);
private:
	CEikArrowHeadScrollButton();
	};




# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcal.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcmbut.h" 1
 
 
 
 
















class CEikLabel;
class CEikImage;
class CEikAlignedControl;
class TResourceReader;
class CEikCommandStack;

class CEikCommandButtonBase : public CEikButtonBase, public MCoeControlContext
	{
public:
	enum TWhichComponent
		{
		EFirst,
		ESecond
		};
	enum TDisplayContent
		{
		EFirstOnly	=0x0100,
		ESecondOnly	=0x0200,
		EBoth		=0x0300
		};
	enum TLayout
		{
		EFirstRightSecondLeft=0x0000,
		EFirstBottomSecondTop=0x0001,
		EFirstTopSecondBottom=0x0002,
		EFirstLeftSecondRight=0x0003,
		EDenseFont			 =0x0008
		};
	enum TExcess
		{
		EShare		=0x0000,
		EToFirst	=0x0010,
		EToSecond	=0x0020
		};

public:  
	  ~CEikCommandButtonBase();
	  void SetButtonLayout(TLayout aLayout);
	  void SetExcessSpace(TExcess aExcess);
	  void SetDisplayContent(TDisplayContent aContent);
	  void LayoutComponents();
	  void StartConstructFromResourceL(TResourceReader& aReader);
	  void ConstructLabelFromResourceL(TResourceReader& aReader,TWhichComponent aWhich);
	  void ConstructImageFromResourceL(TResourceReader& aReader,TWhichComponent aWhich);
	  virtual void UpdateComponentAlignment();
	  void SetDefault(TBool aIsDefault);
public:	 
	  void SetDimmed(TBool aDimmed);
	  TSize MinimumSize();
	  TInt CountComponentControls() const;
	  CCoeControl* ComponentControl(TInt aIndex) const;
	  void ActivateL();
	  void SetContainerWindowL(const CCoeControl& aContainer);
	  void FocusChanged(TDrawNow aDrawNow);
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode  );
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
public:  
	CEikCommandStack* CommandStack() const;
	TInt ButFlags() const;
	TBool IsDefault() const;
protected:  
      void StateChanged();
protected:
	  CEikCommandButtonBase();
	  void SetTextL(const TDesC& aText,CEikAlignedControl*& aComponent);
	  void SetPictureL(const CFbsBitmap* aMain,const CFbsBitmap* aMask,CEikAlignedControl*& aComponent);
	  void SetPictureFromFileL(const TDesC& aFilename,TInt aMain,TInt aMask,CEikAlignedControl*& aComponent);
	inline void CheckCreateCommandStackL();
protected:  
	  void Draw(const TRect& aRect) const;
protected:
	void SetImageAttributes(CEikImage* aImage);
	inline TInt Behavior() const;
protected:
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:
      void SizeChanged();
	  void Reserved_2();
private:  
	  void Reserved_3();
private:  
      void PrepareContext(CWindowGc& aGc) const;
private:
	  virtual void Reserved_4();
private:
	void SetComponentExtents(const TRect& aRect);
	void SetNewComponentExtentL();
    TBool LayoutIsVertical() const;
protected:
	TMargins8 iMargins;
	CEikAlignedControl* iComponents[2];
    TInt iCmdFlags;
private:
	TInt iDrawOffset;
	CEikCommandStack* iCommandStack;
	TInt iDummy;
	TBool iDefault;
	};

class CEikCommandButton : public CEikCommandButtonBase
	{
public:
	enum TLayout
		{
		ETextRightPictureLeft=0x000,
		ETextBottomPictureTop=0x001,
		ETextTopPictureBottom=0x002,
		ETextLeftPictureRight=0x003
		};
	enum TExcess
		{
		EShare		=0x0000,
		EToText		=0x0010,
		EToPicture	=0x0020
		};
	enum TDisplayContent
		{
		ETextOnly		=0x0100,
		EPictureOnly	=0x0200,
		ETextAndPicture	=0x0300
		};
public:
	  CEikCommandButton();
	  ~CEikCommandButton();
	  void SetTextL(const TDesC& aText);
	  void SetPictureL(const CFbsBitmap* aMain,const CFbsBitmap* aMask= 0L );
	  void SetPictureFromFileL(const TDesC& aFilename,TInt aMain,TInt aMask=-1);
	  CEikLabel* Label() const;
	  CEikImage* Picture() const;
	  void SetButtonLayout(TLayout aLayout);
	  void SetExcessSpace(TExcess aExcess);
	  void SetDisplayContent(TDisplayContent aContent);
	  void SetCommandL(TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask);
	  void AddCommandToStackL(TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask);
	  TBool RemoveCommandFromStack(TInt aCommandId);
	  TInt PopCommandFromStack();
public:  
	  void ConstructFromResourceL(TResourceReader& aReader);
public:  
	  void UpdateComponentAlignment();
private:
	void UpdateLabelReserveLengthL(const TDesC* aText);
private:
	TInt iDummy;
	};

 






class CEikTwoPictureCommandButton : public CEikCommandButtonBase
	{
public:
	enum TLayout
		{
		ETextRightPictureLeft=0x000,
		ETextBottomPictureTop=0x001,
		ETextTopPictureBottom=0x002,
		ETextLeftPictureRight=0x003
		};
	enum TExcess
		{
		EShare		=0x0000,
		EToText		=0x0010,
		EToPicture	=0x0020
		};
	enum TDisplayContent
		{
		ETextOnly		=0x0100,
		EPictureOnly	=0x0200,
		ETextAndPicture	=0x0300
		};
private:
	enum TPictureButtonType
		{
		EPictureButWithBorders		=0x0000,
		EPictureButWithoutBorders	=0x1000
		};
	enum TExternalPicture
		{
		EPictureNotOwnedExternally	=0x00,
		EPictureOwnedExternally		=0x01
		};
public:
	  CEikTwoPictureCommandButton();
	  ~CEikTwoPictureCommandButton();
	  TBool IsSecondPictureOwnedExternally();
	  CEikImage* Picture() const;
	  void ConstructImagesFromResourceL(TResourceReader& aReader,TWhichComponent aWhich);
	  void SetTextL(const TDesC& aText);
	  void SetTwoPicturesL(const CFbsBitmap* aMain,const CFbsBitmap* aMask= 0L ,const CFbsBitmap* aSecondMain= 0L , const CFbsBitmap* aSecondMask= 0L );
	  void SetSecondPicture(const CFbsBitmap* aSecondMain, const CFbsBitmap* aSecondMask= 0L );
	  void SetPictureFromFileL(const TDesC& aFilename,TInt aMain,TInt aMask=-1);
	  void SetSecondPictureFromFileL(const TDesC& aFilename,TInt aMain,TInt aMask=-1);
	  void SetSecondPictureOwnedExternally(TBool aOwnership);
public:  
	  void ConstructFromResourceL(TResourceReader& aReader);
	  void ActivateL();
protected:  
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:  
	  void Draw(const TRect&  ) const;
      void StateChanged();
private:  
      void PrepareContext(CWindowGc& aGc) const;
private:
	void SwapPictures(CEikImage* aImage);
private:
	const CFbsBitmap* iSecondBitmap;
	const CFbsBitmap* iSecondMaskBitmap;
	TInt iPictureFlags;
	TInt iDummy;
	};

 





class CEikInverterCommandButton : public CEikCommandButton
	{
public:
	  CEikInverterCommandButton();
	  ~CEikInverterCommandButton();
protected:
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:  
      void PrepareContext(CWindowGc& aGc) const;
private:
	TInt iFlag;
	TInt iDummy;
	};

 
 
 

class CEikTextButton : public CEikCommandButtonBase
	{
public:
	  CEikTextButton();
	  ~CEikTextButton();
	  void SetTextL(const TDesC& aText,TWhichComponent aWhich=EFirst);
	  CEikLabel* Label(TWhichComponent aWhich=EFirst) const;
public:  
	  void ConstructFromResourceL(TResourceReader& aReader);
private:
	TInt iDummy;
	};

class CEikBitmapButton : public CEikCommandButtonBase
	{
public:
	  CEikBitmapButton();
	  ~CEikBitmapButton();
	  void SetPictureL(const CFbsBitmap* aMain,const CFbsBitmap* aMask= 0L ,TWhichComponent aWhich=EFirst);
	  void SetPictureFromFileL(const TDesC& aFilename,TInt aMain,TInt aMask=-1,TWhichComponent aWhich=EFirst);
	  CEikImage* Picture(TWhichComponent aWhich=EFirst) const;
public:  
	  void ConstructFromResourceL(TResourceReader& aReader);
private:
	TInt iDummy;
	};


# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcal.h" 2




class MEikCalendarObserver
	{
public:
	virtual void GetMinimumAndMaximumAndInitialDatesForCalendarL(TTime& aMinimumDate, TTime& aMaximumDate, TTime& aInitialDate) const=0;
	virtual void SetDateFromCalendarAndDrawNow(const TTime& aDate)=0;
	};



# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikmfne.h" 2







 
 
 
class CEikonEnv;
class CTimeEditor;
class CDateEditor;

 
class MAknsControlContext;

 
class CEikMfneExtension;

 

class CEikMfneField : public CBase
	{
public:
	enum THighlightType
		{
		EInverseVideo,
		ECursor
		};
protected:
	  CEikMfneField();
public:
	void Draw(CWindowGc& aGc, const CFont& aFont, const TPoint& aTopLeft) const;
	TInt WidthInPixels(const CFont& aFont) const;
	TInt DistanceFromStartOfFieldToEndOfTextInPixels(const CFont& aFont) const;
	virtual TInt MaximumWidthInPixels(const CFont& aFont, TBool aShrinkToMinimumSize)=0;
	virtual TCoeInputCapabilities InputCapabilities() const=0;
	  virtual TBool IsEditable() const;
	  virtual TBool IsValid() const;
	 
	  virtual THighlightType HighlightType() const;
	  virtual void HandleKey(const CFont& aFont, const TKeyEvent& aKeyEvent, TBool aInterpretLeftAndRightAsEarEvents, TBool& aDataAltered, TInt& aHighlightIncrement);
	  virtual void HandleDeHighlight(const CFont& aFont, CEikonEnv& aEikonEnv, TBool& aDataAltered, TBool& aError);
protected:
	  void HandleLeftOrRightArrow(TChar aKey, TBool& aDataAltered, TInt& aHighlightIncrement);
private:
	virtual const TDesC& Text() const=0;
protected:
	TInt iMinimumWidthInPixels;
	};

 

class CEikMfneSeparator : public CEikMfneField
	{
private:
	CEikMfneSeparator(HBufC* aText);
public:
	  virtual ~CEikMfneSeparator();
	  static CEikMfneSeparator* NewL(TResourceReader& aResourceReader);
	  static CEikMfneSeparator* NewL(HBufC* aText);  
	  void SetText(HBufC* aText);  
private:  
	virtual TInt MaximumWidthInPixels(const CFont& aFont, TBool aShrinkToMinimumSize);
	virtual TCoeInputCapabilities InputCapabilities() const;
	virtual const TDesC& Text() const;
private:
	HBufC* iText;
	};

 

class CEikMfneNumber : public CEikMfneField
	{
public:
	enum
		{
		EFillWithLeadingZeros			=0x1,
		EPreserveOldWidthBeforeEditing	=0x2,
		ERepresentsYear					=0x4,
		EPublicallySettableFlags		=EFillWithLeadingZeros|EPreserveOldWidthBeforeEditing|ERepresentsYear
		};
private:
	enum
		{
		EIsBeingEditedWithCursor		=0x8,
		EIsUninitialised				=0x10
		};
private:
	CEikMfneNumber(TInt aMinimumValue, TInt aMaximumValue, TUint32 aFlags);
	void ConstructL();
public:
	  virtual ~CEikMfneNumber();
	  static CEikMfneNumber* NewL(const CFont& aFont, TResourceReader& aResourceReader);
	  static CEikMfneNumber* NewL(const CFont& aFont, TInt aMinimumValue, TInt aMaximumValue, TInt aInitialValue, TUint32 aFlags);
	  void SetMinimumAndMaximum(TInt aMinimumValue, TInt aMaximumValue, const CFont& aFont);  
	  void GetMinimumAndMaximum(TInt& aMinimumValue, TInt& aMaximumValue) const;
	  void SetValue(TInt aValue, const CFont& aFont);
	  TInt Value() const;
	  virtual TBool IsValid() const;

	  void SetUninitialised(TBool aUninitialised);
	  TBool IsUninitialised() const;

public:	 
	void SetDigitType(TDigitType aDigitType, const CFont& aFont);
	const TDigitType DigitType() const;

	 
	void RefreshDigitType(const CFont& aFont);

public:
	TBool IsTextNull() const;
private:  
	virtual TInt MaximumWidthInPixels(const CFont& aFont, TBool aShrinkToMinimumSize);
	virtual TCoeInputCapabilities InputCapabilities() const;
	virtual TBool IsEditable() const;
	virtual THighlightType HighlightType() const;
	virtual void HandleKey(const CFont& aFont, const TKeyEvent& aKeyEvent, TBool aInterpretLeftAndRightAsEarEvents, TBool& aDataAltered, TInt& aHighlightIncrement);
	virtual void HandleDeHighlight(const CFont& aFont, CEikonEnv& aEikonEnv, TBool& aDataAltered, TBool& aError);
	virtual const TDesC& Text() const;
private:
	TInt MaximumNumberOfDigits() const;
	TInt NumberOfDigits() const;
	void SetTextToValue(TInt aValue, const CFont& aFont);
	TInt ValueFromText() const;
	TBool ConvertsIntoValidValue(TInt& aValue) const;

private:  
	TChar NormalizeDigit(TChar aChar);
	TText ZeroCharacter() const;
	TText NegativeCharacter() const;

private:
	TInt iMinimumValue;
	TInt iMaximumValue;
	TInt iMaxDigits;
	TUint32 iFlags;
	HBufC* iText;
	TChar iNudgeCharMinus;
	TChar iNudgeCharPlus;
	TInt iMaxDigitsMinimumValue;
    TInt iMaxDigitsMaximumValue;
	TDigitType	iDigitType;
	};

 

class CEikMfneSymbol : public CEikMfneField
	{
public:
	class CItem : public CBase
		{
	private:
		CItem(TInt aId, TChar aKeyToMatch, HBufC* aText);
	public:
		  virtual ~CItem();
		  static CItem* NewL(TResourceReader& aResourceReader);
		  static CItem* NewL(TInt aId, TChar aKeyToMatch, HBufC* aText);  
		  void SetText(HBufC* aText);  
	private:
		friend class CEikMfneSymbol;
	private:
		TInt iId;
		TCharF iKeyToMatch;
		HBufC* iText;
		};
private:
	CEikMfneSymbol(TInt aNumSymbolicItems);
public:
	  virtual ~CEikMfneSymbol();
	  static CEikMfneSymbol* NewL(TResourceReader& aResourceReader);
	  static CEikMfneSymbol* NewL(TInt aNumSymbolicItems);
	  void AddSymbolicItem(CItem* aSymbolicItem, TBool aMakeCurrent);  
	  void SetCurrentSymbolicItemToId(TInt aId);
	  TInt IdOfCurrentSymbolicItem() const;
	  void SetUninitialised(TBool aUninitialised);
	  TBool IsUninitialised() const;
private:  
	virtual TInt MaximumWidthInPixels(const CFont& aFont, TBool aShrinkToMinimumSize);
	virtual TCoeInputCapabilities InputCapabilities() const;
	virtual TBool IsEditable() const;
	virtual THighlightType HighlightType() const;
	virtual void HandleKey(const CFont& aFont, const TKeyEvent& aKeyEvent, TBool aInterpretLeftAndRightAsEarEvents, TBool& aDataAltered, TInt& aHighlightIncrement);
	virtual void HandleDeHighlight(const CFont& aFont, CEikonEnv& aEikonEnv, TBool& aDataAltered, TBool& aError);
	virtual const TDesC& Text() const;
private:
	TInt CurrentSymbolicItem() const;
	void SetCurrentSymbolicItem(TInt aCurrentSymbolicItem);
private:
	TInt iNumSymbolicItems;
	TInt iCurrentSymbolicItem;
	CItem** iSymbolicItems;
	};

 

class CEikMfne : public CEikBorderedControl
	{
public:
	 
	  CEikMfne();
	  virtual ~CEikMfne();
	  void CreateFieldArrayL(TInt aNumFields);  
	  void AddField(CEikMfneField* aField);  
	  TMargins BorderMargins() const;
	  void DrawNowAndLeaveWithTimeDateFormatInfoMsgL(TInt aResourceId, const TTime& aTimeDate) const;
	  CEikMfneField* Field(TInt aField) const;
public:
	 
	  static TTime ReadTime(TResourceReader& aResourceReader);
	  static TTime ReadDate(TResourceReader& aResourceReader);
	  static TTime ReadTimeAndDate(TResourceReader& aResourceReader);
	  static TTimeIntervalSeconds ReadDuration(TResourceReader& aResourceReader);
	  static TTimeIntervalSeconds ReadTimeOffset(TResourceReader& aResourceReader);
	  static TTimeIntervalSeconds Convert(const TTime& aTime);
	  static TTime Convert(const TTimeIntervalSeconds& aTimeIntervalSeconds);
     
    inline TInt CurrentField() const;
    inline TInt NumFields() const;

public:  
      void SetMfneAlignment(TInt aAlignment);
      void SetUpAndDownKeysConsumed(TBool aConsume);

     
    void HighlightField(  TInt aFieldPosition );

	  const CFont* Font() const;
	  void SetFont(const CFont* aFont);

     












      void SetSkinBackgroundControlContextL( MAknsControlContext* aControlContext );

public:	 
	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);
	  virtual void PrepareForFocusLossL();
	  virtual TSize MinimumSize();
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
	  virtual TCoeInputCapabilities InputCapabilities() const;
protected:
	 
	  virtual void FocusChanged(TDrawNow aDrawNow);
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
	 
	  void HandleInteraction(TBool aHandleDeHighlight, TInt aNewCurrentField, TInt aOldWidthInPixelsOfOldCurrentField,
								CEikMfneField::THighlightType aOldHighlightTypeOfOldCurrentField, TBool& aDataAltered, TBool& aError);
	  virtual void FieldIsAboutToBeDeHighlighted(CEikMfneField* aField, TBool& aDrawAllFields);  
	  TSize MfneSize() const;
	  TSize MfneSize(TBool aShrinkToMinimumSize);

public:
	static void InvalidFieldAlert();
	static void LeaveWithAlert(TInt aResourceId);

private:
	 
	  virtual void Draw(const TRect& aRect) const;
	  virtual void HandlePointerEventL(const TPointerEvent& aPointerEvent);
	 
	  virtual void CreatePopoutIfRequiredL();
	 
	void DrawRange(CWindowGc& aGc, TInt aFirstField, TInt aLastField) const;
	CWindowGc& PreparedGc() const;
	void SetGcToNormalVideo(CWindowGc& aGc) const;
	void SetGcToInverseVideo(CWindowGc& aGc) const;
	void SetGcToDimmedVideo(CWindowGc& aGc) const;
	void DrawCursor();
	void HideCursor();
	  void Reserved_2();
	  virtual void CEikMfne_Reserved();

private:
	enum {ENullIndex=KMaxTInt};

	 





	TBool ConsumesUpAndDownKeys() const;

	 









	TBool SkinningBackground() const;

	 




 
	void EvaluateSkinningBackground(); 

     









    MAknsControlContext* SkinBackgroundControlContext() const;

     


    void CreateExtensionIfRequiredL();

private:
	TInt iNumFields;
	TInt iCurrentField;
	CEikMfneField** iFields;
	CEikMfneExtension* iExtension;
	const CFont* iFont;
    TInt iAlignment;
    TBitFlags iFlags;
	};

inline TInt CEikMfne::CurrentField() const
    {
    return(iCurrentField);
    }

inline TInt CEikMfne::NumFields() const
    {
    return(iNumFields);
    }

 

class CEikNumberEditor : public CEikMfne
	{
public:
	 
	  CEikNumberEditor();
	  void ConstructL(TInt aMinimumValue, TInt aMaximumValue, TInt aInitialValue);  
	  void SetMinimumAndMaximum(TInt aMinimumValue, TInt aMaximumValue);  
	  void GetMinimumAndMaximum(TInt& aMinimumValue, TInt& aMaximumValue) const;
	  void SetNumber(TInt aNumber);
	  TInt Number() const;  
	 
	  virtual void ConstructFromResourceL(TResourceReader& aResourceReader);
private:
	  virtual void CEikMfne_Reserved();

private:
	void RefreshFromLocale();

private:
	 
	CEikMfneNumber* iNumber;
	TInt iSpare;
	};


 

struct SEikRange
	{
	TInt iLowerLimit;
	TInt iUpperLimit;
	};

 

class CEikRangeEditor : public CEikMfne
	{
public:
	 
	  CEikRangeEditor();
	 
	  void ConstructL(TInt aMinimumValue, TInt aMaximumValue, const SEikRange& aInitialRange, HBufC* aSeparatorText);
	  void SetMinimumAndMaximum(TInt aMinimumValue, TInt aMaximumValue);  
	  void GetMinimumAndMaximum(TInt& aMinimumValue, TInt& aMaximumValue) const;
	  void SetRange(const SEikRange& aRange);
	  SEikRange Range() const;  
	 
	  virtual void ConstructFromResourceL(TResourceReader& aResourceReader);
private:
	virtual void FieldIsAboutToBeDeHighlighted(CEikMfneField* aField, TBool& aDrawAllFields);
	  virtual void CEikMfne_Reserved();
	void RefreshFromLocale();

private:
	 
	CEikMfneNumber* iLowerLimit;
	CEikMfneNumber* iUpperLimit;
	TInt iSpare;
	};


 

class CEikTTimeEditor : public CEikMfne
	{
public:
	virtual void SetMinimumAndMaximum(const TTime& aMinimumTime, const TTime& aMaximumTime)=0;
	virtual void GetMinimumAndMaximum(TTime& aMinimumTime, TTime& aMaximum) const=0;
	virtual void SetTTime(const TTime& aTime)=0;
	virtual TTime GetTTime() const=0;  
	};


class CEikTimeEditor : public CEikTTimeEditor
	{
public:
	 
	  CEikTimeEditor();
	  virtual ~CEikTimeEditor();
	  void ConstructL(const TTime& aMinimumTime, const TTime& aMaximumTime, const TTime& aInitialTime, TUint32 aFlags);  
	  void SetTime(const TTime& aTime);
	  TTime Time() const;
	  void SetUninitialised(TBool aUninitialised);
	  TBool IsUninitialised() const;
	 
	  virtual void SetMinimumAndMaximum(const TTime& aMinimumTime, const TTime& aMaximumTime);  
	  virtual void GetMinimumAndMaximum(TTime& aMinimumTime, TTime& aMaximumTime) const;
	 
	  virtual void ConstructFromResourceL(TResourceReader& aResourceReader);
	  virtual void PrepareForFocusLossL();
private:
	 
	virtual void SetTTime(const TTime& aTime);
	virtual TTime GetTTime() const;  
private:
	 
	void DoSetMinimumAndMaximum(const TTime& aMinimumTime, const TTime& aMaximumTime);
	  virtual void CEikMfne_Reserved();
private:
	CTimeEditor* iTimeEditor;
	TTime iMinimumTime;
	TTime iMaximumTime;
	TInt iSpare;
	};


 

 



class CEikDateEditor : public CEikTTimeEditor, private MEikCalendarObserver
	{
public:
	 
	  CEikDateEditor();
	  virtual ~CEikDateEditor();
	  void ConstructL(const TTime& aMinimumDate, const TTime& aMaximumDate, const TTime& aInitialDate, TBool aWithoutPopoutCalendar);  
	  void SetDate(const TTime& aDate);
	  TTime Date() const;
	  void SetUninitialised(TBool aUninitialised);
	  TBool IsUninitialised() const;
	 
	  virtual void SetMinimumAndMaximum(const TTime& aMinimumDate, const TTime& aMaximumDate);  
	  virtual void GetMinimumAndMaximum(TTime& aMinimumDate, TTime& aMaximumDate) const;
	 
	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);
	  virtual void ConstructFromResourceL(TResourceReader& aResourceReader);
	  virtual void PrepareForFocusLossL();

private:
	 
	virtual void CreatePopoutIfRequiredL();
	 
	virtual void SetTTime(const TTime& aDate);
	virtual TTime GetTTime() const;  
private:
	 
	virtual void GetMinimumAndMaximumAndInitialDatesForCalendarL(TTime& aMinimumDate, TTime& aMaximumDate, TTime& aInitialDate) const;
	virtual void SetDateFromCalendarAndDrawNow(const TTime& aDate);
	 
	void DoSetMinimumAndMaximum(const TTime& aMinimumDate, const TTime& aMaximumDate);
	  virtual void CEikMfne_Reserved();

private:
	CDateEditor* iDateEditor;
	TTime iMinimumDate;
	TTime iMaximumDate;
	TInt iSpare;
	};


 

class CEikTimeAndDateEditor : public CEikTTimeEditor, private MEikCalendarObserver
	{
public:
	 
	  CEikTimeAndDateEditor();
	  virtual ~CEikTimeAndDateEditor();
	 
	  void ConstructL(const TTime& aMinimumTimeAndDate, const TTime& aMaximumTimeAndDate, const TTime& aInitialTimeAndDate, TUint32 aFlags, HBufC* aInterveningText= 0L );
	  void SetTimeAndDate(const TTime& aTimeAndDate);
	  TTime TimeAndDate() const;
	  void SetUninitialised(TBool aUninitialised);
	  TBool IsUninitialised() const;
	 
	  virtual void SetMinimumAndMaximum(const TTime& aMinimumTimeAndDate, const TTime& aMaximumTimeAndDate);  
	  virtual void GetMinimumAndMaximum(TTime& aMinimumTimeAndDate, TTime& aMaximumTimeAndDate) const;
	 
	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);
	  virtual void ConstructFromResourceL(TResourceReader& aResourceReader);
	  virtual void PrepareForFocusLossL();
private:
	 
	virtual void CreatePopoutIfRequiredL();	
	  virtual void CEikMfne_Reserved();
	 
	virtual void SetTTime(const TTime& aTimeAndDate);
	virtual TTime GetTTime() const;  
private:
	 
	virtual void GetMinimumAndMaximumAndInitialDatesForCalendarL(TTime& aMinimumDate, TTime& aMaximumDate, TTime& aInitialDate) const;
	virtual void SetDateFromCalendarAndDrawNow(const TTime& aDate);
	 
	void DoSetMinimumAndMaximum(const TTime& aMinimumTimeAndDate, const TTime& aMaximumTimeAndDate);
private:
	CTimeEditor* iTimeEditor;
	CDateEditor* iDateEditor;
	TTime iMinimumTimeAndDate;
	TTime iMaximumTimeAndDate;
	TInt iSpare;
	};


 

class CEikDurationEditor : public CEikMfne
	{
public:
	 
	  CEikDurationEditor();
	  virtual ~CEikDurationEditor();
	  void ConstructL(const TTimeIntervalSeconds& aMinimumDuration, const TTimeIntervalSeconds& aMaximumDuration, const TTimeIntervalSeconds& aInitialDuration, TUint32 aFlags);
	  void SetMinimumAndMaximum(const TTimeIntervalSeconds& aMinimumDuration, const TTimeIntervalSeconds& aMaximumDuration);  
	  void GetMinimumAndMaximum(TTimeIntervalSeconds& aMinimumDuration, TTimeIntervalSeconds& aMaximumDuration) const;
	  void SetDuration(const TTimeIntervalSeconds& aDuration);
	  TTimeIntervalSeconds Duration() const;  
	 
	  void ConstructFromResourceL(TResourceReader& aResourceReader);
	  void PrepareForFocusLossL();
private:
	 
	void DoSetMinimumAndMaximum(const TTimeIntervalSeconds& aMinimumDuration, const TTimeIntervalSeconds& aMaximumDuration);
	  virtual void CEikMfne_Reserved();
private:
	CTimeEditor* iTimeEditor;
	TTimeIntervalSeconds iMinimumDuration;
	TTimeIntervalSeconds iMaximumDuration;
	TInt iSpare;
	};


class CEikTimeOffsetEditor : public CEikMfne
	{
public:
	 
	  CEikTimeOffsetEditor();
	  virtual ~CEikTimeOffsetEditor();
	  void ConstructL(const TTimeIntervalSeconds& aMinimumTimeOffset, const TTimeIntervalSeconds& aMaximumTimeOffset, const TTimeIntervalSeconds& aInitialTimeOffset, TUint32 aFlags);
	  void SetMinimumAndMaximum(const TTimeIntervalSeconds& aMinimumTimeOffset, const TTimeIntervalSeconds& aMaximumTimeOffset);  
	  void GetMinimumAndMaximum(TTimeIntervalSeconds& aMinimumTimeOffset, TTimeIntervalSeconds& aMaximumTimeOffset) const;
	  void SetTimeOffset(const TTimeIntervalSeconds& aTimeOffset);
	  TTimeIntervalSeconds TimeOffset() const;  
	 
	  void ConstructFromResourceL(TResourceReader& aResourceReader);
	  void PrepareForFocusLossL();
private:
	 
	void DoSetMinimumAndMaximum(const TTimeIntervalSeconds& aMinimumTimeOffset, const TTimeIntervalSeconds& aMaximumTimeOffset);
	  virtual void CEikMfne_Reserved();
private:
	CTimeEditor* iTimeEditor;
	TTimeIntervalSeconds iMinimumTimeOffset;
	TTimeIntervalSeconds iMaximumTimeOffset;
	 
	CEikMfneSymbol* iSign;
	TInt iSpare;
	};




 
 

enum
	{
	EEikOrientationNorthSouth   =0x1000,
	EEikOrientationWestEast     =0x2000,
	EEikOrientationMask=EEikOrientationNorthSouth|EEikOrientationWestEast
	};


enum
	{
	EEikDirectionNegative,
	EEikDirectionPositive,
	EEikDirectionMask=EEikDirectionNegative|EEikDirectionPositive
	};


enum TEikCompass
	{
	EEikCompassNorth=EEikOrientationNorthSouth|EEikDirectionNegative,
	EEikCompassSouth=EEikOrientationNorthSouth|EEikDirectionPositive,
	EEikCompassEast=EEikOrientationWestEast|EEikDirectionNegative,
	EEikCompassWest=EEikOrientationWestEast|EEikDirectionPositive
	};


struct SEikDegreesMinutesDirection
	{
	TInt iDegrees;
	TInt iMinutes;
	TInt iSeconds;
	TEikCompass iDirection;
	};


 
# 31 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnumseced.h" 1
 

























 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikseced.h" 1
 
 
 
 

# 188 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikseced.h"

# 32 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnumseced.h" 2


 
class CAknNumericSecretEditor : public CEikSecretEditor
	{
public:
	  CAknNumericSecretEditor();
    ~CAknNumericSecretEditor();
public:	 
	  virtual TCoeInputCapabilities InputCapabilities() const;
protected:
     
      virtual void AppendCharacterL( TInt aKeyCode );
	  virtual MCoeFepAwareTextEditor_Extension1::CState* CreateFepStateL();
private:  
	  void Reserved_1();
	  void Reserved_2();
private:  
	  void MCoeFepAwareTextEditor_Reserved_2();
private:   
	  virtual void MCoeFepAwareTextEditor_Extension1_Reserved_2();
	  virtual void MCoeFepAwareTextEditor_Extension1_Reserved_3();
	  virtual void MCoeFepAwareTextEditor_Extension1_Reserved_4();
	TInt iSpare;
	};


            
 
# 32 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnumedwin.h" 1
 


























 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 1
 
 
 
 
 
# 972 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h"

# 29 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnumedwin.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnumed.h" 1
 

























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h" 1
 
 
 
 
 
# 972 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwin.h"

# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnumed.h" 2



 



class CAknNumericEdwin : public CEikEdwin
	{
public:
	  virtual ~CAknNumericEdwin();
	enum TValidationStatus
		{
		EValueValid = KErrNone,
		EValueTooSmall,
		EValueTooLarge,
		EValueNotParsed,
		EEmpty
		};

protected:
	  void MapKeyEvent(TKeyEvent& aKeyEvent,TEventCode&  , TDigitType aDigitType) const;

private:  
		  virtual void Reserved_3();
	};



# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnumedwin.h" 2



static const TLitC<sizeof(L"%d"  )/2>   KAknIntegerFormat ={sizeof(L"%d"  )/2-1,L"%d"  } ;

 


class CAknIntegerEdwin : public CAknNumericEdwin
	{
public:
	  static CAknIntegerEdwin* NewL(TInt aMin, TInt aMax, TInt aMaxChars);
	  virtual void ConstructFromResourceL(TResourceReader& aReader);
	  void ConstructL( TInt aMin, TInt aMax, TInt aMaxChars );

	 
	  void SetValueL(TInt aValue);
	  void SetUnsetValue( TInt aUnsetValue);
	  TValidationStatus GetTextAsInteger( TInt& aValue );
	  void SetMinimumIntegerValue( TInt aMinimumValue );
	  void SetMaximumIntegerValue( TInt aMaximumValue );

	 
	  void PrepareForFocusLossL();
	  void HandleResourceChange(TInt aType);
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);

private:
	void CommonConstructL(TInt aMin, TInt aMax, TInt aMaxChars, TInt aFlags, TInt aUnset);
	void RefreshFromLocale();

private:  
      void Reserved_3();

private:
	TInt iMinimumValue;
	TInt iMaximumValue;
	TInt iUnsetValue;
	TAny* iUnsetText;
	TDigitType iDigitType;
	TInt iSpare_Integer_2;
	};


# 33 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikfpne.h" 1
 
 
 
 
 
 












 











class CEikFloatingPointEditor : public CAknNumericEdwin
	{
public:
	 


	  CEikFloatingPointEditor();
	 


	  void ConstructL(const TReal& aMin,const TReal& aMax,TInt aTextLimit);
	 





	  TReal Value() const;
	 



	  TValidationStatus GetValueAsReal( TReal& aValue );
	 




	  void SetValueL(const TReal* aValue);
	 





	  void SetMinMax(TReal aMin,TReal aMax);
	 





	  void GetMinMax(TReal& aMin,TReal& aMax) const;
public:  
	 




	  virtual void ConstructFromResourceL(TResourceReader& aReader);
	 



	  virtual void PrepareForFocusLossL();
	 


	  virtual TCoeInputCapabilities InputCapabilities() const;

	
	 


	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);

	 


	  virtual void HandleResourceChange(TInt aType);

private:  
		  void Reserved_3();

private:
	TReal iValue;
	TReal iMin;
	TReal iMax;
	TInt iSpare;
	};


 

















class CEikFixedPointEditor : public CAknNumericEdwin
	{
public:
	 


	  CEikFixedPointEditor();
	 


	  void ConstructL(TInt aMin,TInt aMax);
	 








	  TInt Value() const;
	 



      TValidationStatus GetValueAsInteger( TInt& aValue );
	 





	  void SetValueL(const TInt* aValue);
	 





	  void SetMinMax(TInt aMin, TInt aMax);
	 





	  void GetMinMax(TInt& aMin, TInt& aMax) const;
	 







	  void SetDecimalPlaces(TInt aDecimalPlaces);
	 







	  TInt DecimalPlaces() const;
public:	 
	 




	  virtual void ConstructFromResourceL(TResourceReader& aReader);
	 



	  virtual void PrepareForFocusLossL();
	 


	  virtual TCoeInputCapabilities InputCapabilities() const;

	 


	  virtual TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);

	 


	  virtual void HandleResourceChange(TInt aType);

private:
	 



	TInt RequiredNumberOfCharacters() const;
private:  
		  void Reserved_3();
private:
	TInt iValue;
	TInt iMin;
	TInt iMax;
	TInt iDecimalPlaces;
	TInt iSpare;
	};

# 34 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikimage.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikalign.h" 1
 
 
 
 
















class CEikAlignedControl : public CCoeControl
	{
public:
	  CEikAlignedControl();
	  ~CEikAlignedControl();
	  void SetAllMarginsTo(TInt aValue);
	  void SetAlignment(TGulAlignmentValue aAlign);
protected:  
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
public:
	TMargins8 iMargin;
	TGulAlignment iAlignment;
	};



# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikimage.h" 2



class CFbsBitmap;
class CBitmapContext;

class CEikImage : public CEikAlignedControl
	{
public:
	  CEikImage();
	  ~CEikImage();
public:  
	  TSize MinimumSize();
	  void ConstructFromResourceL(TResourceReader& aReader);
public:  
	  void CreatePictureFromFileL(const TDesC& aFilename,TInt aMainId,TInt aMaskId=-1);
	  void SetPicture(const CFbsBitmap* aBitmap,const CFbsBitmap* aMaskBitmap= 0L );
	  void SetEmphasis(TBool aEmphasis);
	  void SetPictureOwnedExternally(TBool aOwnership);
	  const CFbsBitmap* Bitmap() const;
	  const CFbsBitmap* Mask() const;
	  void SetBitmap(const CFbsBitmap* aBitmap);
	  void SetMask(const CFbsBitmap* aMaskBitmap);
	  void SetNewBitmaps(const CFbsBitmap* aNewBitmap,const CFbsBitmap* aNewMask);
	  TBool IsPictureOwnedExternally();
	  void SetBrushStyle(CGraphicsContext::TBrushStyle aBrushStyle);
protected:  
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:  
	  void Draw(const TRect& aRect) const;
	  void Reserved_2();
private:
	const CFbsBitmap* iBitmap;
	const CFbsBitmap* iMaskBitmap;
	TInt iImFlags;
	TInt iSpare;
	CGraphicsContext::TBrushStyle iBrushStyle;
	};


# 36 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwob.h" 1
 
 
 
 

# 35 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikedwob.h"

# 37 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpanic.h" 1
 


















 
 
 
 






enum TAknPanic
	{
	EAknPanicFormattedCellListInvalidBitmapIndex,
	EAknPanicNoSuchControlInStack,
	EAknPanicListboxUndefined,
	EAknPanicListboxSizeIsNotAccordingToLAFSpec,
	EAknPanicListboxShortcutValueNotHandled,
	EAknPanicListboxShortcutInvalidValue,
	EAknPanicOutOfRange,
	EAknPanicListboxLayoutProblem,
	EAknPanicLAF,
	EAknPanicLayoutResourceProblem,
	EAknPopupCorrupt,  
    EAknPanicNullPointer,
	EAknPanicLayoutMismatchBetweenMarginsAndParentRect,
	EAknPanicLayoutTextResourceProblem,
	EAknPanicLayoutRectResourceProblem,
	EAknPanicLayoutEdwinResourceProblem,
	EAknPanicLayoutMfneResourceProblem,
	EAknPanicLayoutControlResourceProblem,
	EAknPanicLayoutIncorrectEdwinSize,
	EAknPanicLayoutControlSetRectChangedControlSize,
	EAknPanicNoAnimationData,
	EAknPanicUnknownAnimationType,
	EAknPanicNoUserAnimation,
	EAknPanicAnimationCorrupt,
	EAknPanicDCADecoratorIndexOutOfRange,
	EAknPanicPopupFieldListInvalidDecorator,
	EAknPanicPopupFieldInvalidValue,
	EAknPanicPopupFieldUninitialisedMember,
	EAknPanicPopupFieldEditComboInsufficientSize,
	EAknPanicQueryTimeArrayTimeFormatLeave,
	EAknPanicLayoutTextNotCalled,
	EAknPanicLayoutRectNotCalled,
	EAknStatusPaneUidIndic,
	EAknPanicLayoutDoesNotExists,
	EAknPanicListBoxLayoutDecoratorMemoryAllocation,
	EAknPanicPopupFieldUndefinedMode,
	EAknPanicPopupFieldWrongMode,
	EAknPanicPopupFieldSelectionListDoesntExist,
	EAknPanicPopupFieldSelectionListAlreadyExists,
	EAknPanicPopupFieldListNotImplemented,
	EAknPanicPopupFieldArrayIsEmpty,
	EAknPanicLayoutPopupFieldResourceProblem,
	EAknPanicInvalidResourceData,
	EAknPanicListBoxNotSupportedByListQuery,
	EAknPanicQueryDateArrayTimeFormatLeave,
	EAknPanicPopupFieldCBADoesntExist,
	EAknPanicPopupSettingListMenuListDoesntExist,
	EAknPanicPopupSettingListMenuListAlreadyExists,
	EAknPanicPopupSettingListListNotImplemented,
	EAknPanicLayoutPopupSettingListResourceProblem,
	EAknPanicPopupSettingListInvalidValue,
	EAknPanicPopupSettingListUninitialisedMember,
	EAknPanicOverflow,
	EAknPanicKeyLockObserverAlreadyExists,
	EAknPanicKeyLockObserverNotFound,
	EAknPanicQueryValueInvalidMode,
    EAknPanicNotSupported,
	EAknPanicWrongListBoxTypeUsedInPopupWindow,
	EAknPanicInvalidValue,
	EAknPanicObjectNotFullyConstructed,
	EAknPanicSelfCheckFailure,
	EAknPanicLayoutMissing_AknLayout,
	EAknPanicLayoutMissing_ApacLayout,
    EAknPanicInconsistentDescriptors,
    EAknPanicListBoxItemDrawerNotCreated
	};

extern  void Panic(TAknPanic aPanic);


# 40 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknipfed.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikmfne.h" 1
 
 
 
 

# 669 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikmfne.h"

 
# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknipfed.h" 2


class TInetAddr;
 




class CAknIpFieldEditor : public CEikMfne 
    {
public:  
	  CAknIpFieldEditor();
	void ConstructL(TInetAddr& aMinimumAddress,
                    TInetAddr& aMaximumAddress,
                    TInetAddr& aInitialAddress,
                    const TInt aFlags=0);

	  static CAknIpFieldEditor* NewL(TInetAddr& aMinimumAddress,
                                            TInetAddr& aMaximumAddress,
                                            TInetAddr& aInitialAddress);
	  static CAknIpFieldEditor* NewL();
public:  
	  void SetAddress(const TInetAddr& aAddress);
	  TInetAddr Address() const;
	  virtual void SetMinimumAndMaximum(const TInetAddr& aMinimumAddress,
                                               const TInetAddr& aMaximumAddress);  
	  virtual void GetMinimumAndMaximum(TInetAddr& aMinimumAddress,
                                               TInetAddr& aMaximumAddress) const;
	  TInetAddr ReadIPAddress(TResourceReader& aResourceReader);
public:  
	  void ConstructFromResourceL(TResourceReader& aResourceReader);
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);
private: 
   void SplitAddressIntoFields(
                                const TInetAddr& aAddress,
                                TUint8 &aFieldA,
                                TUint8 &aFieldB,
                                TUint8 &aFieldC,
                                TUint8 &aFieldD) const;
	  virtual void CEikMfne_Reserved();

private:
    TInt iSpare;
    TInt iSpare2;
	};



# 42 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerycontrol.h" 2



 
class CAknQueryControl;
class TAknQueryEcsObserver;
class CAknEcsDetector;
class CAknBitmapAnimation;
class CAknTextControl;
class CAknQueryEditIndicator;
class MLAFIndex;
class MAknEditingStateIndicator;
class TInetAddr;
class CAknQueryExtension;

 



class MAknQueryControlObserver
    {
public:
     


    enum TQueryControlEvent
        {
        EQueryControltSizeChanging,
        EQueryControlEditorStateChanging
        };

     


    enum TQueryValidationStatus
        {
        EEditorValueValid = KErrNone,
        EEditorValueTooSmall,
        EEditorValueTooLarge,
        EEditorValueNotParsed,
        EEditorEmpty
        };

public:
     


    virtual TBool HandleQueryEditorSizeEventL(CAknQueryControl* aQueryControl, TQueryControlEvent aEventType)=0;
     


    virtual TBool HandleQueryEditorStateEventL(CAknQueryControl* aQueryControl, TQueryControlEvent aEventType, TQueryValidationStatus aStatus)=0;
    };

 







class CAknQueryControl : public CCoeControl , public MEikEdwinObserver , public MEikEdwinSizeObserver , public MCoeControlObserver
    {
    public:
         





        enum TQueryControlFlagBitIndices
            {
            EEmergencyCallsEnabledByAPI,
            EEmergencyCallsDisabledByAPI,
            EPredictiveTextEntryPermitted,
            EEditorIndicatorOff
            };

         




        enum TLayoutMethod 
            {
            EConfQueryLayoutM,              
            EDataQueryLayoutM,              
            ECodeQueryLayoutM,              
            ETimeQueryLayoutM,              
            EDateQueryLayoutM,              
            ECombinedCodeDataQueryLayoutM   
            };

    public:   

         


          CAknQueryControl();

         


          virtual ~CAknQueryControl();

         





          void ConstructFromResourceL(TResourceReader& aRes);

    public:  

         




          void SetQueryControlObserver(MAknQueryControlObserver* aQueryControlObserver);

         




          virtual void ReadPromptL(TResourceReader& aRes);

         




          virtual void SetPromptL(const TDesC& aDesC);

         




          void GetText(TDes& aDes) const;

         




          TTime GetTime() const;

         




          TInt GetNumber() const;

         




          TReal GetFloatingPointNumberL() const;

         




          TTimeIntervalSeconds GetDuration() const;

         




          void SetTextL(const TDesC& aDesC);

         




          void SetTime(TTime& aTime);

         




          void SetDuration(TTimeIntervalSeconds& aDuration);

         




          void SetNumberL(TInt aNumber);

          




          void SetFloatingPointNumberL(const TReal* aNumber);

         




          void SetTextEntryLength(TInt aLength);

         



          TInt GetTextEntryLength() const;

         





          void SetMinimumAndMaximum(const TTime& aMinimum, const TTime& aMaximum);

         




          void SetMinimumAndMaximum(const TTimeIntervalSeconds& aMinimumDuration, const TTimeIntervalSeconds& aMaximumDuration);

         




          void SetMinimumAndMaximum(TInt aMinimumValue, TInt aMaximumValue);

         




          void SetNumberOfEditorLines(TInt aNum);

         




          void SetMinimumAndMaximum(const TReal& aMinimumValue, const TReal& aMaximumValue);
         




          TInt GetTextLength() const;

         






          TInt GetNbrOfLines() const;

         





          TInt NbrOfEditorLines() const;


         




          TInt NbrOfPromptLines() const;

         








          virtual CCoeControl* ControlByLayoutOrNull(TInt aLayout);

         



          void SetImageL(CEikImage* aImage);

         


          void SetImageL(const TDesC& aImageFile,
                                TInt aBmpId, TInt aBmpMaskId);
         



          void SetAnimationL(TInt aResource);

         



          void StartAnimationL();

         




          TInt CancelAnimation();

         



        void CancelQueryL();

         


        TBool EditorContentIsValidL() const;

         






        void SetAndUseFlagsL( TBitFlags16 aFlags );

    public:  
    
         







          TKeyResponse OfferKeyEventL( const TKeyEvent& aKeyEvent, TEventCode aType);

         




          TSize MinimumSize();

         




        void PrepareForFocusLossL();

         




        void FocusChanged(TDrawNow aDrawNow);
        
         





          void HandleEdwinEventL(CEikEdwin* aEdwin,TEdwinEvent aEventType);

    public: 

         






          TBool HandleEdwinSizeEventL(CEikEdwin* aEdwin, TEdwinSizeEvent aEventType, TSize aDesirableEdwinSize);

    public: 

         




          void HandleControlEventL(CCoeControl* aControl,TCoeEvent aEventType);

    public:
         








        inline TInt QueryType() const { return iQueryType; } 

         



        virtual TAknWindowLineLayout WindowLayout() const;
    
    public: 
         




        TInt CountComponentControls() const;

         





        CCoeControl* ComponentControl(TInt anIndex) const;

    public:
         


        class TIndex 
        {   
        public:     
            TIndex(TInt aNumberOfPromptLines);  
        
        public: 
            TInt PromptLine() const;    
            
        public: 
            TInt DQPWindowTextsLine2(TInt aLineNum) const;  
            TInt PNWindow() const;  
            TInt PQDWindow(TInt aLineNum) const;    
            
        private:    
            void SelfTest() const;  

        private:    
            TInt  iNumberOfPromptLines; 
        };  

    protected:
         




        void SizeChanged();

         




        void Draw(const TRect& aRect) const;

         


        TTypeUid::Ptr MopSupplyObject(TTypeUid aId);

         



        void Layout();

    protected:
         


        virtual void SetLineWidthsL();

         





        virtual void ConstructQueryL(TResourceReader& aRes);

         


        virtual TRect LayoutRect();

         




        TRect DialogRect() const;

         




        TSize DialogSize() const;

    protected:
         


        virtual void LayoutPrompt(const TLayoutMethod& aLayoutM);

         


        virtual void LayoutImageOrAnim(const TLayoutMethod& aLayoutM);
        
         


        virtual void LayoutEditor(const TLayoutMethod& aLayoutM);

         


        virtual void LayoutEditorFrame(const TLayoutMethod& aLayoutM);

         


        virtual void LayoutEditorIndicator(const TLayoutMethod& aLayoutM);

    protected:

         


        CAknQueryExtension* QueryExtension() const;
    
    private:

         


        void DrawEditorFrame(CWindowGc& aGc,TRect& aRect) const;

         





        void SetFlags( TBitFlags16 aFlags );

         



        void DeployFlagsL();

         



        void DoSetPromptL();

        static TInt StaticPictographCallBack( TAny* aPtr );
        void PictographCallBack();

    protected:
         
        CAknTextControl*  iPrompt;
         
        CAknQueryEditIndicator*  iEditIndicator;
         
        CEikEdwin*               iEdwin;
         
        CEikDateEditor*          iDateEdwin;
         
        CEikTimeEditor*          iTimeEdwin;
         
        CEikDurationEditor*      iDurationEdwin;
         
        CEikSecretEditor*        iSecretEd;
         
        CAknIntegerEdwin*        iNumberEdwin; 
         
        CAknNumericSecretEditor* iPinEdwin;
         
        CEikFloatingPointEditor* iFloatingPointEditor;
         
        CEikImage*               iImage;
         
        TInt                     iControl;
         
        TAknLayoutRect           iLayoutMfne;
         
        CAknEcsDetector*         iEcsDetector;
         
        TAknQueryEcsObserver*    iEcsObserver;
         
        TBitFlags16              iFlags;
        TUint16                  iSpare_1;  
         
        CAknBitmapAnimation*     iAnimation;
         
        MAknQueryControlObserver* iQueryControlObserver;
         
        TInt                      iQueryType;
         
        TAknLayoutRect            iEditorVerShadow;
         
        TAknLayoutRect            iEditorHorShadow;
         
        TAknLayoutRect            iEditorFrame;
    
        TInt       iNumberOfEditorLines;  

        TBool      iHasEditor;    
                                  

        CArrayFixFlat<TInt>* iLineWidths;  
    };



 








 

class CAknExtQueryControl : public CAknQueryControl
    {
    
    public:   

         


          CAknExtQueryControl();

         


          virtual ~CAknExtQueryControl();      

    public:  

         




          TInetAddr GetInetAddress() const;

         




          void SetInetAddress(TInetAddr& aInetAddress);

         




          TInt GetFixedPointNumber() const;

          




          void SetFixedPointNumberL(const TInt* aNumber);


    public:  

         





          void SetMinimumAndMaximum(const TInetAddr& aMinimumAddress, const TInetAddr& aMaximumAddress);

         




          void SetMinimumAndMaximum(TInt aMinimumValue, TInt aMaximumValue);


         








          virtual CCoeControl* ControlByLayoutOrNull(TInt aLayout);

         


        TBool EditorContentIsValidL() const;

         






        void SetAndUseFlagsL( TBitFlags16 aFlags );

    public:  

         




        void PrepareForFocusLossL();

         




        void FocusChanged(TDrawNow aDrawNow);
        

    public: 

         




          void HandleControlEventL(CCoeControl* aControl,TCoeEvent aEventType);

    
    public: 
         




        TInt CountComponentControls() const;

         





        CCoeControl* ComponentControl(TInt anIndex) const;

    public:
         


        class TIndex 
        {   
        public:     
            TIndex(TInt aNumberOfPromptLines);  
        
        public: 
            TInt PromptLine() const;    
            
        public: 
            TInt DQPWindowTextsLine2(TInt aLineNum) const;  
            TInt PNWindow() const;  
            TInt PQDWindow(TInt aLineNum) const;    
            
        private:    
            void SelfTest() const;  

        private:    
            TInt  iNumberOfPromptLines; 
        };  


    protected:
        
         





        virtual void ConstructQueryL(TResourceReader& aRes);

    protected:
                
         


        virtual void LayoutEditor(const TLayoutMethod& aLayoutM);

    
    private:

         





        void SetFlags( TBitFlags16 aFlags );

         



        void DeployFlagsL();

         



        void DoSetPromptL();

        static TInt StaticPictographCallBack( TAny* aPtr );
        void PictographCallBack();

    protected:
         
        CAknIpFieldEditor*      iIpEditor;
        CEikFixedPointEditor*   iFixedPointEditor;
        TAny*                   iSpare_1;
        TAny*                   iSpare_2;
    };



# 33 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknmultilinequerycontrol.h" 1
 




















  



 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknmultilinequerycontrol.h" 2



enum TLinePosition  
    {   
    EFirstLine = 0, 
    ESecondLine 
    };  

 


class CAknMultilineQueryControl : public CAknQueryControl 
    {
    public:  
         


          CAknMultilineQueryControl();

         


          virtual ~CAknMultilineQueryControl();

    public: 
         






          void SetNbrOfPromptLines(TInt aNbrOfPromptLinesFirstLine, TInt aNbrOfPromptLinesSecondLine);
    
         


          TBool IsFirst() const;

         


          TBool IsSecond() const;

    public:  

         






          virtual CCoeControl* ControlByLayoutOrNull(TInt aLayout);

         


        TAknWindowLineLayout WindowLayout() const;

    public:  

         




          TSize MinimumSize();

    public:
         




        class TIndex 
        {   
        public: 
            TIndex(const TLinePosition& aLinePos, TInt aFirstQueryPromptLines,TInt aSecondQueryPromptLines);
        
        public: 
            TInt MainPanePQDCWindow() const;    
            TInt CDCQPWindowLine1() const;  
            TInt CDCQPWindowLine2() const;  
            TInt CDCQPWindowLine3() const;  
            TInt CDCQPWindowRectangles() const; 
            TInt CDCQPWindowLine5() const;  

            TInt CDCQPWindowTextsLine1(TInt aLineNum) const;
            TInt CDCQPWindowTextsLine2() const; 
            TInt CDCQPWindowTextsLine3(TInt aLineNum) const;
            TInt CDCQPWindowTextsLine4() const; 

            TInt CDCPQWindowGraphicsLine5() const;  

        public:
            const TInt LinePos() const { return iLinePos; }
        
        private:    
            TInt FirstQueryPromptLines() const;
            TInt SecondQueryPromptLines() const;

            void SelfTest() const;
    
        private:
            TLinePosition  iLinePos;    
            TInt           iFirstQueryPromptLines;  
            TInt           iSecondQueryPromptLines;
        };
        
    protected:  
         


        void SetLineWidthsL();

         


        void ConstructQueryL(TResourceReader& aRes);

         


        TRect LayoutRect();

    private: 
        void SizeChanged();
        void Draw(const TRect& aRect) const;

    private:     
        void LayoutPrompt(const TLayoutMethod& aLayoutM);
        void LayoutSeparator(const TLayoutMethod& aLayoutM);
        
        void LayoutEditor(const TLayoutMethod& aLayoutM);
        void LayoutEditorFrame(const TLayoutMethod& aLayoutM);
        void LayoutEditorIndicator(const TLayoutMethod& aLayoutM);


    private:  
        void   SetLinePosition();
        TInt16 FirstLineHeight() const;

    private:
        TAknLayoutRect iLayoutLineBetweenEntryFields;  
        TLinePosition  iLinePos;    
        TInt           iFirstQueryPromptLines;  
        TInt           iSecondQueryPromptLines; 
    };



 




 class CAknExtMultilineQueryControl : public CAknExtQueryControl
    {
    public:  
         


          CAknExtMultilineQueryControl();

         


          virtual ~CAknExtMultilineQueryControl();

    public: 
         






          void SetNbrOfPromptLines(TInt aNbrOfPromptLinesFirstLine, TInt aNbrOfPromptLinesSecondLine);
    
         


          TBool IsFirst() const;

         


          TBool IsSecond() const;

    public:  

         






          virtual CCoeControl* ControlByLayoutOrNull(TInt aLayout);

         


        TAknWindowLineLayout WindowLayout() const;

    public:  

         




          TSize MinimumSize();

    public:
         




        class TIndex 
        {   
        public: 
            TIndex(const TLinePosition& aLinePos, TInt aFirstQueryPromptLines,TInt aSecondQueryPromptLines);
        
        public: 
            TInt MainPanePQDCWindow() const;    
            TInt CDCQPWindowLine1() const;  
            TInt CDCQPWindowLine2() const;  
            TInt CDCQPWindowLine3() const;  
            TInt CDCQPWindowRectangles() const; 
            TInt CDCQPWindowLine5() const;  

            TInt CDCQPWindowTextsLine1(TInt aLineNum) const;
            TInt CDCQPWindowTextsLine2() const; 
            TInt CDCQPWindowTextsLine3(TInt aLineNum) const;
            TInt CDCQPWindowTextsLine4() const; 

            TInt CDCPQWindowGraphicsLine5() const;  

        public:
            const TInt LinePos() const { return iLinePos; }
        
        private:    
            TInt FirstQueryPromptLines() const;
            TInt SecondQueryPromptLines() const;

            void SelfTest() const;
    
        private:
            TLinePosition  iLinePos;    
            TInt           iFirstQueryPromptLines;  
            TInt           iSecondQueryPromptLines;
        };
        
    protected:  
         


        void SetLineWidthsL();

         


        void ConstructQueryL(TResourceReader& aRes);

         


        TRect LayoutRect();

    private: 
        void SizeChanged();
        void Draw(const TRect& aRect) const;

    private:     
        void LayoutPrompt(const TLayoutMethod& aLayoutM);
        void LayoutSeparator(const TLayoutMethod& aLayoutM);
        
        void LayoutEditor(const TLayoutMethod& aLayoutM);
        void LayoutEditorFrame(const TLayoutMethod& aLayoutM);
        void LayoutEditorIndicator(const TLayoutMethod& aLayoutM);


    private:  
        void   SetLinePosition();
        TInt16 FirstLineHeight() const;

    private:
        TAknLayoutRect iLayoutLineBetweenEntryFields;  
        TLinePosition  iLinePos;    
        TInt           iFirstQueryPromptLines;  
        TInt           iSecondQueryPromptLines;
        TAny*          iSpare_1;


    };


# 35 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlistquerycontrol.h" 1
 



















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 21 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlistquerycontrol.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupheadingpane.h" 1
 
























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupheadingpane.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgpc.h" 1
 
 
 
 

# 439 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgpc.h"

# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupheadingpane.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknappui.h" 1
 





















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikappui.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeaui.h" 1
 
 
 
 

















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/vwsdef.h" 1
 
 
 
 







class TVwsViewId
 







	{
public:
	inline TVwsViewId();
	inline TVwsViewId(const TVwsViewId& aUid);
	inline TVwsViewId(TUid aAppUid,TUid aViewUid);
	inline TBool operator==(const TVwsViewId& aUid) const;
	inline TBool operator!=(const TVwsViewId& aUid) const;
public:
	 


	TUid iAppUid;
	 


	TUid iViewUid;
	};

 


 
const TInt KErrViewWrongMode=1;  


 
 
 
 
class TVwsViewIdAndMessage
 



	{
public:
	inline TVwsViewIdAndMessage();
	inline TVwsViewIdAndMessage(const TVwsViewId& aId);
	inline TVwsViewIdAndMessage(const TVwsViewId& aId,TUid aCustomMessageId,const TDesC8& aCustomMessage);
public:
	TVwsViewId iViewId;
	TUid iCustomMessageId;
	TInt iCustomMessageLength;
	TPtrC8 iCustomMessage;
	};



class TVwsViewEvent
 
 
 
 
 



	{
public:
	enum TVwsViewEventType
		{
		EVwsActivateView,
		EVwsDeactivateView,
		EVwsScreenDeviceChanged,
		EVwsDeactivationNotification,
		EVwsActivationNotification
		};
public:
	inline TVwsViewEvent();
	inline TVwsViewEvent(TVwsViewEventType aEventType);
	inline TVwsViewEvent(TVwsViewEventType aEventType,const TVwsViewId& aViewOneId);
	inline TVwsViewEvent(TVwsViewEventType aEventType,const TVwsViewId& aViewOneId,const TVwsViewId& aViewTwoId);
	inline TVwsViewEvent(TVwsViewEventType aEventType,const TVwsViewId& aViewOneId,const TVwsViewId& aViewTwoId,TUid aCustomMessageId,TInt aCustomMessageLength);
public:
	TVwsViewEventType iEventType;
	TVwsViewId iViewOneId;
	TVwsViewId iViewTwoId;
	TUid iCustomMessageId;
	TInt iCustomMessageLength;
	};


 
 
 
 
typedef TPckgBuf<TVwsViewIdAndMessage> TVwsViewIdAndMessageBuf;

 
typedef TPckgBuf<TVwsViewEvent> TVwsViewEventBuf;


 
 
 

inline TVwsViewId::TVwsViewId()
 

	: iAppUid(TUid::Null() ), iViewUid(TUid::Null() ) {}

inline TVwsViewId::TVwsViewId(const TVwsViewId& aUid)
 




	: iAppUid(aUid.iAppUid), iViewUid(aUid.iViewUid) {}

inline TVwsViewId::TVwsViewId(TUid aAppUid,TUid aViewUid)
 



	: iAppUid(aAppUid), iViewUid(aViewUid) {}

inline TBool TVwsViewId::operator==(const TVwsViewId& aUid) const
 







	{
	return (aUid.iAppUid==iAppUid && aUid.iViewUid==iViewUid);
	}

inline TBool TVwsViewId::operator!=(const TVwsViewId& aUid) const
 







	{
	return (aUid.iAppUid!=iAppUid || aUid.iViewUid!=iViewUid);
	}


inline TVwsViewIdAndMessage::TVwsViewIdAndMessage()
	: iViewId(TVwsViewId()), iCustomMessageLength(0)
	{
	iCustomMessageId.iUid=0;
	iCustomMessage.Set(KNullDesC8);
	}

inline TVwsViewIdAndMessage::TVwsViewIdAndMessage(const TVwsViewId& aId)
	: iViewId(aId), iCustomMessageLength(0)
	{
	iCustomMessageId.iUid=0;
	iCustomMessage.Set(KNullDesC8);
	}

inline TVwsViewIdAndMessage::TVwsViewIdAndMessage(const TVwsViewId& aId,TUid aCustomMessageId,const TDesC8& aCustomMessage)
	: iViewId(aId), iCustomMessageId(aCustomMessageId)
	{
	iCustomMessageLength=aCustomMessage.Length();
	iCustomMessage.Set(aCustomMessage);
	}


inline TVwsViewEvent::TVwsViewEvent() {}

inline TVwsViewEvent::TVwsViewEvent(TVwsViewEventType aEventType)
	: iEventType(aEventType),iViewOneId(),iViewTwoId(),iCustomMessageId(TUid::Null() ),iCustomMessageLength(0) {}

inline TVwsViewEvent::TVwsViewEvent(TVwsViewEventType aEventType,const TVwsViewId& aViewOneId)
	: iEventType(aEventType),iViewOneId(aViewOneId),iViewTwoId(),iCustomMessageId(TUid::Null() ),iCustomMessageLength(0) {}

inline TVwsViewEvent::TVwsViewEvent(TVwsViewEventType aEventType,const TVwsViewId& aViewOneId,const TVwsViewId& aViewTwoId)
	: iEventType(aEventType),iViewOneId(aViewOneId),iViewTwoId(aViewTwoId),iCustomMessageId(TUid::Null() ),iCustomMessageLength(0) {}

inline TVwsViewEvent::TVwsViewEvent(TVwsViewEventType aEventType,const TVwsViewId& aViewOneId,const TVwsViewId& aViewTwoId,TUid aCustomMessageId,TInt aCustomMessageLength)
	: iEventType(aEventType),iViewOneId(aViewOneId),iViewTwoId(aViewTwoId),iCustomMessageId(aCustomMessageId),iCustomMessageLength(aCustomMessageLength) {}



# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeaui.h" 2








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeauib.h" 1
 
 
 
 








class CCoeControl;
class TWsEvent;

class CCoeAppUiBase : public CBase
 






    {
public:
 













    virtual void HandleWsEventL(const TWsEvent& aEvent,CCoeControl* aDestination)=0;
	  virtual void PrepareToExit();
protected:
	  virtual void HandleScreenDeviceChangedL();  
private:
 
	  virtual void Reserved_2();
    };


# 30 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeaui.h" 2








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeview.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 1
 
 
 
 

# 627 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeview.h" 2


class CCoeAppUi;

class MCoeView
 





	{
public:	
	 


	virtual TVwsViewId ViewId() const=0;
private:
	 












	virtual void ViewActivatedL(const TVwsViewId& aPrevViewId,TUid aCustomMessageId,const TDesC8& aCustomMessage)=0;
	 





	virtual void ViewDeactivated()=0;

protected:
	  virtual TVwsViewIdAndMessage ViewScreenDeviceChangedL();
private:
	  virtual void ViewConstructL();
protected:
	  virtual TBool ViewScreenModeCompatible(TInt aScreenMode);  
private:
	friend class CCoeViewManager;
	  virtual void MCoeView_Reserved_2();
	};


class CCoeScreenDeviceChangeDefaultHandler : public CCoeStatic
 
 
 
 







	{
public:
	  ~CCoeScreenDeviceChangeDefaultHandler();
	  static CCoeScreenDeviceChangeDefaultHandler* Self();
protected:
	  CCoeScreenDeviceChangeDefaultHandler();
public:
	virtual void HandleScreenDeviceChangedL()=0;
	virtual TVwsViewIdAndMessage DefaultViewOnScreenDeviceChanged()=0;
	};



# 38 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coeaui.h" 2







class CCoeEnv;
class CCoeControl;

 





typedef CCoeFep* (*TCoeFepFactoryFunctionL)(CCoeEnv& aConeEnvironment, const TDesC& aFullFileNameOfDll, const CCoeFepParameters& aFepParameters);

 





typedef void (*TCoeSynchronouslyExecuteFepSettingsDialogFunctionL)(CCoeEnv& aConeEnvironment, const TDesC& aFullFileNameOfDll);

 






enum
	{
	 
	ECoeStackPriorityDefault=0,
	 
	ECoeStackPriorityMenu=10,
	 
	ECoeStackPriorityDialog=50,
	 
	ECoeStackPriorityCba=60,
	 
	ECoeStackPriorityAlert=200,
	 
	ECoeStackPriorityFep=250,
	 
	ECoeStackPriorityEnvironmentFilter=300
	};


 






enum
	{
	 
	ECoeStackFlagStandard			= 0,	
	 
	ECoeStackFlagRefusesAllKeys		= 0x01,
	 
	ECoeStackFlagRefusesFocus		= 0x02,
	 
	ECoeStackFlagOwnershipTransfered= 0x04,	
	 



	ECoeStackFlagSharable			= 0x08
	};

class CCoeControlStack;
class CCoeViewManager;
class MCoeViewDeactivationObserver;
class MCoeViewActivationObserver;
class MCoeViewObserver;

class CCoeAppUi : public CCoeAppUiBase
 











	{
public:
	  CCoeAppUi();
	  ~CCoeAppUi();
	  void ConstructL(CCoeAppUi* aPrevious= 0L );
public:  
	  void AddToStackL(CCoeControl* aControl,TInt aPriority=ECoeStackPriorityDefault,TInt aStackingFlags=ECoeStackFlagStandard);
	  void RemoveFromStack(CCoeControl* aControl);
	  void UpdateStackedControlFlags(CCoeControl* aControl,TInt aFlags,TInt aMask);
	  void HandleStackChanged();
	  TBool IsDisplayingMenuOrDialog() const; 
	  TBool IsDisplayingDialog() const; 
	  TBool IsDisplayingControlBetweenPriorities(TInt aLowerPriority, TInt aHigherPriority) const;
	  CArrayFix<TCoeHelpContext>* AppHelpContextL() const;
	  virtual TCoeInputCapabilities InputCapabilities() const;
	  void HandleStackedControlsResourceChange(TInt aType);
	  void ActivateViewL(const TVwsViewId& aViewId);
	  void ActivateViewL(const TVwsViewId& aViewId,TUid aCustomMessageId,const TDesC8& aCustomMessage);
	  void RegisterViewL(MCoeView& aView);
	  void DeregisterView(const MCoeView& aView);
	  void SetDefaultViewL(const MCoeView& aView);
	  TInt GetDefaultViewId(TVwsViewId& aViewId) const;
	  TInt GetActiveViewId(TVwsViewId& aViewId) const;
	  void AddToStackL(const MCoeView& aView,CCoeControl* aControl,TInt aPriority=ECoeStackPriorityDefault,TInt aStackingFlags=ECoeStackFlagStandard);
public:  
	TBool IsControlOnStack(CCoeControl* aControl) const;
	void SetCurrentControlStackGroupId(TInt aGroupId);
public:  
	  void CreateActivateViewEventL(const TVwsViewId& aViewId,TUid aCustomMessageId,const TDesC8& aCustomMessage);
	  void ActivateTopViewL();
	  void DeactivateActiveViewL();
	  void RegisterApplicationViewL(TUid aAppUid);
	  void DeregisterApplicationView();
	  void CheckInitializeViewsL(TUid aAppUid);
	  void SetApplicationViewAsDefaultL();  
	  void AddViewDeactivationObserverL(MCoeViewDeactivationObserver* aViewDeactivationObserver);
	  void RemoveViewDeactivationObserver(MCoeViewDeactivationObserver* aViewDeactivationObserver);
	  void NotifyNextDeactivation(const TVwsViewId& aViewId, MCoeViewDeactivationObserver& aViewDeactivationObserver);
	  void NotifyNextDeactivation(MCoeViewDeactivationObserver& aViewDeactivationObserver);
	  void AddViewActivationObserverL(MCoeViewActivationObserver* aViewActivationObserver);
	  void RemoveViewActivationObserver(MCoeViewActivationObserver* aViewActivationObserver);
	  void NotifyNextActivation(const TVwsViewId& aViewId, MCoeViewActivationObserver& aViewActivationObserver);
	  void NotifyNextActivation(MCoeViewActivationObserver& aViewActivationObserver);
	  void AddViewObserverL(MCoeViewObserver* aViewObserver);
	  void RemoveViewObserver(MCoeViewObserver* aViewObserver);
	  void WriteInternalStateOfStackedControlsL(RWriteStream& aWriteStream) const;  
 	  void SetSystemDefaultViewL(const TVwsViewId& aViewId,TInt aMode);  
 	  void SetSystemDefaultViewL(const TVwsViewId& aViewId);  
 	  void GetSystemDefaultViewL(TVwsViewId& aViewId);  
public: 
	  void RegisterViewAndAddStackL(MCoeView& aView);
	  void DeregisterViewAndRemoveStack(const MCoeView& aView);
	  void RemoveFromViewStack(const MCoeView& aView,CCoeControl* aControl);
	  void UpdateViewStackedControlFlags(const MCoeView& aView,CCoeControl* aControl,TInt aFlags,TInt aMask);
	  void AddToViewStackL(const MCoeView& aView,CCoeControl* aControl,TInt aPriority=ECoeStackPriorityDefault,TInt aStackingFlags=ECoeStackFlagStandard);
protected:  
	  void HandleWsEventL(const TWsEvent& aEvent,CCoeControl* aDestination);
	  void HandleScreenDeviceChangedL();
	  void Reserved_2();
private:  
	  virtual TKeyResponse HandleKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  virtual void HandleForegroundEventL(TBool aForeground);
	  virtual void HandleSwitchOnEventL(CCoeControl* aDestination);
	  virtual void HandleSystemEventL(const TWsEvent& aEvent);
	  virtual void HandleApplicationSpecificEventL(TInt aType,const TWsEvent& aEvent);
	  virtual void SetAndDrawFocus(TBool aFocus);
	  virtual CArrayFix<TCoeHelpContext>* HelpContextL() const;
private:
	enum TRemoveCondition
		{
		ERemoveUnconditionally,
		ERemoveOnlyIfSharable
		};
private:
	CCoeControl* TopFocusableControl() const;
	CCoeControl* TopFocusedControl() const;
	TInt FindPos(CCoeControlStack* aStack,CCoeControl* aControl) const;
	void SetFocusToControl(CCoeControl* aControl,TBool aFocus);
	void DoAddToStackL(CCoeControlStack* aStack,CCoeControl* aControl,TInt aPriority,TInt aStackingFlags);
	void DoAddToStackL(CCoeControlStack* aStack,CCoeControl* aControl,TInt aPriority,TInt aStackingFlags, TInt aGroupId);
	void DoRemoveFromStack(CCoeControlStack* aStack,CCoeControl* aControl,TRemoveCondition aRemoveCondition=ERemoveUnconditionally);
	void DoUpdateStackedControlFlags(CCoeControlStack* aStack,CCoeControl* aControl,TInt aFlags,TInt aMask);
private:
	class CExtra;
	friend class CExtra;
	friend class CTestDriver;
protected:
	CCoeEnv* iCoeEnv;
private:
	CCoeViewManager* iViewManager;
	CCoeControlStack* iStack;
	CExtra* iExtra;
	};

class MCoeViewDeactivationObserver
 







	{
public:

	 
	 
	 
	 
	virtual void HandleViewDeactivation(const TVwsViewId& aViewIdToBeDeactivated,const TVwsViewId& aNewlyActivatedViewId)=0;

private:
	  virtual void MCoeViewDeactivationObserver_Reserved_1();
	  virtual void MCoeViewDeactivationObserver_Reserved_2();
	};

class MCoeViewActivationObserver
 




	{
public:

	 
	 
	 
	 
	virtual void HandleViewActivation(const TVwsViewId& aNewlyActivatedViewId,const TVwsViewId& aViewIdToBeDeactivated)=0;

private:
	  virtual void MCoeViewActivationObserver_Reserved_1();
	  virtual void MCoeViewActivationObserver_Reserved_2();
	};


class MCoeViewObserver
 



	{
public:
	virtual void HandleViewEventL(const TVwsViewEvent& aEvent)=0;
	};



# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikappui.h" 2
































# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknwseventobserver.h" 1
 
 
 
 
 
 
 



 

 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknwseventobserver.h" 2


 

enum TAknWsEventObserverPanic
	{
	EAknWsEventObserverFailedToAddObserver,
	EAknWsEventObserverUnknownObserverRemoved
	};

extern  void Panic(TAknWsEventObserverPanic aPanic);


 

class MAknWsEventObserver
	{
public:
	virtual void HandleWsEventL(const TWsEvent& aEvent,CCoeControl* aDestination) = 0;
	};


 
 
 

class CAknWsEventMonitor: public CBase, public MAknWsEventObserver
{
public:
	static CAknWsEventMonitor* NewL();
	virtual ~CAknWsEventMonitor();
	void ConstructL();
	  void AddObserverL(MAknWsEventObserver* aEventObserver);
	  void RemoveObserver(const MAknWsEventObserver* aEventObserver);
	  void HandleWsEventL(const TWsEvent& aEvent,CCoeControl* aDestination);
private:
	MAknWsEventObserver* iEventObserver;
	TInt iSpare;
private:
 
	  virtual void Reserved_1();

};



# 42 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikappui.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemop.h" 1
 
 

# 140 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemop.h"

# 45 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikappui.h" 2


class MEikMenuBar;
class MEikMenuPane;
class CEikDocument;
class CEikApplication;
class MApaEmbeddedDocObserver;
struct SExtendedError;
class MEikAppUiFactory;
class CAknKeySoundSystem;

const TUid KUidEikColorSchemeStore={0x1};
const TUid KUidEikColorSchemeStream={0x1};

class CEikAppUi : public CCoeAppUi, public MEikMenuObserver, public MCoeMessageObserver, public MObjectProvider
	{
private:
	friend class CAknAppUi;
	enum
		{
		EStandardAppFlag			= 0x00,
		ENoAppResourceFileFlag		= 0x01,
		ENonStandardResourceFileFlag= 0x02,
		ENoScreenFurnitureFlag		= 0x04,
		ELayoutAwareAppFlag			= 0x08,
		EAknEnableSkinFlag			= 0x1000,
		ELayoutAwareBuild			= 0
		};

public:
	enum
		{
		EStandardApp				= ELayoutAwareBuild | EStandardAppFlag,
		ENoAppResourceFile			= ELayoutAwareBuild | ENoAppResourceFileFlag,
		ENonStandardResourceFile	= ELayoutAwareBuild | ENonStandardResourceFileFlag,
		ENoScreenFurniture			= ELayoutAwareBuild | ENoScreenFurnitureFlag,
		ELastReservedEikAppUiFlag	= 0x08,
         












        EAknEnableSkin				= ELayoutAwareBuild | EAknEnableSkinFlag
		};

	enum TAppUiOrientation
		{
         




		EAppUiOrientationUnspecified,
		 





		EAppUiOrientationPortrait,
		 





		EAppUiOrientationLandscape
		};

public:
	  ~CEikAppUi();
	  CEikAppUi();
public:  
	  virtual void ConstructL();
	  virtual void HandleModelChangeL();
	  void LaunchPopupMenuL(TInt aResourceId,const TPoint& aTargetPos,TPopupTargetPosType aTargetType,const CEikHotKeyTable* aHotKeyTable= 0L );
	inline CEikAppUi* ContainerAppUi() const;
	  void SetDocument(CEikDocument* aDocument);
	  void SetEmbeddedDocInfo(MApaEmbeddedDocObserver* aObserver,TBool aReadOnly);
	  virtual TBool ProcessCommandParametersL(TApaCommand aCommand,TFileName& aDocumentName,const TDesC8& aTail);
	  CEikDocument* Document() const;
	  CEikApplication* Application() const;
	  TRect ClientRect() const;
	  TRect ApplicationRect() const;
	  virtual void StopDisplayingMenuBar();
	  TBool FadeWhenInBackground();
	  void SetFaded(TBool aFade);
	  TBool IsFaded() const;
public:  
	  void ReportResourceChangedToAppL(TInt aType);
	  virtual void HandleCommandL(TInt aCommand);
	  virtual void ProcessMessageL(TUid aUid,const TDesC8& aParams);
	  virtual void OpenFileL(const TDesC& aFileName);
	  virtual void CreateFileL(const TDesC& aFileName);
	  virtual TErrorHandlerResponse HandleError(TInt aError,const SExtendedError& aExtErr,TDes& aErrorText,TDes& aContextText);
	  virtual void HandleResourceChangeL(TInt aType);
	  TBool IsForeground() const;
	  TBool IsPartialForeground() const;
	  TBool IsFullScreenApp() const;
	  TBool IsLayoutAwareApp() const;
	  void SetLayoutAwareApp(TBool aLayoutAwareApp);
	  TAppUiOrientation Orientation() const;
	  void SetOrientationL(TAppUiOrientation aOrientation);
 
	  CAknWsEventMonitor* EventMonitor() const;
	  CAknKeySoundSystem* KeySounds() const;
public:  
	  void PrepareToExit();
protected:  
	  void BaseConstructL(TInt aAppUiFlags=EStandardApp);
	  void ReadAppInfoResourceL(TInt aResourceFileOffset=0);
	  void CreateHotKeyControlL(TInt aResourceId);
	  void SetDocChanged();
	  void SaveAnyChangesL();
	  void Exit();
	  void SaveL();
	  void ClosePopup();
	  TBool ProcessCommandParametersL(TApaCommand aCommand,TFileName& aDocumentName);
	  void SetFullScreenApp(TBool aIsFullScreen);
protected:  
	  void HandleSideBarMenuL(TInt aResourceId,const TPoint& aPos,TInt aModifiers,const CEikHotKeyTable* aTable);
protected:  
	  void HandleApplicationSpecificEventL(TInt aType,const TWsEvent& aEvent);  
	  void HandleForegroundEventL(TBool aForeground);
	  void HandleWsEventL(const TWsEvent& aEvent, CCoeControl* aDestination);
	  void HandleSystemEventL(const TWsEvent& aEvent);
	  void HandleScreenDeviceChangedL();
private:  
	  void ProcessCommandL(TInt aCommand);
private:  
	  void SetEmphasis(CCoeControl* aMenuWindow,TBool aEmphasis);
protected:  
	  MCoeMessageObserver::TMessageResponse HandleMessageL(TUint32 aClientHandleOfTargetWindowGroup, TUid aMessageUid, const TDesC8& aMessageParameters);
protected:  
	  TTypeUid::Ptr MopSupplyObject(TTypeUid aId);
	  MObjectProvider* MopNext();
private:  
	  void Reserved_1();
	  void Reserved_2();
private:  
	  virtual TBool ValidFileType(TUid aFileUid) const;
	  virtual void Reserved_3();
	  virtual void Reserved_4();
	void SimulateWsEventL(TInt aEvent);
	TInt FindAppWgIdBelowMeL();
	TInt EventForForegroundState(TBool aPartialFg, TBool aForeground);
	TBool ThreadIsForeground() const;
private:  
	void CreateResourceIndependentFurnitureL();
	TBool ValidFileExists(const TDesC& aFileName);
    void UpdateSettingCacheAndForwardEventL( TInt aEventId );
protected:
	CEikDocument* iDocument;
	CEikAppUi* iContainerAppUi;
	MApaEmbeddedDocObserver* iDoorObserver;
	TBool iEmbeddedAndReadOnly;
	TBitFlags iFlags;
	 
	CAknKeySoundSystem* iKeySounds;	 
private:
	 
	CAknWsEventMonitor* iEventMonitor;
	MEikAppUiFactory* iFactory;
	TInt iSpare2;	
	TInt iSpare;
	};

inline CEikAppUi* CEikAppUi::ContainerAppUi() const
	{ return iContainerAppUi; }


# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknappui.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikspane.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikspmod.h" 1
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh" 1
# 877 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/uikon.hrh"


# 14 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikspmod.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrvc.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrvs.h" 1
 
 
 
 













# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrv.pan" 1
 
 
 
 



 





 


enum TEikServPanic
	{
	EEikServPanicNotifyServiceNotSupported,
	EEikServPanicNotifyBadDescriptor,
	EEikServPanicAlarmAlertServiceNotSupported,
	EEikServPanicNoTaskListDialog,
	EEikServPanicTaskNull,
	EEsPanicAlarmAlert,
	EEikServPanicAlarmAlertServerAlreadyConnected,
	EEikServEnvPanicNullAppUi,
	EEikServPanicNoSuchLabelInAlarm,
	EEikServPanicDriveIndexOutOfRange,
	EEikServPanicNotiferArrayNotNull,
	EEikServPanicChannelIndexOutOfRange,
	EEikServPanicNullObservedList,
	EEikServPanicQueueIndexOutOfRange,
	EEikServPanicNotifyAlertQueueEmpty,
	EEikSrvClientPanicInconsistentMessageParameters,
	};

 


extern  void Panic(TEikServPanic aPanic);

# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrvs.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apgtask.h" 1
 
 
 
 








class RWsSession;
struct TKeyEvent;

 








enum TApaSystemEvent
	{
	 
	EApaSystemEventShutdown=1,
	 
	EApaSystemEventBackupStarting,
	 
	EApaSystemEventBackupComplete,
	 
	EApaSystemEventBroughtToForeground
	};


 





 





 





 











 


const TInt KUidApaMessageSwitchOpenFileValue16=0x10003A39;

 


const TUid KUidApaMessageSwitchOpenFile16={KUidApaMessageSwitchOpenFileValue16};

 


const TInt KUidApaMessageSwitchCreateFileValue16=0x10003A3A;

 


const TUid KUidApaMessageSwitchCreateFile16={KUidApaMessageSwitchCreateFileValue16};

class TApaTask
 















	{
public:
	  TApaTask(RWsSession& aWsSession);
	  void SetWgId(TInt aWgId);
	  TInt WgId() const;
	  TBool Exists() const;
	  TThreadId ThreadId() const;
	  void BringToForeground();
	  void SendToBackground();
	  void EndTask();
	  void KillTask();
	  void SendKey(TInt aKeyCode,TInt aModifiers);
	  void SendKey(const TKeyEvent& aKey);
	  void SendSystemEvent(TApaSystemEvent aEvent);
	  TInt SwitchOpenFile(const TDesC& aFilename);
	  TInt SwitchCreateFile(const TDesC& aFilename);
	  TInt SendMessage(TUid aUid, const TDesC8& aParams);
private:
	TInt CheckSwitchFile() const;
private:
	RWsSession& iWsSession;
	TInt iWgId;
	};

class TApaTaskList
 










	{
public:	
	 



	enum TCycleDirection
		{
		 

		EForwards,
		 


		EBackwards
		};
public:
	  TApaTaskList(RWsSession& aWsSession);
	  TApaTask FindApp(const TDesC& aAppName);
	  TApaTask FindDoc(const TDesC& aDocName);
	  TApaTask FindByPos(TInt aPos);
	  TApaTask FindApp(TUid aAppUid);
	  TInt CycleTasks(TUid aAppUid,TCycleDirection aDirection=EForwards);
private:
	void FindByPosL(TApaTask& aTask,TInt aPos);
private:
	RWsSession& iWsSession;
	};



# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrvs.h" 2




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrv.h" 1
 
 
 
 

















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikunder.h" 1
 
 
 
 








class RThread;

 



class MEikUndertakerObserver
	{
public:
	virtual void HandleThreadExitL(RThread& aThread)=0;
	};

 



class CEikUndertaker : public CActive
	{
public:
	  static CEikUndertaker* NewL(MEikUndertakerObserver& aObserver);
	  ~CEikUndertaker();
private:
	CEikUndertaker(MEikUndertakerObserver& aObserver);
	void ConstructL();
	void Request();
private:  
	virtual void DoCancel();
	virtual void RunL();
private:
	MEikUndertakerObserver& iObserver;
	RUndertaker iUndertaker;
	TInt iThreadHandle;
	};


# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrv.h" 2



class CEikServAppUiBase;
class CDictionaryFileStore;
class CEikServStatusPane;
class CEikServAppStarter;
class CVwsSessionWrapper;
class CEikServExtra;
class CEikServAppUiSession;
class CEikSgcServer;

class CEikServAppUiServer :public CServer
	{
	friend class CEikServAppUiSession;
public:
	enum {EPriority=EPriorityAbsoluteHigh};
	  static CEikServAppUiServer* NewL();
	virtual CSharableSession* NewSessionL(const TVersion &aVersion) const;
	inline void SessionDied();
	static TInt ThreadFunction(TAny* aStarted);
private:
	CEikServAppUiServer(TInt aPriority=EPriority);
	void ConstructL();
private:
	CEikServAppUiBase* iAppUi;
	CEikServAppUiSession* iSession;
	};

class CEikServAppUiSession : public CSession
	{
public:
	 CEikServAppUiSession(RThread aClient, CEikServAppUiServer * aServer);
	 static CEikServAppUiSession* NewL(RThread aClient, CEikServAppUiServer * aServer);
	~CEikServAppUiSession();
	void ConstructL();
	virtual void ServiceL(const RMessage &aMessage);
	void Write(const TAny* aPtr,const TDesC8& aDes,TInt anOffset=0);
protected:
	CEikServAppUiServer* iAppUiServer;
	TBool iScreenBlanked;
	};

inline void CEikServAppUiServer::SessionDied() { iSession= 0L ; }

 



class CEikPasswordModeCategory : public CBase
	{
public:
	  static CEikPasswordModeCategory* NewLC(RFs& aFs);
	  ~CEikPasswordModeCategory();
	  void GetPasswordModeL(TPasswordMode& aMode) const; 
	  void SetPasswordModeL(TPasswordMode aMode);
private:
	CEikPasswordModeCategory();
	void ConstructL(RFs& aFs);
private:
	CDictionaryFileStore* iStore;
	};

 
 
 

class CEikServNotifyServer;
class CNotifierServerExtended;
class CEikServBackupServer;
class CEikServAlarmAlertServer;
class CEikKeyWindow;
class CEikUndertaker;
class CEikPasswordControl;
class CEikTaskListDialog;
class MEikServNotifyAlert;
class MEikServAlarmFactory;
class CEikServDllClose;
class CEikServBlankWin;

 



class TEikServCtrlFactories
	{
public:
	inline TEikServCtrlFactories();
	inline TEikServCtrlFactories(MEikServNotifyAlert* aAlert,MEikServAlarmFactory* aAlarmAlert);
public:
	MEikServNotifyAlert* iAlert;
	MEikServAlarmFactory* iAlarmAlert;
	};


 



class CEikServAppUiBase : public CEikAppUi, public MEikUndertakerObserver
    {
public:
	enum TTaskCycleDirection { EBackwards, EForwards };
	enum TEikServServers { EAlwlSvr=0x01, EApaSvr=0x02, EBackupSvr=0x04 };
	enum TEikSrvShutdownState {	EShutdownWaitingForApps=0, EShutdownKillingRogueApps };
public:
	  static CEikServAppUiBase* NewLC();
	  ~CEikServAppUiBase();
	  void NotifyAlarmServerOfTaskChange() const;
	  virtual void EnableTaskListL();
	  virtual void LaunchTaskListL() const;
	  void CycleTasks(TTaskCycleDirection aDirection) const;
	  void SetStatusPaneFlags(TInt aFlags) const;
	  void SetStatusPaneLayoutL(TInt aLayoutResId) const;
	  virtual void BlankScreenL();
	  virtual void UnblankScreen();
	  void ShutdownAppsL(const TUid aRequesterUID, const RMessage& aShutdownMessage, const TInt aTimeoutInMicroseconds);
	static TInt ShutdownTimeoutL(TAny* aPtr);
	  void HandleForegroundEventL(TBool aForeground);
	  void SetSgcParamsL(TInt aWgId, TBitFlags aFullScreen, TInt aSpLayout, TInt aSpFlags);
	  void PrepareForAppExitL(TInt aWgId);

public:
	inline RWindowGroup& AlertGroupWin() const;
	  void BringAlertGroupWinForwards(TBool aForwards);

protected:
	  void ConstructL();
	  void InitializeL(TEikServCtrlFactories& aCtrlFactories);
	  CEikServAppUiBase();
	  void HandleWsEventL(const TWsEvent& aEvent,CCoeControl* aDestination);
protected:  
	  void HandleThreadExitL(RThread& aThread);
private:  
	  void HandleSystemEventL(const TWsEvent& aEvent);
	  void HandleApplicationSpecificEventL(TInt aType,const TWsEvent& aEvent);
      TKeyResponse HandleKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  void HandleSwitchOnEventL(CCoeControl* aDestination);
	  void HandleResourceChangeL(TInt aType);
private:  
	void SetSystemTime() const;
	static TInt RestartServerCallback(TAny* aObj);
	static TInt StartNotifierServerCallBackL(TAny* aPtr);
	void RestartServer();
	TInt DoShutdownTimeoutL();
	void ProceedWithShutdown();

protected:
	RWindowGroup iAlertGroupWin;
	TInt iAlertGroupForwardsCount;
	TInt iResourceFileOffset;
	CEikServNotifyServer* iNotifyServer;
	CEikServBackupServer* iBackupRestoreServer;
	CEikServAlarmAlertServer* iAlarmAlertServer;
	CEikUndertaker* iUndertaker;
	RWindowGroup iBackdropWindowGroup;
	CEikServStatusPane* iStatusPane;
	CEikServBlankWin* iBlankWin;
	TInt iBlankWinRefCount;
public:
	 
	 
	class CAppExitNotifier : public CActive
		{
	public:
		enum TAppExitMethod
			{
			EAppExitNormal,
			EAppExitForced
			};
	public:  
		static CAppExitNotifier* NewL(TApaTask* aTask,	CEikServAppUiBase* aObserver);
		~CAppExitNotifier();
		void ExitTask();		 
		void KillTask();		 
		TBool IsDead();
		const TApaTask& Task() const;
		const TThreadId ThreadId() const;
	private:
		void ConstructL();
		void RunL();
		void DoCancel();
		CAppExitNotifier(TApaTask* aTask, CEikServAppUiBase* aObserver);

	private:   
		CEikServAppUiBase* iObserver;	     
		TBool iIsDead;						 
		TApaTask* iTask;						 
		RThread iThread;					 
		TThreadId iThreadId;				 
		TAppExitMethod iExitMethod;			 
		};
public:
	void AppExitNotifierL(const CAppExitNotifier* aNotifier,CAppExitNotifier::TAppExitMethod aHowClosed);
private:
	CEikServExtra* iEikServExtra;
	TInt iServerToRestart;
	CEikServAppStarter* iAppStarter;
	CVwsSessionWrapper* iVwsSession;
	};

 



class CEikServEnv : public CEikonEnv
	{
public:
	  CEikServEnv();
	  ~CEikServEnv();
public:
	void SetEikServer(CEikServAppUiServer* aServer);
	void SetUiDll(RLibrary& aDll);
private:
	RLibrary iUiDll;
	CEikServAppUiServer* iServer;
	};

inline TEikServCtrlFactories::TEikServCtrlFactories()
	: iAlert(0L ), iAlarmAlert(0L )
	{}
inline TEikServCtrlFactories::TEikServCtrlFactories(MEikServNotifyAlert* aAlert,MEikServAlarmFactory* aAlarmAlert)
	: iAlert(aAlert), iAlarmAlert(aAlarmAlert)
	{}

inline RWindowGroup& CEikServAppUiBase::AlertGroupWin() const
	{ return((RWindowGroup&)iAlertGroupWin); }
      

# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrvs.h" 2



class CDictionaryFileStore;
static const TLitC<sizeof(L"EikAppUiServer" )/2>  EIKAPPUI_SERVER_NAME ={sizeof(L"EikAppUiServer" )/2-1,L"EikAppUiServer" } ;
static const TLitC<sizeof(L"EikAppUiServerStartSemaphore" )/2>  EIKAPPUI_SERVER_SEMAPHORE ={sizeof(L"EikAppUiServerStartSemaphore" )/2-1,L"EikAppUiServerStartSemaphore" } ;
const TUint KEikSrvDefaultHeapSize=0x10000; 



enum TEikUiOpCode
    {
	EEikAppUiNotifyAlarmServerOfTaskChange,
	EEikAppUiLaunchTaskList,
	EEikAppUiCycleTasks,
	EEikAppUiAddToStack,
	EEikAppUiRemoveFromStack,
	EEikAppUiExecuteD,
	EEikAppUiSetStatusPaneFlags,
	EEikAppUiSetStatusPaneLayout,
	EEikAppUiNotifer,
	EEikAppUiBlankScreen,
	EEikAppUiUnblankScreen,
	EEikAppUiShutdownApps,
	EEikAppUiEnableTaskList,
	EEikAppUiSetSgcParams,
	EEikAppUiBlockServerStatusPaneRedraws,
	EEikAppUiRedrawServerStatusPane,
	EEikAppUiPrepareForAppExit,
	EEikAppUiSetSystemFaded,
	EEikAppUiIsSystemFaded
	};
enum TEikAppUiServPanic
	{
	EEikSrvDefault,
	EEikSrvSvrCreateServer,
	EEikSrvSvrStartServer,
	EEikSrvSrvNotFound
	};
	
struct SStartThreadArg
	{
	 
	};


 
extern  void PanicServer(TEikAppUiServPanic aPanic);

class TLaunchServer
	{
public:
	virtual void LaunchL(RLibrary* aLibrary)=0;
	};
      

# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrvc.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrv.h" 1
 
 
 
 

# 250 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrv.h"

# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiksrvc.h" 2


const TInt KNumConnectRetries=5;

 



class REikAppUiSession : public RSessionBase
	{
public:
	  REikAppUiSession();
	  TInt Connect();
	  TVersion Version() const;
	  void NotifyAlarmServerOfTaskChange() const;
	  TInt EnableTaskList() const;
	  void LaunchTaskList() const;
	  void CycleTasks(CEikServAppUiBase::TTaskCycleDirection aDirection) const;
	  TInt SetStatusPaneFlags(TInt aFlags) const;
	  TInt SetStatusPaneLayout(TInt aLayoutResId) const;
	  TInt BlankScreen() const;
	  TInt UnblankScreen() const;
	  TInt ShutdownApps(const TUid aRequesterUID, const TInt aTimeoutInMicroseconds);
	  void Close();

	 
	  TInt SetSgcParams(TInt aWgId, TBitFlags aAppFlags, TInt aSpLayout, TInt aSpFlags);
	  TInt BlockServerStatusPaneRedraws();
	  TInt RedrawServerStatusPane();
	  TInt PrepareForAppExit(TInt aWgId);
	  TInt SetSystemFaded(TBool aFade);
	  TInt IsSystemFaded(TBool& aFade) const;

private:		
	void StartServerL();




	};

 
 
 

 
extern  void PanicServer(TEikAppUiServPanic aPanic);




# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikspmod.h" 2




class TResourceReader;
class CEikStatusPaneLayoutTree;
class CEikonEnv;
class CAknSgcClient;


 
const TInt KEikStatusPaneDirectionBit		= 0x04;
const TInt KEikStatusPaneHiddenBit			= 0x08;
const TInt KEikStatusPaneInitInitializedBit	= 0x80000000;


typedef TUid TPaneId;

class TEikStatusPaneInit
	{
public:
	TEikStatusPaneInit();
	TEikStatusPaneInit(const TEikStatusPaneInit& aCopy);
	TEikStatusPaneInit& operator=(const TEikStatusPaneInit& aCopy);
	
	inline TPaneId Id() const;
	void LoadDefaults(TResourceReader& aResource);

	inline TBool AppOwned() const;
	inline TInt ControlTypeId() const;
	inline TInt ControlResourceId() const;

	inline void SetHidden();
	inline void ClearHidden();
	inline TBool IsHidden() const;

private:
	inline TBool Initialized();
	inline void SetInitialized();

private:
	TPaneId iId;
	TInt iControlId;
	TInt iControlResource;
	TInt iFlags;
	};


class CEikStatusPaneSetInit : public CArrayFixFlat<TEikStatusPaneInit>
	{
public:
	static CEikStatusPaneSetInit* NewL();
	~CEikStatusPaneSetInit();

	void LoadDefaultsL(TResourceReader& aResource);
	TEikStatusPaneInit& FindL(const TPaneId& aPaneId);

private:
	CEikStatusPaneSetInit();
	};


class MEikStatusPaneLayoutTreeVisitor
	{
public:
	virtual void VisitL(CEikStatusPaneLayoutTree* aNode) = 0;
	};


class CEikStatusPaneLayoutTree : public CBase
	{
public:
	enum TDirection
		{
		EHorizontal,
		EVertical
		};

public:
	~CEikStatusPaneLayoutTree();
	static CEikStatusPaneLayoutTree* NewL(TResourceReader& aResource, TDirection aDefaultDirection = EHorizontal);

	CEikStatusPaneLayoutTree* Find(const TPaneId& aPaneId);
	void AcceptL(MEikStatusPaneLayoutTreeVisitor* aVisitor);

	inline TPaneId Id() const;
	inline TRect Rect() const;

private:
	CEikStatusPaneLayoutTree(TDirection aDefaultDirection);
	void ConstructL(TResourceReader& aResource);

	void SetRect(const TRect& aRect);
	inline TDirection Direction();
	void SetDirection(TDirection aDirection);
	inline TInt Size();
	inline TBool Stretchable();
	void SetStretchable(TBool aStretchable);
	void Layout();

    











	void Layout(TInt aLayoutResourceId);

     










    TRect AknLayoutRect(TInt aLayoutResourceId, TPaneId aPaneId);

     







    void SetAknLayoutUsed(TBool aAknLayoutUsed);
    
     







    TBool AknLayoutUsed();

private:
	TPaneId iId;
	TInt iFlags;
	TRect iRect;
	TInt iSize;

	typedef CArrayPtrFlat<CEikStatusPaneLayoutTree> CSubPaneArray;
	CSubPaneArray* iSubPanes;

private:
	friend class CEikStatusPaneLayout;
	};


class CEikStatusPaneLayout : public CBase
	{
public:
	static CEikStatusPaneLayout* NewL(TResourceReader& aResource, const TRect& aScreenRect);
	static CEikStatusPaneLayout* NewL(TResourceReader& aResource, const TRect& aScreenRect, TInt aLayoutId);
	~CEikStatusPaneLayout();

	inline CEikStatusPaneLayoutTree* Find(const TPaneId& aPaneId) const;
	inline void AcceptL(MEikStatusPaneLayoutTreeVisitor* aVisitor);
	inline TRect Rect() const;

     







	void AknLayoutRefresh(TInt aLayoutResourceId);

     








    TBool AknLayoutUsed();

private:
	CEikStatusPaneLayout();
	void ConstructL(TResourceReader& aResource, const TRect& aScreenRect, TInt aLayoutId);

private:
	CEikStatusPaneLayoutTree* iRoot;
	};


class CEikStatusPaneModelBase : public CBase
	{
public:
	  ~CEikStatusPaneModelBase();

	inline CEikStatusPaneSetInit* PaneInits() const;
	  virtual void SetLayoutL(TInt aLayoutResId, TBool aChangeStatusPaneNow = ETrue);
	inline CEikStatusPaneLayout* CurrentLayout() const;
	  TInt CurrentLayoutResId() const;

     







	void AknLayoutRefresh();

     









	TBool AknLayoutUsed(TInt aLayoutId);


protected:
	class CIdLayoutPair : public CBase
		{
	public:
		CIdLayoutPair(TInt aResId, CEikStatusPaneLayout* aLayout);
		~CIdLayoutPair();
	public:
		TInt iResId;
		CEikStatusPaneLayout* iLayout;
		};
	typedef CArrayPtrFlat<CIdLayoutPair> CLayoutIdSet;
	typedef CArrayFixFlat<TInt> CIdSet;

protected:
	  CEikStatusPaneModelBase(CEikonEnv& aEikEnv);
	  void BaseConstructL(TInt aCoreResId);

	  CEikStatusPaneLayout* LoadLayoutL(TInt aLayoutResId);

	inline CIdSet* LegalIds() const;
	TBool IsLegalId(TInt aLayoutResId) const;

private:
	CEikStatusPaneLayout* Layout(TInt aLayoutResId);
	void CheckLayoutL(CEikStatusPaneLayout* aLayout);

private:
	  virtual void Reserved_1();

private:
	class TLayoutChecker : public MEikStatusPaneLayoutTreeVisitor
		{
	public:
		TLayoutChecker(CEikStatusPaneSetInit* aPanes);
		void VisitL(CEikStatusPaneLayoutTree* aNode);
	private:
		CEikStatusPaneSetInit* iPanes;	
		};

protected:
	CLayoutIdSet* iLayouts;
	TInt iCurrentResId;
	CEikonEnv& iEikEnv;

private:
	CEikStatusPaneSetInit* iPanes;
	CEikStatusPaneLayout* iCurrentLayout;
	CIdSet* iLegalIds;
	};


class CEikAppStatusPaneModel : public CEikStatusPaneModelBase
	{
public:
	static CEikAppStatusPaneModel* NewL(CEikonEnv& aEikEnv,   TInt aCoreResId, TInt aAppResId = 0 , TBool aChangeStatusPaneNow = ETrue);
	~CEikAppStatusPaneModel();
	void ApplyCurrentLayoutL();
public:	 
	void SetLayoutL(TInt aLayoutResId, TBool aChangeStatusPaneNow = ETrue);
private:
	CEikAppStatusPaneModel(CEikonEnv& aEikEnv);
	void ConstructL(TInt aCoreResId, TInt aAppResId, TBool aChangeStatusPaneNow = ETrue);
	};


inline TPaneId TEikStatusPaneInit::Id() const { return iId; }
inline TBool TEikStatusPaneInit::AppOwned() const { return iFlags & 1 ; }
inline TInt TEikStatusPaneInit::ControlTypeId() const { return iControlId; }
inline TInt TEikStatusPaneInit::ControlResourceId() const { return iControlResource; }
inline void TEikStatusPaneInit::SetHidden() {iFlags|=KEikStatusPaneHiddenBit;}
inline void TEikStatusPaneInit::ClearHidden() {iFlags&=~KEikStatusPaneHiddenBit;}
inline TBool TEikStatusPaneInit::IsHidden() const {return iFlags&KEikStatusPaneHiddenBit;}

inline CEikStatusPaneLayoutTree* CEikStatusPaneLayout::Find(const TPaneId& aPaneId) const { return iRoot->Find(aPaneId); }
inline void CEikStatusPaneLayout::AcceptL(MEikStatusPaneLayoutTreeVisitor* aVisitor) { iRoot->AcceptL(aVisitor); }
inline TRect CEikStatusPaneLayout::Rect() const { return iRoot->Rect(); }

inline TPaneId CEikStatusPaneLayoutTree::Id() const { return iId; }
inline TRect CEikStatusPaneLayoutTree::Rect() const { return iRect; }


inline CEikStatusPaneSetInit* CEikStatusPaneModelBase::PaneInits() const { return iPanes; }
inline CEikStatusPaneLayout* CEikStatusPaneModelBase::CurrentLayout() const { return iCurrentLayout; }
inline CEikStatusPaneModelBase::CIdSet* CEikStatusPaneModelBase::LegalIds() const { return iLegalIds; }


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikspane.h" 2











class CCoeBrushAndPenContext;
class CEikStatusPaneContainer;
class TEikStatusPaneSyncDrawer;

const TInt KStatusPaneCapsPresentBit = 1;
const TInt KStatusPaneCapsAppOwnedBit = 2;
const TInt KStatusPaneCapsInCurrentLayoutBit = 4;


 





class MEikStatusPaneObserver
	{
public:
	virtual void HandleStatusPaneSizeChange() = 0;
	};

 



class CEikStatusPaneBase : public CBase
	{
public:
	class TPaneCapabilities
		{
	public:
		TPaneCapabilities();
		inline TBool IsPresent() const;
		inline TBool IsAppOwned() const;
		inline TBool IsInCurrentLayout() const;
	private:
		inline void SetPresent();
		inline void SetAppOwned();
		inline void SetInCurrentLayout();
	private:
		TInt iFlags;
	private:
		friend class CEikStatusPaneBase;
		};

public:
	  ~CEikStatusPaneBase();

	  static CEikStatusPaneBase* Current();
	
	inline   void SetObserver(MEikStatusPaneObserver* aObserver);
	  void ReduceRect(TRect& aBoundingRect) const;
	  void GetShapeL(TRegion& aRegion, TBool aIncludeAppPanes, TBool aIncludeServerPanes) const;

	  virtual void SwitchLayoutL(TInt aLayoutResourceId);
	  virtual void MakeVisible(TBool aVisible);
	  virtual void SetDimmed(TBool aDimmed);
	  virtual void SetFaded(TBool aFaded);
	  virtual void HandleResourceChange(TInt aType);
	  virtual TBool OkToChangeStatusPaneNow();

	  void SetFlags(TInt aFlags);
	  TInt Flags() const;
	  TBool IsVisible() const;
	  TBool IsDimmed() const;
	  TBool IsFaded() const;

	  TPaneCapabilities PaneCapabilities(TPaneId aPaneId) const;
	  TRect PaneRectL(TPaneId aPaneId) const;
	  CCoeControl* ControlL(TPaneId aPaneId) const;
	  CCoeControl* SwapControlL(TPaneId aPaneId, CCoeControl* aNewControl);
	  CCoeControl* ContainerControlL(TPaneId aPaneId) const;
	inline RWindowGroup* WindowGroup() const;
	  void DrawNow();
	  TInt CurrentLayoutResId() const;

protected:
	  CEikStatusPaneBase(CEikonEnv& aEikEnv, RWindowGroup* aParent);
	  void BaseConstructL(TInt aCoreResId);

	virtual CEikStatusPaneModelBase* CreateModelL(TInt aCoreResId) const = 0;
	void CreatePanesL();
	void CreatePaneL(const TEikStatusPaneInit& aPaneInit);
	CEikStatusPaneContainer* Find(TPaneId aPaneId) const;

	virtual TBool IsApp() const = 0;
	inline TRect Rect() const;

private:
	void ApplyLayoutL(CEikStatusPaneLayout* aLayout);
	void SetAllInvisible();

public:    
    void ReportSizeChange();

private:
	class TSetRectAndVisibility : public MEikStatusPaneLayoutTreeVisitor
		{
	public:
		TSetRectAndVisibility(TBool aIsApp, CEikStatusPaneBase* aStatusPane);
		void VisitL(CEikStatusPaneLayoutTree* aNode);
	private:
		TBool iIsApp;
		CEikStatusPaneBase* iStatusPane;
		};
	friend class TSetRectAndVisibility;

protected:
	CEikonEnv& iEikEnv;
	CEikStatusPaneModelBase* iModel;

	TInt iFlags;

private:
	typedef CArrayPtrFlat<CEikStatusPaneContainer> CContainerControls;
	CContainerControls* iControls;
	MEikStatusPaneObserver* iObserver;
	RWindowGroup* iParentWindowGroup;
	TInt iSpbSpare;
	};

 





class CEikStatusPane : public CEikStatusPaneBase, public MCoeForegroundObserver
	{
public:
	  static CEikStatusPane* NewL(CEikonEnv& aEikEnv, RWindowGroup* aParent, TInt aCoreStatusPaneModelResId, TInt aAppStatusPaneModelResId= 0 );
	  ~CEikStatusPane();

	  void ApplyCurrentSettingsL();
	  void PrepareForAppExit();

	 
	  virtual void MakeVisible(TBool aVisible);
	  virtual void SetDimmed(TBool aDimmed);
	  virtual void SetFaded(TBool aFaded);
	  virtual void HandleResourceChange(TInt aType);
	  virtual TBool OkToChangeStatusPaneNow();

private:
	CEikStatusPane(CEikonEnv& aEikEnv, RWindowGroup* aParent, TInt aAppStatusPaneModelId);
	void ConstructL(TInt aCoreStatusPaneModelResId);

	virtual CEikStatusPaneModelBase* CreateModelL(TInt aCoreResId) const;
	TBool IsApp() const;

	void ApplyCurrentFlags();
	void HideAppPanes(TBool aHide);

private:  
	void HandleGainingForeground();
	void HandleLosingForeground();

private:
	TInt iAppDeclId;
	TEikStatusPaneSyncDrawer* iSyncDrawer;	 
	TInt iSpare;	 
	};






 



inline TBool CEikStatusPaneBase::TPaneCapabilities::IsPresent() const { return iFlags & KStatusPaneCapsPresentBit; }
 



inline TBool CEikStatusPaneBase::TPaneCapabilities::IsAppOwned() const { return iFlags & KStatusPaneCapsAppOwnedBit; }
 


inline TBool CEikStatusPaneBase::TPaneCapabilities::IsInCurrentLayout() const { return iFlags & KStatusPaneCapsInCurrentLayoutBit; }
 


inline void CEikStatusPaneBase::SetObserver(MEikStatusPaneObserver* aObserver) { iObserver = aObserver; }
inline TRect CEikStatusPaneBase::Rect() const { return iModel->CurrentLayout()->Rect(); }
inline RWindowGroup* CEikStatusPaneBase::WindowGroup() const { return iParentWindowGroup; }


# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknappui.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcba.h" 1
 
 
 
 





# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikctgrp.h" 1
 
 
 
 










class TEikGroupControl
	{
public:
	inline TEikGroupControl();
	inline TEikGroupControl(CCoeControl* aControl,TInt aId,TInt aLength,TInt aFlags);
public:
	CCoeControl* iControl;
	TInt iId;
	TInt iLongId;
public:
	inline TBool IsLengthSet() const;
	inline TInt Length() const;
	inline TBool IsStretchable() const;
	inline void SetLength(TInt aLength);
	inline void SetStretchable();
public:
	enum TControlFlags
		{
		ESetLength		=0x01,
		EAllowStretch	=0x02
		};
private:
	TInt iLength;
	TInt iFlags;
	};

class CEikControlGroup : public CEikBorderedControl
	{
friend class CTestControlGroup;  

 
friend class CEikCba;
 
public:
	enum TStartCorner
		{
		EFromTopLeft=SLafControlGroup::EFromTopLeft,
		EFromTopRight=SLafControlGroup::EFromTopRight,
		EFromBottomLeft=SLafControlGroup::EFromBottomLeft,
		EFromBottomRight=SLafControlGroup::EFromBottomRight
		};
	enum TOrientation
		{
		ELayHorizontally=SLafControlGroup::ELayHorizontally,
		ELayVertically	=SLafControlGroup::ELayVertically	
		};
public:  
	  CEikControlGroup();
	  ~CEikControlGroup();
	  void ConstructL(TStartCorner aStart,TOrientation aOrientation);
	  virtual void AddControlL(CCoeControl* aControl,TInt aId);
	  virtual void AddControlL(TEikGroupControl& aGroupControl);
	  void InsertControlL(TEikGroupControl& aGroupControl,TInt aIndex);
	  void DeleteControl(TInt aIndex,TInt aCount);
	  void SetLengthInPixels(TInt aLength);
	  void SetBreadthInPixels(TInt aBreadth);
	  void SetControlSpacing(TInt aHSpacing,TInt aVSpacing);
	  void SetControlLayout(TStartCorner aStart,TOrientation aOrientation);
	  void SetNumberOfLines(TInt aNumLines,TBool aDistributeEvenly);
	  void SetControlsAllSameSize();
	  void LayoutControls();
	  CCoeControl* ControlById(TInt aId) const;
	  TInt IndexById(TInt aId) const;
	  void Reset();
	  TInt ControlId(CCoeControl* aControl) const;
	  CCoeControl* Control(TInt aIndex) const;  
	  CArrayFix<TEikGroupControl>* ControlArray() const;
	  TOrientation Orientation() const;
	  void ControlSpacing(TInt& aHSpacing,TInt& aVSpacing) const;
public:  
	  TSize MinimumSize();
      TInt CountComponentControls() const;
	  virtual void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;  
	  virtual void HandleResourceChange(TInt aType);			 
protected:
	enum
		{
		EDistributeEvenly	=0x40,
		EAllSameSize		=0x80
		};
protected:  
      CCoeControl* ComponentControl(TInt aIndex) const;
	  void WriteInternalStateL(RWriteStream& aWriteStream) const;
private:  
	  void Reserved_2();
private:  
	  TInt Adjacent(TInt aRow,TInt aColumn,TInt aCtrlIndex,TInt aTotalRows,TInt aTotalColumns) const;
	  TStartCorner StartCorner() const;
	  void DeleteAllComponents();
	  TSize ControlMinimumSize(TInt aIndex) const;
	  TInt ControlMinimumLength(TInt aIndex);
	  TSize LargestControlSize() const;
	  TBool DistributeEvenly() const;
	  TBool AllSameSize();
private:  
      void SizeChanged();
	  void Draw(const TRect& aRect) const;
protected:
	CArrayFix<TEikGroupControl>* iControlArray;
private:
	TInt iLayout;
	TInt iLines;
	TInt iHSpacing;
	TInt iVSpacing;
	TInt iBreadth;
	TInt iLength;
	TSize iLargestControl;
	};


inline TEikGroupControl::TEikGroupControl()
	{ iControl= 0L ; iId=iFlags=iLength=0; }
inline TEikGroupControl::TEikGroupControl(CCoeControl* aControl,TInt aId,TInt aLength,TInt aFlags)
	: iControl(aControl),iId(aId),iLength(aLength),iFlags(aFlags)
	{}
inline TBool TEikGroupControl::IsLengthSet() const
	{ return iFlags&ESetLength; }
inline TInt TEikGroupControl::Length() const
	{ return iLength; }
inline TBool TEikGroupControl::IsStretchable() const
	{ return iFlags&EAllowStretch; }
inline void TEikGroupControl::SetLength(TInt aLength)
	{ iLength=aLength; iFlags|=ESetLength; }
inline void TEikGroupControl::SetStretchable()
	{ iFlags|=EAllowStretch; }


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcba.h" 2








# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgrp.h" 1
 
 
 
 

# 55 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikbtgrp.h"

# 18 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcba.h" 2











# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikimage.h" 1
 
 
 
 

# 49 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikimage.h"

# 29 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcba.h" 2


class CEikLabel;
class CEikCbaButton;
class CCoeBrushAndPenContext;
class MEikCommandObserver;
class TCoeColorUse;

class CEikScrollBar ;
class TEikScrollBarModel;

class CEikCbaExtension;
class TAknsItemID;

const TInt KMaxCbaLabelLength = 32;

 




class CEikCba : public CEikControlGroup, public MEikButtonGroup, public MEikScrollBarObserver
	{
public:
	enum { ETypeId =  0x101F4105  }; 

	 
	static CEikCba* NewL(const CEikCba* aPrevious,MEikCommandObserver* aCommandObserver,RWindowGroup* aParentWg);
	static CEikCba* NewL(TInt aResourceId,const CEikCba* aPrevious,MEikCommandObserver* aCommandObserver,RWindowGroup* aParentWg);
	static CEikCba* NewLC(const CEikCba* aPrevious,MEikCommandObserver* aCommandObserver,RWindowGroup* aParentWg);
	static CEikCba* NewLC(TInt aResourceId,const CEikCba* aPrevious,MEikCommandObserver* aCommandObserver,RWindowGroup* aParentWg);
	~CEikCba();

public:		 
	const TInt MaxCommands() const;
	void UpdateCbaLabels(TBool aScrollerOn);

	 
	void SetSBFrameObserver(MEikScrollBarObserver* aObserver);
	void SetScrollBarModelL(TEikScrollBarModel* aModel);
	const CEikCbaScrollBarFrame* ScrollBarFrame() const;
	CEikScrollBar * VScrollBarAsControl();

public:		 
	void InsertControlL(TEikGroupControl& aGroupControl,TInt aIndex);	 

public:		 
	void SetCommandL(TInt aPosition,TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask);
	void SetCommandL(TInt aPosition,TInt aResourceId);
	void SetCommandSetL(TInt aResourceId);
	void AddCommandL(TInt aPosition,TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask);
	void AddCommandToStackL(TInt aPosition,TInt aCommandId,const TDesC* aText,const CFbsBitmap* aBitmap,const CFbsBitmap* aMask);
	void AddCommandToStackL(TInt aPosition,TInt aResourceId);
	void AddCommandSetToStackL(TInt aResourceId);
	void SetDefaultCommand(TInt aCommandId);
	TSize CalcMinimumSizeL(TInt aResourceId);
	void RemoveCommandFromStack(TInt aPosition,TInt aCommandId);
	TInt CommandPos(TInt aCommandId) const;
	void DimCommand(TInt aCommandId,TBool aDimmed);
	TBool IsCommandDimmed(TInt aCommandId) const;
	void MakeCommandVisible(TInt aCommandId,TBool aVisible);
	TBool IsCommandVisible(TInt aCommandId) const;
	void AnimateCommand(TInt aCommandId);
	CCoeControl* AsControl();
	const CCoeControl* AsControl() const;
	void SetBoundingRect(const TRect& aBoundingRect);
	void ReduceRect(TRect& aBoundingRect) const;
	CCoeControl* GroupControlById(TInt aCommandId);
	CCoeControl* GroupControlById(TInt aCommandId) const;
	TInt CommandId(TInt aCommandPos) const;
	TInt ButtonCount() const;
	void RemovePreviousCommand(TInt aPosition);

	 
	CEikCommandButton* GroupControlAsButton(TInt aCommandId) const ;
	TUint ButtonGroupFlags() const ;
	  void SetButtonGroupFlags(TInt aFlags);

     











      void SetSkinBackgroundId(const TAknsItemID& aIID);

public:		 
	virtual void Reserved_MtsmPosition();
	virtual void Reserved_MtsmObject();

public:		 
	TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	TSize MinimumSize();
	void GetColorUseListL(CArrayFix<TCoeColorUse>& aColorUseList) const;
	void HandleResourceChange(TInt aType);

protected:	 
	virtual void HandleScrollEventL(CEikScrollBar* aScrollBar,TEikScrollEvent aEventType);

protected:   
    TTypeUid::Ptr MopSupplyObject(TTypeUid aId);
    void Draw(const TRect& aRect) const;

private:	 
	CEikCba(const CEikCba* aPrevious,MEikCommandObserver* aCommandObserver,RWindowGroup* aParentWg);
	void BaseConstructL();
	void ConstructL(TInt aResourceId);
	void ConstructFromResourceL(TResourceReader& aReader);
	CEikCbaButton* ButtonById(TInt aCommandId) const;
	void CreateScrollBarFrameL();
	void InsertScrollBarL();
	TEikGroupControl VScrollBarAsGroupControl();
    void CheckSkinAndUpdateContext();

private:	 
	void SizeChanged();

private:
	TUint					iCbaFlags;
	const CEikCba*			iLink;	 
	CCoeBrushAndPenContext* iBrushAndPenContext;
	MEikCommandObserver*	iCommandObserver;
	CEikCbaScrollBarFrame*	iSBFrame;
    CEikCbaExtension*       iExtension;		
	RWindowGroup*			iParentWg;
	};


class CEikCbaButton : public CCoeControl
	{
public:
	struct SButtonOptions
		{
		TInt iCommandId;
		TBool iDimmed;
		};
public:
	~CEikCbaButton();
	void ConstructL(TGulAlignmentValue aAlignment);
public:
	void AddCommandL(const TDesC& aText);
	void PushCommandL(TInt aCommandId,const TDesC& aText);
	TInt PopCommand();
	void RemoveCommand(TInt aCommandId);
	void RemovePreviousCommand();
	 
	void SwitchToShortTextL(TBool aShortText);
	void SetLabelFont(const CFont* aLabelFont);
	void TruncateLabelText();
	 
public:  
	void SetContainerWindowL(const CCoeControl& aContainer);
	void ConstructFromResourceL(TResourceReader& aReader, TGulAlignmentValue anAlignment);
	TSize MinimumSize();
	void SetDimmed(TBool aDimmed);
public:
    void SetImage(CEikImage &aImage);
    void ReplaceImageByLabel();
    inline TBool IsImageOn() const {return iDoImage;};
private:
 
	TInt IndexFromCommandId(TInt aCommandId);
	void UpdateLabelText(TPtrC aLabelText);
private:  
	TInt CountComponentControls() const;
	CCoeControl* ComponentControl(TInt aIndex) const;
	void SizeChanged();
private:
	TBuf<KMaxCbaLabelLength> iFullLabelText;
	TPtrC iLongLabelText;
	TPtrC iShortLabelText;
	CEikLabel* iLabel;
	CDesCArray* iText;
	CArrayFix<SButtonOptions>* iButtonOptions;
    CEikImage* iImage;
    TBool iDoImage;
	TInt iSpare;
	};



# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknappui.h" 2



class CEikButtonGroupContainer;
class CAknAppShutter;
class CAknAppUiExtension;



class CAknAppUi : public CEikAppUi, MEikStatusPaneObserver, public MCoeViewDeactivationObserver
    {
public:
	  void BaseConstructL(TInt aAppUiFlags=EStandardApp);
	  ~CAknAppUi();

	  CEikStatusPane* StatusPane();
	  CEikButtonGroupContainer* Cba();

	  void ProcessCommandL(TInt aCommand);
	  CAknKeySoundSystem* KeySounds();

      TErrorHandlerResponse HandleError (TInt aError, const SExtendedError& aExtErr, TDes& aErrorText, TDes& aContextText); 

	  void RunAppShutter();
	  TBool IsAppShutterRunning() const;

public:  
	  virtual void HandleViewDeactivation(const TVwsViewId& aViewIdToBeDeactivated, const TVwsViewId &aNewlyActivatedViewId);

public:  
	  void PrepareToExit();

protected:
	 
	  void HandleStatusPaneSizeChange();

	 
	  void HandleSystemEventL(const TWsEvent& aEvent);

protected:  
	  virtual void Reserved_MtsmPosition();
	  virtual void Reserved_MtsmObject();
protected:
      void HandleForegroundEventL(TBool aForeground);
	  void HandleWsEventL(const TWsEvent& aEvent,CCoeControl* aDestination);

	  void SetKeyBlockMode(TAknKeyBlockMode aMode);




    void DecideWsClientBufferSizesL();

private:
	void UpdateKeyBlockMode();
	void HandleErrorL(TInt aError);

private:
	TBool iDumpNextControl;
	CAknAppShutter* iAppShutter;	 
	TAknKeyBlockMode iBlockMode;
	CAknAppUiExtension * iExtension;

public:
     


      void HideApplicationFromFSW(TBool aHide=ETrue);
    };











# 31 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupheadingpane.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopup.h" 1
 
























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopup.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcmobs.h" 1
 
 
 
 

# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikcmobs.h"

# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopup.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h" 1
 
 
 
 
   
# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eiklbx.h"

# 28 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopup.h" 2



# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupfader.h" 1
 


















 
 
 
 

# 56 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupfader.h"

# 31 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopup.h" 2


class CAknPopupHeadingPane;
class CEikButtonGroupContainer;
class CEikListBox;
class CAknSearchField;
class CAknPopupListExtension;

 


























class CAknPopupList : public CEikBorderedControl, public MEikCommandObserver, public MEikListBoxObserver, public MCoeControlObserver, public MAknIntermediateState, public MAknFadedComponent
	{
public:
	  static CAknPopupList* NewL(CEikListBox* aListBox, TInt aCbaResource, AknPopupLayouts::TAknPopupLayouts aType =AknPopupLayouts::EMenuWindow);
	  TBool ExecuteLD();
	  void SetTitleL(const TDesC& aTitle);
	  void CancelPopup();
public:  
	  CEikButtonGroupContainer *ButtonGroupContainer();
	  CAknPopupHeadingPane *Heading();
	  CAknPopupHeadingPane *Heading() const;
	  CEikListBox *ListBox();
	
	  void SetMaximumHeight(TInt aItems);
      TBool EnableFind(TBool aEnable=ETrue);
      CAknSearchField* FindBox() const;

protected:
	 
	  void ProcessCommandL(TInt aCommandId);
	 
	  void HandleListBoxEventL(CEikListBox* aListBox, TListBoxEvent aEventType);
	 
	  void HandleControlEventL(CCoeControl* aControl,TCoeEvent aEventType);
protected:
	  CAknPopupList();
	  ~CAknPopupList();
	  void ConstructL(CEikListBox* aListBox, TInt aCbaResource, AknPopupLayouts::TAknPopupLayouts aType );
	  virtual void AttemptExitL(TBool aAccept);
	  virtual void SetupWindowLayout(AknPopupLayouts::TAknPopupLayouts aType);
	  CEikListBox* ListBox() const;
	  const TAknPopupWindowLayoutDef &Layout() const;
	  TAknPopupWindowLayoutDef &Layout();

protected:  
	  TTypeUid::Ptr MopSupplyObject(TTypeUid aId);

private:
	void FadeBehindPopup(TBool aFade);

private:
	 
	 
	  TSize MinimumSize();
	  CCoeControl* ComponentControl(TInt aIndex) const;
	  TInt CountComponentControls() const;
	  void Draw(const TRect& aRect) const;
	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType);
	  void FocusChanged(TDrawNow aDrawNow);

	  void CloseState();
	static TInt ClosePopup(TAny *aObj);
	 
	  virtual TInt CountFadedComponents();
	  virtual CCoeControl* FadedComponent(TInt aIndex);

private:
	void RemoveFindFiltering();

protected:  
	CEikListBox*				iListBox;
	CEikButtonGroupContainer*	iPopoutCba;
	CAknPopupHeadingPane*		iTitle;
	TBool*						iReturn;	 
	TBool						iMarkable;
	TInt						iCurrentResource;
	AknPopupLayouts::TAknPopupLayouts iWindowType;
	TAknPopupWindowLayoutDef iLayout;
    
    TBool iAppBroughtForwards;
	TAknPopupFader iPopupFader;
	CIdle *iIdle;

	CActiveSchedulerWait iWait;		 
private:
    CAknPopupListExtension* iPopupListExtension;     
	};





# 32 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupheadingpane.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/gulicon.h" 1
 
 
 
 









class CFbsBitmap;

class CGulIcon : public CBase
 



	{
public:
	  static CGulIcon* NewLC();
	  static CGulIcon* NewL();
	  static CGulIcon* NewL(CFbsBitmap* aBitmap, CFbsBitmap* aMask= 0L );
	 
	  void SetBitmap(CFbsBitmap* aBitmap);
	  void SetMask(CFbsBitmap* aMask);
	  CFbsBitmap* Bitmap() const;
	  CFbsBitmap* Mask() const;
	  void SetBitmapsOwnedExternally(TBool aOwnedExternally);
	  TBool BitmapsOwnedExternally() const;
	 
	  ~CGulIcon();
private:
	CGulIcon();
private:
	CFbsBitmap* iBitmap;
	CFbsBitmap* iMask;
	TBool iBitmapsOwnedExternally;
	};


# 33 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknpopupheadingpane.h" 2



class CAknTextControl;
class CEikImage;
class CAknBitmapAnimation;
class CAknPopupHeadingAttributes;
 


class CAknPopupHeadingPane : public CCoeControl
{
    public:
         


        enum THeadingPaneLayout
            {
            EQueryHeadingPane,
            EListHeadingPane
            };


    public:
		  CAknPopupHeadingPane();
          ~CAknPopupHeadingPane();
          void SizeChanged();
          TSize MinimumSize();
          void ConstructL(TPtrC aText);
          void ConstructFromResourceL(TResourceReader &aReader);

          CEikLabel *Prompt() const;
		  TPtr PromptText() const;

          void SetTextL(TPtrC aText);
          void SetHeaderImageL(CEikImage *aImage);
          void SetHeaderAnimationL(TInt aResourceId);		
          void SetLayout( THeadingPaneLayout aLayout );

          void StartAnimationL();
          TInt CancelAnimation();

    public:  
        virtual void ActivateL();

    private:
        TInt CountComponentControls() const;
        CCoeControl* ComponentControl(TInt anIndex) const;
          virtual void Draw(const TRect& aRect) const;

		void DoSetPromptL();
		void LayoutQueryHeadingPane();
		void LayoutListHeadingPane();
	
	private:
        TAknLayoutRect     iLayoutLine;
        TAknLayoutRect     iLayoutHeading;
        CAknTextControl*   iPrompt;
        CEikImage*         iHeaderImage;
        CAknBitmapAnimation* iAnimation;
        TInt               iHeadingLayoutRef;
	CAknPopupHeadingAttributes* iAttributes;  

	private:  
		void SetAnimationBackGroundFrameL();

    public:  
        void SetPageL(TInt aCurrent, TInt aMax=0);

    private:
        HBufC* PageTextL() const;
};



# 22 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlistquerycontrol.h" 2


class CEikFormattedCellListBox;
struct TAknPopupWindowLayoutDef;

 


class CAknListQueryControl : public CCoeControl
    {
    public:
         


          CAknListQueryControl();
    
         


          void ConstructFromResourceL(TResourceReader& aRes);

         


          virtual ~CAknListQueryControl();

         




          TSize MinimumSize();

         




          TInt CountComponentControls() const;

         





          CCoeControl* ComponentControl(TInt anIndex) const;

         







          TKeyResponse OfferKeyEventL( const TKeyEvent& aKeyEvent, TEventCode aType);

         




          void Draw(const TRect& aRect) const;

         



          void SetLayout(TAknPopupWindowLayoutDef* aLayout);

          void FocusChanged(TDrawNow aDrawNow);

         



        inline CEikFormattedCellListBox* Listbox() const;

         



        inline CAknPopupHeadingPane* Heading() const;

         



        inline TInt Listtype() const;

    private:
        CEikFormattedCellListBox* iListBox;
        CAknPopupHeadingPane*     iHeading;
        TInt                      iListType;
        TAknPopupWindowLayoutDef* iLayout;

	public:
		 


        inline CEikFormattedCellListBox* listbox() const;
        inline CAknPopupHeadingPane* heading() const;
        inline TInt listtype() const;
    };

inline CEikFormattedCellListBox *CAknListQueryControl::Listbox() const 
	{ 
	return iListBox; 
	}

inline CAknPopupHeadingPane *CAknListQueryControl::Heading() const 
    {
    if ( iHeading && iHeading->Prompt() )
        return iHeading;
    return 0;
    }

inline TInt CAknListQueryControl::Listtype() const 
	{ 
	return iListType; 
	}

 


inline CEikFormattedCellListBox* CAknListQueryControl::listbox() const 
	{ 
	return Listbox();
	}

inline CAknPopupHeadingPane* CAknListQueryControl::heading() const 
	{ 
	return Heading(); 
	}

inline TInt CAknListQueryControl::listtype() const 
	{ 
	return Listtype(); 
	}


# 36 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2


# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydata.h" 1
 

























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/in_sock.h" 1
 











# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/es_sock.h" 1
 











# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/nifvar.h" 1
 













 








const TInt KConnectionUninitialised  = 0;               
const TInt KStartingSelection        = 1000;            
const TInt KFinishedSelection        = 2000;            
const TInt KConnectionFailure        = 2001;            

const TInt KMinAgtProgress           = 2500;
const TInt KConnectionOpen           = 3500;            
const TInt KConnectionClosed         = 4500;            
const TInt KMaxAgtProgress           = 5500;

const TInt KMinNifProgress           = 6000;
const TInt KLinkLayerOpen            = 7000;            
const TInt KLinkLayerClosed          = 8000;            
const TInt KMaxNifProgress           = 9000;

 









const TInt KStartingConnection = 3000;				 
const TInt KIncomingConnectionInProgress = 3350;	 
const TInt KDataTransferTemporarilyBlocked = 4000;	 
const TInt KConnectionStartingClose	= 4250;			 

 









const TInt KPsdStartingConfiguration = KMinAgtProgress;	 
const TInt KPsdFinishedConfiguration = 2750;			 

const TInt KPsdAnsweringIncoming	 = KIncomingConnectionInProgress;  

const TInt KPsdStartingActivation	 = KStartingConnection;  
const TInt KPsdFinishedActivation	 = KConnectionOpen;		 

const TInt KPsdSuspended			 = KDataTransferTemporarilyBlocked;	 

const TInt KPsdStartingDeactivation	 = KConnectionStartingClose;	 
const TInt KPsdFinishedDeactivation  = KConnectionClosed;			 

 









const TInt KCsdStartingDialling	= KMinAgtProgress;		 
const TInt KCsdFinishedDialling = 2600;					 
const TInt KCsdScanningScript	= 2650;					 
const TInt KCsdScannedScript	= 2750;					 
const TInt KCsdGettingLoginInfo	= 2800;					 
const TInt KCsdGotLoginInfo		= 2900;					 
const TInt KCsdStartingConnect	= KStartingConnection;	 
const TInt KCsdFinishedConnect	= 3100;					 
const TInt KCsdStartingLogIn	= 3200;					 
const TInt KCsdFinishedLogIn	= 3250;					 

const TInt KCsdStartingAnswer	= KIncomingConnectionInProgress;  
const TInt KCsdAnswered			= 3400;					 

const TInt KCsdConnectionOpen	= KConnectionOpen;		 
const TInt KCsdStartingHangUp	= KConnectionStartingClose;	 
const TInt KCsdFinishedHangUp	= KConnectionClosed;	 

 



const TInt KMinConfigDaemonProgress = 8100;
const TInt KConfigDaemonLoading = 8100;
const TInt KConfigDaemonLoaded = 8200;
const TInt KConfigDaemonStartingRegistration = 8300;
const TInt KConfigDaemonFinishedRegistration = 8400;
const TInt KConfigDaemonStartingDeregistration = 8600;
const TInt KConfigDaemonFinishedDeregistrationStop = 8700;
const TInt KConfigDaemonFinishedDeregistrationPreserve = 8701;
const TInt KConfigDaemonFinishedDormantMode = 8750;
const TInt KConfigDaemonUnloading = 8800;
const TInt KConfigDaemonUnloaded = 8900;
const TInt KMaxConfigDaemonProgress = 8900;

 





const TInt KAgentUninitialised = KConnectionUninitialised;
const TInt KAgentUnconnected = 1;
const TInt KMaxAgentProgress = 999;
const TInt KMinInterfaceProgress = 1000;
const TInt KMaxInterfaceProgress = 1999;

 



enum TCallbackAction
	{
	ECallbackActionIETFType0	=0,
	ECallbackActionIETFType1	=1,
	ECallbackActionIETFType2	=2,
	ECallbackActionIETFType3	=3,
	ECallbackActionIETFType4	=4,
	ECallbackActionIETFType5	=5,
	 
	ECallbackActionMSCBCPRequireClientSpecifiedNumber	= 1001,
	ECallbackActionMSCBCPAcceptServerSpecifiedNumber	= 1002,
	ECallbackActionMSCBCPOverrideServerSpecifiedNumber	= 1003
	};

 










enum TConnectionType
	{
	 




	EConnectionGeneric,

	 

	EConnectionCSD = 1000,

	 


	EConnectionGPRS = 2000,

	EConnectionGPRSR97,
	EConnectionGPRSR99,
	EConnectionGPRSRel4,
	EConnectionGPRSRel5,

	 


	EConnectionCDMA = 2500,

	EConnectionCDMA20001xRTT,
	EConnectionCDMA20001xRTTDO,
	EConnectionCDMA20001xRTTDV,
	EConnectionCDMA20003xRTT,
	 

	EConnectionEthernet = 3000,

	 

	EConnectionWLAN = 3100,

	 
 
	EConnectionBTPAN = 4000

	 

	};

 





enum TConnectionLayer
	{
	EPhysicalLayer,
	EDataLinkLayer = 100,
	ENetworkLayer = 200,
	ETransportLayer = 300,
	ESessionLayer = 400,
	EPresentationLayer = 500,
	EApplicationLayer = 600
	};


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/es_sock.h" 2















 



static const TLitC<sizeof(L"SocketServer" )/2>  SOCKET_SERVER_NAME ={sizeof(L"SocketServer" )/2-1,L"SocketServer" } ;



 




const TUint KESockDefaultMessageSlots=8;

 




const TUint KConnectionMajorVersionNumber=1;

 




const TUint KConnectionMinorVersionNumber=0;

 





const TUint KConnectionBuildVersionNumber=68;

 







const TUint KMaxSubConnectionEventSize = 512; 

 




typedef TUint TSubConnectionUniqueId;

 




typedef TBuf8<KMaxSubConnectionEventSize> TSubConnectionNotificationBuf;

 
const TUint KUseEmbeddedUniqueId = 0;  

const TUint KConnProgressDefault = 0;  


class TNifProgress
 





	{	
public:
	inline TNifProgress();
	TInt iStage;
	TInt iError;
	};

class TNifAgentInfo
 





	{
public:
	 
	TVersion iVersion;

	 
	TName iName;
	};

 





typedef TPckgBuf<TNifProgress> TNifProgressBuf;

 





struct SSockAddr
 



	{ 
	 
	TUint iFamily; 
	 
	TUint iPort; 
	};

 




const TUint KMaxSockAddrSize=0x20;

class TSockAddr : public TBuf8<KMaxSockAddrSize>
 

















	{
public:
	  TSockAddr();
	  TSockAddr(TUint aFamily);
	  TUint Family() const;
	  void SetFamily(TUint aFamily);
	  TUint Port() const;
	  void SetPort(TUint aPort);
	  TBool CmpPort(const TSockAddr& anAddr) const;
	  TInt GetUserLen();
protected:
	  void SetUserLen(TInt aLen);
	inline TUint8* UserPtr() const;
private:
	inline SSockAddr* BasePtr() const;
	};

 
 


const TUint KAFUnspec=0;

 
 


const TUint KSockStream=1;
 
const TUint KSockDatagram=2;
 
const TUint KSockSeqPacket=3;
 
const TUint KSockRaw=4;

 
 
 
 


const TInt KSOLSocket=1;
 
const TInt KLevelUnspecified=0;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 






const TUint KSODebug=1;
 




const TUint KSORecvBuf=2;
 




const TUint KSOSendBuf=3;
 





const TUint KSONonBlockingIO=4;
 




const TUint KSOBlockingIO=5;
 


const TUint KSOSelectPoll=6;
 

const TUint KSOReadBytesPending=7;
 


const TUint KSOUrgentDataOffset=8;
 
const TUint KSOSelectLastError=9;


 

 
const TInt  KSocketBufSizeUndefined=0;
 
const TInt  KSocketDefaultBufferSize=4096;

 
const TUint KSocketInternalOptionBit=0x80000000;	 

 







const TUint KInternalIoctlBit=0x80000000;

 








const TUint KIOctlSelect=1;

 
 
 


const TUint KSockSelectRead   =0x00000001;
 
const TUint KSockSelectWrite  =0x00000002;
 
const TUint KSockSelectExcept =0x00000004;
 
const TUint KSockSelectReadContinuation = 0x01000000;

 




const TUint KSockWriteUrgent=0x00000001;	 
const TUint KSocketInternalWriteBit=0x80000000;	 
const TUint KSockWriteSystemMask=0xFF000000;	 

 
 



const TUint KSockReadPeek=0x00000001;		 
const TUint KSocketInternalReadBit=0x80000000;	 
const TUint KSockReadContinuation = 0x01000000;	 
 

 


enum TByteOrder
	{
	 
	EBigEndian,
	 
	ELittleEndian,
	 
	EOtherByteOrder,
	};

 
 
 
 
 
 


const TUint KSIConnectionLess=0x00000001;
 
const TUint KSIReliable=0x00000002;
 
const TUint KSIInOrder=0x00000004;
 
const TUint KSIMessageBased=0x00000008;
 
const TUint KSIDatagram=KSIMessageBased;
 
const TUint KSIStreamBased=0x00000010;
 
const TUint KSIPseudoStream=0x00000020;
 
const TUint KSIUrgentData=0x00000040;
 
const TUint KSIConnectData=0x00000080;
 
const TUint KSIDisconnectData=0x00000100;
 
const TUint KSIBroadcast=0x00000200;
 
const TUint KSIMultiPoint=0x00000400;
 
const TUint KSIQOS=0x00000800;
 
const TUint KSIWriteOnly=0x00001000;
 
const TUint KSIReadOnly=0x00002000;
 
const TUint KSIGracefulClose=0x00004000;
 
const TUint KSICanReconnect=0x00008000;
 

const TUint KSIPeekData=0x00010000;
 


const TUint KSIRequiresOwnerInfo=0x00020000;	 

 
 
 
 
 
 



const TUint KNSNameResolution=0x00000001;
 
const TUint KNSHeirarchicalNaming=0x00000002;
 

const TUint KNSRemoteDiscovery=0x00000004;
 

const TUint KNSServiceResolution=0x00000008;
 
const TUint KNSNameRegistration=0x00000010;
 
const TUint KNSServiceRegistration=0x00000020;
 

const TUint KNSDynamicAddressing=0x00000040;
 
const TUint KNSInfoDatabase=0x00000080;
 

const TUint KNSRequiresConnectionStartup=0x00000100;

 
 
 
 


const TUint KSocketNoSecurity=0x00000000;
 


const TUint KSecureSockets=0x00000001;

 
 
 
 


const TInt KSocketMessageSizeIsStream=0;
 
const TInt KSocketMessageSizeUndefined=1;
 


const TInt KSocketMessageSizeNoLimit=-1;


 


const TUint KUndefinedSockType=0xFFFFFFFF;


 


const TUint KUndefinedProtocol=0xFFFFFFFE;

 


typedef TBuf<0x20> TProtocolName;
 
typedef TBuf<0x20> TServiceName;
 
typedef TBuf<0x100> THostName;

 





struct TProtocolDesc
 
	{
public:
	 


	TProtocolName iName;
	 

	TUint iAddrFamily;
	 
	TUint iSockType;
	 
	TUint iProtocol;
	 


	TVersion iVersion;
	 


	TByteOrder iByteOrder;
	 


	TUint iServiceInfo;
	 



	TUint iNamingServices;
	 


	TUint iSecurity;
	 


	TInt iMessageSize;
	};

 
 




const TInt KErrWouldBlock=-1000;

 








const TInt KErrConnectionTerminated=-17210;

 


typedef TPckgBuf<TInt> TSockXfrLength;

class TSockIO
 




	{
public:
	const TSockXfrLength* iLength;   
	TUint iFlags;                    
	TSockAddr* iAddr;                
	};

class TSockIOBufC : public TPckgC<TSockIO>
 
	{
public:
	inline TSockIOBufC();
	TSockIO iArgs;
	};

class TSockOpen
 
	{
public:
	TUint iAddrFamily;
	TUint iSockType;
	TUint iProtocol;
	TInt  iHandle;
	TInt  iReserved;
	};

class TSockOpenBufC : public TPckgC<TSockOpen>
 
	{
public:
	inline TSockOpenBufC();
	TSockOpen iArgs;
	};

class RSocket;
class RConnection;
class RSocketServ : public RSessionBase
 





















	{
public:
      RSocketServ();
	  TInt Connect(TUint aMessageSlots=KESockDefaultMessageSlots);
	  TVersion Version() const;
	  TInt NumProtocols(TUint& aCount);
	  TInt GetProtocolInfo(TUint anIndex,TProtocolDesc& aProtocol);
	  TInt FindProtocol(const TProtocolName& aName,TProtocolDesc& aProtocol);
	  void StartProtocol(TUint anAddrFamily,TUint aSockType,TUint aProtocol,TRequestStatus& aStatus);
	  void StopProtocol(TUint anAddrFamily,TUint aSockType,TUint aProtocol,TRequestStatus& aStatus);
	  TInt InstallExtension(const TDesC& aDllName, const TDesC& aArgs=TPtrC());
	  void SetExclusiveMode(TRequestStatus& aStatus);
	  void ClearExclusiveMode();
	  TInt __DbgMarkHeap();
	  TInt __DbgCheckHeap(TInt aCount);
	  TInt __DbgMarkEnd(TInt aCount);
	  TInt __DbgFailNext(TInt aCount);
	  TInt __DbgFailNextMbuf(TInt aCount);
	  TInt __DbgSetMbufPoolLimit(TInt asize);
	  TInt __DbgCheckMbuf(TInt asize);
	  TInt __DbgMbufFreeSpace();
	  TInt __DbgMbufTotalSpace();
	};

class RSocket : public RSubSessionBase
 

















	{
friend class RSocketServ;
public:
	 
	enum TShutdown 
		{
		 
		ENormal,
		 
		EStopInput,
		 
		EStopOutput,
		 
		EImmediate
		};
public:
	  RSocket();
	  TInt Open(RSocketServ& aServer,TUint addrFamily,TUint sockType,TUint protocol);
	  TInt Open(RSocketServ& aServer,TUint addrFamily,TUint sockType,TUint protocol, RConnection& aConnection);
	  TInt Open(RSocketServ &aServer,const TDesC& aName);
	  TInt Open(RSocketServ& aServer);
	  void Send(const TDesC8& aDesc,TUint someFlags,TRequestStatus& aStatus);

	  void Send(const TDesC8& aDesc,TUint someFlags,TRequestStatus& aStatus,TSockXfrLength& aLen);
	  void CancelSend();
	
	  void Recv(TDes8& aDesc,TUint flags,TRequestStatus& aStatus);

	  void Recv(TDes8& aDesc,TUint flags,TRequestStatus& aStatus,TSockXfrLength& aLen);
	
	  void RecvOneOrMore(TDes8& aDesc,TUint flags,TRequestStatus& aStatus,TSockXfrLength& aLen);
	  void CancelRecv();
	
	  void Read(TDes8& aDesc,TRequestStatus& aStatus);
	  void CancelRead();

	  void Write(const TDesC8& aDesc,TRequestStatus& aStatus);
	  void CancelWrite();
	  void SendTo(const TDesC8& aDesc,TSockAddr& anAddr,TUint flags,TRequestStatus& aStatus);

	  void SendTo(const TDesC8& aDesc,TSockAddr& anAddr,TUint flags,TRequestStatus& aStatus,TSockXfrLength& aLen);

	  void RecvFrom(TDes8& aDesc,TSockAddr& anAddr,TUint flags,TRequestStatus& aStatus);

	  void RecvFrom(TDes8& aDesc,TSockAddr& anAddr,TUint flags,TRequestStatus& aStatus,TSockXfrLength& aLen);
	  void Connect(TSockAddr& anAddr,TRequestStatus& aStatus);
	  void Connect(TSockAddr& anAddr,const TDesC8& aConnectDataOut,TDes8& aConnectDataIn,TRequestStatus& aStatus);
	  void CancelConnect();
	  TInt Bind(TSockAddr& anAddr);
	  TInt SetLocalPort(TInt aPort);
	  void Accept(RSocket& aBlankSocket,TRequestStatus& aStatus);
	  void Accept(RSocket& aBlankSocket,TDes8& aConnectData,TRequestStatus& aStatus);
	  void CancelAccept();
	  TInt Listen(TUint qSize);
	  TInt Listen(TUint qSize,const TDesC8& aConnectData);
	  TInt SetOpt(TUint anOptionName,TUint anOptionLevel,const TDesC8& anOption=TPtrC8(0L ,0));
	  TInt SetOpt(TUint anOptionName,TUint anOptionLevel,TInt anOption);
	  TInt GetOpt(TUint anOptionName,TUint anOptionLevel,TDes8& anOption);
	  TInt GetOpt(TUint anOptionName,TUint anOptionLevel,TInt &anOption);
	  void Ioctl(TUint aCommand,TRequestStatus& aStatus,TDes8* aDesc= 0L ,TUint aLevel=KLevelUnspecified);
	  void CancelIoctl();
	  TInt GetDisconnectData(TDes8& aDesc);
	  void LocalName(TSockAddr& anAddr);
	  TUint LocalPort();
	  void RemoteName(TSockAddr& anAddr);
	  void Close();
	  void Shutdown(TShutdown aHow,TRequestStatus& aStatus);
	  void Shutdown(TShutdown aHow,const TDesC8& aDisconnectDataOut,TDes8& aDisconnectDataIn,TRequestStatus& aStatus);
	  void CancelAll();
	  TInt Info(TProtocolDesc& aProtocol);
	  TInt Name(TName& aName);
	  TInt Transfer(RSocketServ& aServer, const TDesC& aName);
private:
	TSockIOBufC iRecvArgPkg;
	TSockIOBufC iSendArgPkg;
	};

class TNameRecord
 


	{
public:
	inline TNameRecord();
	 


	enum {EAlias=0x00000001,};
	 


	THostName iName;
	 


	TSockAddr iAddr;
	 
	TInt iFlags;
	};

 



typedef TPckgBuf<TNameRecord> TNameEntry;

class RHostResolver : public RSubSessionBase
 

























	{
public:
	  TInt Open(RSocketServ& aSocketServer,TUint anAddrFamily,TUint aProtocol);
	  TInt Open(RSocketServ& aSocketServer,TUint anAddrFamily,TUint aProtocol, RConnection& aConnection);
	  void GetByName(const TDesC& aName,TNameEntry& aResult,TRequestStatus& aStatus);
	  TInt GetByName(const TDesC& aName,TNameEntry& aResult);
	  void Next(TNameEntry& aResult,TRequestStatus& aStatus);
	  TInt Next(TNameEntry& aResult);
	  void GetByAddress(const TSockAddr& anAddr,TNameEntry& aResult,TRequestStatus& aStatus);
	  TInt GetByAddress(const TSockAddr& anAddr,TNameEntry& aResult);
	  TInt GetHostName(TDes& aName);
	  void GetHostName(TDes& aName,TRequestStatus &aStatus);
	  TInt SetHostName(const TDesC& aName);
	  void Close();
	  void Cancel();

      void Query(const TDesC8& aQuery, TDes8& aResult, TRequestStatus& aStatus);
      TInt Query(const TDesC8& aQuery, TDes8& aResult);
      void QueryGetNext(TDes8& aResult, TRequestStatus& aStatus);
      TInt QueryGetNext(TDes8& aResult);

private:
	};

 





typedef TPckgBuf<TInt> TPortNum;

class RServiceResolver : public RSubSessionBase
 


	{
public:
	  TInt Open(RSocketServ& aSocketServer,TUint anAddrFamily,TUint sockType,TUint aProtocol);
	  void GetByName(const TDesC& aName,TPortNum& aPort,TRequestStatus& aStatus);
	  TInt GetByName(const TDesC& aName,TPortNum& aPort);
	  void GetByNumber(const TUint aPort,TDes& aName,TRequestStatus& aStatus);
	  TInt GetByNumber(const TUint aPort,TDes& aName);
	  void RegisterService(const TDesC& aName,const TUint& aPort,TRequestStatus& aStatus);
	  TInt RegisterService(const TDesC& aName,const TUint& aPort);
	  void RemoveService(const TDesC& aName,const TUint& aPort,TRequestStatus& aStatus);
	  TInt RemoveService(const TDesC& aName,const TUint& aPort);
	  void Close();
	  void Cancel();
private:
	};

class RNetDatabase: public RSubSessionBase
 














	{
public:
	  TInt Open(RSocketServ& aSocketServer,TUint anAddrFamily,TUint aProtocol);
	  void Query(const TDesC8& aQuery,TDes8& aResult,TRequestStatus& aStat);
	  TInt Query(const TDesC8& aQuery,TDes8& aResult);
	  void Add(const TDesC8& anItem,TRequestStatus& aStat);
	  TInt Add(const TDesC8& anItem);
	  void Remove(const TDesC8& anItem,TRequestStatus& aStat);
	  TInt Remove(const TDesC8& anItem);
	  void Close();
	  void Cancel();
private:
	};

 




const TUint KCOLConnection = 1;						 
const TUint KCOLProvider = 2;						 
const TUint KConnInternalOptionBit = 0x80000000;	 
const TUint KConnWriteUserDataBit = 0x40000000;
const TUint KConnReadUserDataBit = 0x20000000;

 







const TUint KCoEnumerateConnectionClients  =  1 | (KConnWriteUserDataBit | KConnReadUserDataBit);

 








const TUint KCoGetConnectionClientInfo     =  2 | (KConnWriteUserDataBit | KConnReadUserDataBit);

 
const TUint KCoEnumerateConnectionSockets  =  3 | (KConnWriteUserDataBit | KConnReadUserDataBit);

 








const TUint KCoGetConnectionSocketInfo     =  4 | (KConnWriteUserDataBit | KConnReadUserDataBit);

 




const TUint KConnectionTypeDefault = 0;

class TConnPref;
class TSubConnectionInfo;
class TSubConnectionEvent;

class RConnection : public RSubSessionBase
 





















































	{
public:
	 
	enum TConnAttachType 
		{ 
		 

		EAttachTypeNormal, 
		 


		EAttachTypeMonitor 
		};
	 
	enum TConnStopType 
		{ 
		 


		EStopNormal, 
		 

		EStopAuthoritative 
		};

	 


	  RConnection();
	  virtual ~RConnection();
	  TInt Open(RSocketServ& aSocketServer, TUint aConnectionType = KConnectionTypeDefault);
	  TInt Open(RSocketServ& aSocketServer, TName& aName);
	  void Close();

	  void Start(TRequestStatus& aStatus);
	  void Start(TConnPref& aPref, TRequestStatus& aStatus);
	  TInt Start();
	  TInt Start(TConnPref& aPref);
	  TInt Stop();
	  TInt Stop(TConnStopType aStopType);
	  TInt Stop(TSubConnectionUniqueId aSubConnectionUniqueId);
	  TInt Stop(TSubConnectionUniqueId aSubConnectionUniqueId, TConnStopType aStopType);

	  void ProgressNotification(TNifProgressBuf& aProgress, TRequestStatus& aStatus, TUint aSelectedProgress = KConnProgressDefault);
	  void ProgressNotification(TSubConnectionUniqueId aSubConnectionUniqueId, TNifProgressBuf& aProgress, TRequestStatus& aStatus, TUint aSelectedProgress = KConnProgressDefault);
	  void CancelProgressNotification();
	  void CancelProgressNotification(TSubConnectionUniqueId aSubConnectionUniqueId);
	  TInt Progress(TNifProgress& aProgress);
	  TInt Progress(TSubConnectionUniqueId aSubConnectionUniqueId, TNifProgress& aProgress);
	  TInt LastProgressError(TNifProgress& aProgress);
	  void ServiceChangeNotification(TUint32& aNewISPId, TDes& aNewServiceType, TRequestStatus& aStatus);
	  void CancelServiceChangeNotification();

	  TInt GetIntSetting(const TDesC& aSettingName, TUint32& aValue);
	  TInt GetBoolSetting(const TDesC& aSettingName, TBool& aValue);
	  TInt GetDesSetting(const TDesC& aSettingName, TDes8& aValue);
	  TInt GetDesSetting(const TDesC& aSettingName, TDes16& aValue);
	  TInt GetLongDesSetting(const TDesC& aSettingName, TDes& aValue);

	  TInt Name(TName& aName);

	  TInt EnumerateConnections(TUint& aCount);
	  TInt GetConnectionInfo(TUint aIndex, TDes8& aConnectionInfo);

	  void AllInterfaceNotification(TDes8& aNotification, TRequestStatus& aStatus);
	  void CancelAllInterfaceNotification();

	  void Ioctl(TUint aOptionLevel, TUint aOptionName, TRequestStatus& aStatus, TDes8* aDesc);
	  void Ioctl(TUint aOptionLevel, TUint aOptionName, TRequestStatus& aStatus);	
	  void CancelIoctl();
	  TInt Control(TUint aOptionLevel, TUint aOptionName, TDes8& aOption);
	  TInt GetOpt(TUint aOptionLevel, TUint aOptionName, TInt& aOption);
	  TInt SetOpt(TUint aOptionLevel, TUint aOptionName, TInt aOption = 0);

	  TInt Attach(const TDesC8& aConnectionInfo, TConnAttachType aAttachType);

	  TInt EnumerateSubConnections(TUint& aCount);
	  TInt GetSubConnectionInfo(TDes8& aSubConnectionInfo);
	  TInt GetSubConnectionInfo(TUint aIndex, TDes8& aSubConnectionInfo);
	  void AllSubConnectionNotification(TSubConnectionNotificationBuf& aSubConnectionEvent, TRequestStatus& aStatus);
	  void CancelAllSubConnectionNotification();

	  void DataTransferredRequest(TPckg<TUint>& aUplinkVolume, TPckg<TUint>& aDownlinkVolume, TRequestStatus& aStatus);
	  void DataTransferredRequest(TSubConnectionUniqueId aSubConnectionUniqueId, TPckg<TUint>& aUplinkVolume, TPckg<TUint>& aDownlinkVolume, TRequestStatus& aStatus);
	  void DataTransferredCancel();
	  void DataTransferredCancel(TSubConnectionUniqueId aSubConnectionUniqueId);
	  void DataSentNotificationRequest(TUint aThreshold, TPckg<TUint>& aUplinkVolume, TRequestStatus& aStatus);
	  void DataSentNotificationRequest(TSubConnectionUniqueId aSubConnectionUniqueId, TUint aThreshold, TPckg<TUint>& aUplinkVolume, TRequestStatus& aStatus);
	  void DataSentNotificationCancel();
	  void DataSentNotificationCancel(TSubConnectionUniqueId aSubConnectionUniqueId);
	  void DataReceivedNotificationRequest(TUint aThreshold, TPckg<TUint>& aDownlinkVolume, TRequestStatus& aStatus);
	  void DataReceivedNotificationRequest(TSubConnectionUniqueId aSubConnectionUniqueId, TUint aThreshold, TPckg<TUint>& aDownlinkVolume, TRequestStatus& aStatus);
	  void DataReceivedNotificationCancel();
	  void DataReceivedNotificationCancel(TSubConnectionUniqueId aSubConnectionUniqueId);
	  void IsConnectionActiveRequest(TUint aSecs, TPckg<TBool>& aState, TRequestStatus& aStatus);
	  void IsConnectionActiveCancel();
	  void IsSubConnectionActiveRequest(TSubConnectionUniqueId aSubConnectionUniqueId, TUint aSecs, TPckg<TBool>& aState, TRequestStatus& aStatus);
	  void IsSubConnectionActiveCancel(TSubConnectionUniqueId aSubConnectionUniqueId);

	 



	  static TVersion Version();

	TBool SameSession(TInt aSessionHandle);
private:
	TPckg<TUint32> iNewISPId;
	TUint32 iReserved[4];
	};

class ByteOrder
 


	{
public:
	  static TUint32 Swap32(TUint32 aVal);
	  static TUint16 Swap16(TUint16 aVal);
	inline static TUint16 Swap16(TUint aVal);
	};

class BigEndian
 


	{
public:
	  static TUint32 Get32(const TUint8* aPtr);
	  static TUint16 Get16(const TUint8* aPtr);
	  static void Put32(TUint8* aPtr, TUint32 aVal);
	  static void Put16(TUint8* aPtr, TUint16 aVal);
	};

class LittleEndian
 


	{
public:
	  static TUint32 Get32(const TUint8* aPtr);
	  static TUint16 Get16(const TUint8* aPtr);
	  static void Put32(TUint8* aPtr, TUint32 aVal);
	  static void Put16(TUint8* aPtr, TUint16 aVal);
	};

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/es_sock.inl" 1
 





inline TSockIOBufC::TSockIOBufC()	: TPckgC<TSockIO>(iArgs)

	{}

inline TSockOpenBufC::TSockOpenBufC()	: TPckgC<TSockOpen>(iArgs)

	{}

inline SSockAddr *TSockAddr::BasePtr() const
 




	{ return (SSockAddr*)iBuf; }


inline TUint8 *TSockAddr::UserPtr() const
 


	{ return (TUint8*)(BasePtr()+1); }

inline TUint16 ByteOrder::Swap16(TUint aVal)
 





	{ return ByteOrder::Swap16((TUint16)aVal); }

inline TNameRecord::TNameRecord()
	:iName(),iAddr(),iFlags(0)	
 



	{}

inline TNifProgress::TNifProgress()	:iStage(0), iError(KErrNone) 
 


	{}
# 1141 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/es_sock.h" 2

	


# 13 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/in_sock.h" 2



 
 
 
const TUint KAfInet				= 0x0800;    
 
const TUint KAfInet6			= 0x0806;    
 

 



const TUint KProtocolUnknown = 0xdead;

 
 
const TUint KProtocolInetIcmp	= 1;		 
const TUint KProtocolInetTcp	= 6;		 
const TUint KProtocolInetUdp	= 17;		 
const TUint KProtocolInetIp		= 0x100;	 
 

 





  
 
const TUint KProtocolInet6Ipip	= 41;		 
 
const TUint KProtocolInet6Icmp	= 58;		 
 
const TUint KProtocolInet6Ip	= 0xF00;	 
 

 
 
 
const TUint KSolInetIcmp		= 0x101;	 
 
const TUint KSolInetTcp			= 0x106;	 
 
const TUint KSolInetUdp			= 0x111;	 
 
const TUint KSolInetIp			= 0x100;	 
 
const TUint KSolInetIfCtrl		= 0x201;	 
 
const TUint KSolInetRtCtrl		= 0x202;	 
 

 



const TUint KSolInetDnsCtrl		= 0x204;

 
const TUint KSolInetIfQuery		= 0x206;	 

 
 
 
const TInt KInetAddrMaxBits         = 32;
 
const TInt KInet6AddrMaxBits        = 128;
 

 
 
 
const TUint KInetPortAny			= 0x0000; 
 
const TUint KInetPortNone			= 0x0000;
 
const TUint KInetMinAutoPort		= 32768;	 
 
const TUint KInetMaxAutoPort		= 60999;	 
 

 
 













 
 
 
const TUint32 KInetAddrAny				= (TUint32)((((TUint32)( 0 ))<<24)|(( 0 )<<16)|(( 0 )<<8)|( 0 )) ;
 
const TUint32 KInetAddrNone				= (TUint32)((((TUint32)( 0 ))<<24)|(( 0 )<<16)|(( 0 )<<8)|( 0 )) ;
 
const TUint32 KInetAddrAll				= (TUint32)((((TUint32)( 255 ))<<24)|(( 255 )<<16)|(( 255 )<<8)|( 255 )) ;
 
const TUint32 KInetAddrBroadcast		= (TUint32)((((TUint32)( 255 ))<<24)|(( 255 )<<16)|(( 255 )<<8)|( 255 )) ;
 
const TUint32 KInetAddrLoop				= (TUint32)((((TUint32)( 127 ))<<24)|(( 0 )<<16)|(( 0 )<<8)|( 1 )) ;

 
const TUint32 KInetAddrGroupUnspec		= (TUint32)((((TUint32)( 224 ))<<24)|(( 0 )<<16)|(( 0 )<<8)|( 0 )) ;
 
const TUint32 KInetAddrGroupAllHosts	= (TUint32)((((TUint32)( 224 ))<<24)|(( 0 )<<16)|(( 0 )<<8)|( 1 )) ;

 
const TUint32 KInetAddrLinkLocalNet		= (TUint32)((((TUint32)( 169 ))<<24)|(( 254 )<<16)|(( 0 )<<8)|( 0 )) ;
 
const TUint32 KInetAddrLinkLocalNetMask	= (TUint32)((((TUint32)( 255 ))<<24)|(( 255 )<<16)|(( 0 )<<8)|( 0 )) ;

 
const TUint32 KInetAddrMaskAll			= (TUint32)((((TUint32)( 0 ))<<24)|(( 0 )<<16)|(( 0 )<<8)|( 0 )) ;
 
const TUint32 KInetAddrMaskHost			= (TUint32)((((TUint32)( 255 ))<<24)|(( 255 )<<16)|(( 255 )<<8)|( 255 )) ;
 


 
 

const TUint32 KInetAddrNetMaskA			= (TUint32)((((TUint32)( 255 ))<<24)|(( 0 )<<16)|(( 0 )<<8)|( 0 )) ;
 

const TUint32 KInetAddrHostMaskA		= ~KInetAddrNetMaskA;
 

const TInt KInetAddrShiftA				= 24;
 

const TUint32 KInetAddrNetMaskB 		= (TUint32)((((TUint32)( 255 ))<<24)|(( 255 )<<16)|(( 0 )<<8)|( 0 )) ;
 

const TUint32 KInetAddrHostMaskB		= ~KInetAddrNetMaskB;
 

const TInt KInetAddrShiftB				= 16;
 

const TUint32 KInetAddrNetMaskC 		= (TUint32)((((TUint32)( 255 ))<<24)|(( 255 )<<16)|(( 255 )<<8)|( 0 )) ;
 

const TUint32 KInetAddrHostMaskC		= ~KInetAddrNetMaskC;
 

const TInt KInetAddrShiftC				= 8;

 
const TUint32 KInetAddrIdMaskA			= 0x80000000;
 
const TUint32 KInetAddrIdValA			= 0x00000000;
 
const TUint32 KInetAddrIdMaskB			= 0xc0000000;
 
const TUint32 KInetAddrIdValB			= 0x80000000;
 
const TUint32 KInetAddrIdMaskC			= 0xe0000000;
 
const TUint32 KInetAddrIdValC			= 0xc0000000;
 
const TUint32 KInetAddrIdMaskD			= 0xf0000000;
 
const TUint32 KInetAddrIdValD			= 0xe0000000;
 
const TUint32 KInetAddrIdMaskE			= 0xf8000000;
 
const TUint32 KInetAddrIdValE			= 0xf0000000;

enum TInetAddrClass
	{
	EInetClassUnknown = 0,
	EInetClassA,
	EInetClassB,
	EInetClassC,
	EInetClassD,
	EInetClassE,
	EInetMulticast = EInetClassD,
	EInetExperimental = EInetClassE
	};

 
struct SInetAddr
	{ TUint32 iAddr; };


class TIp6Addr
 
	{
public:
	  TBool IsUnicast() const;		 
	  TBool IsMulticast() const;		 
	  TBool IsLoopback() const;		 
	  TBool IsUnspecified() const;	 
	  TBool IsLinkLocal() const;		 
	  TBool IsSiteLocal() const;		 
	  TBool IsV4Compat() const;		 
	  TBool IsV4Mapped() const;		 
	  TBool IsEqual(const TIp6Addr &aAddr) const; 
	  TInt Match(const TIp6Addr &aAddr) const;	 
	  TInt Scope() const;
	union
		{
		TUint8  iAddr8[16];
		TUint16 iAddr16[8];
		TUint32 iAddr32[4];
		} u;
	};


 
struct SInet6Addr
	{
	TIp6Addr iAddr;		 
	TUint32 iFlow;		 
	TUint32 iScope;		 
	};

 

  
 
const TInt KIp6AddrScopeNodeLocal = 0x01;      
 
const TInt KIp6AddrScopeLinkLocal = 0x02;      
 
const TInt KIp6AddrScopeSiteLocal = 0x05;      
 
const TInt KIp6AddrScopeOrganization = 0x08;   
 
const TInt KIp6AddrScopeGlobal = 0x0E;	       
 










 
const TInt KIp6AddrScopeNetwork = 0x10;	       
 

 
 
 
const TIp6Addr KInet6AddrNone = {{{0}}};
 
const TIp6Addr KInet6AddrLoop = {{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}}};
 
const TIp6Addr KInet6AddrLinkLocal = {{{0xfe, 0x80, }}};
 

 









































class TInetAddr : public TSockAddr
	{
public:
	  TInetAddr();
	  TInetAddr(const TSockAddr& anAddr);
	  TInetAddr(TUint aPort);
	  TInetAddr(const TIp6Addr &anAddr, TUint aPort);
	  TInetAddr(TUint32 anAddr, TUint aPort);
	  void SetAddress(TUint32 anAddr);
	  void SetAddress(const TIp6Addr &anAddr);
	  void SetV4CompatAddress(TUint32 anAddr);
	  void SetV4MappedAddress(TUint32 anAddr);
	  void SetFlowLabel(TInt aLabel);
	  TInt FlowLabel() const;
	  const TIp6Addr &Ip6Address() const;
	  void ConvertToV4Compat();
	  void ConvertToV4Mapped();
	  void ConvertToV4();
	  TBool CmpAddr(const TInetAddr& anAddr) const;

	 





	  TBool Match(const TInetAddr& aHost) const;

	 











	  TBool Match(const TInetAddr& aNet, const TInetAddr& aMask) const;
	  TBool Match(const TInetAddr& aNet, TInt aPrefixLen) const;
	  void PrefixMask(TInt aPrefixLen);
	  void Prefix(const TInetAddr& aAddr, TInt aPrefixLen);
	  void Output(TDes &aBuf) const;
	  TInt Input(const TDesC &aBuf);

	 







	inline static TInetAddr& Cast(const TSockAddr& anAddr);

	 







	inline static TInetAddr& Cast(const TSockAddr* anAddr);
	
	 
	 

	  TBool IsUnicast() const;
	  TBool IsMulticast() const;
	  TBool IsLoopback() const;
	  TBool IsUnspecified() const;
	  TBool IsLinkLocal() const;
	  TBool IsSiteLocal() const;
	  TBool IsV4Compat() const;
	  TBool IsV4Mapped() const;
	  TUint32 Address() const;  
	  void NetMask(const TInetAddr& aAddr);
	  void Net(const TInetAddr& aAddr);
	  void NetBroadcast(const TInetAddr& aAddr);
	  void SubNet(const TInetAddr& aAddr, const TInetAddr& aMask);
	  void SubNetBroadcast(const TInetAddr& aAddr, const TInetAddr& aMask);
        
	 








	inline TBool IsClassA() const;

	 








	inline TBool IsClassB() const;

	 








	inline TBool IsClassC() const;

	 








	inline TBool IsBroadcast() const;

	 






	inline TBool IsWildAddr() const;

	 




	inline TBool IsWildPort() const;
	 

	  void SetScope(TUint32 aScope);
	  TUint32 Scope() const;
	  void Init(TUint aFamily);
	  void OutputWithScope(TDes &aBuf) const;
protected:
	inline SInetAddr *Addr4Ptr() const;	 
	inline SInet6Addr *AddrPtr() const;	 
	inline static TInt AddrLen();		 
private:
	TInt Ipv4Input(const TDesC& aDes);	 
	TInt Ipv6Input(const TDesC& aDes);	 
	};


 
 
inline SInet6Addr* TInetAddr::AddrPtr() const
	{ return (SInet6Addr*)UserPtr(); }

inline TInt TInetAddr::AddrLen()
	{ return sizeof(SInet6Addr); }

inline TInetAddr& TInetAddr::Cast(const TSockAddr& anAddr)
	 






        { return *((TInetAddr*)&anAddr); }

inline TInetAddr& TInetAddr::Cast(const TSockAddr* anAddr)
	 






        { return *((TInetAddr*)anAddr); }

 
inline SInetAddr* TInetAddr::Addr4Ptr() const
	{ return (SInetAddr*)UserPtr(); }

inline TBool TInetAddr::IsBroadcast() const
	 








	{ return Address() == KInetAddrBroadcast; }

inline TBool TInetAddr::IsWildPort() const
	 


	{ return Port() == KInetPortNone; }

inline TBool TInetAddr::IsWildAddr() const
	 




	{ return IsUnspecified(); }

 

inline TBool TInetAddr::IsClassA() const
	 







	 
	{ if (Family() == KAfInet6 
		  && !(IsV4Mapped() || IsV4Compat()) )
	    return EFalse;

	  return (Address() & KInetAddrIdMaskA) == KInetAddrIdValA; }

inline TBool TInetAddr::IsClassB() const
	 







	 
	{ if (Family() == KAfInet6 
		  && !(IsV4Mapped() || IsV4Compat()) )
	    return EFalse;

	  return (Address() & KInetAddrIdMaskB) == KInetAddrIdValB; }

inline TBool TInetAddr::IsClassC() const
	 







	 
	{ if (Family() == KAfInet6 
		  && !(IsV4Mapped() || IsV4Compat()) )
	    return EFalse;

	  return (Address() & KInetAddrIdMaskC) == KInetAddrIdValC; }
 

 
 
const TUint KIpDontFragment		= 0x010000;	   
const TUint KIpHeaderIncluded	= 0x020000;	   
 

const TUint KIpDontRoute		= 0x040000;
 


class TSoInetLastErr
 





 
	{
public:
	 
	TInt iStatus;			 
	 
	TInt iErrType;			 
	 
	TInt iErrCode;			 
	 

	TInetAddr iSrcAddr;		 
	 

	TInetAddr iDstAddr;		 
	 

	TInetAddr iErrAddr;		 
	};

class TIp6Mreq
 
	{
public:
	
	TIp6Addr iAddr;		 
	TUint iInterface;	 
	};

 
 
 
 
 




const TInt KSoInetEnumInterfaces = 0x211;	 

 





const TInt KSoInetNextInterface = 0x212;	 

 













const TInt KSoInetConfigInterface = 0x213;	 

 


enum TIfStatus
	{
	 
	EIfPending,				 
	 
	EIfUp,					 
	 
	EIfBusy,				 
	 
	EIfDown,				 
	};

class TSoInetInterfaceInfo
 
 






	{
public:
	 
	TName iTag;				 
	 
	TName iName;			 
	 
	TIfStatus iState;		 
	 
	TInt iMtu;				 
	 
	TInt iSpeedMetric;		 
	 


	TUint iFeatures;		 
	TSockAddr iHwAddr;		 
	TInetAddr iAddress;		 
	TInetAddr iNetMask;		 
	TInetAddr iBrdAddr;		 
	TInetAddr iDefGate;		 
	TInetAddr iNameSer1;	 
	TInetAddr iNameSer2;	 
	};


 
 
 
 
 
 
 
 




const TUint KSoInetDeleteInterface = 0x214;	   

 








const TUint KSoInetChangeInterface = 0x215;	   

 


const TUint KSoInetResetInterface = 0x216;	 

 


const TUint KSoInetStartInterface = 0x217;	 

class TSoInet6InterfaceInfo : public TSoInetInterfaceInfo
 
 
	{
public:
	 


	TUint iDelete:1;

	 


	TUint iAlias:1;
	
	 


	TUint iDoPrefix:1;
	
	 


	TUint iDoId:1;
	
	 


	TUint iDoState:1;
	 


	TUint iDoAnycast:1;
	
	 
	TUint iDoProxy:1;
	};

 



typedef TUint32 TInetScopeIds[16];

class TSoInetIfQuery
 


























	{
public:
	TInetAddr iDstAddr;		 
	TInetAddr iSrcAddr;		 
	TUint32 iIndex;			 
	TName iName;			 
	 
	TUint iIsUp:1;			 
	TInetScopeIds iZone;	 
	};

 






const TUint KSoInetIfQueryByDstAddr	= 0x1;	 

 








const TUint KSoInetIfQueryBySrcAddr	= 0x2;	 

 

const TUint KSoInetIfQueryByIndex	= 0x3;	 

 

const TUint KSoInetIfQueryByName	= 0x4;	 

 


const TUint KSoInetIfQuerySetScope	= 0x10;	 

 
 
 




const TInt KSoInetEnumRoutes  = 0x221;		 

 




const TInt KSoInetNextRoute	  = 0x222;		 

 







const TInt KSoInetAddRoute	  = 0x223;		 

 







const TInt KSoInetDeleteRoute = 0x224;		 

 









const TInt KSoInetChangeRoute = 0x225;		 

 




enum TRouteState
	{
	 
	ERtNone,
	 


	ERtPending,	
	 


	ERtBusy,
	 
	ERtReady,
	 


	ERtDown	
	};

 


enum TRouteType
	{
	 


	ERtNormal,
	 


	ERtUser,
	 


	ERtIcmpAdd,
	 


	ERtIcmpDel	
	};

class TSoInetRouteInfo
 








	{
public:
	TRouteType iType;		 
	TRouteState iState;		 
	TInt iMetric;			 
	TInetAddr iIfAddr;		 
	TInetAddr iGateway;		 
	TInetAddr iDstAddr;		 
	TInetAddr iNetMask;		 
	};

class TSoInetCachedRouteInfo : public TSoInetRouteInfo
 







 
 
	{
public:
	TInt iPathMtu;			 
	TUint iPathRtt;			 
	};

 











const TInt KSoInetCachedRouteByDest = 0x225;


 
 

enum TNameRecordFlags
	{
	EDnsAlias=0x00000001,		 
	EDnsAuthoritive=0x00000002,  
	EDnsHostsFile=0x00000004,    
	EDnsServer=0x00000008,       
	EDnsHostName=0x00000010,     
	EDnsCache=0x00000020		 
	};

 










const TUint KSoDnsCacheEnable = 0x600;

 






const TUint KSoDnsCacheFlush = 0x601;

 

 
const TUint KIoctlTcpNotifyDataSent = 0x300;   

 
 







const TUint KSoTcpSendWinSize = 0x301;  

 







const TUint KSoTcpRecvWinSize = 0x302;  

 







const TUint KSoTcpMaxSegSize = 0x303;  

 







const TUint KSoTcpNoDelay = 0x304;  

 









const TUint KSoTcpKeepAlive = 0x305;  

 











const TUint KSoTcpAsync2MslWait = 0x306;

 




const TUint KSoTcpSendBytesPending = 0x307;  

 





const TUint KSoTcpReadBytesPending = 0x308;  

 






const TUint KSoTcpListening = 0x309;  

 




const TUint KSoTcpNumSockets = 0x310;  

 










const TUint KSoTcpReadUrgentData = 0x311;  

 





const TUint KSoTcpPeekUrgentData = 0x312;  

 





const TUint KSoTcpRcvAtMark = 0x313;  

 






const TUint KSoTcpNextSendUrgentData = 0x314;  

 






const TUint KSoTcpOobInline = 0x315;  

 
const TUint KSOTcpDebugMode = 0x11110000;


 
 







const TUint KSoIpOptions = 0x401;  

 









const TUint KSoRawMode = 0x402;  

 





const TUint KSoHeaderIncluded = 0x403;  

 








const TUint KSoIpTOS = 0x404;  

 








const TUint KSoIpTTL = 0x405;  

 






const TUint KSoReuseAddr = 0x406;  

 







const TUint KSoNoInterfaceError = 0x407;  

 












const TUint KSoUserSocket = 0x408;  

 
const TUint KSoInterfaceIndex = 0x409;  

 





const TUint KSoKeepInterfaceUp = 0x40a;  
const TUint KSoNoSourceAddressSelect = 0x40b;  

 




const TUint KSoInetLastError = 0x200;  

 
const TUint KIoctlInetLastError = 0x200;  

 
 
 
 











  

 




const TUint KSoIp6UnicastHops = 0x465;  

 


const TUint KSoIp6MulticastIf = 0x46a;  

 






const TUint KSoIp6MulticastHops	= 0x46b;  

 




const TUint KSoIp6MulticastLoop	= 0x46c;  

 


const TUint KSoIp6JoinGroup	= 0x46d;  

 


const TUint KSoIp6LeaveGroup = 0x46e;  
 

 
 






const TUint KSoUdpReceiveICMPError = 0x500;  

 









const TUint KSoUdpRecvBuf = 0x501;

 


const TUint KSoUdpSynchronousSend = 0x560;  

 
const TUint KSoFlowClosing = 0x600 | KSocketInternalOptionBit;

 
 
const TInt KErrNetUnreach = -190;		 
const TInt KErrHostUnreach = -191;		 
const TInt KErrNoProtocolOpt = -192;	 
const TInt KErrUrgentData = -193;		 
 


# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydata.h" 2


class CAknQueryDialog;
class TInetAddr;


  TInt GetMaxTextLength(const CAknQueryControl* aControl, const TDes& aDataText, TInt aApiValue);

class MAknQueryData
    {
    public:
        virtual void SetL(CAknQueryControl* aControl, TInt aMaxLength) = 0;
        virtual void Get(CAknQueryControl* aControl) = 0;
    };

template<class T>
class TAknQueryData : public MAknQueryData
    {
    public:
        TAknQueryData(T& aData) : iData(aData) {}

        void SetL(CAknQueryControl* aControl, TInt aMaxLength);
        void Get(CAknQueryControl* aControl);

    public:
        T& iData;
    };

template<>
class TAknQueryData<TDes> : public MAknQueryData
    {
    public:
        TAknQueryData(TDes& aData) : iData(aData) {}

        void SetL(CAknQueryControl* aControl,TInt aMaxLength)
            { aControl->SetTextL(iData); 
              aControl->SetTextEntryLength(
                  GetMaxTextLength(aControl,iData,aMaxLength)); }
        void Get(CAknQueryControl* aControl) 
            { aControl->GetText(iData); }
    public:
        TDes& iData;
    };

template<>
class TAknQueryData<TInt> : public MAknQueryData
    {
    public:
        TAknQueryData(TInt& aData) : iData(aData) {}

        void SetL(CAknQueryControl* aControl,TInt  )
            { aControl->SetNumberL(iData); }
        void Get(CAknQueryControl* aControl) 
            { iData=aControl->GetNumber(); }
    public:
        TInt& iData;
    };

template<>
class TAknQueryData<TTime> : public MAknQueryData
    {
    public:
        TAknQueryData(TTime& aData) : iData(aData) {}

        void SetL(CAknQueryControl* aControl,TInt  )
            { aControl->SetTime(iData); }
        void Get(CAknQueryControl* aControl) 
            { iData=aControl->GetTime(); }
    public:
        TTime& iData;
    };

template<>
class TAknQueryData<TTimeIntervalSeconds> : public MAknQueryData
    {
    public:
        TAknQueryData(TTimeIntervalSeconds& aData) : iData(aData) {}

        void SetL(CAknQueryControl* aControl,TInt  )
            { aControl->SetDuration(iData); }
        void Get(CAknQueryControl* aControl) 
            { iData=aControl->GetDuration(); }
    public:
        TTimeIntervalSeconds& iData;
    };

template<>
class TAknQueryData<TReal> : public MAknQueryData
    {
    public:
        TAknQueryData(TReal& aData) : iData(aData) {}

        void SetL(CAknQueryControl* aControl,TInt  )
            { aControl->SetFloatingPointNumberL(&iData); }
        void Get(CAknQueryControl* aControl) 
            { iData=aControl->GetFloatingPointNumberL(); }
    public:
        TReal& iData;
    };


template<>  
class TAknQueryData<TInetAddr> : public MAknQueryData
    {
    public:
        TAknQueryData(TInetAddr& aData) : iData(aData) {}
        void SetL(CAknQueryControl* aControl,TInt  )
            {
                CAknExtQueryControl* control = (static_cast< CAknExtQueryControl* >( aControl )) ;
                control->SetInetAddress(iData);
            }
        void Get(CAknQueryControl* aControl) 
            {
                CAknExtQueryControl* control = (static_cast< CAknExtQueryControl* >( aControl )) ;
                iData=control->GetInetAddress();
            }

    public:
        TInetAddr& iData;
    };



# 38 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2



class CAknKeySoundSystem;
class TInetAddr;


 




class CAknQueryDialog : public CAknDialog , public MAknQueryControlObserver 
    {
    public:
         





      enum TTone {
         
        ENoTone = 0,        
         
        EConfirmationTone = EAvkonSIDConfirmationTone, 
         
        EWarningTone = EAvkonSIDWarningTone,      
         
        EErrorTone = EAvkonSIDErrorTone         
        };

    public:
          static CAknQueryDialog* NewL(const TTone& aTone = ENoTone);
          static CAknQueryDialog* NewL(TDes& aText, const TTone& aTone = ENoTone);
          static CAknQueryDialog* NewL(TInt& aNumber, const TTone& aTone = ENoTone);
          static CAknQueryDialog* NewL(TTime& aTime, const TTone& aTone = ENoTone);
          static CAknQueryDialog* NewL(TTimeIntervalSeconds& aTime, const TTone& aTone = ENoTone);
          static CAknQueryDialog* NewL(TReal& aNumber, const TTone& aTone = ENoTone);
          static CAknQueryDialog* NewL(TInetAddr& aInetAddr, const TTone& aTone = ENoTone);

    public:
          virtual ~CAknQueryDialog();

         




          CAknQueryDialog(const TTone& aTone);

    public:

         



          virtual CAknPopupHeadingPane* QueryHeading() const;

         




          CAknPopupHeadingPane* Heading() const;

         




          void SetPromptL(const TDesC& aPrompt);

         



          void MakeLeftSoftkeyVisible(TBool aVisible);

         








           void SetEmergencyCallSupport( TBool aOnOff );

         




           void RemoveEditorIndicator();

          









           void SetPredictiveTextInputPermitted( TBool aPermitted );

          TInt RunLD();

          TInt ExecuteLD(TInt aResourceId);

          TInt ExecuteLD(TInt aResourceId, const TDesC& aPrompt);



    public: 
         







          TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);
    
    public:
         









      static TInt MaxTextLength(const CAknQueryControl* aControl, const TDes& aDataText, TInt aApiValue) ;

    protected: 
         





          void SetSizeAndPosition(const TSize& aSize);

         




          void PreLayoutDynInitL(void);

         




          void PostLayoutDynInitL();

         







          virtual TBool OkToExitL(TInt aButtonId);

    public: 
         






          TBool HandleQueryEditorSizeEventL(CAknQueryControl* aQueryControl, TQueryControlEvent aEventType);

         







          TBool HandleQueryEditorStateEventL(CAknQueryControl* aQueryControl, TQueryControlEvent aEventType, TQueryValidationStatus aStatus);

         



          virtual TBool NeedToDismissQueryL(const TKeyEvent& aKeyEvent);
        
         





          virtual void DismissQueryL();

    protected:
         



          virtual void  UpdateLeftSoftKeyL();

         



          virtual void DoSetPromptL();

         



          virtual CAknQueryControl* QueryControl() const;

    protected:  
         


        void  PlayTone();
         


        void  ReportUserActivity() const ;
         


        void  LayoutAndDraw();
         



        TInt  GetLeftCBAShortKeyPress();
         



        TInt  GetRightCBAShortKeyPress();
         



        TBool IsLeftSoftkeyVisible(); 

    protected:
         


          TPtrC Prompt() const; 

        TTone& Tone() { return iTone; }
        const TTone& Tone() const { return iTone; }

        TBitFlags16& Flags() { return iFlags; }
        const TBitFlags16& Flags() const { return iFlags; }

        CAknKeySoundSystem* SoundSystem() const { return iSoundSystem; }
    protected:  
        CCoeControl* CAknQueryDialog::FindControlOnAnyPageWithControlType(TInt aControlType, TInt* aLineIndex=0, TInt* aPageIndex=0) const;

    protected:
         




         
        TTone  iTone;
         
        TDesC *iPrompt;  
         
        TAny* iSpare_2;
         
        TBitFlags16 iFlags;      
         
        TInt iSpare_1;          
         
        CAknKeySoundSystem* iSoundSystem;

    public:
         


          CAknQueryDialog();
          CAknQueryDialog(TDesC& aPrompt,const TTone& aTone = ENoTone);

         


          void SetHeaderTextL(const TDesC& aHeader);

         


          void SetHeaderImageL(CEikImage* aImage);

         


          TInt RunDlgLD(TInt aResourceId);

         


          static TInt MaxTextLength(const CAknQueryControl* aControl, const TDes* aDataText, TInt aApiValue);
    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private: 
          virtual void CAknQueryDialog_Reserved();
    };

 
 
 

 


 


class CAknTextQueryDialog : public CAknQueryDialog
    {
    public: 

          static CAknTextQueryDialog* NewL(TDes& aDataText, const TTone& aTone = ENoTone);

    public:

          CAknTextQueryDialog(TDes& aDataText, const TTone& aTone = ENoTone);
    
         


          virtual ~CAknTextQueryDialog();

    public: 
         




          void SetMaxLength(TInt aLength);

         




           virtual TBool CheckIfEntryTextOk() const;

         










          void SetDefaultInputMode(TInt aInputMode);

    protected: 
         




          void PreLayoutDynInitL();

         







          virtual TBool OkToExitL(TInt aButtonId);
               
    public: 
         






          TBool HandleQueryEditorSizeEventL(CAknQueryControl* aQueryControl, TQueryControlEvent aEventType);
    
    protected:
         



        void SetControlTextL();

        inline TDes& Text() { return iDataText; }
        inline const TDesC& Text() const { return iDataText; }

    protected: 
         




         
        TInt  iTextMaxLength; 
         
        TDes& iDataText;
         
        TBool iEditorTextOk; 
    
    public:
         


          CAknTextQueryDialog(TDes& aDataText, TDesC& aPrompt,const TTone& aTone = ENoTone);
    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    };

 
 
 

 


class CAknNumberQueryDialog : public CAknQueryDialog
    {
    public:     
          static CAknNumberQueryDialog* NewL(TInt& aNumber, const TTone& aTone = ENoTone);

    public:
         


          CAknNumberQueryDialog(TInt& aNumber, const TTone& aTone = ENoTone);
        
         


          virtual ~CAknNumberQueryDialog();
    
    public:
         





          void SetMinimumAndMaximum(TInt aMinimumValue, TInt aMaximumValue);  

    protected: 
         




          void PreLayoutDynInitL();

         







          virtual TBool OkToExitL(TInt aButtonId);
    
        inline TInt& Number() { return iNumber; }
        inline const TInt& Number() const { return iNumber; }

    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    protected:
         


         TInt& iNumber;
    };

 
 
 

 


class CAknTimeQueryDialog : public CAknQueryDialog
    {
    public:
          static CAknTimeQueryDialog* NewL(TTime& aTime, const TTone& aTone = ENoTone);

    public:
         


          CAknTimeQueryDialog(TTime& aTime, const TTone& aTone = ENoTone);
       
         


          virtual ~CAknTimeQueryDialog();

    public: 
         





          void SetMinimumAndMaximum(const TTime& aMinimum, const TTime& aMaximum);  
    
    protected: 
         




          void PreLayoutDynInitL();

         







          virtual TBool OkToExitL(TInt aButtonId);
    
        inline TTime& Time() { return iTime; }
        inline const TTime& Time() const { return iTime; }

    protected:
         


        TTime& iTime;

    public:
         


          CAknTimeQueryDialog(TTime& aTime,TDesC& aPrompt,const TTone& aTone = ENoTone);
    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    };

 
 
 

 


class CAknDurationQueryDialog : public CAknQueryDialog
    {
    public:
          static CAknDurationQueryDialog* NewL(TTimeIntervalSeconds& aTime, const TTone& aTone = ENoTone);

    public:
         


          CAknDurationQueryDialog(TTimeIntervalSeconds& aDuration, const TTone& aTone = ENoTone);

         


          virtual ~CAknDurationQueryDialog();

    public: 
         





          void SetMinimumAndMaximum(const TTimeIntervalSeconds& aMinimumDuration, const TTimeIntervalSeconds& aMaximumDuration);  

    protected: 
         




          void PreLayoutDynInitL();

         







          virtual TBool OkToExitL(TInt aButtonId);

        inline TTimeIntervalSeconds& Duration() { return iDuration; }
        inline const TTimeIntervalSeconds& Duration() const { return iDuration; }
    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    protected:
         


         TTimeIntervalSeconds& iDuration;
    };

 
 
 

 


class CAknFloatingPointQueryDialog : public CAknQueryDialog
    {
    public:

          static CAknFloatingPointQueryDialog* NewL(TReal& aNumber, const TTone& aTone = ENoTone);

    public:

         


          CAknFloatingPointQueryDialog(TReal& aNumber, const TTone& aTone = ENoTone);

         


          virtual ~CAknFloatingPointQueryDialog();

    public: 
         





          void SetMinimumAndMaximum(const TReal& aMinimumNumber, const TReal& aMaximumNumber);  

    protected: 
         




          void PreLayoutDynInitL();

         







          virtual TBool OkToExitL(TInt aButtonId);

        inline TReal& Number() { return iNumber; }
        inline const TReal& Number() const { return iNumber; }
    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    protected:
         


        TReal& iNumber;
    };


 
 
 

 








class CAknMultiLineDataQueryDialog : public CAknQueryDialog
    {
    public:
          static CAknMultiLineDataQueryDialog* NewL(TTime& aTime1, TTime& aTime2, TTone aTone = ENoTone);
          static CAknMultiLineDataQueryDialog* NewL(TDes&  aText1, TDes&  aText2, TTone aTone = ENoTone);
          static CAknMultiLineDataQueryDialog* NewL(TDes&  aText1, TTime& aTime2, TTone aTone = ENoTone);
          static CAknMultiLineDataQueryDialog* NewL(TDes&  aText1, TInt&  aNum2,  TTone aTone = ENoTone);
          static CAknMultiLineDataQueryDialog* NewL(TDes& aText1,  TTimeIntervalSeconds& aDur2, TTone aTone = ENoTone);
          static CAknMultiLineDataQueryDialog* NewL(TTime& aTime1, TTimeIntervalSeconds& aDur2, TTone aTone = ENoTone);
          static CAknMultiLineDataQueryDialog* NewL(TInt&  aNum1,  TInt&  aNum2, TTone aTone = ENoTone);

          virtual ~CAknMultiLineDataQueryDialog();

    protected:
         




        template <class T1, class T2> void SetDataL(T1& aData1, T2& aData2)
            {
            iFirstData  = new (ELeave) TAknQueryData<T1>(aData1);
            iSecondData = new (ELeave) TAknQueryData<T2>(aData2);
            }

         




        template <class T1, class T2> static CAknMultiLineDataQueryDialog* 
            DoNewL(T1& aData1, T2& aData2, const TTone& aTone)
            {
                CAknMultiLineDataQueryDialog* self = new (ELeave) CAknMultiLineDataQueryDialog(aTone);
                CleanupStack::PushL(self);

                self->SetDataL(aData1,aData2);
    
                CleanupStack::Pop(self);
                return self;
            }
    
    protected:
         




          CAknMultiLineDataQueryDialog(const TTone& aTone);

    public:

         





          void SetPromptL(const TDesC& aFirstPrompt, const TDesC& aSecondPrompt);
        
    public: 

         



          void SetMaxLengthOfFirstEditor(TInt aFirstTextEditorMaxLength);

         



          void SetMaxLengthOfSecondEditor(TInt aSecondTextEditorMaxLength);

    protected: 
         







          virtual TBool OkToExitL(TInt aButtonId);

         







          void PreLayoutDynInitL();
    
    protected:
         



          void UpdateLeftSoftKeyL();

         



          void DoSetPromptL();

    protected:
         






          TBool NeedToDismissQueryL(const TKeyEvent& aKeyEvent);

    protected:
         


          CAknMultilineQueryControl* FirstControl() const;
          CAknMultilineQueryControl* SecondControl() const;
          CAknQueryControl* QueryControl() const;
          CAknPopupHeadingPane* QueryHeading() const;

    protected:
         













        template<class T>
            T& FirstData(const T&) { return (static_cast< TAknQueryData<T>* >( iFirstData )) ->iData; }

        template<class T>
            T& SecondData(const T&){ return (static_cast< TAknQueryData<T>* >( iSecondData )) ->iData; }

        template<class T>
            const T& FirstData(const T&) const { return (static_cast< TAknQueryData<T>* >( iFirstData )) ->iData; }

        template<class T>
            const T& SecondData(const T&) const { return (static_cast< TAknQueryData<T>* >( iSecondData )) ->iData; }

         


          TPtrC SecondPrompt() const; 

    private:
        TDesC* iSecondPrompt;

        MAknQueryData* iFirstData;
        MAknQueryData* iSecondData;

        TInt iFirstEditorMaxLength;
        TInt iSecondEditorMaxLength;

    public:
         


    
          CAknMultiLineDataQueryDialog(TTime* aTime, TTime* aTime2,TDesC* aPrompt= 0L ,TDesC* aPrompt2= 0L , const TTone& aTone = ENoTone);
          CAknMultiLineDataQueryDialog(TDes* aDataText, TDes* aDataText2,TDesC* aPrompt= 0L ,TDesC* aPrompt2= 0L ,const TTone& aTone = ENoTone);
          CAknMultiLineDataQueryDialog(TDes* aDataText, TTime* aTime,TDesC* aPrompt= 0L ,TDesC* aPrompt2= 0L ,const TTone& aTone = ENoTone);
          CAknMultiLineDataQueryDialog(TDes* aDataText, TInt* aNumber,TDesC* aPrompt= 0L ,TDesC* aPrompt2= 0L ,const TTone& aTone = ENoTone);
          CAknMultiLineDataQueryDialog(TDes* aDataText, TTimeIntervalSeconds* aDuration,TDesC* aPrompt= 0L ,TDesC* aPrompt2= 0L ,const TTone& aTone = ENoTone);
          CAknMultiLineDataQueryDialog(TTime* aTime, TTimeIntervalSeconds* aDuration,TDesC* aPrompt= 0L ,TDesC* aPrompt2= 0L ,const TTone& aTone = ENoTone);
          CAknMultiLineDataQueryDialog(TInt* aNumber, TInt* aNumber2,TDesC* aPrompt= 0L ,TDesC* aPrompt2= 0L ,const TTone& aTone = ENoTone);
    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    protected:
         


        TDes16* iText;        
        TDes16* iSecondText;  
    };

 
 
 
 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlistquerydialog.h" 1
 






















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 1
 




















# 1313 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h"

# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknlistquerydialog.h" 2


class CAknMessageQueryControl;

 



class CAknListQueryDialog : public CAknQueryDialog,public MEikListBoxObserver, public MAknIntermediateState
	{
    public:
         




	      CAknListQueryDialog(TInt* aIndex);

         




          CAknListQueryDialog(CListBoxView::CSelectionIndexArray* aSelectionIndexArray);

         


	      virtual ~CAknListQueryDialog();

         





          void SetSizeAndPosition(const TSize &aSize);

         







	      TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);
	    
	     




          void HandleListBoxEventL(CEikListBox* aListBox, TListBoxEvent aEventType);

         



	      void SetItemTextArray(MDesC16Array * aItemTextArray);

         



	      void SetOwnershipType(TListBoxModelItemArrayOwnership aOwnershipType);

         





	      void SetIconArrayL(CArrayPtr<CGulIcon>* aIcons);

         



	      CEikListBox *ListBox() const;

		 


		  CAknListQueryControl* ListControl() const;

		 


		  CAknMessageQueryControl* MessageBox() const;

		 



		  CAknPopupHeadingPane* QueryHeading() const;

         


	      void ActivateL();

    protected:
         




	      void PreLayoutDynInitL(void);

         




          void PostLayoutDynInitL();

         







          TBool OkToExitL(TInt aButtonId);

         



	      TInt BorderStyle();

    protected:
         



	      void CloseState();

    private:
         



	    static TInt ClosePopup(TAny *aObj);

	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknDialog_Reserved();
	private:
		  virtual void CAknQueryDialog_Reserved();
    private:
         
        TInt *iIndex;
         
        CListBoxView::CSelectionIndexArray *iSelectionIndexArray;
         
	    TBool iEnterKeyPressed;
         
	    CIdle *iIdle;
         
	    TAknPopupWindowLayoutDef iLayout;

    protected:
         



		  CAknSearchField *FindBox() const;
        
    public:
	      void SetTone(TInt aTone); 
	};


# 969 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknquerydialog.h" 2



 
 
 


 





class CAknIpAddressQueryDialog : public CAknQueryDialog
    {
    public:     
          static CAknIpAddressQueryDialog* NewL(TInetAddr& aInetAddr, const TTone& aTone = ENoTone);


    private:
        CAknIpAddressQueryDialog(TInetAddr& aInetAddr, const TTone& aTone = ENoTone);
    public:        
         


          virtual ~CAknIpAddressQueryDialog();
    
    public:  
         





          void SetMinimumAndMaximum(const TInetAddr& aMinimumAddress, const TInetAddr& aMaximumAddress);  

          virtual TBool NeedToDismissQueryL(const TKeyEvent& aKeyEvent);


    protected:
          virtual CAknQueryControl* QueryControl() const;
    
    protected: 

         





          void SetSizeAndPosition(const TSize& aSize);

         




          void PreLayoutDynInitL();

         








          void PostLayoutDynInitL();

          virtual void DoSetPromptL();
        
          virtual TBool OkToExitL(TInt aButtonId);

          void UpdateLeftSoftKeyL();
    
        inline TInetAddr& InetAddr() { return iInetAddr; }
        inline const TInetAddr& InetAddr() const { return iInetAddr; }

    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    protected:

         TInetAddr& iInetAddr;
    };


 
 
 


 





class CAknFixedPointQueryDialog : public CAknQueryDialog
    {
    public:     
          static CAknFixedPointQueryDialog* NewL(TInt& aNumber, const TTone& aTone);


    private:
        CAknFixedPointQueryDialog(TInt& aNumber, const TTone& aTone = ENoTone);
    public:
        
         


          virtual ~CAknFixedPointQueryDialog();
    
    public:  
         





          void SetMinimumAndMaximum(TInt aMinimumValue, TInt aMaximumValue);  

          virtual TBool NeedToDismissQueryL(const TKeyEvent& aKeyEvent);


    protected:

         






          virtual CAknQueryControl* QueryControl() const;
    
    protected: 

         





          void SetSizeAndPosition(const TSize& aSize);

         




          void PreLayoutDynInitL();

         








          void PostLayoutDynInitL();

          virtual void DoSetPromptL();
        
          virtual TBool OkToExitL(TInt aButtonId);

          void UpdateLeftSoftKeyL();
    
        inline TInt& Number() { return iNumber; }
        inline const TInt& Number() const { return iNumber; }

    private: 
          virtual void CEikDialog_Reserved_1();
          virtual void CEikDialog_Reserved_2();  
    private: 
          virtual void CAknDialog_Reserved();
    private:
          virtual void CAknQueryDialog_Reserved();
    private:
         TInt& iNumber;
    };


 
 
 

 










class CAknMultiLineIpQueryDialog : public CAknMultiLineDataQueryDialog
    {
    public:

          static CAknMultiLineIpQueryDialog* NewL(TInetAddr&  aAddress1,  TInetAddr&  aAddress2, TTone aTone = ENoTone);

          virtual ~CAknMultiLineIpQueryDialog();

    protected:
         




        template <class T1, class T2> void SetDataL(T1& aData1, T2& aData2)
            {
            iFirstData  = new (ELeave) TAknQueryData<T1>(aData1);
            iSecondData = new (ELeave) TAknQueryData<T2>(aData2);
            }

         




        template <class T1, class T2> static CAknMultiLineIpQueryDialog* 
            DoNewL(T1& aData1, T2& aData2, const TTone& aTone)
            {
                CAknMultiLineIpQueryDialog* self = new (ELeave) CAknMultiLineIpQueryDialog(aTone);
                CleanupStack::PushL(self);

                self->SetDataL(aData1,aData2);
    
                CleanupStack::Pop(self);
                return self;
            }
    
    private:
        CAknMultiLineIpQueryDialog(const TTone& aTone);

    public:

         





          void SetPromptL(const TDesC& aFirstPrompt, const TDesC& aSecondPrompt);
        
    public: 

         



          void SetMaxLengthOfFirstEditor(TInt aFirstTextEditorMaxLength);

         



          void SetMaxLengthOfSecondEditor(TInt aSecondTextEditorMaxLength);

    protected: 
         







          virtual TBool OkToExitL(TInt aButtonId);

         







          void PreLayoutDynInitL();
    
    protected:
         



          void UpdateLeftSoftKeyL();

         



          void DoSetPromptL();

    protected:
         






          TBool NeedToDismissQueryL(const TKeyEvent& aKeyEvent);

    protected:
         


          CAknExtMultilineQueryControl* FirstControl() const;
          CAknExtMultilineQueryControl* SecondControl() const;
          CAknQueryControl* QueryControl() const;

    protected:

         


          TPtrC SecondPrompt() const; 

    private:
        TDesC* iSecondPrompt;

        MAknQueryData* iFirstData;
        MAknQueryData* iSecondData;

        TInt iFirstEditorMaxLength;
        TInt iSecondEditorMaxLength;

    private:
        TDes16* iText;       
        TDes16* iSecondText; 
    };



# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknmessagequerydialog.h" 2

class CEikImage;

 


class CAknMessageQueryDialog : public CAknQueryDialog
	{
public:
	  static CAknMessageQueryDialog* NewL(TDesC& aMessage, const TTone& aTone = ENoTone);

	 


	  ~CAknMessageQueryDialog();

	 



      CAknMessageQueryDialog(const TTone aTone);

public:
	 



	  void SetMessageTextL(const TDesC& aMessage);

	 





	  void SetHeaderTextL(const TDesC& aHeader);  

     






      void SetHeaderImage(CEikImage* aImage);     

     






      void SetHeaderAnimation( TInt aResourceId );

public:  
   	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode);

protected:  
	  virtual void PreLayoutDynInitL();
	  virtual void SetSizeAndPosition(const TSize& aSize);
	  virtual void PostLayoutDynInitL();

private: 
	  virtual void CEikDialog_Reserved_1();
	  virtual void CEikDialog_Reserved_2();	
private: 
	  virtual void CAknDialog_Reserved();
private:
	  virtual void CAknQueryDialog_Reserved();
private:
    TDesC* iMessage;
    TDesC* iHeader;
    CEikImage* iHeaderImage;
    TInt iAnimationId;

public:
	 



     
	  CAknMessageQueryDialog(TDesC* aMessage, TDesC* aHeader); 
     
      CAknMessageQueryDialog(TDesC* aMessage, TDesC* aHeader, CEikImage *aHeaderImage); 
     
      CAknMessageQueryDialog(TDesC* aMessage, TDesC* aHeader, const TTone aTone); 
     
      CAknMessageQueryDialog(TDesC* aMessage, TDesC* aHeader, CEikImage *aHeaderImage, const TTone aTone); 
     
      void SetMessageText(TDesC* aMessage); 
     
	  void SetMessageText(const TDesC& aMessage);
     
      void SetHeaderText(TDesC* aHeader);  
     
	  void SetHeaderText(const TDesC& aHeader);  

	 
      CAknMessageQueryDialog();
	};




 
# 47 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnotewrappers.h" 1
 

























# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnotedialog.h" 1
 

























class CEikImage;
class CAknKeySoundSystem;
class CAknNoteControl;
class CAknNoteAttributes;

 







class CAknNoteDialog : public CEikDialog
{
public:
	 



  enum TTimeout {
	 
	EUndefinedTimeout = 0,   
	 
    ENoTimeout = 0,         
	 
    EShortTimeout = 1500000,
	 
    ELongTimeout = 3000000   
    };

    




  enum TTone {
	 
    ENoTone = 0,		
	 
    EConfirmationTone = EAvkonSIDConfirmationTone, 
	 
    EWarningTone = EAvkonSIDWarningTone,      
	 
    EErrorTone = EAvkonSIDErrorTone         
    };

public:
   






	  CAknNoteDialog();
    









	  CAknNoteDialog(const TTone& aTone, const TTimeout& aTimeout = ENoTimeout);
    
















	  CAknNoteDialog(CEikDialog** aSelfPtr, const TTone& aTone = ENoTone, const TTimeout& aTimeout = ENoTimeout);
    







	  virtual ~CAknNoteDialog();
    






	  void SetTimeout(const TTimeout& aTimeout);
    






	  void SetTone(const TTone& aTone);
    














	  void SetTextWrapping(TBool aEnabled);
    














	  void SetTextProcessing(TBool aEnabled);
    









	  void SetImageL(CEikImage* aImage);
    











	  void SetIconL(CEikImage* aIcon);
    
















	  void SetTextNumberL(TInt aNumber);
    










	  void SetTextPluralityL(const TBool isPlural);
    













	  void SetTextL(const TDesC& aLabel);
	
    











	  TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent,TEventCode aType) ;

	 





	  void HandleResourceChange(TInt aType);

    












	  void LayoutAndDraw();
    






      virtual TInt RunLD();
	
protected:
   













	  void SetSizeAndPosition(const TSize& aSize);
    














	  void PreLayoutDynInitL(void);
    











	  void PostLayoutDynInitL();
    










	  void PlayTone();
    











	  void ReportUserActivity() const;
    












      static TInt StaticDeleteL(TAny* aThis);
    









	  CAknNoteAttributes* ControlAttributes();
    






	  void TransferControlAttributes();
    







	  CAknKeySoundSystem* SoundSystem() const;
    











      CAknNoteControl* NoteControl();

private:
    void DbgCheckSelfPtr(CEikDialog** aSelfPtr);

protected:
    CPeriodic*          iTimer;			 
    TInt                iTimeoutInMicroseconds;  
	
    CEikDialog**        iSelfPtr;  
								   
    TTone               iTone;	   
    CAknNoteAttributes* iControlAttributes;   
private:
	TInt iSpare;

public:
	 


	  TInt ExecuteDlgLD(const TTimeout aTimeout,const TTone aTone,TInt aResourceID);
	  TInt ExecuteDlgLD(const TTone aTone,TInt aResourceID);
	  TInt ExecuteDlgLD(TInt aResourceId, TInt aNoteControlId=0);
	  TInt RunDlgLD(const TTimeout aTimeout,const TTone aTone);
	  TInt RunDlgLD(const TTone aTone);
	  TInt RunDlgLD();
	  TInt RunDlgLD(TInt aNoteControlId);
	  void SetCurrentLabelL(TInt aControlId,const TDesC& aLabel);
	private: 
	  virtual void CEikDialog_Reserved_1();
	  virtual void CEikDialog_Reserved_2();	
	private:  
	  virtual void CAknNoteDialog_Reserved();
protected:
	 


	  static TInt StaticDelete(TAny* aThis);

	 
	  void SetNoMemoryAllocation();


private:  

	  void SizeChanged();

	void SetSkinBackGroundRect(); 
	};



# 27 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknnotewrappers.h" 2




class TResourceReader;


class TAknNoteResData
	{
public:
    void ReadFromResource(TResourceReader& aResReader);
public:
	TInt iResId;
    CAknNoteDialog::TTimeout iTimeout;
    CAknNoteDialog::TTone iTone;
    TBuf<256> iText;
	};

 


class CAknNoteWrapper : public CAknNoteDialog
    {
    public:
	    




          CAknNoteWrapper();
	    







          CAknNoteWrapper(CAknNoteWrapper** aSelfPtr);
        










		  TInt ExecuteLD(TInt aResId);
        











		  TInt ExecuteLD(TInt aResId, const TDesC& aPrompt);
	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknNoteDialog_Reserved();
	private:
		TAknNoteResData ReadResDataAndPrepareL(TInt aResId);
    };

 




class CAknResourceNoteDialog : public CAknNoteWrapper
    {
    public:
	    








		  TInt ExecuteLD();
	    








		  TInt ExecuteLD(const TDesC& aPrompt);

    protected:
		 






        inline CAknResourceNoteDialog(TInt aResId)
            : iResId(aResId)
            {
            }
		
		 










        inline CAknResourceNoteDialog(TInt aResId, CAknNoteWrapper** aSelfPtr)
            : CAknNoteWrapper(aSelfPtr), iResId(aResId)
            {
            }
	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknNoteDialog_Reserved();
	private:  
		  virtual void CAknResourceNoteDialog_Reserved();
    private:
        TInt iResId;
		TInt iSpare;
    };

 



class CAknConfirmationNote : public CAknResourceNoteDialog
    {
    public:
	    





          CAknConfirmationNote();
	    









          CAknConfirmationNote( TBool aWaitingDialog );
	    








          CAknConfirmationNote(CAknConfirmationNote** aSelfPtr);
	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknNoteDialog_Reserved();
	private: 
		  virtual void CAknResourceNoteDialog_Reserved();
    };

 



class CAknInformationNote : public CAknResourceNoteDialog
    {
    public:
	    





          CAknInformationNote();
	    









		  CAknInformationNote( TBool aWaitingDialog );
	    








		  CAknInformationNote(CAknInformationNote** aSelfPtr);
	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknNoteDialog_Reserved();
	private: 
		  virtual void CAknResourceNoteDialog_Reserved();
    };

 



class CAknErrorNote : public CAknResourceNoteDialog
    {
    public:
        





		  CAknErrorNote();
	    









		  CAknErrorNote( TBool aWaitingDialog );
	    







     
		  CAknErrorNote(CAknErrorNote** aSelfPtr);
	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknNoteDialog_Reserved();
	private: 
		  virtual void CAknResourceNoteDialog_Reserved();
    };

 



class CAknWarningNote : public CAknResourceNoteDialog
    {
    public:
	    





          CAknWarningNote();
        









		  CAknWarningNote( TBool aWaitingDialog );
	    







     
		  CAknWarningNote(CAknWarningNote** aSelfPtr);
	private: 
		  virtual void CEikDialog_Reserved_1();
		  virtual void CEikDialog_Reserved_2();	
	private: 
		  virtual void CAknNoteDialog_Reserved();
	private: 
		  virtual void CAknResourceNoteDialog_Reserved();
    };


            
# 48 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/stringloader.h" 1
 






















 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h" 1
 
 
 
 

# 627 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coemain.h"

# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/stringloader.h" 2



 

 








































































































class StringLoader 
    {
    public:
        
         













          static void Load( TDes& aDest, TInt aResourceId, 
                                   CCoeEnv* aLoaderEnv = 0L  );

         














          static void Format( TDes& aDest, const TDesC& aSource, 
                                   TInt aPosition, TInt aSubs );

         














          static void Format( TDes& aDest, const TDesC& aSource, 
                                   TInt aPosition, const TDesC& aSubs );

         











          static HBufC* LoadL( TInt aResourceId, 
                                      CCoeEnv* aLoaderEnv = 0L  );

         














          static HBufC* LoadL( TInt aResourceId, TInt aInt, 
                                      CCoeEnv* aLoaderEnv = 0L );

         














          static HBufC* LoadL( TInt aResourceId, 
                                    const TDesC& aString, 
                                    CCoeEnv* aLoaderEnv = 0L  );

         

















          static HBufC* LoadL( TInt aResourceId, const TDesC& aString, 
                                    TInt aInt, CCoeEnv* aLoaderEnv = 0L  );

         















          static HBufC* LoadL( TInt aResourceId,
                                    const CArrayFix<TInt>& aInts,
                                    CCoeEnv* aLoaderEnv = 0L );

         















          static HBufC* LoadL( TInt aResourceId,
                                    const MDesC16Array & aStrings,
                                    CCoeEnv* aLoaderEnv = 0L );

         


















          static HBufC* LoadL( TInt aResourceId,
                                    const MDesC16Array & aStrings, 
                                    const CArrayFix<TInt>& aInts,
                                    CCoeEnv* aLoaderEnv = 0L );
         












          static HBufC* LoadLC( TInt aResourceId,
                                        CCoeEnv* aLoaderEnv = 0L );

         














          static HBufC* LoadLC( TInt aResourceId, TInt aInt,
                                        CCoeEnv* aLoaderEnv = 0L );

         














          static HBufC* LoadLC( TInt aResourceId, 
                                    const TDesC& aString,
                                    CCoeEnv* aLoaderEnv = 0L );

         

















          static HBufC* LoadLC( TInt aResourceId, const TDesC& aString, 
                                    TInt aInt, CCoeEnv* aLoaderEnv = 0L  );

         
















          static HBufC* LoadLC( TInt aResourceId,
                                    const CArrayFix<TInt>& aInts,
                                    CCoeEnv* aLoaderEnv = 0L );

         
















          static HBufC* LoadLC( TInt aResourceId,
                                    const MDesC16Array & aStrings,
                                    CCoeEnv* aLoaderEnv = 0L );

         


















          static HBufC* LoadLC( TInt aResourceId,
                                    const MDesC16Array & aStrings, 
                                    const CArrayFix<TInt>& aInts,
                                    CCoeEnv* aLoaderEnv = 0L );

    private:

         


        StringLoader();
        
         
        StringLoader( const StringLoader& );
         
        StringLoader& operator= ( const StringLoader& );

         









        static HBufC* FormatStringL(
            const TDesC& aSource,
            const TDesC& aKey,
            const TDesC& aSubs );

         















        static HBufC* FormatStringL( 
            const TDesC& aSource,
            const TDesC& aKey, 
            const TDesC& aSubs,
            TBidiText::TDirectionality aDirectionality,
            TInt& aParamCount,
            TInt aSubCount);

         








        static HBufC* FormatStringL( TDesC& aSource, 
                                   const CArrayFix<TInt>& aInts, 
                                   TInt aMax );

         











        static HBufC* FormatStringL( TDesC& aSource, 
                                   const MDesC16Array & aStrings, 
                                   TInt aMax);
         












        static TInt Formater( 
            TDes& aDest, 
            const TDesC& aSource,  
            const TDesC& aKey,
            const TDesC& aSubs,
            TBidiText::TDirectionality aDirectionality);

         








        static void KeyStringFormater( TDes& aDest, const TText& aKey, 
                                        TInt aPosition, const TDesC& aKeyString );

         






        static void ConvertNumberStringToArabic(TDes& intbuf);

         



        static TBidiText::TDirectionality ResolveDirectionality( TDes& aText );

         







        static TInt GetParamCount( const TDesC& aText, TInt aIndex = -1);

         








        static TInt GetSubStringCount( const TDesC& aText );
    };


            
 
# 49 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/hlplch.h" 1
 
 
 
 
 









# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdll.h" 1
 
 
 
 












class EikDll
	{
public:  
	  static void StartDocL(const TDesC& aDocName);
	  static TThreadId StartExeL(const TDesC& aName);
	  static TThreadId StartAppL(const CApaCommandLine& aCommandLine);
public:
	  static void RunAppInsideThread(CApaCommandLine* aCommandLine);
	};


# 15 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/hlplch.h" 2











 



const TUid KHlpAppUid={ 0x10005234 };

 



const TUid KHlpAppWsMsg={ 0x100055c7 };

 



const TInt KMaxCmdLineLength = 512;

static const TLitC<sizeof(L"z:\\System\\Apps\\CsHelp\\CsHelp.app" )/2>  KHlpAppPath ={sizeof(L"z:\\System\\Apps\\CsHelp\\CsHelp.app" )/2-1,L"z:\\System\\Apps\\CsHelp\\CsHelp.app" } ;

class CHlpCmdLine : public CBase
 



	{
public:
	static CHlpCmdLine* NewL(CArrayFix<TCoeHelpContext>* aContextList);
	static CHlpCmdLine* NewLC(CArrayFix<TCoeHelpContext>* aContextList);
	~CHlpCmdLine();
public:
	TPtr8 CmdLine();
private:
	void BuildCmdLineL();
	void AddContextL(TCoeHelpContext& aContext);
private:
	void ConstructL();
	CHlpCmdLine(CArrayFix<TCoeHelpContext>* aContextList);
private:
	CArrayFix<TCoeHelpContext>* iContextList;
	CBufFlat* iCmdLine;
	};

class HlpLauncher
 





	{
public:
	 	static void LaunchHelpApplicationL(RWsSession& aWsSession, CArrayFix<TCoeHelpContext>* aContextList);
	 	static void LaunchHelpApplicationL(RWsSession& aWsSession, TUid aUid);
	 	static void LaunchHelpApplicationL(RWsSession& aWsSession);
private:
	static void DoLaunchHelpApplicationL(RWsSession& aWsSession, const TDesC8& aCmdLine);
	};


# 50 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/caknfileselectiondialog.h" 1
 






















 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/cakncommondialogsbase.h" 1
 






















 

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coneresloader.h" 1
 
























 
class CCoeEnv;

 






























class RConeResourceLoader
    {
    public:
         



          RConeResourceLoader(CCoeEnv& aEnv);

         







          TInt Open(TFileName& aFileName);

         






          void OpenL(TFileName& aFileName);


         





          void Close();

    private:
                
         
        RConeResourceLoader(const RConeResourceLoader&);
        RConeResourceLoader& operator= ( const RConeResourceLoader& );
    
         
        CCoeEnv& iEnv; 
        TInt iResourceFileOffset;
    };




 
# 26 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/cakncommondialogsbase.h" 2


 

 



enum TCommonDialogType
	{
	ECFDDialogTypeNormal,
	ECFDDialogTypeSelect,
	ECFDDialogTypeSave,
	ECFDDialogTypeMove,
	ECFDDialogTypeBrowse,
	ECFDDialogTypeDefaultSetting,
	ECFDDialogTypeCopy
	};

 


static const TLitC<sizeof(L"CommonDialogs"  )/2>   KCFDPanicText ={sizeof(L"CommonDialogs"  )/2-1,L"CommonDialogs"  } ;

 


enum TCFDPanics
	{
	ECFDPanicInvalidFilterType						=  1,
	ECFDPanicInvalidFilterStyle						=  2,
	ECFDPanicInvalidAttributeFilterDataLength		=  3,
	ECFDPanicInvalidAttributeFilterDataCount		=  4,
	ECFDPanicInvalidFileNameFilterDataLength		=  5,
	ECFDPanicInvalidFileNameFilterDataCount			=  6,
	ECFDPanicNoLocationStructures					=  7,
	ECFDPanicRootPathNotDefined						=  8,
	ECFDPanicNoPathForFileNamePromptDialog			=  9,
	ECFDPanicOutOfBounds							= 10,
	ECFDPanicNullParameter							= 11,
	ECFDPanicNoResourceDefined						= 12,
	ECFDPanicTitleOrSoftkeyNotSet					= 13
	};

 
class CCoeEnv;

 
 







class CAknCommonDialogsBase : public CBase
	{
	public:		 

		 






		enum TReturnKey
			{
			ERightSoftkey = EFalse,
			ELeftSoftkey,
			ESelectionKey
			};

	protected:	 

		CAknCommonDialogsBase();

		virtual ~CAknCommonDialogsBase();

		 


		void BaseConstructL();

	protected:	 

		 




		CCoeEnv* iCoeEnv;

	private:	 

		 
		RConeResourceLoader iResourceLoader;
	};



 
# 25 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/caknfileselectiondialog.h" 2


 
class CAknFileSelectionModel;
class CAknFileSelectionEventHandler;
class MAknFileSelectionObserver;
class MAknFileFilter;

 
 





class CAknFileSelectionDialog : public CAknCommonDialogsBase
	{
	public:		 
		 




		  static CAknFileSelectionDialog* NewL(
			TCommonDialogType aDialogType );

		 





		  static CAknFileSelectionDialog* NewL(
			TCommonDialogType aDialogType, TInt aResourceId );

		  ~CAknFileSelectionDialog();

	public:  
		
		 



		  void SetObserver( MAknFileSelectionObserver* aObserver );

		 




		  void AddFilterL( MAknFileFilter* aFilter );

		 





		  void SetDefaultFolderL( const TDesC& aDefaultFolder );

		 



		  void SetTitleL( const TDesC& aText );

		 



		  void SetLeftSoftkeyFileL( const TDesC& aText );

		 



		  void SetLeftSoftkeyFolderL( const TDesC& aText );

		 



		  void SetRightSoftkeyRootFolderL( const TDesC& aText );

		 



		  void SetRightSoftkeySubfolderL( const TDesC& aText );

		 







		  TBool ExecuteL( TDes& aFileName );

		 



		  static TBool RunDlgLD( TDes& aFileName,
			const TDesC& aDefaultFolder,
			MAknFileSelectionObserver* aObserver = 0L  );

		 



		  static TBool RunDlgLD( TDes& aFileName,
			const TDesC& aDefaultFolder,
			const TDesC& aTitle,
			MAknFileSelectionObserver* aObserver = 0L  );

		 



		  static TBool RunDlgLD( TDes& aFileName,
			const TDesC& aDefaultFolder,
			TInt aResourceId,
			MAknFileSelectionObserver* aObserver = 0L  );

	private:	 

		 


















		static TBool RunL(
			TInt aResourceId,
			TDes& aFileName,
			const TDesC& aDefaultFolder,
			const TDesC& aTitle,
			MAknFileSelectionObserver* aObserver );

		 







		TBool PrepareL( const TDesC& aFileName );

		 




		void SetResourceId( TInt& aResourceId, TCommonDialogType aType ) const;

		 



		void ReadFromResourceL( TInt aResourceId );

	private:	 

		CAknFileSelectionDialog( TCommonDialogType aDialogType );

		 



		void ConstructFromResourceL( TInt aResourceId );

	private:	 

		 
		TCommonDialogType iDialogType;

		 
		CAknFileSelectionModel* iModel;

		 
		CAknFileSelectionEventHandler* iEventHandler;

		 
		MAknFileSelectionObserver* iObserver;

		 
		HBufC* iTitle;

		 
		HBufC* iLeftSoftkeyFile;

		 
		HBufC* iLeftSoftkeyFolder;

		 
		HBufC* iRightSoftkeyRootFolder;

		 
		HBufC* iRightSoftkeySubfolder;

		 
		HBufC* iRootPath;

		 
		HBufC* iDefaultFolder;

		 
		TBool iExecuted;
	};



 
# 51 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/pathinfo.h" 1
 

























 


 
 

















class PathInfo
    {
    public:  

         



          static const TDesC& RomRootPath();
         



          static const TDesC& PhoneMemoryRootPath();
         



          static const TDesC& MemoryCardRootPath();


         



          static const TDesC& GamesPath();
         



          static const TDesC& InstallsPath();
         



          static const TDesC& OthersPath();
         



          static const TDesC& VideosPath();
         



          static const TDesC& ImagesPath();

        
         


          static const TDesC& PicturesPath();        

        
         



          static const TDesC& GmsPicturesPath();
         



          static const TDesC& MmsBackgroundImagesPath();
         



          static const TDesC& PresenceLogosPath();
         



          static const TDesC& SoundsPath();
         



          static const TDesC& DigitalSoundsPath();
         



          static const TDesC& SimpleSoundsPath();

         
         
         

         




          static const TDesC& ImagesThumbnailPath();

         





          static const TDesC& MemoryCardContactsPath();

    private:

         


        PathInfo();
    };


            
 
# 52 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2


# 1 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60.hrh" 1
 













 
enum Tayfly_s60Ids
	{
	ECommand1 = 0x6001,  
	ECommand2,
	ECommand3,
	EHelp,
	EAbout
	};


# 54 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60.pan" 1
 











 
enum Tayfly_s60Panics
	{
	Eayfly_s60Ui = 1
	 
	};

inline void Panic(Tayfly_s60Panics aReason)
	{
	static const TLitC<sizeof(L"ayfly_s60" )/2>  applicationName ={sizeof(L"ayfly_s60" )/2-1,L"ayfly_s60" } ;
	User::Panic(applicationName, aReason);
	}


# 55 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60Document.h" 1
 











 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/akndoc.h" 1
 





















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdoc.h" 1
 
 
 
 




# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/apparc.h" 1
 
 
 
 























 
class CApaApplication;
class CApaDocument;
class CApaProcess;
class MApaEmbeddedDocObserver;
 
 
class CApaDll;
class CApaExe;
class RReadStream;
class RWriteStream;
class CFileStore;
class CPersistentStore;
class CStreamDictionary;
class CDictionaryStore;
class CApaAppInfoFileReader;
class TApaAppHolderInfo;
class CImplementationInformation;
class TApaApplicationFactory;
class CApaAppHolder;

 








typedef CApaApplication* (*CreateCApaApplication)();

 

class TApaLastUsedEntry
 







	{
public:
	  TApaLastUsedEntry(TFileName aFileName, TUid aAppUid);
	  TApaLastUsedEntry();
	  void ExternalizeL(RWriteStream& aStream) const;
	  void InternalizeL(RReadStream& aStream);
public:
	TFileName iFileName;
	TUid iAppUid;
	};


 

class CApaRecentFile
 








	{
public:
	  static void AddLastUsedEntryL(RFs& aFs, const TDesC& aFileName, TUid aAppUid);
	  static TApaLastUsedEntry GetRecentFileL(RFs& aFs, TUid aAppUid, TInt aIndex);
	  static CArrayFixFlat<TApaLastUsedEntry>* GetRecentFileListL(RFs& aFs, TUid aAppUid);
	};

 

class CApaApplication : public CBase
 
 












	{
public:
	 









	virtual void PreDocConstructL()=0;  
	
	 









	virtual CApaDocument* CreateDocumentL(CApaProcess* aProcess)=0;
	
	 






	virtual TUid AppDllUid()const=0;
	 
	 
	  static TInt GenerateFileName(RFs& aFs,TFileName& aRootName);
	  CDictionaryStore* OpenIniFileL(RFs& aFs)const;
	  CApaAppInfoFileReader* OpenAppInfoFileL()const;
	 










	virtual CDictionaryStore* OpenIniFileLC(RFs& aFs)const=0;
	 







	virtual CApaAppInfoFileReader* OpenAppInfoFileLC()const=0;
	 
	 
	  virtual TFileName AppFullName()const;  
	 













	virtual void Capability(TDes8& aInfo)const=0;
	 
	 
	  TFileName DllName()const;
	
	  ~CApaApplication();

private:
	 
	  virtual void Reserved_1();
private:
	CApaAppHolder* iAppHolder;   
	TUid iDtorKey;	 
	friend class CApaAppHolder;
	friend class CApaProcess;
	friend class TApaApplicationFactory;  
	};

class CApaDocument : public CBase
 
 










	{
public:
	class TCapability
	 
		{
	public:
		  TCapability();
		 
		inline TBool CanDrawGlass()const;
		inline TBool CanPrint()const;
		inline void SetCanDrawGlass();
		inline void SetCanPrint();
		 
	private:
		enum {
			ECanDrawGlass	=0x01,
			ECanPrint		=0x02
			};
	private:
		TUint iCapability;
		};
	 
public:
	 
	 








	virtual void NewDocumentL()=0;  
	
	 











	virtual CFileStore* CreateFileStoreLC(RFs& aFs,const TDesC& aFileName)=0;  
	 
	 
	  virtual CPicture* GlassPictureL();  
	
	 











	virtual void EditL(MApaEmbeddedDocObserver* aContainer,TBool aReadOnly=EFalse)=0;  
	
	 










	virtual void PrintL(const CStreamStore& aSourceStore)=0;  
	 
	 

	 














	virtual void SaveL()=0;  
	 















	virtual void StoreL(CStreamStore& aStore,CStreamDictionary& aStreamDic) const=0;  
	
	 













	virtual void RestoreL(const CStreamStore& aStore,const CStreamDictionary& aStreamDic)=0;  
	
	 




















	inline virtual void DetachFromStoreL(CPicture::TDetach  =CPicture::EDetachFull) {}  
	  virtual void ExternalizeL(RWriteStream& aStream)const;
	 
	 
	
	 











	virtual TBool IsEmpty()const=0;  
	  virtual void ValidatePasswordL()const;  
	
	  virtual TCapability Capability()const;  
	inline CApaApplication* Application()const;
	inline CApaProcess* Process()const;
	
	 







	virtual TBool HasChanged()const =0;
	 
	  virtual ~CApaDocument();
protected:
	  CApaDocument(CApaApplication& aApp,CApaProcess& aProcess);
private:
	 
	  virtual void Reserved_1();
	  virtual void Reserved_2();
protected:
	MApaEmbeddedDocObserver* iContainer;  
private:
	CApaApplication* iApplication;  
	CApaProcess* iApaProcess;
	TInt iSpare;
	};



class TApaApplicationFactory
 






	{
public:
	typedef CApaApplication* (*TFunction)();
public:
	  TApaApplicationFactory(TFunction aFunction);
	  TApaApplicationFactory(const CImplementationInformation& aEmbeddedApplicationInformation);
	  TApaApplicationFactory(TUid aEmbeddedApplicationUid);
	CApaApplication* CreateApplicationL() const;
	HBufC* AppFileNameL() const;
	TUid AppFileUid() const;
private:
	enum TType
		{
		ETypeFunction,							 
		ETypeEmbeddedApplicationInformation,	 
		ETypeEmbeddedApplicationUid				 
		};
private:
	static CApaApplication* CreateEmbeddedApplicationL(TUid aUid);
	static HBufC* EmbeddedApplicationDisplayNameLC(TUid aUid);
	static HBufC* FullAppFileNameL(const TDesC& aAppName);
	static void CleanupImplementationArray(TAny* aImplementationArray);
private:
	TType iType;
	TUint iData;
	TInt iSpare1;
	TInt iSpare2;
	};


class CApaProcess : public CBase
 

















	{
public:
	  static CApaProcess* NewL(const RFs& aFs,CApaAppFinder& aAppFinder);
	  void ResetL();
	 
	 
	  static CStreamDictionary* ReadRootStreamLC(RFs& aFs,CFileStore*& aStore,const TDesC& aDocFullFileName,TUint aFileMode);  
	  static void WriteRootStreamL(CPersistentStore& aStore,CStreamDictionary& aStreamDic,const CApaApplication& aApp);
	  static void WriteRootStreamL(CPersistentStore& aStore,CStreamDictionary& aStreamDic,const TApaAppIdentifier& aAppId);
	  static TApaAppIdentifier ReadAppIdentifierL(const CStreamStore& aStore,const CStreamDictionary& aStreamDic);
	  static void WriteAppIdentifierL(CStreamStore& aStore,CStreamDictionary& aStreamDic,const TApaAppIdentifier& aAppId);
	 
	 
	  CApaDocument* AddNewDocumentL(const TDesC& aDllFileName,TUid aDllUid= TUid::Null() );  
	  CApaDocument* OpenNewDocumentL(CFileStore*& aStore,CStreamDictionary*& aStreamDic,const TDesC& aDocFullFileName,TUint aFileMode);  
	  void DestroyDocument(CApaDocument* aDoc);  
	 
	 
	  void SetMainDocument(CApaDocument* aDocument);
	  void SetMainDocFileName(const TDesC& aMainDocFileName);  
	  void SetMainDocFileNameL(const TDesC& aMainDocFileName);
	 
	 
	  TPtrC MainDocFileName()const;
	inline RFs& FsSession()const;
	inline CApaDocument* MainDocument()const;
	inline TPtrC TempFilePath()const;
	inline CApaAppFinder* AppFinder()const;
	 
	  ~CApaProcess();
protected:
	  CApaProcess(const RFs& aFs,CApaAppFinder& aAppFinder);
	  void ConstructL();
public:
	  CApaDocument* AddNewDocumentL(TApaApplicationFactory aApplicationFactory);
public:
	static TInt IdleRemoveApplications(TAny* aThis);
	void RemoveMarkedApplications();
private:
	CApaAppHolder* AddAppL(const TDesC& aAppFileName,TUid aUid);  
	CApaDll* AddAppDllL(const TDesC& aDllFullPath);
	CApaExe* AddAppExeL(TApaApplicationFactory aApplicationFactory);
	void RemoveApp(CApaAppHolder* aAppHolder);
	CApaDocument* CreateDocL(CApaApplication* aApp);
	CApaAppHolder* FindAppInListL(const TDesC& aAppFileName,TUid aUid)const;  
	void DeleteAllDocs();
	void MarkApplicationForRemoval(CApaApplication* aApp);
private:
	CArrayFixFlat<TApaAppHolderInfo>* iAppList;  
	CArrayFixFlat<CApaDocument*>* iDocList;  
	CApaDocument* iMainDoc;
	HBufC* iMainDocFileName;
	CApaAppFinder* iAppFinder;
	RFs iFsSession;  
	CIdle* iApplicationRemover;
	};


class MApaEmbeddedDocObserver
 





	{
public:
	 
	enum TExitMode {
		 
		EKeepChanges,
		 

		ERevertToSaved,
		 
		ENoChanges,
		 
		EEmpty
		};
public:
	 


	virtual void NotifyExit(TExitMode aMode)=0;  
	};


 
inline CApaApplication* CApaDocument::Application()const
 


	{ return iApplication; }

inline CApaProcess* CApaDocument::Process()const
 


	{ return iApaProcess; }

inline TBool CApaDocument::TCapability::CanDrawGlass()const
 


	{ return iCapability&ECanDrawGlass; }

inline TBool CApaDocument::TCapability::CanPrint()const
 



	{ return iCapability&ECanPrint; }

inline void CApaDocument::TCapability::SetCanDrawGlass()
 
	{ iCapability = iCapability|ECanDrawGlass; }

inline void CApaDocument::TCapability::SetCanPrint()
 

	{ iCapability = iCapability|ECanPrint; }

inline TPtrC CApaProcess::TempFilePath()const 
 





	{ return iAppFinder->TempPath(); }

inline RFs& CApaProcess::FsSession()const
 


	{ return (RFs&)iFsSession; }

inline CApaDocument* CApaProcess::MainDocument()const
 


	{ return iMainDoc; }

inline CApaAppFinder* CApaProcess::AppFinder()const 
	{ return iAppFinder; }


# 9 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdoc.h" 2

# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/savenotf.h" 1
 
 
 
 







 


class RSaveSession : public RSessionBase
	{
public:
	TInt ConnectL();
	void NotifySave(TRequestStatus& aStatus);
	void NotifySaveCancel();
	TInt HandleSaveError(TInt aError);
private:
	TInt StartServerL();
	};

 


class MSaveObserver
	{
public:
	enum TSaveType
		{
		ESaveNone,
		ESaveData,
		ESaveAll,
		ESaveQuick,
		EReleaseRAM,
		EReleaseDisk,
		};
public:
	virtual void SaveL(TSaveType aSaveType)=0;
	};

 



class CSaveNotifier : public CActive
	{
public:
	  static CSaveNotifier* NewL(MSaveObserver& aObserver);
	  ~CSaveNotifier();
	  void DelayRequeue();
	  void Queue();
	  void HandleError(TInt aError);
private:
	inline CSaveNotifier(MSaveObserver& aObserver);
	void ConstructL();
	void Start();
private:  
	void DoCancel();
	void RunL();
private:
	RSaveSession iSaveSession;
	MSaveObserver& iSaveObserver;
	TUint iFlags;
	};


# 10 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikdoc.h" 2


class CEikAppUi;
class CEikApplication;
class CApaWindowGroupName;

class CEikDocument : public CApaDocument
	{
public:  
	virtual CEikAppUi* CreateAppUiL()=0;
	  virtual CFileStore* OpenFileL(TBool aDoOpen,const TDesC& aFilename,RFs& aFs);
	  void PrepareToEditL(MApaEmbeddedDocObserver* aObserver,TBool aReadOnly);
	  void PrepareToEditL();
	  void SetAppFileMode(TUint aMode);
	  TUint AppFileMode() const;
	  virtual void UpdateTaskNameL(CApaWindowGroupName* aWgName);
	  const TApaAppCaption& AppCaption() const;
	  void SetChanged(TBool aHasChanged);
	  void SetEditStoreL(CStreamStore* aStore);
	inline CStreamStore* EditStore() const;
	  ~CEikDocument();
	  virtual void SaveL(MSaveObserver::TSaveType aSaveType);
public:  
	  void NewDocumentL();
	  CFileStore* CreateFileStoreLC(RFs& aFs,const TDesC& aFileName);
	  void EditL(MApaEmbeddedDocObserver* aObserver,TBool aReadOnly=EFalse);
	  void PrintL(const CStreamStore& aSourceStore);
	  void SaveL();
	  void StoreL(CStreamStore& aStore,CStreamDictionary& aStreamDic) const;
	  void RestoreL(const CStreamStore& aStore,const CStreamDictionary& aStreamDic);
	  void ExternalizeL(RWriteStream& aStream) const;
	  TBool IsEmpty() const;
	  TBool HasChanged() const;
protected:
	  CEikDocument(CEikApplication& aApp);
private:
	void NullAppUi();
	 
	  virtual void Reserved_1();
	  virtual void Reserved_2();
protected:
	CEikAppUi* iAppUi;
	CStreamStore* iEditStore;
private:
	TBool iChanged;
	TUint iAppFileMode;
	 
	friend class CEikAppUi;
	};





 
 
 

inline CStreamStore* CEikDocument::EditStore() const
	{ return(iEditStore); }



# 23 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/akndoc.h" 2


class CAknDocument : public CEikDocument
	{
public:	 
	  CFileStore* OpenFileL(TBool aDoOpen,const TDesC& aFilename,RFs& aFs);
protected:
	  CAknDocument(CEikApplication& aApp);
	};



# 14 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60Document.h" 2


 
class Cayfly_s60AppUi;
class CEikApplication;

 

 




class Cayfly_s60Document : public CAknDocument
	{
public:
	 

	 








	static Cayfly_s60Document* NewL(CEikApplication& aApp);

	 








	static Cayfly_s60Document* NewLC(CEikApplication& aApp);

	 



	virtual ~Cayfly_s60Document();

public:
	 

	 






	CEikAppUi* CreateAppUiL();

private:
	 

	 



	void ConstructL();

	 




	Cayfly_s60Document(CEikApplication& aApp);

	};


 
# 56 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60Application.h" 1
 











 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknapp.h" 1
 






















# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/eikapp.h" 1
 
 
 
 












class CCoeEnv;

class CEikApplication : public CApaApplication
	{
public:
	  ~CEikApplication();
	inline TInt ResourceFileOffset() const;
	inline CApaProcess* Process() const;
	inline const TApaAppCaption& AppCaption() const;
	  virtual void GetDefaultDocumentFileName(TFileName& aDocumentName) const;
	  virtual TFileName BitmapStoreName() const;
	 
	  CApaAppInfoFileReader* OpenAppInfoFileLC() const;
	  CDictionaryStore* OpenIniFileLC(RFs& aFs) const;
	  void Capability(TDes8& aInfo) const;
	  void SetToIniFileNameL(TParse& aParser) const;
protected:  
	  void PreDocConstructL();
	  CApaDocument* CreateDocumentL(CApaProcess* aProcess);
private:
	 
	  virtual void Reserved_1();
protected:  
	  CEikApplication();
public:  
	  virtual TFileName ResourceFileName() const;
private:  
	virtual CApaDocument* CreateDocumentL()=0;
private:  
	void ParseWithAppName(TParse& aParse,const TDesC& aFileName) const;
	void ReadCaptionNameL();
protected:
	CCoeEnv* iCoeEnv;
	TInt iResourceFileOffset;
private:
	CApaProcess* iProcess;
	TApaAppCaption iCaption;
	TApaAppCapabilityBuf* iCapabilityBuf;
	TUint iAppFlags;
	TInt iSpare;
	};

inline TInt CEikApplication::ResourceFileOffset() const
	{ return(iResourceFileOffset); }

inline CApaProcess* CEikApplication::Process() const
	{ return(iProcess); }

inline const TApaAppCaption& CEikApplication::AppCaption() const
	{ return(iCaption);	}


# 24 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/aknapp.h" 2


class CAknApplication : public CEikApplication
	{
public:
	 
	  virtual void PreDocConstructL();
	  CDictionaryStore* OpenIniFileLC(RFs& aFs) const;
	};



# 14 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60Application.h" 2



 
 
const TUid KUidayfly_s60App =
	{
	0xEA0B66F6 
	};

 

 





class Cayfly_s60Application : public CAknApplication
	{
public:
	Cayfly_s60Application();
	~Cayfly_s60Application();
	 

	 



	TUid AppDllUid() const;

protected:
	 

	 





	CApaDocument* CreateDocumentL();
	};


 
# 57 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60AppUi.h" 1
 











 


 
class Cayfly_s60AppView;

 
 





struct CurrentSong
{
    TFileName FileName;
     
};

class Cayfly_s60AppUi : public CAknAppUi
	{
public:
	 

	 



	void ConstructL();

	 




	Cayfly_s60AppUi();

	 



	virtual ~Cayfly_s60AppUi();

private:
	 

	 




	void HandleCommandL(TInt aCommand);

	 




	void HandleStatusPaneSizeChange();

	TKeyResponse HandleKeyEventL(const TKeyEvent &aKeyEvent, TEventCode aType);


private:
	 

	 



	Cayfly_s60AppView* iAppView;
	void *currentSong;
	TInt iVolume;
	 
	 


	};


 
# 58 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2

# 1 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60AppView.h" 1
 











 
# 1 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h" 1
 
 
 
 

# 330 "/home/andrew/symbian-sdks/s60_26_cw/epoc32/include/coecntrl.h"

# 14 "/home/andrew/Projects/ayfly/src/s60/inc/ayfly_s60AppView.h" 2


 
class Cayfly_s60AppView : public CCoeControl
	{
public:
	 

	 






	static Cayfly_s60AppView* NewL(const TRect& aRect);

	 







	static Cayfly_s60AppView* NewLC(const TRect& aRect);

	 



	virtual ~Cayfly_s60AppView();

public:
	 

	 




	void Draw(const TRect& aRect) const;

	 



	virtual void SizeChanged();

private:
	 

	 






	void ConstructL(const TRect& aRect);

	 



	Cayfly_s60AppView();

	};


 
# 59 "/home/andrew/Projects/ayfly/src/s60/inc/s60.h" 2






# 22 "../src/ayfly_s60Application.cpp" 2



Cayfly_s60Application::Cayfly_s60Application()
{
	
}

Cayfly_s60Application::~Cayfly_s60Application()
{
}

 

 
 
 
 
 
CApaDocument* Cayfly_s60Application::CreateDocumentL()
	{
	 
	return Cayfly_s60Document::NewL(*this);
	}

 
 
 
 
 
TUid Cayfly_s60Application::AppDllUid() const
	{
	 
	return KUidayfly_s60App;
	}

 
